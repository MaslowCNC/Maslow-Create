/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// If the loader is already loaded, just stop.
if (!self.define) {
  const singleRequire = async name => {
    if (name !== 'require') {
      name = name + '.js';
    }
    if (!registry[name]) {
      
        await new Promise(async resolve => {
          if ("document" in self) {
            const script = document.createElement("script");
            
              script.src = name;
            
            // Ya never know
            script.defer = true;
            document.head.appendChild(script);
            script.onload = resolve;
          } else {
            importScripts(name);
            resolve();
          }
        });
      

      if (!registry[name]) {
        throw new Error(`Module ${name} didnâ€™t register its module`);
      }
    }
    return registry[name];
  };

  const require = async (names, resolve) => {
    const modules = await Promise.all(names.map(singleRequire));
    resolve(modules.length === 1 ? modules[0] : modules);
  };

  const registry = {
    require: Promise.resolve(require)
  };

  self.define = (moduleName, depsNames, factory) => {
    if (registry[moduleName]) {
      // Module is already loading or loaded.
      return;
    }
    registry[moduleName] = new Promise(async resolve => {
      let exports = {};
      const module = {
        
          uri: location.origin + moduleName.slice(1)
        
      };
      const deps = await Promise.all(
        depsNames.map(depName => {
          if (depName === "exports") {
            return exports;
          }
          if (depName === "module") {
            return module;
          }
          return singleRequire(depName);
        })
      );
      const facValue = factory(...deps);
      if(!exports.default) {
        exports.default = facValue;
      }
      resolve(exports);
    });
  };
}
define("./maslowWorker.js",['require'], function (require) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
      var n = {};
      if (e) {
        Object.keys(e).forEach(function (k) {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        });
      }
      n['default'] = e;
      return n;
    }
  }

  /**
   * Set a mat4 to the identity matrix
   *
   * @returns {mat4} out
   */
  const identity = () => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

  const EPSILON = 1e-5;

  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {vec3} axis the axis to rotate around
   * @returns {mat4} out
   */
  const fromRotation = (rad, [x, y, z]) => {
    let len = Math.sqrt(x * x + y * y + z * z);

    if (Math.abs(len) < EPSILON) {
      return identity();
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const t = 1 - c;

    // Perform rotation-specific matrix multiplication
    return [x * x * t + c,
            y * x * t + z * s,
            z * x * t - y * s,
            0,
            x * y * t - z * s,
            y * y * t + c,
            z * y * t + x * s,
            0,
            x * z * t + y * s,
            y * z * t - x * s,
            z * z * t + c,
            0,
            0,
            0,
            0,
            1];
  };

  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {vec3} v Scaling vector
   * @returns {mat4} out
   */
  const fromScaling = ([x = 1, y = 1, z = 1]) => [x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1];

  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {vec3} v Translation vector
   * @returns {mat4} out
   */
  const fromTranslation = ([x = 0, y = 0, z = 0]) => [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];

  /**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */
  const fromValues = (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) =>
    [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33];

  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */
  const fromXRotation = (rad) => {
    const s = Math.sin(rad);
    const c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    return [1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1];
  };

  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */
  const fromYRotation = (rad) => {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    return [c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1];
  };

  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */
  const fromZRotation = (rad) => {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    // Perform axis-specific matrix multiplication
    return [c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  };

  /**
   * Calculates the absolute value of the give vector
   *
   * @param {vec3} [out] - receiving vector
   * @param {vec3} vec - given value
   * @returns {vec3} absolute value of the vector
   */
  const abs = ([x, y, z]) => [Math.abs(x), Math.abs(y), Math.abs(z)];

  /**
   * Adds two vec3's
   *
   * @param {vec3} a the first vector to add
   * @param {vec3} b the second vector to add
   * @returns {vec3} the added vectors
   */
  const add = ([ax = 0, ay = 0, az = 0], [bx = 0, by = 0, bz = 0]) => [(ax + bx), (ay + by), (az + bz)];

  /**
   * Calculates the dot product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} dot product of a and b
   */
  const dot = ([ax, ay, az], [bx, by, bz]) => (ax * bx) + (ay * by) + (az * bz);

  /**
   * Scales a vec3 by a scalar number
   *
   * @param {Number} amount amount to scale the vector by
   * @param {vec3} vector the vector to scale
   * @returns {vec3} out
   */
  const scale = (amount, [x = 0, y = 0, z = 0]) => [(x * amount), (y * amount), (z * amount)];

  /**
   * Normalize a vec3
   *
   * @param {vec3} a vector to normalize
   * @returns {vec3} out
   */
  const normalize = (a) => {
    const [x, y, z] = a;
    const len = (x * x) + (y * y) + (z * z);
    if (len > 0) {
      // TODO: evaluate use of glm_invsqrt here?
      return scale(1 / Math.sqrt(len), a);
    } else {
      return a;
    }
  };

  const spatialResolution = 1e5;

  // Quantize values for use in spatial coordinates, and so on, even if the usual quantizeForSpace is disabled.
  const reallyQuantizeForSpace = (value) => (Math.round(value * spatialResolution) / spatialResolution);

  const solve2Linear = (a, b, c, d, u, v) => {
    const det = a * d - b * c;
    const invdet = 1.0 / det;
    const x = u * d - b * v;
    const y = -u * c + a * v;
    return [x * invdet, y * invdet];
  };

  /**
   * Get the angle between two 3D vectors
   * @param {vec3} a The first operand
   * @param {vec3} b The second operand
   * @returns {Number} The angle in radians
   */
  const angle = (a, b) => {
    const cosine = reallyQuantizeForSpace(dot(normalize(a), normalize(b)));
    return cosine > 1.0 ? 0 : Math.acos(cosine);
  };

  // Normalize negative zero to positive zero.
  const f = (v) => v === 0 ? 0 : v;

  const canonicalize = ([x = 0, y = 0, z = 0]) => [f(reallyQuantizeForSpace(x)), f(reallyQuantizeForSpace(y)), f(reallyQuantizeForSpace(z))];

  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  const cross = ([ax, ay, az], [bx, by, bz]) => [ay * bz - az * by,
                                                        az * bx - ax * bz,
                                                        ax * by - ay * bx];

  /**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} distance between a and b
   */
  const distance = ([ax, ay, az], [bx, by, bz]) => {
    const x = bx - ax;
    const y = by - ay;
    const z = bz - az;
    return Math.sqrt(x * x + y * y + z * z);
  };

  /**
   * Divides two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  const divide = ([ax, ay, az], [bx, by, bz]) => [ax / bx,
                                                         ay / by,
                                                         az / bz];

  const equals = ([ax, ay, az], [bx, by, bz]) => (ax === bx) && (ay === by) && (az === bz);

  /**
   * Creates a new vec3 from the point given.
   * Missing ranks are implicitly zero.
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */
  const fromPoint = ([x = 0, y = 0, z = 0]) => [x, y, z];

  /** create a vec3 from a single scalar value
   * all components of the resulting vec3 have the value of the
   * input scalar
   * @param  {Float} scalar
   * @returns {Vec3}
   */
  const fromScalar = (scalar) => [scalar, scalar, scalar];

  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */
  const fromValues$1 = (x = 0, y = 0, z = 0) => [x, y, z];

  // extend to a 3D vector by adding a z coordinate:
  const fromVec2 = ([x = 0, y = 0], z = 0) => [x, y, z];

  /**
   * Calculates the length of a vec3
   *
   * @param {vec3} a vector to calculate length of
   * @returns {Number} length of a
   */
  const length = ([x = 0, y = 0, z = 0]) => Math.sqrt((x * x) + (y * y) + (z * z));

  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {Number} t interpolant (0.0 to 1.0) applied between the two inputs
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  const lerp = (t, [ax, ay, az], [bx, by, bz]) => [ax + t * (bx - ax),
                                                          ay + t * (by - ay),
                                                          az + t * (bz - az)];

  /**
   * Returns the maximum of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  const max = ([ax, ay, az], [bx, by, bz]) => [Math.max(ax, bx),
                                                      Math.max(ay, by),
                                                      Math.max(az, bz)];

  /**
   * Returns the minimum of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  const min = ([ax, ay, az], [bx, by, bz]) => [Math.min(ax, bx),
                                                      Math.min(ay, by),
                                                      Math.min(az, bz)];

  /**
   * Multiplies two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  const multiply = ([ax, ay, az], [bx, by, bz]) => [(ax * bx), (ay * by), (az * bz)];

  /**
   * Negates the components of a vec3
   *
   * @param {vec3} a vector to negate
   * @returns {vec3} out
   */
  const negate = ([x, y, z]) => [-x, -y, -z];

  // find a vector that is somewhat perpendicular to this one
  const random = (vec) => {
    const temp = abs(vec);
    if ((temp[0] <= temp[1]) && (temp[0] <= temp[2])) {
      return [1, 0, 0];
    } else if ((temp[1] <= temp[0]) && (temp[1] <= temp[2])) {
      return [0, 1, 0];
    } else {
      return [0, 0, 1];
    }
  };

  const rotateX = ([x, y, z], angle) =>
    [x,
     y * Math.cos(angle) - z * Math.sin(angle),
     y * Math.sin(angle) + z * Math.cos(angle)];

  const rotateY = ([x, y, z], angle) =>
    [z * Math.sin(angle) + x * Math.cos(angle),
     y,
     z * Math.cos(angle) - x * Math.sin(angle)];

  const rotateZ = ([x, y, z], angle) =>
    [x * Math.cos(angle) - y * Math.sin(angle),
     x * Math.sin(angle) + y * Math.cos(angle),
     z];

  /**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} squared distance between a and b
   */
  const squaredDistance = ([ax, ay, az], [bx, by, bz]) => {
    const x = bx - ax;
    const y = by - ay;
    const z = bz - az;
    return (x * x) + (y * y) + (z * z);
  };

  /**
   * Calculates the squared length of a vec3
   *
   * @param {vec3} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */
  const squaredLength = ([x, y, z]) => (x * x) + (y * y) + (z * z);

  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  const subtract = ([ax, ay, az], [bx, by, bz]) => [(ax - bx), (ay - by), (az - bz)];

  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   * @param {[[<vec3>], <mat4> , <vec3>]} params
   * @param {mat4} params[1] matrix matrix to transform with
   * @param {vec3} params[2] vector the vector to transform
   * @returns {vec3} out
   */
  const transform = (matrix, [x = 0, y = 0, z = 0]) => {
    let w = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15];
    w = w || 1.0;
    return [(matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12]) / w,
            (matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13]) / w,
            (matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14]) / w];
  };

  /**
   * Rotate vector 3D vector around the x-axis
   * @param {Number} angle The angle of rotation
   * @param {vec3} origin The origin of the rotation
   * @param {vec3} vector The vec3 point to rotate
   * @returns {vec3} out
   */
  const turnX = (angle, origin, vector) => {
    const p = subtract(vector, origin);
    // rotate
    const r = [p[0],
               p[1] * Math.cos(angle) - p[2] * Math.sin(angle),
               p[1] * Math.sin(angle) + p[2] * Math.cos(angle)];
    // translate
    return add(r, origin);
  };

  /**
   * Rotate vector 3D vector around the y-axis
   * @param {Number} angle The angle of rotation
   * @param {vec3} origin The origin of the rotation
   * @param {vec3} vector The vec3 point to turn
   * @returns {vec3} out
   */
  const turnY = (angle, origin, vector) => {
    const p = subtract(vector, origin);
    // turn
    const r = [p[2] * Math.sin(angle) + p[0] * Math.cos(angle),
               p[1],
               p[2] * Math.cos(angle) - p[0] * Math.sin(angle)];
    // translate
    return add(r, origin);
  };

  /**
   * Rotate vector 3D vector around the z-axis
   * @param {Number} angle The angle of rotation in radians
   * @param {vec3} origin The origin of the rotation
   * @param {vec3} vector The vec3 point to turn
   * @returns {vec3} out
   */
  const turnZ = (angle, origin, vector) => {
    const p = subtract(vector, origin);
    // turn
    const r = [p[0] * Math.cos(angle) - p[1] * Math.sin(angle),
               p[0] * Math.sin(angle) + p[1] * Math.cos(angle),
               p[2]];
    // translate
    return add(r, origin);
  };

  /**
   * Calculates the unit vector of the given vector
   *
   * @param {vec3} vector - the base vector for calculations
   * @returns {vec3} unit vector of the given vector
   */
  const unit = (vector) => {
    const [x, y, z] = vector;
    const magnitude = length(vector);
    return [x / magnitude,
            y / magnitude,
            z / magnitude];
  };



  var vec = /*#__PURE__*/Object.freeze({
    __proto__: null,
    abs: abs,
    add: add,
    angle: angle,
    canonicalize: canonicalize,
    cross: cross,
    distance: distance,
    divide: divide,
    dot: dot,
    equals: equals,
    fromPoint: fromPoint,
    fromScalar: fromScalar,
    fromValues: fromValues$1,
    fromVec2: fromVec2,
    length: length,
    lerp: lerp,
    max: max,
    min: min,
    multiply: multiply,
    negate: negate,
    normalize: normalize,
    random: random,
    rotateX: rotateX,
    rotateY: rotateY,
    rotateZ: rotateZ,
    scale: scale,
    squaredDistance: squaredDistance,
    squaredLength: squaredLength,
    subtract: subtract,
    transform: transform,
    turnX: turnX,
    turnY: turnY,
    turnZ: turnZ,
    unit: unit
  });

  /**
   * determine whether the input matrix is a mirroring transformation
   *
   * @param {mat4} mat the input matrix
   * @returns {boolean} output
   */
  const isMirroring = (mat) => {
    const u = [mat[0], mat[4], mat[8]];
    const v = [mat[1], mat[5], mat[9]];
    const w = [mat[2], mat[6], mat[10]];

    // for a true orthogonal, non-mirrored base, u.cross(v) == w
    // If they have an opposite direction then we are mirroring
    const mirrorvalue = dot(cross(u, v), w);
    const ismirror = (mirrorvalue < 0);
    return ismirror;
  };

  /**
   * Multiplies two mat4's
   *
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */
  const multiply$1 = (a, b) => {
    const out = Array(16);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];

    // Cache only the current line of the second matrix
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  };

  /**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} distance between a and b
   */
  const distance$1 = ([ax, ay], [bx, by]) => {
    const x = bx - ax;
    const y = by - ay;
    return Math.sqrt(x * x + y * y);
  };

  /**
   * Calculates the dot product of two vec2's
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {Number} dot product of a and b
   */
  const dot$1 = ([ax, ay], [bx, by]) => (ax * bx) + (ay * by);

  const equals$1 = ([ax, ay], [bx, by]) => (ax === bx) && (ay === by);

  const fromAngleRadians = (radians) => [Math.cos(radians), Math.sin(radians)];

  /**
   * Negates the components of a vec2
   *
   * @param {vec2} a vector to negate
   * @returns {vec2} out
   */
  const negate$1 = ([x, y]) => [-x, -y];

  /**
   * Rotates a vec2 by an angle
   *
   * @param {Number} angle the angle of rotation (in radians)
   * @param {vec2} vector the vector to rotate
   * @returns {vec2} out
   */
  const rotate = (angle, [x, y]) => {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    return [x * c - y * s,
            x * s + y * c];
  };

  /**
   * Calculates the normal value of the give vector
   * The normal value is the given vector rotated 90 degress.
   *
   * @param {vec2} vec - given value
   * @returns {vec2} normal value of the vector
   */
  const normal = (vec) => rotate(Math.PI / 2, vec);

  /**
   * Normalize the given vector.
   *
   * @param {vec2} a vector to normalize
   * @returns {vec2} normalized (unit) vector
   */
  const normalize$1 = ([x, y]) => {
    let len = x * x + y * y;
    if (len > 0) {
      len = 1 / Math.sqrt(len);
      return [x * len, y * len];
    } else {
      return [x, y];
    }
  };

  /**
   * Scales a vec2 by a scalar number
   *
   * @param {Number} amount amount to scale the vector by
   * @param {vec2} vector the vector to scale
   * @returns {vec2} out
   */
  const scale$1 = (amount, [x, y]) => [x * amount, y * amount];

  /**
   * Subtracts vector b from vector a
   *
   * @param {vec2} a the first operand
   * @param {vec2} b the second operand
   * @returns {vec2} out
   */
  const subtract$1 = ([ax, ay], [bx, by]) => [ax - bx, ay - by];

  const assertUnique = (path) => {
    let last = null;
    for (const point of path) {
      if (point === undefined) {
        throw Error(`die: ${JSON.stringify(path)}`);
      }
      if (last !== null && equals(point, last)) {
        throw Error(`die: ${JSON.stringify(path)}`);
      }
      last = point;
    }
  };

  const assertGood = (path) => {
    assertUnique(path);
  };

  const canonicalizePoint = (point, index) => {
    if (point === null) {
      if (index !== 0) throw Error('Path has null not at head');
      return point;
    } else {
      return canonicalize(point);
    }
  };

  const canonicalize$1 = (path) => path.map(canonicalizePoint);

  const isClosed = (path) => (path.length === 0) || (path[0] !== null);

  const close = (path) => isClosed(path) ? path : path.slice(1);

  const concatenate = (...paths) => {
    const result = [null, ...[].concat(...paths.map(close))];
    return result;
  };

  const deduplicate = (path) => {
    const unique = [];
    let last = path[path.length - 1];
    for (const point of path) {
      if (last === null || point === null || !equals(point, last)) {
        unique.push(point);
      }
      last = point;
    }
    return unique;
  };

  const flip = (path) => {
    if (path[0] === null) {
      return [null, ...path.slice(1).reverse()];
    } else {
      return path.slice().reverse();
    }
  };

  const getEdges = (path) => {
    const edges = [];
    let last = null;
    for (const point of path) {
      if (point === null) {
        continue;
      }
      if (last !== null) {
        edges.push([last, point]);
      }
      last = point;
    }
    if (path[0] !== null) {
      edges.push([last, path[0]]);
    }
    return edges;
  };

  const X = 0;
  const Y = 1;

  /**
   * Measure the area of a path as though it were a polygon.
   * A negative area indicates a clockwise path, and a positive area indicates a counter-clock-wise path.
   * See: http://mathworld.wolfram.com/PolygonArea.html
   * @returns {Number} The area the path would have if it were a polygon.
   */
  const measureArea = (path) => {
    let last = path.length - 1;
    let current = (path[0] === null) ? 1 : 0;
    let twiceArea = 0;
    for (; current < path.length; last = current++) {
      twiceArea += path[last][X] * path[current][Y] - path[last][Y] * path[current][X];
    }
    return twiceArea / 2;
  };

  const isClockwise = (path) => measureArea(path) < 0;

  const isCounterClockwise = (path) => measureArea(path) > 0;

  const open = (path) => isClosed(path) ? [null, ...path] : path;

  const toSegments = (options = {}, path) => {
    const segments = [];
    if (path[0] !== null) {
      segments.push([path[path.length - 1], path[0]]);
      segments.push([path[0], path[1]]);
    }
    for (let nth = 2; nth < path.length; nth++) {
      segments.push([path[nth - 1], path[nth]]);
    }
    if (segments.some(segment => segment[1] === undefined)) {
      throw Error('die');
    }
    return segments;
  };

  const transform$1 = (matrix, path) =>
    path.map((point, index) => (point === null) ? null : transform(matrix, point));

  const isOpen = (path) => !isClosed(path);

  const translate = (vector, path) => transform$1(fromTranslation(vector), path);
  const rotateX$1 = (radians, path) => transform$1(fromXRotation(radians), path);
  const rotateZ$1 = (radians, path) => transform$1(fromZRotation(radians), path);
  const scale$2 = (vector, path) => transform$1(fromScaling(vector), path);

  const X$1 = 0;
  const Y$1 = 1;

  // The resolution is 1 / multiplier.
  const createNormalize2 = (multiplier = 1e5) => {
    const map = new Map();
    const update = (key, value) => {
      if (!map.has(key)) {
        map.set(key, value);
      }
    };
    const normalize2 = (coordinate) => {
      // Apply a spatial quantization to the 2 dimensional coordinate.
      const nx = Math.floor(coordinate[X$1] * multiplier - 0.5);
      const ny = Math.floor(coordinate[Y$1] * multiplier - 0.5);
      // Look for an existing inhabitant.
      const value = map.get(`${nx}/${ny}`);
      if (value !== undefined) {
        return value;
      }
      // One of the ~0 or ~1 values will match the rounded values above.
      // The other will match the adjacent cell.
      const nx0 = nx;
      const ny0 = ny;
      const nx1 = nx + 1;
      const ny1 = ny + 1;
      // Populate the space of the quantized coordinate and its adjacencies.
      const normalized = coordinate;
      update(`${nx0}/${ny0}`, normalized);
      update(`${nx0}/${ny1}`, normalized);
      update(`${nx1}/${ny0}`, normalized);
      update(`${nx1}/${ny1}`, normalized);
      // This is now the normalized coordinate for this region.
      return normalized;
    };
    return normalize2;
  };

  const X$2 = 0;
  const Y$2 = 1;
  const Z = 2;

  // The resolution is 1 / multiplier.
  // export const createNormalize3 = (multiplier = 1e5) => {
  const createNormalize3 = (multiplier = 1e5 * 2) => {
    const map = new Map();
    const update = (key, value) => {
      if (!map.has(key)) {
        map.set(key, value);
      }
    };
    const normalize3 = (coordinate) => {
      // Apply a spatial quantization to the 2 dimensional coordinate.
      const nx = Math.floor(coordinate[X$2] * multiplier - 0.5);
      const ny = Math.floor(coordinate[Y$2] * multiplier - 0.5);
      const nz = Math.floor(coordinate[Z] * multiplier - 0.5);
      // Look for an existing inhabitant.
      const value = map.get(`${nx}/${ny}/${nz}`);
      if (value !== undefined) {
        return value;
      }
      // One of the ~0 or ~1 values will match the rounded values above.
      // The other will match the adjacent cell.
      const nx0 = nx;
      const ny0 = ny;
      const nz0 = nz;
      const nx1 = nx + 1;
      const ny1 = ny + 1;
      const nz1 = nz + 1;
      // Populate the space of the quantized coordinate and its adjacencies.
      const normalized = coordinate;
      update(`${nx0}/${ny0}/${nz0}`, normalized);
      update(`${nx0}/${ny0}/${nz1}`, normalized);
      update(`${nx0}/${ny1}/${nz0}`, normalized);
      update(`${nx0}/${ny1}/${nz1}`, normalized);
      update(`${nx1}/${ny0}/${nz0}`, normalized);
      update(`${nx1}/${ny0}/${nz1}`, normalized);
      update(`${nx1}/${ny1}/${nz0}`, normalized);
      update(`${nx1}/${ny1}/${nz1}`, normalized);
      // This is now the normalized coordinate for this region.
      return normalized;
    };
    return normalize3;
  };

  /**
   * Transforms the vertices of a polygon, producing a new poly3.
   *
   * The polygon does not need to be a poly3, but may be any array of
   * points. The points being represented as arrays of values.
   *
   * If the original has a 'plane' property, the result will have a clone
   * of the plane.
   *
   * @param {Function} [transform=vec3.clone] - function used to transform the vertices.
   * @returns {Array} a copy with transformed vertices and copied properties.
   *
   * @example
   * const vertices = [ [0, 0, 0], [0, 10, 0], [0, 10, 10] ]
   * let observed = poly3.map(vertices)
   */
  const map = (original, transform) => {
    if (original === undefined) {
      original = [];
    }
    if (transform === undefined) {
      transform = _ => _;
    }
    return original.map(vertex => transform(vertex));
  };

  const canonicalize$2 = polygon => map(polygon, canonicalize);

  /**
   * Flip the give polygon to face the opposite direction.
   *
   * @param {poly3} polygon - the polygon to flip
   * @returns {poly3} a new poly3
   */
  const flip$1 = (polygon) => [...polygon].reverse();

  /**
   * Create a poly3 from the given points.
   *
   * @param {Array[]} points - list of points
   * @param {plane} [planeof] - plane of the polygon
   *
   * @example
   * const points = [
   *   [0,  0, 0],
   *   [0, 10, 0],
   *   [0, 10, 10]
   * ]
   * const polygon = createFromPoints(points)
   */
  const fromPoints = (points, planeof) => [...points];

  const canonicalize$3 = ([x = 0, y = 0, z = 0, w = 0]) => [reallyQuantizeForSpace(x), reallyQuantizeForSpace(y), reallyQuantizeForSpace(z), reallyQuantizeForSpace(w)];

  /**
   * Compare the given planes for equality
   * @return {boolean} true if planes are equal
   */
  const equals$2 = (a, b) =>
    (a[0] === b[0]) &&
    (a[1] === b[1]) &&
    (a[2] === b[2]) &&
    (a[3] === b[3]);

  /**
   * Flip the given plane (vec4)
   *
   * @param {vec4} vec - plane to flip
   * @return {vec4} flipped plane
   */
  const flip$2 = ([x = 0, y = 0, z = 0, w = 0]) => [-x, -y, -z, -w];

  /**
   * Create a new plane from the given points
   *
   * @param {Vec3} a - 3D point
   * @param {Vec3} b - 3D point
   * @param {Vec3} c - 3D point
   * @returns {Vec4} a new plane with properly typed values
   */
  const fromPoints$1 = (a, b, c) => {
    // let n = b.minus(a).cross(c.minus(a)).unit()
    // FIXME optimize later
    const ba = subtract(b, a);
    const ca = subtract(c, a);
    const cr = cross(ba, ca);
    const normal = unit(cr); // normal part
    //
    const w = dot(normal, a);
    return [normal[0], normal[1], normal[2], w];
  };

  const X$3 = 0;
  const Y$3 = 1;
  const Z$1 = 2;
  const W = 3;

  // Newell's method for computing the plane of a polygon.
  const fromPolygon = (polygon) => {
    const normal = [0, 0, 0];
    const reference = [0, 0, 0];
    let lastPoint = polygon[polygon.length - 1];
    for (const thisPoint of polygon) {
      normal[X$3] += (lastPoint[Y$3] - thisPoint[Y$3]) * (lastPoint[Z$1] + thisPoint[Z$1]);
      normal[Y$3] += (lastPoint[Z$1] - thisPoint[Z$1]) * (lastPoint[X$3] + thisPoint[X$3]);
      normal[Z$1] += (lastPoint[X$3] - thisPoint[X$3]) * (lastPoint[Y$3] + thisPoint[Y$3]);
      reference[X$3] += lastPoint[X$3];
      reference[Y$3] += lastPoint[Y$3];
      reference[Z$1] += lastPoint[Z$1];
      lastPoint = thisPoint;
    }
    const factor = 1 / length(normal);
    const plane = scale(factor, normal);
    plane[W] = dot(reference, normal) * factor / polygon.length;
    if (isNaN(plane[X$3])) {
      return undefined;
    } else {
      return plane;
    }
  };

  const W$1 = 3;

  /**
   * Calculate the distance to the given point
   * @return {Number} signed distance to point
   */
  const signedDistanceToPoint = (plane, point) => dot(plane, point) - plane[W$1];

  /**
   * Split the given line by the given plane.
   * Robust splitting, even if the line is parallel to the plane
   * @return {vec3} a new point
   */
  const splitLineSegmentByPlane = (plane, p1, p2) => {
    const direction = subtract(p2, p1);
    let lambda = (plane[3] - dot(plane, p1)) / dot(plane, direction);
    if (Number.isNaN(lambda)) lambda = 0;
    if (lambda > 1) lambda = 1;
    if (lambda < 0) lambda = 0;
    return add(p1, scale(lambda, direction));
  };

  const X$4 = 0;
  const Y$4 = 1;
  const Z$2 = 2;
  const W$2 = 3;

  const toXYPlaneTransforms = (plane, rightVector) => {
    if (plane === undefined) {
      throw Error('die');
    }
    if (rightVector === undefined) {
      rightVector = random(plane);
    }

    const v = unit(cross(plane, rightVector));
    const u = cross(v, plane);
    const p = multiply(plane, fromScalar(plane[W$2]));

    const to = fromValues(u[X$4], v[X$4], plane[X$4], 0,
                          u[Y$4], v[Y$4], plane[Y$4], 0,
                          u[Z$2], v[Z$2], plane[Z$2], 0,
                          0, 0, -plane[W$2], 1);

    const from = fromValues(u[X$4], u[Y$4], u[Z$2], 0,
                            v[X$4], v[Y$4], v[Z$2], 0,
                            plane[X$4], plane[Y$4], plane[Z$2], 0,
                            p[X$4], p[Y$4], p[Z$2], 1);

    return [to, from];
  };

  /**
   * Transform the given plane using the given matrix
   * @return {Array} a new plane with properly typed values
   */
  const transform$2 = (matrix, plane) => {
    const ismirror = isMirroring(matrix);
    // get two vectors in the plane:
    const r = random(plane);
    const u = cross(plane, r);
    const v = cross(plane, u);
    // get 3 points in the plane:
    let point1 = multiply(plane, [plane[3], plane[3], plane[3]]);
    let point2 = add(point1, u);
    let point3 = add(point1, v);
    // transform the points:
    point1 = transform(matrix, point1);
    point2 = transform(matrix, point2);
    point3 = transform(matrix, point3);
    // and create a new plane from the transformed points:
    let newplane = fromPoints$1(point1, point2, point3);
    if (ismirror) {
      // the transform is mirroring so mirror the plane
      newplane = flip$2(newplane);
    }
    return newplane;
  };

  const toPlane = (polygon) => {
    if (polygon.plane === undefined) {
      polygon.plane = fromPolygon(polygon);
    }
    return polygon.plane;
  };

  /**
   * Check whether the polygon is convex.
   * @returns {boolean}
   */
  const areVerticesConvex = (vertices, plane) => {
    if (plane === undefined) {
      return false;
    }
    const numvertices = vertices.length;
    if (numvertices > 3) {
      let prevprevpos = vertices[numvertices - 2];
      let prevpos = vertices[numvertices - 1];
      for (let i = 0; i < numvertices; i++) {
        const pos = vertices[i];
        if (!isConvexPoint(prevprevpos, prevpos, pos, plane)) {
          return false;
        }
        prevprevpos = prevpos;
        prevpos = pos;
      }
    }
    return true;
  };

  // calculate whether three points form a convex corner
  //  prevpoint, point, nextpoint: the 3 coordinates (Vector3D instances)
  //  normal: the normal vector of the plane
  const isConvexPoint = (prevpoint, point, nextpoint, plane) => {
    const crossproduct = cross(subtract(point, prevpoint),
                               subtract(nextpoint, point));
    // The plane of a polygon is structurally equivalent to its normal.
    const crossdotnormal = dot(crossproduct, plane);
    // CHECK: 0 or EPS?
    return crossdotnormal >= 0;
  };

  const isConvex = (polygon) => areVerticesConvex(polygon, toPlane(polygon));

  // Affine transformation of polygon. Returns a new polygon.
  const transform$3 = (matrix, polygon) => {
    const transformed = map(polygon, vertex => transform(matrix, vertex));
    if (isMirroring(matrix)) {
      // Reverse the order to preserve the orientation.
      transformed.reverse();
    }
    return transformed;
  };

  const isDegenerate = (polygon) => {
    for (let nth = 0; nth < polygon.length; nth++) {
      if (equals(polygon[nth], polygon[(nth + 1) % polygon.length])) {
        return true;
      }
    }
    return false;
  };

  const canonicalize$4 = (polygons) => {
    const canonicalized = [];
    for (let polygon of polygons) {
      polygon = canonicalize$2(polygon);
      if (!isDegenerate(polygon)) {
        canonicalized.push(polygon);
      }
    }
    return canonicalized;
  };

  const measureBoundingBox = (polygons) => {
    if (polygons.measureBoundingBox === undefined) {
      const min = [Infinity, Infinity, Infinity];
      const max = [-Infinity, -Infinity, -Infinity];
      for (const path of polygons) {
        for (const point of path) {
          if (point[0] < min[0]) min[0] = point[0];
          if (point[1] < min[1]) min[1] = point[1];
          if (point[2] < min[2]) min[2] = point[2];
          if (point[0] > max[0]) max[0] = point[0];
          if (point[1] > max[1]) max[1] = point[1];
          if (point[2] > max[2]) max[2] = point[2];
        }
      }
      polygons.measureBoundingBox = [min, max];
    }
    return polygons.measureBoundingBox;
  };

  const iota = 1e-5;
  const X$5 = 0;
  const Y$5 = 1;
  const Z$3 = 2;

  // Requires a conservative gap.
  const doesNotOverlap = (a, b) => {
    if (a.length === 0 || b.length === 0) {
      return true;
    }
    const [minA, maxA] = measureBoundingBox(a);
    const [minB, maxB] = measureBoundingBox(b);
    if (maxA[X$5] <= minB[X$5] - iota * 10) { return true; }
    if (maxA[Y$5] <= minB[Y$5] - iota * 10) { return true; }
    if (maxA[Z$3] <= minB[Z$3] - iota * 10) { return true; }
    if (maxB[X$5] <= minA[X$5] - iota * 10) { return true; }
    if (maxB[Y$5] <= minA[Y$5] - iota * 10) { return true; }
    if (maxB[Z$3] <= minA[Z$3] - iota * 10) { return true; }
    return false;
  };

  /**
   * Transforms each polygon of Polygons.
   *
   * @param {Polygons} original - the Polygons to transform.
   * @param {Function} [transform=identity] - function used to transform the polygons.
   * @returns {Polygons} a copy with transformed polygons.
   */
  const map$1 = (original, transform) => {
    if (original === undefined) {
      original = [];
    }
    if (transform === undefined) {
      transform = _ => _;
    }
    return original.map(polygon => transform(polygon));
  };

  const flip$3 = (polygons) => map$1(polygons, flip$1);

  // const EPSILON = 1e-5;
  const EPSILON2 = 1e-10;

  const pushWhenValid = (out, points, expectedPlane) => {
    const validated = [];
    const l = points.length;
    for (let i = 0; i < l; i++) {
      if (squaredDistance(points[i], points[(i + 1) % l]) > EPSILON2) {
        validated.push(points[i]);
      }
    }
    if (validated.length < 3) {
      return;
    }
    const plane = fromPolygon(validated);
    if (plane === undefined) {
      return;
    }
    if (expectedPlane !== undefined) {
      validated.plane = expectedPlane;
    }
    out.push(validated);
  };

  const toTriangles = (options = {}, paths) => {
    const triangles = [];
    for (const path of paths) {
      for (let nth = 2; nth < path.length; nth++) {
        triangles.push([path[0], path[nth - 1], path[nth]]);
      }
    }
    return triangles;
  };

  const THRESHOLD = 1e-5;

  // We expect a solid of reconciled triangles.

  const watertight = Symbol('watertight');

  const X$6 = 0;
  const Y$6 = 1;
  const Z$4 = 2;

  const orderVertices = (a, b) => {
    const dX = a[X$6] - b[X$6];
    if (dX !== 0) return dX;
    const dY = a[Y$6] - b[Y$6];
    if (dY !== 0) return dY;
    const dZ = a[Z$4] - b[Z$4];
    return dZ;
  };

  const makeWatertight = (solid, normalize, threshold = THRESHOLD) => {
    if (!solid[watertight]) {
      if (isWatertight(solid)) {
        solid[watertight] = solid;
      }
    }

    if (!solid[watertight]) {
      if (normalize === undefined) {
        normalize = createNormalize3(1 / threshold);
      }

      const vertices = new Set();

      const reconciledSolid = [];
      for (const surface of solid) {
        const reconciledSurface = [];
        for (const path of surface) {
          const reconciledPath = [];
          for (const point of path) {
            const reconciledPoint = normalize(point);
            reconciledPath.push(reconciledPoint);
            vertices.add(reconciledPoint);
          }
          if (toPlane(reconciledPath) !== undefined) {
            // Filter degenerates.
            reconciledSurface.push(reconciledPath);
          }
        }
        reconciledSolid.push(reconciledSurface);
      }

      const orderedVertices = [...vertices];
      orderedVertices.sort(orderVertices);
      for (let i = 0; i < orderedVertices.length; i++) {
        orderedVertices[i].index = i;
      }

      const watertightSolid = [];
      for (const surface of reconciledSolid) {
        const watertightPaths = [];
        for (const path of surface) {
          const watertightPath = [];
          for (const [start, end] of getEdges(path)) {
            watertightPath.push(start);
            const span = distance(start, end);
            const colinear = [];
            let limit = Math.max(start.index, end.index);
            for (let i = Math.min(start.index, end.index); i < limit; i++) {
              const vertex = orderedVertices[i];
              // FIX: Threshold
              if (Math.abs(distance(start, vertex) + distance(vertex, end) - span) < threshold) {
                colinear.push(vertex);
              }
            }
            // Arrange by distance from start.
            colinear.sort((a, b) => distance(start, a) - distance(start, b));
            // Insert into the path.
            watertightPath.push(...colinear);
          }
          pushWhenValid(watertightPaths, watertightPath);
        }
        watertightSolid.push(watertightPaths);
      }
      // At this point we should have the correct structure for assembly into a solid.
      // We just need to ensure triangulation to support deformation.

      solid[watertight] = watertightSolid;
    }

    return solid[watertight];
  };

  const isWatertight = (solid) => {
    const edges = new Set();
    for (const surface of solid) {
      for (const path of surface) {
        for (const [start, end] of getEdges(path)) {
          edges.add(`${JSON.stringify([start, end])}`);
        }
      }
    }
    for (const surface of solid) {
      for (const path of surface) {
        for (const [start, end] of getEdges(path)) {
          if (!edges.has(`${JSON.stringify([end, start])}`)) {
            return false;
          }
        }
      }
    }
    return true;
  };

  // export const toPlane = (surface) => toPlaneOfPolygon(surface[0]);
  const canonicalize$5 = (surface) => surface.map(canonicalize$2);

  // Transforms
  const transform$4 = (matrix, surface) => surface.map(polygon => transform$3(matrix, polygon));
  const translate$1 = (vector, surface) => transform$4(fromTranslation(vector), surface);

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var fastEquals_cjs = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, '__esModule', { value: true });

  var HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';
  var keys = Object.keys;
  /**
   * @function addToCache
   *
   * add object to cache if an object
   *
   * @param value the value to potentially add to cache
   * @param cache the cache to add to
   */
  function addToCache(value, cache) {
      if (value && typeof value === 'object') {
          cache.add(value);
      }
  }
  /**
   * @function hasPair
   *
   * @description
   * does the `pairToMatch` exist in the list of `pairs` provided based on the
   * `isEqual` check
   *
   * @param pairs the pairs to compare against
   * @param pairToMatch the pair to match
   * @param isEqual the equality comparator used
   * @param meta the meta provided
   * @returns does the pair exist in the pairs provided
   */
  function hasPair(pairs, pairToMatch, isEqual, meta) {
      var length = pairs.length;
      var pair;
      for (var index = 0; index < length; index++) {
          pair = pairs[index];
          if (isEqual(pair[0], pairToMatch[0], meta) &&
              isEqual(pair[1], pairToMatch[1], meta)) {
              return true;
          }
      }
      return false;
  }
  /**
   * @function hasValue
   *
   * @description
   * does the `valueToMatch` exist in the list of `values` provided based on the
   * `isEqual` check
   *
   * @param values the values to compare against
   * @param valueToMatch the value to match
   * @param isEqual the equality comparator used
   * @param meta the meta provided
   * @returns does the value exist in the values provided
   */
  function hasValue(values, valueToMatch, isEqual, meta) {
      var length = values.length;
      for (var index = 0; index < length; index++) {
          if (isEqual(values[index], valueToMatch, meta)) {
              return true;
          }
      }
      return false;
  }
  /**
   * @function sameValueZeroEqual
   *
   * @description
   * are the values passed strictly equal or both NaN
   *
   * @param a the value to compare against
   * @param b the value to test
   * @returns are the values equal by the SameValueZero principle
   */
  function sameValueZeroEqual(a, b) {
      return a === b || (a !== a && b !== b);
  }
  /**
   * @function isPlainObject
   *
   * @description
   * is the value a plain object
   *
   * @param value the value to test
   * @returns is the value a plain object
   */
  function isPlainObject(value) {
      return value.constructor === Object || value.constructor == null;
  }
  /**
   * @function isPromiseLike
   *
   * @description
   * is the value promise-like (meaning it is thenable)
   *
   * @param value the value to test
   * @returns is the value promise-like
   */
  function isPromiseLike(value) {
      return !!value && typeof value.then === 'function';
  }
  /**
   * @function isReactElement
   *
   * @description
   * is the value passed a react element
   *
   * @param value the value to test
   * @returns is the value a react element
   */
  function isReactElement(value) {
      return !!(value && value.$$typeof);
  }
  /**
   * @function getNewCacheFallback
   *
   * @description
   * in cases where WeakSet is not supported, creates a new custom
   * object that mimics the necessary API aspects for cache purposes
   *
   * @returns the new cache object
   */
  function getNewCacheFallback() {
      return Object.create({
          _values: [],
          add: function (value) {
              this._values.push(value);
          },
          has: function (value) {
              return this._values.indexOf(value) !== -1;
          },
      });
  }
  /**
   * @function getNewCache
   *
   * @description
   * get a new cache object to prevent circular references
   *
   * @returns the new cache object
   */
  var getNewCache = (function (canUseWeakMap) {
      if (canUseWeakMap) {
          return function _getNewCache() {
              return new WeakSet();
          };
      }
      return getNewCacheFallback;
  })(HAS_WEAKSET_SUPPORT);
  /**
   * @function createCircularEqualCreator
   *
   * @description
   * create a custom isEqual handler specific to circular objects
   *
   * @param [isEqual] the isEqual comparator to use instead of isDeepEqual
   * @returns the method to create the `isEqual` function
   */
  function createCircularEqualCreator(isEqual) {
      return function createCircularEqual(comparator) {
          var _comparator = isEqual || comparator;
          return function circularEqual(a, b, cache) {
              if (cache === void 0) { cache = getNewCache(); }
              var hasA = cache.has(a);
              var hasB = cache.has(b);
              if (hasA || hasB) {
                  return hasA && hasB;
              }
              addToCache(a, cache);
              addToCache(b, cache);
              return _comparator(a, b, cache);
          };
      };
  }
  /**
   * @function toPairs
   *
   * @description
   * convert the map passed into pairs (meaning an array of [key, value] tuples)
   *
   * @param map the map to convert to [key, value] pairs (entries)
   * @returns the [key, value] pairs
   */
  function toPairs(map) {
      var pairs = new Array(map.size);
      var index = 0;
      map.forEach(function (value, key) {
          pairs[index++] = [key, value];
      });
      return pairs;
  }
  /**
   * @function toValues
   *
   * @description
   * convert the set passed into values
   *
   * @param set the set to convert to values
   * @returns the values
   */
  function toValues(set) {
      var values = new Array(set.size);
      var index = 0;
      set.forEach(function (value) {
          values[index++] = value;
      });
      return values;
  }
  /**
   * @function areArraysEqual
   *
   * @description
   * are the arrays equal in value
   *
   * @param a the array to test
   * @param b the array to test against
   * @param isEqual the comparator to determine equality
   * @param meta the meta object to pass through
   * @returns are the arrays equal
   */
  function areArraysEqual(a, b, isEqual, meta) {
      var length = a.length;
      if (b.length !== length) {
          return false;
      }
      for (var index = 0; index < length; index++) {
          if (!isEqual(a[index], b[index], meta)) {
              return false;
          }
      }
      return true;
  }
  /**
   * @function areMapsEqual
   *
   * @description
   * are the maps equal in value
   *
   * @param a the map to test
   * @param b the map to test against
   * @param isEqual the comparator to determine equality
   * @param meta the meta map to pass through
   * @returns are the maps equal
   */
  function areMapsEqual(a, b, isEqual, meta) {
      if (a.size !== b.size) {
          return false;
      }
      var pairsA = toPairs(a);
      var pairsB = toPairs(b);
      var length = pairsA.length;
      for (var index = 0; index < length; index++) {
          if (!hasPair(pairsB, pairsA[index], isEqual, meta) ||
              !hasPair(pairsA, pairsB[index], isEqual, meta)) {
              return false;
          }
      }
      return true;
  }
  var OWNER = '_owner';
  var hasOwnProperty = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
  /**
   * @function areObjectsEqual
   *
   * @description
   * are the objects equal in value
   *
   * @param a the object to test
   * @param b the object to test against
   * @param isEqual the comparator to determine equality
   * @param meta the meta object to pass through
   * @returns are the objects equal
   */
  function areObjectsEqual(a, b, isEqual, meta) {
      var keysA = keys(a);
      var length = keysA.length;
      if (keys(b).length !== length) {
          return false;
      }
      var key;
      for (var index = 0; index < length; index++) {
          key = keysA[index];
          if (!hasOwnProperty(b, key)) {
              return false;
          }
          if (key === OWNER && isReactElement(a)) {
              if (!isReactElement(b)) {
                  return false;
              }
          }
          else if (!isEqual(a[key], b[key], meta)) {
              return false;
          }
      }
      return true;
  }
  /**
   * @function areRegExpsEqual
   *
   * @description
   * are the regExps equal in value
   *
   * @param a the regExp to test
   * @param b the regExp to test agains
   * @returns are the regExps equal
   */
  function areRegExpsEqual(a, b) {
      return (a.source === b.source &&
          a.global === b.global &&
          a.ignoreCase === b.ignoreCase &&
          a.multiline === b.multiline &&
          a.unicode === b.unicode &&
          a.sticky === b.sticky &&
          a.lastIndex === b.lastIndex);
  }
  /**
   * @function areSetsEqual
   *
   * @description
   * are the sets equal in value
   *
   * @param a the set to test
   * @param b the set to test against
   * @param isEqual the comparator to determine equality
   * @param meta the meta set to pass through
   * @returns are the sets equal
   */
  function areSetsEqual(a, b, isEqual, meta) {
      if (a.size !== b.size) {
          return false;
      }
      var valuesA = toValues(a);
      var valuesB = toValues(b);
      var length = valuesA.length;
      for (var index = 0; index < length; index++) {
          if (!hasValue(valuesB, valuesA[index], isEqual, meta) ||
              !hasValue(valuesA, valuesB[index], isEqual, meta)) {
              return false;
          }
      }
      return true;
  }

  var isArray = Array.isArray;
  var HAS_MAP_SUPPORT = typeof Map === 'function';
  var HAS_SET_SUPPORT = typeof Set === 'function';
  var OBJECT_TYPEOF = 'object';
  function createComparator(createIsEqual) {
      var isEqual = 
      /* eslint-disable no-use-before-define */
      typeof createIsEqual === 'function'
          ? createIsEqual(comparator)
          : comparator;
      /* eslint-enable */
      /**
       * @function comparator
       *
       * @description
       * compare the value of the two objects and return true if they are equivalent in values
       *
       * @param a the value to test against
       * @param b the value to test
       * @param [meta] an optional meta object that is passed through to all equality test calls
       * @returns are a and b equivalent in value
       */
      function comparator(a, b, meta) {
          if (sameValueZeroEqual(a, b)) {
              return true;
          }
          if (a && b && typeof a === OBJECT_TYPEOF && typeof b === OBJECT_TYPEOF) {
              if (isPlainObject(a) && isPlainObject(b)) {
                  return areObjectsEqual(a, b, isEqual, meta);
              }
              var arrayA = isArray(a);
              var arrayB = isArray(b);
              if (arrayA || arrayB) {
                  return arrayA === arrayB && areArraysEqual(a, b, isEqual, meta);
              }
              var aDate = a instanceof Date;
              var bDate = b instanceof Date;
              if (aDate || bDate) {
                  return aDate === bDate && sameValueZeroEqual(a.getTime(), b.getTime());
              }
              var aRegExp = a instanceof RegExp;
              var bRegExp = b instanceof RegExp;
              if (aRegExp || bRegExp) {
                  return aRegExp === bRegExp && areRegExpsEqual(a, b);
              }
              if (isPromiseLike(a) || isPromiseLike(b)) {
                  return a === b;
              }
              if (HAS_MAP_SUPPORT) {
                  var aMap = a instanceof Map;
                  var bMap = b instanceof Map;
                  if (aMap || bMap) {
                      return aMap === bMap && areMapsEqual(a, b, isEqual, meta);
                  }
              }
              if (HAS_SET_SUPPORT) {
                  var aSet = a instanceof Set;
                  var bSet = b instanceof Set;
                  if (aSet || bSet) {
                      return aSet === bSet && areSetsEqual(a, b, isEqual, meta);
                  }
              }
              return areObjectsEqual(a, b, isEqual, meta);
          }
          return false;
      }
      return comparator;
  }

  // comparator
  var deepEqual = createComparator();
  var shallowEqual = createComparator(function () { return sameValueZeroEqual; });
  var circularDeepEqual = createComparator(createCircularEqualCreator());
  var circularShallowEqual = createComparator(createCircularEqualCreator(sameValueZeroEqual));

  exports.circularDeepEqual = circularDeepEqual;
  exports.circularShallowEqual = circularShallowEqual;
  exports.createCustomEqual = createComparator;
  exports.deepEqual = deepEqual;
  exports.sameValueZeroEqual = sameValueZeroEqual;
  exports.shallowEqual = shallowEqual;

  });

  unwrapExports(fastEquals_cjs);
  var fastEquals_cjs_1 = fastEquals_cjs.circularDeepEqual;
  var fastEquals_cjs_2 = fastEquals_cjs.circularShallowEqual;
  var fastEquals_cjs_3 = fastEquals_cjs.createCustomEqual;
  var fastEquals_cjs_4 = fastEquals_cjs.deepEqual;
  var fastEquals_cjs_5 = fastEquals_cjs.sameValueZeroEqual;
  var fastEquals_cjs_6 = fastEquals_cjs.shallowEqual;

  /**
   * @constant DEFAULT_OPTIONS_KEYS the default options keys
   */
  var DEFAULT_OPTIONS_KEYS = {
      isEqual: true,
      isMatchingKey: true,
      isPromise: true,
      maxSize: true,
      onCacheAdd: true,
      onCacheChange: true,
      onCacheHit: true,
      transformKey: true,
  };
  /**
   * @function slice
   *
   * @description
   * slice.call() pre-bound
   */
  var slice = Array.prototype.slice;
  /**
   * @function cloneArray
   *
   * @description
   * clone the array-like object and return the new array
   *
   * @param arrayLike the array-like object to clone
   * @returns the clone as an array
   */
  function cloneArray(arrayLike) {
      var length = arrayLike.length;
      if (!length) {
          return [];
      }
      if (length === 1) {
          return [arrayLike[0]];
      }
      if (length === 2) {
          return [arrayLike[0], arrayLike[1]];
      }
      if (length === 3) {
          return [arrayLike[0], arrayLike[1], arrayLike[2]];
      }
      return slice.call(arrayLike, 0);
  }
  /**
   * @function getCustomOptions
   *
   * @description
   * get the custom options on the object passed
   *
   * @param options the memoization options passed
   * @returns the custom options passed
   */
  function getCustomOptions(options) {
      var customOptions = {};
      /* eslint-disable no-restricted-syntax */
      for (var key in options) {
          if (!DEFAULT_OPTIONS_KEYS[key]) {
              customOptions[key] = options[key];
          }
      }
      /* eslint-enable */
      return customOptions;
  }
  /**
   * @function isMemoized
   *
   * @description
   * is the function passed already memoized
   *
   * @param fn the function to test
   * @returns is the function already memoized
   */
  function isMemoized(fn) {
      return (typeof fn === 'function' &&
          fn.isMemoized);
  }
  /**
   * @function isSameValueZero
   *
   * @description
   * are the objects equal based on SameValueZero equality
   *
   * @param object1 the first object to compare
   * @param object2 the second object to compare
   * @returns are the two objects equal
   */
  function isSameValueZero(object1, object2) {
      // eslint-disable-next-line no-self-compare
      return object1 === object2 || (object1 !== object1 && object2 !== object2);
  }
  /**
   * @function mergeOptions
   *
   * @description
   * merge the options into the target
   *
   * @param existingOptions the options provided
   * @param newOptions the options to include
   * @returns the merged options
   */
  function mergeOptions(existingOptions, newOptions) {
      // @ts-ignore
      var target = {};
      /* eslint-disable no-restricted-syntax */
      for (var key in existingOptions) {
          target[key] = existingOptions[key];
      }
      for (var key in newOptions) {
          target[key] = newOptions[key];
      }
      /* eslint-enable */
      return target;
  }

  // utils
  var Cache = /** @class */ (function () {
      function Cache(options) {
          this.keys = [];
          this.values = [];
          this.options = options;
          var isMatchingKeyFunction = typeof options.isMatchingKey === 'function';
          if (isMatchingKeyFunction) {
              this.getKeyIndex = this._getKeyIndexFromMatchingKey;
          }
          else if (options.maxSize > 1) {
              this.getKeyIndex = this._getKeyIndexForMany;
          }
          else {
              this.getKeyIndex = this._getKeyIndexForSingle;
          }
          this.canTransformKey = typeof options.transformKey === 'function';
          this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;
          this.shouldUpdateOnAdd = typeof options.onCacheAdd === 'function';
          this.shouldUpdateOnChange = typeof options.onCacheChange === 'function';
          this.shouldUpdateOnHit = typeof options.onCacheHit === 'function';
      }
      Object.defineProperty(Cache.prototype, "size", {
          get: function () {
              return this.keys.length;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Cache.prototype, "snapshot", {
          get: function () {
              return {
                  keys: cloneArray(this.keys),
                  size: this.size,
                  values: cloneArray(this.values),
              };
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @function _getKeyIndexFromMatchingKey
       *
       * @description
       * gets the matching key index when a custom key matcher is used
       *
       * @param keyToMatch the key to match
       * @returns the index of the matching key, or -1
       */
      Cache.prototype._getKeyIndexFromMatchingKey = function (keyToMatch) {
          var _a = this.options, isMatchingKey = _a.isMatchingKey, maxSize = _a.maxSize;
          var keys = this.keys;
          var keysLength = keys.length;
          if (!keysLength) {
              return -1;
          }
          if (isMatchingKey(keys[0], keyToMatch)) {
              return 0;
          }
          if (maxSize > 1) {
              for (var index = 1; index < keysLength; index++) {
                  if (isMatchingKey(keys[index], keyToMatch)) {
                      return index;
                  }
              }
          }
          return -1;
      };
      /**
       * @function _getKeyIndexForMany
       *
       * @description
       * gets the matching key index when multiple keys are used
       *
       * @param keyToMatch the key to match
       * @returns the index of the matching key, or -1
       */
      Cache.prototype._getKeyIndexForMany = function (keyToMatch) {
          var isEqual = this.options.isEqual;
          var keys = this.keys;
          var keysLength = keys.length;
          if (!keysLength) {
              return -1;
          }
          if (keysLength === 1) {
              return this._getKeyIndexForSingle(keyToMatch);
          }
          var keyLength = keyToMatch.length;
          var existingKey;
          var argIndex;
          if (keyLength > 1) {
              for (var index = 0; index < keysLength; index++) {
                  existingKey = keys[index];
                  if (existingKey.length === keyLength) {
                      argIndex = 0;
                      for (; argIndex < keyLength; argIndex++) {
                          if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {
                              break;
                          }
                      }
                      if (argIndex === keyLength) {
                          return index;
                      }
                  }
              }
          }
          else {
              for (var index = 0; index < keysLength; index++) {
                  existingKey = keys[index];
                  if (existingKey.length === keyLength &&
                      isEqual(existingKey[0], keyToMatch[0])) {
                      return index;
                  }
              }
          }
          return -1;
      };
      /**
       * @function _getKeyIndexForSingle
       *
       * @description
       * gets the matching key index when a single key is used
       *
       * @param keyToMatch the key to match
       * @returns the index of the matching key, or -1
       */
      Cache.prototype._getKeyIndexForSingle = function (keyToMatch) {
          var keys = this.keys;
          if (!keys.length) {
              return -1;
          }
          var existingKey = keys[0];
          var length = existingKey.length;
          if (keyToMatch.length !== length) {
              return -1;
          }
          var isEqual = this.options.isEqual;
          if (length > 1) {
              for (var index = 0; index < length; index++) {
                  if (!isEqual(existingKey[index], keyToMatch[index])) {
                      return -1;
                  }
              }
              return 0;
          }
          return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;
      };
      /**
       * @function orderByLru
       *
       * @description
       * order the array based on a Least-Recently-Used basis
       *
       * @param key the new key to move to the front
       * @param value the new value to move to the front
       * @param startingIndex the index of the item to move to the front
       */
      Cache.prototype.orderByLru = function (key, value, startingIndex) {
          var keys = this.keys;
          var values = this.values;
          var currentLength = keys.length;
          var index = startingIndex;
          while (index--) {
              keys[index + 1] = keys[index];
              values[index + 1] = values[index];
          }
          keys[0] = key;
          values[0] = value;
          var maxSize = this.options.maxSize;
          if (currentLength === maxSize && startingIndex === currentLength) {
              keys.pop();
              values.pop();
          }
          else if (startingIndex >= maxSize) {
              // eslint-disable-next-line no-multi-assign
              keys.length = values.length = maxSize;
          }
      };
      /**
       * @function updateAsyncCache
       *
       * @description
       * update the promise method to auto-remove from cache if rejected, and
       * if resolved then fire cache hit / changed
       *
       * @param memoized the memoized function
       */
      Cache.prototype.updateAsyncCache = function (memoized) {
          var _this = this;
          var _a = this.options, onCacheChange = _a.onCacheChange, onCacheHit = _a.onCacheHit;
          var firstKey = this.keys[0];
          var firstValue = this.values[0];
          this.values[0] = firstValue.then(function (value) {
              if (_this.shouldUpdateOnHit) {
                  onCacheHit(_this, _this.options, memoized);
              }
              if (_this.shouldUpdateOnChange) {
                  onCacheChange(_this, _this.options, memoized);
              }
              return value;
          }, function (error) {
              var keyIndex = _this.getKeyIndex(firstKey);
              if (keyIndex !== -1) {
                  _this.keys.splice(keyIndex, 1);
                  _this.values.splice(keyIndex, 1);
              }
              throw error;
          });
      };
      return Cache;
  }());

  // cache
  function createMemoizedFunction(fn, options) {
      if (options === void 0) { options = {}; }
      if (isMemoized(fn)) {
          return createMemoizedFunction(fn.fn, mergeOptions(fn.options, options));
      }
      if (typeof fn !== 'function') {
          throw new TypeError('You must pass a function to `memoize`.');
      }
      var _a = options.isEqual, isEqual = _a === void 0 ? isSameValueZero : _a, isMatchingKey = options.isMatchingKey, _b = options.isPromise, isPromise = _b === void 0 ? false : _b, _c = options.maxSize, maxSize = _c === void 0 ? 1 : _c, onCacheAdd = options.onCacheAdd, onCacheChange = options.onCacheChange, onCacheHit = options.onCacheHit, transformKey = options.transformKey;
      var normalizedOptions = mergeOptions({
          isEqual: isEqual,
          isMatchingKey: isMatchingKey,
          isPromise: isPromise,
          maxSize: maxSize,
          onCacheAdd: onCacheAdd,
          onCacheChange: onCacheChange,
          onCacheHit: onCacheHit,
          transformKey: transformKey,
      }, getCustomOptions(options));
      var cache = new Cache(normalizedOptions);
      var keys = cache.keys, values = cache.values, canTransformKey = cache.canTransformKey, shouldCloneArguments = cache.shouldCloneArguments, shouldUpdateOnAdd = cache.shouldUpdateOnAdd, shouldUpdateOnChange = cache.shouldUpdateOnChange, shouldUpdateOnHit = cache.shouldUpdateOnHit;
      // @ts-ignore
      var memoized = function memoized() {
          // @ts-ignore
          var key = shouldCloneArguments
              ? cloneArray(arguments)
              : arguments;
          if (canTransformKey) {
              key = transformKey(key);
          }
          var keyIndex = keys.length ? cache.getKeyIndex(key) : -1;
          if (keyIndex !== -1) {
              if (shouldUpdateOnHit) {
                  onCacheHit(cache, normalizedOptions, memoized);
              }
              if (keyIndex) {
                  cache.orderByLru(keys[keyIndex], values[keyIndex], keyIndex);
                  if (shouldUpdateOnChange) {
                      onCacheChange(cache, normalizedOptions, memoized);
                  }
              }
          }
          else {
              var newValue = fn.apply(this, arguments);
              var newKey = shouldCloneArguments
                  ? key
                  : cloneArray(arguments);
              cache.orderByLru(newKey, newValue, keys.length);
              if (isPromise) {
                  cache.updateAsyncCache(memoized);
              }
              if (shouldUpdateOnAdd) {
                  onCacheAdd(cache, normalizedOptions, memoized);
              }
              if (shouldUpdateOnChange) {
                  onCacheChange(cache, normalizedOptions, memoized);
              }
          }
          return values[0];
      };
      memoized.cache = cache;
      memoized.fn = fn;
      memoized.isMemoized = true;
      memoized.options = normalizedOptions;
      return memoized;
  }

  var microMemoize_cjs = createMemoizedFunction;

  const memoizedOps = new Set();

  const memoize = (op, options) => {
    const memoizedOp = microMemoize_cjs(op, options);
    memoizedOps.add(memoizedOp);
    return memoizedOp;
  };

  const clearCache = () => {
    for (const memoizedOp of memoizedOps) {
      const cache = memoizedOp.cache;
      cache.keys.length = 0;
      cache.values.length = 0;
    }
  };

  // This is a very thin abstraction layer to decouple from any particular cache implementation.

  const maxSize = 500;

  // Keyed by identity

  const cache = (op) => memoize(op, { maxSize });

  // Keyed by matrix structure and geometry identity.

  const isMatchingTransformKey = ([aMatrix, aGeometry], [bMatrix, bGeometry]) =>
    aGeometry === bGeometry && fastEquals_cjs_4(aMatrix, bMatrix);

  const cacheTransform = (op) => memoize(op, { isMatchingKey: isMatchingTransformKey, maxSize });

  // Keyed by tag-list and geometry identity.

  const isMatchingRewriteTagsKey = ([aAdd, aRemove, aGeometry, aConditionTags, aConditionSpec],
                                    [bAdd, bRemove, bGeometry, bConditionTags, bConditionSpec]) =>
    aGeometry === bGeometry && aConditionSpec === bConditionSpec && fastEquals_cjs_4(aConditionTags, bConditionTags) && fastEquals_cjs_4(aAdd, bAdd) && fastEquals_cjs_4(aRemove, bRemove);

  const cacheRewriteTags = (op) => memoize(op, { isMatchingKey: isMatchingRewriteTagsKey, maxSize });

  // Keyed by plane structure and geometry identity.

  const isMatchingCutKey = ([aPlane, aGeometry], [bPlane, bGeometry]) =>
    aGeometry === bGeometry && fastEquals_cjs_4(aPlane, bPlane);

  const cacheCut = (op) => memoize(op, { isMatchingKey: isMatchingCutKey, maxSize });

  // Keyed by points structure.

  const isMatchingPointsKey = ([aPoints], [bPoints]) => fastEquals_cjs_4(aPoints, bPoints);

  const cachePoints = (op) => memoize(op, { isMatchingKey: isMatchingPointsKey, maxSize });

  // FIX: This is incorrect, since it assumes the first non-degenerate polygon is representative.

  const toPlane$1 = (surface) => {
    if (surface.plane !== undefined) {
      return surface.plane;
    } else {
      for (const polygon of surface) {
        const plane = toPlane(polygon);
        if (plane !== undefined) {
          surface.plane = plane;
          return surface.plane;
        }
      }
    }
  };

  const EPSILON$1 = 1e-5;

  const COPLANAR = 0; // Neither front nor back.
  const FRONT = 1;
  const BACK = 2;
  const SPANNING = 3; // Both front and back.

  const toType = (plane, point) => {
    let t = signedDistanceToPoint(plane, point);
    if (t < -EPSILON$1) {
      return BACK;
    } else if (t > EPSILON$1) {
      return FRONT;
    } else {
      return COPLANAR;
    }
  };

  const pointType = [];

  const cutSurface = (plane, coplanarFrontSurfaces, coplanarBackSurfaces, frontSurfaces, backSurfaces, frontEdges, backEdges, surface) => {
    const surfacePlane = toPlane$1(surface);
    if (surfacePlane === undefined) {
      // Degenerate.
      return;
    }
    let coplanarFrontPolygons;
    let coplanarBackPolygons;
    let frontPolygons;
    let backPolygons;
    for (let polygon of surface) {
      pointType.length = 0;
      let polygonType = COPLANAR;
      if (!equals$2(surfacePlane, plane)) {
        for (const point of polygon) {
          const type = toType(plane, point);
          polygonType |= type;
          pointType.push(type);
        }
      }

      // Put the polygon in the correct list, splitting it when necessary.
      switch (polygonType) {
        case COPLANAR: {
          if (dot(plane, surfacePlane) > 0) {
            if (coplanarFrontPolygons === undefined) {
              coplanarFrontPolygons = [];
            }
            coplanarFrontPolygons.push(polygon);
          } else {
            if (coplanarBackPolygons === undefined) {
              coplanarBackPolygons = [];
            }
            coplanarBackPolygons.push(polygon);
          }
          break;
        }
        case FRONT: {
          if (frontPolygons === undefined) {
            frontPolygons = [];
          }
          frontPolygons.push(polygon);
          let startPoint = polygon[polygon.length - 1];
          let startType = pointType[polygon.length - 1];
          for (let nth = 0; nth < polygon.length; nth++) {
            const endPoint = polygon[nth];
            const endType = pointType[nth];
            if (startType === COPLANAR && endType === COPLANAR) {
              frontEdges.push([startPoint, endPoint]);
            }
            startPoint = endPoint;
            startType = endType;
          }
          break;
        }
        case BACK: {
          if (backPolygons === undefined) {
            backPolygons = [];
          }
          backPolygons.push(polygon);
          let startPoint = polygon[polygon.length - 1];
          let startType = pointType[polygon.length - 1];
          for (let nth = 0; nth < polygon.length; nth++) {
            const endPoint = polygon[nth];
            const endType = pointType[nth];
            if (startType === COPLANAR && endType === COPLANAR) {
              backEdges.push([startPoint, endPoint]);
            }
            startPoint = endPoint;
            startType = endType;
          }
          break;
        }
        case SPANNING: {
          // Make a local copy so that mutation does not propagate.
          polygon = polygon.slice();
          let backPoints = [];
          let frontPoints = [];
          // Add the colinear spanning point to the polygon.
          {
            let last = polygon.length - 1;
            for (let current = 0; current < polygon.length; last = current++) {
              const lastType = pointType[last];
              const lastPoint = polygon[last];
              if ((lastType | pointType[current]) === SPANNING) {
                // Break spanning segments at the point of intersection.
                const rawSpanPoint = splitLineSegmentByPlane(plane, lastPoint, polygon[current]);
                const spanPoint = subtract(rawSpanPoint, scale(signedDistanceToPoint(surfacePlane, rawSpanPoint), plane));
                // Note: Destructive modification of polygon here.
                polygon.splice(current, 0, spanPoint);
                pointType.splice(current, 0, COPLANAR);
              }
            }
          }
          // Spanning points have been inserted.
          {
            let last = polygon.length - 1;
            let lastCoplanar = polygon[pointType.lastIndexOf(COPLANAR)];
            for (let current = 0; current < polygon.length; last = current++) {
              const point = polygon[current];
              const type = pointType[current];
              const lastType = pointType[last];
              const lastPoint = polygon[last];
              if (type !== FRONT) {
                backPoints.push(point);
              }
              if (type !== BACK) {
                frontPoints.push(point);
              }
              if (type === COPLANAR) {
                if (lastType === COPLANAR) {
                  frontEdges.push([lastPoint, point]);
                  backEdges.push([lastPoint, point]);
                } else if (lastType === BACK) {
                  frontEdges.push([lastCoplanar, point]);
                } else if (lastType === FRONT) {
                  backEdges.push([lastCoplanar, point]);
                }
                lastCoplanar = point;
              }
            }
          }
          if (frontPoints.length >= 3) {
          // Add the polygon that sticks out the front of the plane.
            if (frontPolygons === undefined) {
              frontPolygons = [];
            }
            frontPolygons.push(frontPoints);
          }
          if (backPoints.length >= 3) {
          // Add the polygon that sticks out the back of the plane.
            if (backPolygons === undefined) {
              backPolygons = [];
            }
            backPolygons.push(backPoints);
          }
          break;
        }
      }
    }
    if (coplanarFrontPolygons !== undefined) {
      coplanarFrontSurfaces.push(coplanarFrontPolygons);
    }
    if (coplanarBackPolygons !== undefined) {
      coplanarBackSurfaces.push(coplanarBackPolygons);
    }
    if (frontPolygons !== undefined) {
      frontSurfaces.push(frontPolygons);
    }
    if (backPolygons !== undefined) {
      backSurfaces.push(backPolygons);
    }
  };

  const cutImpl = (planeSurface, surface) => {
    const front = [];
    const back = [];
    const frontEdges = [];
    const backEdges = [];

    cutSurface(toPlane$1(planeSurface), front, back, front, back, frontEdges, backEdges, surface);
    if (frontEdges.some(edge => edge[1] === undefined)) {
      throw Error(`die/end/missing: ${JSON.stringify(frontEdges)}`);
    }

    return [].concat(...back);
  };

  const cut = cacheCut(cutImpl);

  const eachPoint = (thunk, surface) => {
    for (const polygon of surface) {
      for (const [x = 0, y = 0, z = 0] of polygon) {
        thunk([x, y, z]);
      }
    }
  };

  /**
   * Transforms each polygon of the surface.
   *
   * @param {Polygons} original - the Polygons to transform.
   * @param {Function} [transform=identity] - function used to transform the polygons.
   * @returns {Polygons} a copy with transformed polygons.
   */
  const map$2 = (original, transform) => {
    if (original === undefined) {
      original = [];
    }
    if (transform === undefined) {
      transform = _ => _;
    }
    return original.map(polygon => transform(polygon));
  };

  const flip$4 = (surface) => map$2(surface, flip$1);

  // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)
  const measureBoundingBox$1 = (surface) => {
    if (surface.measureBoundingBox === undefined) {
      let max = [-Infinity, -Infinity, 0];
      let min = [Infinity, Infinity, 0];
      for (const polygon of surface) {
        for (const point of polygon) {
          if (point[0] < min[0]) min[0] = point[0];
          if (point[1] < min[1]) min[1] = point[1];
          if (point[0] > max[0]) max[0] = point[0];
          if (point[1] > max[1]) max[1] = point[1];
        }
      }
      surface.measureBoundingBox = [min, max];
    }
    return surface.measureBoundingBox;
  };

  // move to tagged

  const fromPathImpl = (path) => [path];

  const fromPath = cache(fromPathImpl);

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance$1 = global$1.performance || {};
  var performanceNow =
    performance$1.now        ||
    performance$1.mozNow     ||
    performance$1.msNow      ||
    performance$1.oNow       ||
    performance$1.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance$1)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var enums = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
   * By far the most widely used winding rules for polygon filling are EvenOdd & NonZero (GDI, GDI+, XLib, OpenGL, Cairo, AGG, Quartz, SVG, Gr32)
   * Others rules include Positive, Negative and ABS_GTR_EQ_TWO (only in OpenGL)
   * see http://glprogramming.com/red/chapter11.html
   */
  var PolyFillType;
  (function (PolyFillType) {
      PolyFillType["EvenOdd"] = "evenOdd";
      PolyFillType["NonZero"] = "nonZero";
      PolyFillType["Positive"] = "positive";
      PolyFillType["Negative"] = "negative";
  })(PolyFillType = exports.PolyFillType || (exports.PolyFillType = {}));
  var ClipType;
  (function (ClipType) {
      ClipType["Intersection"] = "intersection";
      ClipType["Union"] = "union";
      ClipType["Difference"] = "difference";
      ClipType["Xor"] = "xor";
  })(ClipType = exports.ClipType || (exports.ClipType = {}));
  var PolyType;
  (function (PolyType) {
      PolyType["Subject"] = "subject";
      PolyType["Clip"] = "clip";
  })(PolyType = exports.PolyType || (exports.PolyType = {}));
  var JoinType;
  (function (JoinType) {
      JoinType["Square"] = "square";
      JoinType["Round"] = "round";
      JoinType["Miter"] = "miter";
  })(JoinType = exports.JoinType || (exports.JoinType = {}));
  var EndType;
  (function (EndType) {
      EndType["ClosedPolygon"] = "closedPolygon";
      EndType["ClosedLine"] = "closedLine";
      EndType["OpenButt"] = "openButt";
      EndType["OpenSquare"] = "openSquare";
      EndType["OpenRound"] = "openRound";
  })(EndType = exports.EndType || (exports.EndType = {}));
  var PointInPolygonResult;
  (function (PointInPolygonResult) {
      PointInPolygonResult[PointInPolygonResult["Outside"] = 0] = "Outside";
      PointInPolygonResult[PointInPolygonResult["Inside"] = 1] = "Inside";
      PointInPolygonResult[PointInPolygonResult["OnBoundary"] = -1] = "OnBoundary";
  })(PointInPolygonResult = exports.PointInPolygonResult || (exports.PointInPolygonResult = {}));
  /**
   * Format to use when loading the native library instance.
   */
  var NativeClipperLibRequestedFormat;
  (function (NativeClipperLibRequestedFormat) {
      /**
       * Try to load the WebAssembly version, if it fails try to load the Asm.js version.
       */
      NativeClipperLibRequestedFormat["WasmWithAsmJsFallback"] = "wasmWithAsmJsFallback";
      /**
       * Load the WebAssembly version exclusively.
       */
      NativeClipperLibRequestedFormat["WasmOnly"] = "wasmOnly";
      /**
       * Load the Asm.js version exclusively.
       */
      NativeClipperLibRequestedFormat["AsmJsOnly"] = "asmJsOnly";
  })(NativeClipperLibRequestedFormat = exports.NativeClipperLibRequestedFormat || (exports.NativeClipperLibRequestedFormat = {}));
  /**
   * The format the native library being used is in.
   */
  var NativeClipperLibLoadedFormat;
  (function (NativeClipperLibLoadedFormat) {
      /**
       * WebAssembly.
       */
      NativeClipperLibLoadedFormat["Wasm"] = "wasm";
      /**
       * Asm.js.
       */
      NativeClipperLibLoadedFormat["AsmJs"] = "asmJs";
  })(NativeClipperLibLoadedFormat = exports.NativeClipperLibLoadedFormat || (exports.NativeClipperLibLoadedFormat = {}));

  });

  unwrapExports(enums);
  var enums_1 = enums.PolyFillType;
  var enums_2 = enums.ClipType;
  var enums_3 = enums.PolyType;
  var enums_4 = enums.JoinType;
  var enums_5 = enums.EndType;
  var enums_6 = enums.PointInPolygonResult;
  var enums_7 = enums.NativeClipperLibRequestedFormat;
  var enums_8 = enums.NativeClipperLibLoadedFormat;

  var nativeEnumConversion = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });

  function polyFillTypeToNative(nativeLib, polyFillType) {
      switch (polyFillType) {
          case enums.PolyFillType.EvenOdd:
              return nativeLib.PolyFillType.EvenOdd;
          case enums.PolyFillType.NonZero:
              return nativeLib.PolyFillType.NonZero;
          case enums.PolyFillType.Positive:
              return nativeLib.PolyFillType.Positive;
          case enums.PolyFillType.Negative:
              return nativeLib.PolyFillType.Negative;
          default:
              throw new Error("unknown poly fill type");
      }
  }
  exports.polyFillTypeToNative = polyFillTypeToNative;
  function clipTypeToNative(nativeLib, clipType) {
      switch (clipType) {
          case enums.ClipType.Intersection:
              return nativeLib.ClipType.Intersection;
          case enums.ClipType.Union:
              return nativeLib.ClipType.Union;
          case enums.ClipType.Difference:
              return nativeLib.ClipType.Difference;
          case enums.ClipType.Xor:
              return nativeLib.ClipType.Xor;
          default:
              throw new Error("unknown clip type");
      }
  }
  exports.clipTypeToNative = clipTypeToNative;
  function polyTypeToNative(nativeLib, polyType) {
      switch (polyType) {
          case enums.PolyType.Subject:
              return nativeLib.PolyType.Subject;
          case enums.PolyType.Clip:
              return nativeLib.PolyType.Clip;
          default:
              throw new Error("unknown poly type");
      }
  }
  exports.polyTypeToNative = polyTypeToNative;
  function joinTypeToNative(nativeLib, joinType) {
      switch (joinType) {
          case enums.JoinType.Square:
              return nativeLib.JoinType.Square;
          case enums.JoinType.Round:
              return nativeLib.JoinType.Round;
          case enums.JoinType.Miter:
              return nativeLib.JoinType.Miter;
          default:
              throw new Error("unknown join type");
      }
  }
  exports.joinTypeToNative = joinTypeToNative;
  function endTypeToNative(nativeLib, endType) {
      switch (endType) {
          case enums.EndType.ClosedPolygon:
              return nativeLib.EndType.ClosedPolygon;
          case enums.EndType.ClosedLine:
              return nativeLib.EndType.ClosedLine;
          case enums.EndType.OpenButt:
              return nativeLib.EndType.OpenButt;
          case enums.EndType.OpenSquare:
              return nativeLib.EndType.OpenSquare;
          case enums.EndType.OpenRound:
              return nativeLib.EndType.OpenRound;
          default:
              throw new Error("unknown end type");
      }
  }
  exports.endTypeToNative = endTypeToNative;

  });

  unwrapExports(nativeEnumConversion);
  var nativeEnumConversion_1 = nativeEnumConversion.polyFillTypeToNative;
  var nativeEnumConversion_2 = nativeEnumConversion.clipTypeToNative;
  var nativeEnumConversion_3 = nativeEnumConversion.polyTypeToNative;
  var nativeEnumConversion_4 = nativeEnumConversion.joinTypeToNative;
  var nativeEnumConversion_5 = nativeEnumConversion.endTypeToNative;

  var mem = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function mallocDoubleArray(nativeClipperLib, len) {
      var nofBytes = len * Float64Array.BYTES_PER_ELEMENT;
      var ptr = nativeClipperLib._malloc(nofBytes);
      return new Float64Array(nativeClipperLib.HEAPF64.buffer, ptr, len);
  }
  exports.mallocDoubleArray = mallocDoubleArray;
  function freeTypedArray(nativeClipperLib, array) {
      nativeClipperLib._free(array.byteOffset);
  }
  exports.freeTypedArray = freeTypedArray;

  });

  unwrapExports(mem);
  var mem_1 = mem.mallocDoubleArray;
  var mem_2 = mem.freeTypedArray;

  var PathToNativePath = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });

  var coordsPerPoint = 2;
  function getNofItemsForPath(path) {
      return 1 + path.length * coordsPerPoint;
  }
  exports.getNofItemsForPath = getNofItemsForPath;
  // js to c++
  function writePathToDoubleArray(path, heapBytes, startPtr) {
      var len = path.length;
      heapBytes[startPtr] = len;
      var arrayI = 1 + startPtr;
      for (var i = 0; i < len; i++) {
          heapBytes[arrayI++] = path[i].x;
          heapBytes[arrayI++] = path[i].y;
      }
      return arrayI;
  }
  exports.writePathToDoubleArray = writePathToDoubleArray;
  function pathToDoubleArray(nativeClipperLib, path) {
      var nofItems = getNofItemsForPath(path);
      var heapBytes = mem.mallocDoubleArray(nativeClipperLib, nofItems);
      writePathToDoubleArray(path, heapBytes, 0);
      return heapBytes;
  }
  exports.pathToDoubleArray = pathToDoubleArray;
  function doubleArrayToNativePath(nativeClipperLib, array, freeArray) {
      var p = new nativeClipperLib.Path();
      nativeClipperLib.toPath(p, array.byteOffset);
      if (freeArray) {
          mem.freeTypedArray(nativeClipperLib, array);
      }
      return p;
  }
  exports.doubleArrayToNativePath = doubleArrayToNativePath;
  function pathToNativePath(nativeClipperLib, path) {
      var array = pathToDoubleArray(nativeClipperLib, path);
      return doubleArrayToNativePath(nativeClipperLib, array, true);
  }
  exports.pathToNativePath = pathToNativePath;
  // c++ to js
  function nativePathToDoubleArray(nativeClipperLib, nativePath, freeNativePath) {
      var array = nativeClipperLib.fromPath(nativePath);
      if (freeNativePath) {
          nativePath.delete();
      }
      return array;
  }
  exports.nativePathToDoubleArray = nativePathToDoubleArray;
  function doubleArrayToPath(nativeClipperLib, array, _freeDoubleArray, startPtr) {
      var len = array[startPtr];
      var path = [];
      path.length = len;
      var arrayI = 1 + startPtr;
      for (var i = 0; i < len; i++) {
          path[i] = {
              x: array[arrayI++],
              y: array[arrayI++]
          };
      }
      if (_freeDoubleArray) {
          mem.freeTypedArray(nativeClipperLib, array);
      }
      return {
          path: path,
          ptrEnd: arrayI
      };
  }
  exports.doubleArrayToPath = doubleArrayToPath;
  function nativePathToPath(nativeClipperLib, nativePath, freeNativePath) {
      var array = nativePathToDoubleArray(nativeClipperLib, nativePath, freeNativePath);
      return doubleArrayToPath(nativeClipperLib, array, true, 0).path;
  }
  exports.nativePathToPath = nativePathToPath;

  });

  unwrapExports(PathToNativePath);
  var PathToNativePath_1 = PathToNativePath.getNofItemsForPath;
  var PathToNativePath_2 = PathToNativePath.writePathToDoubleArray;
  var PathToNativePath_3 = PathToNativePath.pathToDoubleArray;
  var PathToNativePath_4 = PathToNativePath.doubleArrayToNativePath;
  var PathToNativePath_5 = PathToNativePath.pathToNativePath;
  var PathToNativePath_6 = PathToNativePath.nativePathToDoubleArray;
  var PathToNativePath_7 = PathToNativePath.doubleArrayToPath;
  var PathToNativePath_8 = PathToNativePath.nativePathToPath;

  var PathsToNativePaths = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });


  // js to c++
  function pathsToDoubleArray(nativeClipperLib, myPaths) {
      var nofPaths = myPaths.length;
      // first calculate nof items required
      var nofItems = 1; // for path count
      for (var i = 0; i < nofPaths; i++) {
          nofItems += PathToNativePath.getNofItemsForPath(myPaths[i]);
      }
      var heapBytes = mem.mallocDoubleArray(nativeClipperLib, nofItems);
      heapBytes[0] = nofPaths;
      var ptr = 1;
      for (var i = 0; i < nofPaths; i++) {
          var path = myPaths[i];
          ptr = PathToNativePath.writePathToDoubleArray(path, heapBytes, ptr);
      }
      return heapBytes;
  }
  exports.pathsToDoubleArray = pathsToDoubleArray;
  function doubleArrayToNativePaths(nativeClipperLib, array, freeArray) {
      var p = new nativeClipperLib.Paths();
      nativeClipperLib.toPaths(p, array.byteOffset);
      if (freeArray) {
          mem.freeTypedArray(nativeClipperLib, array);
      }
      return p;
  }
  exports.doubleArrayToNativePaths = doubleArrayToNativePaths;
  function pathsToNativePaths(nativeClipperLib, paths) {
      var array = pathsToDoubleArray(nativeClipperLib, paths);
      return doubleArrayToNativePaths(nativeClipperLib, array, true);
  }
  exports.pathsToNativePaths = pathsToNativePaths;
  // c++ to js
  function nativePathsToDoubleArray(nativeClipperLib, nativePaths, freeNativePaths) {
      var array = nativeClipperLib.fromPaths(nativePaths);
      if (freeNativePaths) {
          nativePaths.delete();
      }
      return array;
  }
  exports.nativePathsToDoubleArray = nativePathsToDoubleArray;
  function doubleArrayToPaths(nativeClipperLib, array, _freeDoubleArray) {
      var len = array[0];
      var paths = [];
      paths.length = len;
      var arrayI = 1;
      for (var i = 0; i < len; i++) {
          var result = PathToNativePath.doubleArrayToPath(nativeClipperLib, array, false, arrayI);
          paths[i] = result.path;
          arrayI = result.ptrEnd;
      }
      if (_freeDoubleArray) {
          mem.freeTypedArray(nativeClipperLib, array);
      }
      return paths;
  }
  exports.doubleArrayToPaths = doubleArrayToPaths;
  function nativePathsToPaths(nativeClipperLib, nativePaths, freeNativePaths) {
      var array = nativePathsToDoubleArray(nativeClipperLib, nativePaths, freeNativePaths);
      return doubleArrayToPaths(nativeClipperLib, array, true);
  }
  exports.nativePathsToPaths = nativePathsToPaths;

  });

  unwrapExports(PathsToNativePaths);
  var PathsToNativePaths_1 = PathsToNativePaths.pathsToDoubleArray;
  var PathsToNativePaths_2 = PathsToNativePaths.doubleArrayToNativePaths;
  var PathsToNativePaths_3 = PathsToNativePaths.pathsToNativePaths;
  var PathsToNativePaths_4 = PathsToNativePaths.nativePathsToDoubleArray;
  var PathsToNativePaths_5 = PathsToNativePaths.doubleArrayToPaths;
  var PathsToNativePaths_6 = PathsToNativePaths.nativePathsToPaths;

  var PolyNode_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });

  /**
   * PolyNodes are encapsulated within a PolyTree container, and together provide a data structure representing the parent-child relationships of polygon
   * contours returned by clipping/ofsetting methods.
   *
   * A PolyNode object represents a single polygon. It's isHole property indicates whether it's an outer or a hole. PolyNodes may own any number of PolyNode
   * children (childs), where children of outer polygons are holes, and children of holes are (nested) outer polygons.
   */
  var PolyNode = /** @class */ (function () {
      function PolyNode() {
          this._childs = [];
          this._contour = [];
          this._isOpen = false;
          this._index = 0;
      }
      Object.defineProperty(PolyNode.prototype, "parent", {
          /**
           * Returns the parent PolyNode.
           *
           * The PolyTree object (which is also a PolyNode) does not have a parent and will return undefined.
           */
          get: function () {
              return this._parent;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(PolyNode.prototype, "childs", {
          /**
           * A read-only list of PolyNode.
           * Outer PolyNode childs contain hole PolyNodes, and hole PolyNode childs contain nested outer PolyNodes.
           */
          get: function () {
              return this._childs;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(PolyNode.prototype, "contour", {
          /**
           * Returns a path list which contains any number of vertices.
           */
          get: function () {
              return this._contour;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(PolyNode.prototype, "isOpen", {
          /**
           * Returns true when the PolyNode's Contour results from a clipping operation on an open contour (path). Only top-level PolyNodes can contain open contours.
           */
          get: function () {
              return this._isOpen;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(PolyNode.prototype, "index", {
          /**
           * Index in the parent's child list, or 0 if no parent.
           */
          get: function () {
              return this._index;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(PolyNode.prototype, "isHole", {
          /**
           * Returns true when the PolyNode's polygon (Contour) is a hole.
           *
           * Children of outer polygons are always holes, and children of holes are always (nested) outer polygons.
           * The isHole property of a PolyTree object is undefined but its children are always top-level outer polygons.
           *
           * @return {boolean}
           */
          get: function () {
              if (this._isHole === undefined) {
                  var result = true;
                  var node = this._parent;
                  while (node !== undefined) {
                      result = !result;
                      node = node._parent;
                  }
                  this._isHole = result;
              }
              return this._isHole;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * The returned PolyNode will be the first child if any, otherwise the next sibling, otherwise the next sibling of the Parent etc.
       *
       * A PolyTree can be traversed very easily by calling GetFirst() followed by GetNext() in a loop until the returned object is undefined.
       *
       * @return {PolyNode | undefined}
       */
      PolyNode.prototype.getNext = function () {
          if (this._childs.length > 0) {
              return this._childs[0];
          }
          else {
              return this.getNextSiblingUp();
          }
      };
      PolyNode.prototype.getNextSiblingUp = function () {
          if (this._parent === undefined) {
              return undefined;
          }
          else if (this._index === this._parent._childs.length - 1) {
              //noinspection TailRecursionJS
              return this._parent.getNextSiblingUp();
          }
          else {
              return this._parent._childs[this._index + 1];
          }
      };
      PolyNode.fillFromNativePolyNode = function (pn, nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode) {
          pn._parent = parent;
          var childs = nativePolyNode.childs;
          for (var i = 0, max = childs.size(); i < max; i++) {
              var newChild = PolyNode.fromNativePolyNode(nativeLib, childs.get(i), pn, i, freeNativePolyNode);
              pn._childs.push(newChild);
          }
          // do we need to clear the object ourselves? for now let's assume so (seems to work)
          pn._contour = PathToNativePath.nativePathToPath(nativeLib, nativePolyNode.contour, true);
          pn._isOpen = nativePolyNode.isOpen();
          pn._index = childIndex;
          if (freeNativePolyNode) {
              nativePolyNode.delete();
          }
      };
      PolyNode.fromNativePolyNode = function (nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode) {
          var pn = new PolyNode();
          PolyNode.fillFromNativePolyNode(pn, nativeLib, nativePolyNode, parent, childIndex, freeNativePolyNode);
          return pn;
      };
      return PolyNode;
  }());
  exports.PolyNode = PolyNode;

  });

  unwrapExports(PolyNode_1);
  var PolyNode_2 = PolyNode_1.PolyNode;

  var PolyTree_1 = createCommonjsModule(function (module, exports) {
  var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Object.defineProperty(exports, "__esModule", { value: true });

  /**
   * PolyTree is intended as a read-only data structure that should only be used to receive solutions from clipping and offsetting operations. It's an
   * alternative to the Paths data structure which also receives these solutions. PolyTree's two major advantages over the Paths structure are: it properly
   * represents the parent-child relationships of the returned polygons; it differentiates between open and closed paths. However, since PolyTree is a more
   * complex structure than the Paths structure, and since it's more computationally expensive to process (the Execute method being roughly 5-10% slower), it
   * should used only be when parent-child polygon relationships are needed, or when open paths are being 'clipped'.
   *
   * A PolyTree object is a container for any number of PolyNode children, with each contained PolyNode representing a single polygon contour (either an outer
   * or hole polygon). PolyTree itself is a specialized PolyNode whose immediate children represent the top-level outer polygons of the solution. (It's own
   * Contour property is always empty.) The contained top-level PolyNodes may contain their own PolyNode children representing hole polygons that may also
   * contain children representing nested outer polygons etc. Children of outers will always be holes, and children of holes will always be outers.
   *
   * PolyTrees can also contain open paths. Open paths will always be represented by top level PolyNodes. Two functions are provided to quickly separate out
   * open and closed paths from a polytree - openPathsFromPolyTree and closedPathsFromPolyTree.
   */
  var PolyTree = /** @class */ (function (_super) {
      __extends(PolyTree, _super);
      function PolyTree() {
          var _this = _super.call(this) || this;
          _this._total = 0;
          return _this;
      }
      Object.defineProperty(PolyTree.prototype, "total", {
          /**
           * Returns the total number of PolyNodes (polygons) contained within the PolyTree. This value is not to be confused with childs.length which returns the
           * number of immediate children only (Childs) contained by PolyTree.
           */
          get: function () {
              return this._total;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * This method returns the first outer polygon contour if any, otherwise undefined.
       *
       * This function is equivalent to calling childs[0].
       */
      PolyTree.prototype.getFirst = function () {
          if (this.childs.length > 0) {
              return this.childs[0];
          }
          else {
              return undefined;
          }
      };
      /**
       * Internal use.
       * Constructs a PolyTree from a native PolyTree.
       */
      PolyTree.fromNativePolyTree = function (nativeLib, nativePolyTree, freeNativePolyTree) {
          var pt = new PolyTree();
          PolyNode_1.PolyNode.fillFromNativePolyNode(pt, nativeLib, nativePolyTree, undefined, 0, false); // do NOT free them, they are freed on destruction of the polytree
          pt._total = nativePolyTree.total();
          if (freeNativePolyTree) {
              nativePolyTree.delete(); // this deletes all inner paths, contours etc
          }
          return pt;
      };
      return PolyTree;
  }(PolyNode_1.PolyNode));
  exports.PolyTree = PolyTree;

  });

  unwrapExports(PolyTree_1);
  var PolyTree_2 = PolyTree_1.PolyTree;

  var Clipper_1 = createCommonjsModule(function (module, exports) {
  var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });




  var Clipper = /** @class */ (function () {
      /**
       * The Clipper constructor creates an instance of the Clipper class. One or more InitOptions may be passed as a parameter to set the corresponding properties.
       * (These properties can still be set or reset after construction.)
       *
       * @param _nativeLib
       * @param initOptions
       */
      function Clipper(_nativeLib, initOptions) {
          if (initOptions === void 0) { initOptions = {}; }
          this._nativeLib = _nativeLib;
          var realInitOptions = __assign({ reverseSolutions: false, strictlySimple: false, preserveCollinear: false }, initOptions);
          var nativeInitOptions = 0;
          if (realInitOptions.reverseSolutions) {
              nativeInitOptions += _nativeLib.InitOptions.ReverseSolution;
          }
          if (realInitOptions.strictlySimple) {
              nativeInitOptions += _nativeLib.InitOptions.StrictlySimple;
          }
          if (realInitOptions.preserveCollinear) {
              nativeInitOptions += _nativeLib.InitOptions.PreserveCollinear;
          }
          this._clipper = new _nativeLib.Clipper(nativeInitOptions);
      }
      Object.defineProperty(Clipper.prototype, "preserveCollinear", {
          /**
           * By default, when three or more vertices are collinear in input polygons (subject or clip), the Clipper object removes the 'inner' vertices before
           * clipping. When enabled the preserveCollinear property prevents this default behavior to allow these inner vertices to appear in the solution.
           *
           * @return {boolean} - true if set, false otherwise
           */
          get: function () {
              return this._clipper.preserveCollinear;
          },
          /**
           * By default, when three or more vertices are collinear in input polygons (subject or clip), the Clipper object removes the 'inner' vertices before
           * clipping. When enabled the preserveCollinear property prevents this default behavior to allow these inner vertices to appear in the solution.
           *
           * @param value - value to set
           */
          set: function (value) {
              this._clipper.preserveCollinear = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Clipper.prototype, "reverseSolution", {
          /**
           * When this property is set to true, polygons returned in the solution parameter of the execute() method will have orientations opposite to their normal
           * orientations.
           *
           * @return {boolean} - true if set, false otherwise
           */
          get: function () {
              return this._clipper.reverseSolution;
          },
          /**
           * When this property is set to true, polygons returned in the solution parameter of the execute() method will have orientations opposite to their normal
           * orientations.
           *
           * @param value - value to set
           */
          set: function (value) {
              this._clipper.reverseSolution = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Clipper.prototype, "strictlySimple", {
          /**
           * Terminology:
           * - A simple polygon is one that does not self-intersect.
           * - A weakly simple polygon is a simple polygon that contains 'touching' vertices, or 'touching' edges.
           * - A strictly simple polygon is a simple polygon that does not contain 'touching' vertices, or 'touching' edges.
           *
           * Vertices 'touch' if they share the same coordinates (and are not adjacent). An edge touches another if one of its end vertices touches another edge
           * excluding its adjacent edges, or if they are co-linear and overlapping (including adjacent edges).
           *
           * Polygons returned by clipping operations (see Clipper.execute()) should always be simple polygons. When the StrictlySimply property is enabled,
           * polygons returned will be strictly simple, otherwise they may be weakly simple. It's computationally expensive ensuring polygons are strictly simple
           * and so this property is disabled by default.
           *
           * Note: There's currently no guarantee that polygons will be strictly simple since 'simplifying' is still a work in progress.
           *
           * @return {boolean} - true if set, false otherwise
           */
          get: function () {
              return this._clipper.strictlySimple;
          },
          /**
           * Terminology:
           * - A simple polygon is one that does not self-intersect.
           * - A weakly simple polygon is a simple polygon that contains 'touching' vertices, or 'touching' edges.
           * - A strictly simple polygon is a simple polygon that does not contain 'touching' vertices, or 'touching' edges.
           *
           * Vertices 'touch' if they share the same coordinates (and are not adjacent). An edge touches another if one of its end vertices touches another edge
           * excluding its adjacent edges, or if they are co-linear and overlapping (including adjacent edges).
           *
           * Polygons returned by clipping operations (see Clipper.execute()) should always be simple polygons. When the StrictlySimply property is enabled,
           * polygons returned will be strictly simple, otherwise they may be weakly simple. It's computationally expensive ensuring polygons are strictly simple
           * and so this property is disabled by default.
           *
           * Note: There's currently no guarantee that polygons will be strictly simple since 'simplifying' is still a work in progress.
           *
           * @param value - value to set
           */
          set: function (value) {
              this._clipper.strictlySimple = value;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Any number of subject and clip paths can be added to a clipping task, either individually via the addPath() method, or as groups via the addPaths()
       * method, or even using both methods.
       *
       * 'Subject' paths may be either open (lines) or closed (polygons) or even a mixture of both, but 'clipping' paths must always be closed. Clipper allows
       * polygons to clip both lines and other polygons, but doesn't allow lines to clip either lines or polygons.
       *
       * With closed paths, orientation should conform with the filling rule that will be passed via Clipper's execute method.
       *
       * Path Coordinate range:
       * Path coordinates must be between Â± 9007199254740991, otherwise a range error will be thrown when attempting to add the path to the Clipper object.
       * If coordinates can be kept between Â± 0x3FFFFFFF (Â± 1.0e+9), a modest increase in performance (approx. 15-20%) over the larger range can be achieved by
       * avoiding large integer math.
       *
       * Return Value:
       * The function will return false if the path is invalid for clipping. A path is invalid for clipping when:
       * - it has less than 2 vertices
       * - it has 2 vertices but is not an open path
       * - the vertices are all co-linear and it is not an open path
       *
       * @param path - Path to add
       * @param polyType - Polygon type
       * @param closed - If the path is closed
       */
      Clipper.prototype.addPath = function (path, polyType, closed) {
          var nativePath = PathToNativePath.pathToNativePath(this._nativeLib, path);
          try {
              return this._clipper.addPath(nativePath, nativeEnumConversion.polyTypeToNative(this._nativeLib, polyType), closed);
          }
          finally {
              nativePath.delete();
          }
      };
      /**
       * Any number of subject and clip paths can be added to a clipping task, either individually via the addPath() method, or as groups via the addPaths()
       * method, or even using both methods.
       *
       * 'Subject' paths may be either open (lines) or closed (polygons) or even a mixture of both, but 'clipping' paths must always be closed. Clipper allows
       * polygons to clip both lines and other polygons, but doesn't allow lines to clip either lines or polygons.
       *
       * With closed paths, orientation should conform with the filling rule that will be passed via Clipper's execute method.
       *
       * Path Coordinate range:
       * Path coordinates must be between Â± 9007199254740991, otherwise a range error will be thrown when attempting to add the path to the Clipper object.
       * If coordinates can be kept between Â± 0x3FFFFFFF (Â± 1.0e+9), a modest increase in performance (approx. 15-20%) over the larger range can be achieved
       * by avoiding large integer math.
       *
       * Return Value:
       * The function will return false if the path is invalid for clipping. A path is invalid for clipping when:
       * - it has less than 2 vertices
       * - it has 2 vertices but is not an open path
       * - the vertices are all co-linear and it is not an open path
       *
       * @param paths - Paths to add
       * @param polyType - Paths polygon type
       * @param closed - If all the inner paths are closed
       */
      Clipper.prototype.addPaths = function (paths, polyType, closed) {
          var nativePaths = PathsToNativePaths.pathsToNativePaths(this._nativeLib, paths);
          try {
              return this._clipper.addPaths(nativePaths, nativeEnumConversion.polyTypeToNative(this._nativeLib, polyType), closed);
          }
          finally {
              nativePaths.delete();
          }
      };
      /**
       * The Clear method removes any existing subject and clip polygons allowing the Clipper object to be reused for clipping operations on different polygon sets.
       */
      Clipper.prototype.clear = function () {
          this._clipper.clear();
      };
      /**
       * This method returns the axis-aligned bounding rectangle of all polygons that have been added to the Clipper object.
       *
       * @return {{left: number, right: number, top: number, bottom: number}} - Bounds
       */
      Clipper.prototype.getBounds = function () {
          var nativeBounds = this._clipper.getBounds();
          var rect = {
              left: nativeBounds.left,
              right: nativeBounds.right,
              top: nativeBounds.top,
              bottom: nativeBounds.bottom
          };
          nativeBounds.delete();
          return rect;
      };
      /**
       * Once subject and clip paths have been assigned (via addPath and/or addPaths), execute can then perform the clipping operation (intersection, union,
       * difference or XOR) specified by the clipType parameter.
       *
       * The solution parameter in this case is a Paths or PolyTree structure. The Paths structure is simpler than the PolyTree structure. Because of this it is
       * quicker to populate and hence clipping performance is a little better (it's roughly 10% faster). However, the PolyTree data structure provides more
       * information about the returned paths which may be important to users. Firstly, the PolyTree structure preserves nested parent-child polygon relationships
       * (ie outer polygons owning/containing holes and holes owning/containing other outer polygons etc). Also, only the PolyTree structure can differentiate
       * between open and closed paths since each PolyNode has an IsOpen property. (The Path structure has no member indicating whether it's open or closed.)
       * For this reason, when open paths are passed to a Clipper object, the user must use a PolyTree object as the solution parameter, otherwise an exception
       * will be raised.
       *
       * When a PolyTree object is used in a clipping operation on open paths, two ancilliary functions have been provided to quickly separate out open and
       * closed paths from the solution - OpenPathsFromPolyTree and ClosedPathsFromPolyTree. PolyTreeToPaths is also available to convert path data to a Paths
       * structure (irrespective of whether they're open or closed).
       *
       * There are several things to note about the solution paths returned:
       * - they aren't in any specific order
       * - they should never overlap or be self-intersecting (but see notes on rounding)
       * - holes will be oriented opposite outer polygons
       * - the solution fill type can be considered either EvenOdd or NonZero since it will comply with either filling rule
       * - polygons may rarely share a common edge (though this is now very rare as of version 6)
       *
       * The subjFillType and clipFillType parameters define the polygon fill rule to be applied to the polygons (ie closed paths) in the subject and clip
       * paths respectively. (It's usual though obviously not essential that both sets of polygons use the same fill rule.)
       *
       * execute can be called multiple times without reassigning subject and clip polygons (ie when different clipping operations are required on the
       * same polygon sets).
       *
       * @param clipType - Clip operation type
       * @param subjFillType - Fill type of the subject polygons
       * @param clipFillType - Fill type of the clip polygons
       * @param cleanDistance - Clean distance over the output, or undefined for no cleaning.
       * @return {Paths | undefined} - The solution or undefined if there was an error
       */
      Clipper.prototype.executeToPaths = function (clipType, subjFillType, clipFillType, cleanDistance) {
          var outNativePaths = new this._nativeLib.Paths();
          try {
              var success = this._clipper.executePathsWithFillTypes(nativeEnumConversion.clipTypeToNative(this._nativeLib, clipType), outNativePaths, nativeEnumConversion.polyFillTypeToNative(this._nativeLib, subjFillType), nativeEnumConversion.polyFillTypeToNative(this._nativeLib, clipFillType));
              if (!success) {
                  return undefined;
              }
              else {
                  if (cleanDistance !== undefined) {
                      this._nativeLib.cleanPolygons(outNativePaths, cleanDistance);
                  }
                  return PathsToNativePaths.nativePathsToPaths(this._nativeLib, outNativePaths, true); // frees outNativePaths
              }
          }
          finally {
              if (!outNativePaths.isDeleted()) {
                  outNativePaths.delete();
              }
          }
      };
      /**
       * Once subject and clip paths have been assigned (via addPath and/or addPaths), execute can then perform the clipping operation (intersection, union,
       * difference or XOR) specified by the clipType parameter.
       *
       * The solution parameter can be either a Paths or PolyTree structure. The Paths structure is simpler than the PolyTree structure. Because of this it is
       * quicker to populate and hence clipping performance is a little better (it's roughly 10% faster). However, the PolyTree data structure provides more
       * information about the returned paths which may be important to users. Firstly, the PolyTree structure preserves nested parent-child polygon relationships
       * (ie outer polygons owning/containing holes and holes owning/containing other outer polygons etc). Also, only the PolyTree structure can differentiate
       * between open and closed paths since each PolyNode has an IsOpen property. (The Path structure has no member indicating whether it's open or closed.)
       * For this reason, when open paths are passed to a Clipper object, the user must use a PolyTree object as the solution parameter, otherwise an exception
       * will be raised.
       *
       * When a PolyTree object is used in a clipping operation on open paths, two ancilliary functions have been provided to quickly separate out open and
       * closed paths from the solution - OpenPathsFromPolyTree and ClosedPathsFromPolyTree. PolyTreeToPaths is also available to convert path data to a Paths
       * structure (irrespective of whether they're open or closed).
       *
       * There are several things to note about the solution paths returned:
       * - they aren't in any specific order
       * - they should never overlap or be self-intersecting (but see notes on rounding)
       * - holes will be oriented opposite outer polygons
       * - the solution fill type can be considered either EvenOdd or NonZero since it will comply with either filling rule
       * - polygons may rarely share a common edge (though this is now very rare as of version 6)
       *
       * The subjFillType and clipFillType parameters define the polygon fill rule to be applied to the polygons (ie closed paths) in the subject and clip
       * paths respectively. (It's usual though obviously not essential that both sets of polygons use the same fill rule.)
       *
       * execute can be called multiple times without reassigning subject and clip polygons (ie when different clipping operations are required on the
       * same polygon sets).
       *
       * @param clipType - Clip operation type
       * @param subjFillType - Fill type of the subject polygons
       * @param clipFillType - Fill type of the clip polygons
       * @return {PolyTree | undefined} - The solution or undefined if there was an error
       */
      Clipper.prototype.executeToPolyTee = function (clipType, subjFillType, clipFillType) {
          var outNativePolyTree = new this._nativeLib.PolyTree();
          try {
              var success = this._clipper.executePolyTreeWithFillTypes(nativeEnumConversion.clipTypeToNative(this._nativeLib, clipType), outNativePolyTree, nativeEnumConversion.polyFillTypeToNative(this._nativeLib, subjFillType), nativeEnumConversion.polyFillTypeToNative(this._nativeLib, clipFillType));
              if (!success) {
                  return undefined;
              }
              else {
                  return PolyTree_1.PolyTree.fromNativePolyTree(this._nativeLib, outNativePolyTree, true); // frees outNativePolyTree
              }
          }
          finally {
              if (!outNativePolyTree.isDeleted()) {
                  outNativePolyTree.delete();
              }
          }
      };
      /**
       * Checks if the object has been disposed.
       *
       * @return {boolean} - true if disposed, false if not
       */
      Clipper.prototype.isDisposed = function () {
          return this._clipper === undefined || this._clipper.isDeleted();
      };
      /**
       * Since this library uses WASM/ASM.JS internally for speed this means that you must dispose objects after you are done using them or mem leaks will occur.
       */
      Clipper.prototype.dispose = function () {
          if (this._clipper) {
              this._clipper.delete();
              this._clipper = undefined;
          }
      };
      return Clipper;
  }());
  exports.Clipper = Clipper;

  });

  unwrapExports(Clipper_1);
  var Clipper_2 = Clipper_1.Clipper;

  var ClipperError_1 = createCommonjsModule(function (module, exports) {
  var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Object.defineProperty(exports, "__esModule", { value: true });
  var ClipperError = /** @class */ (function (_super) {
      __extends(ClipperError, _super);
      function ClipperError(message) {
          var _this = _super.call(this, message) || this;
          _this.message = message;
          Object.setPrototypeOf(_this, ClipperError.prototype);
          _this.name = _this.constructor.name;
          _this.stack = new Error().stack;
          return _this;
      }
      return ClipperError;
  }(Error));
  exports.ClipperError = ClipperError;

  });

  unwrapExports(ClipperError_1);
  var ClipperError_2 = ClipperError_1.ClipperError;

  var clipFunctions = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });



  var devMode =  process.env && process.env.NODE_ENV !== "production";
  var addPathOrPaths = function (clipper, inputDatas, polyType) {
      if (inputDatas === undefined) {
          return;
      }
      // add each input
      for (var i = 0, maxi = inputDatas.length; i < maxi; i++) {
          var inputData = inputDatas[i];
          // add the path/paths
          var pathOrPaths = inputData.data;
          if (!pathOrPaths || pathOrPaths.length <= 0) {
              continue;
          }
          var closed_1 = inputData.closed === undefined ? true : inputData.closed;
          // is it a path or paths?
          if (Array.isArray(pathOrPaths[0])) {
              // paths
              if (!clipper.addPaths(pathOrPaths, polyType, closed_1)) {
                  throw new ClipperError_1.ClipperError("invalid paths");
              }
          }
          else {
              // path
              if (!clipper.addPath(pathOrPaths, polyType, closed_1)) {
                  throw new ClipperError_1.ClipperError(`invalid path: ${JSON.stringify(pathOrPaths)}`);
              }
          }
      }
  };
  function clipToPathsOrPolyTree(polyTreeMode, nativeClipperLib, params) {
      if (devMode) {
          if (!polyTreeMode && params.subjectInputs && params.subjectInputs.some(function (si) { return !si.closed; })) {
              throw new Error("clip to a PolyTree (not to a Path) when using open paths");
          }
      }
      var clipper = new Clipper_1.Clipper(nativeClipperLib, params);
      //noinspection UnusedCatchParameterJS
      try {
          addPathOrPaths(clipper, params.subjectInputs, enums.PolyType.Subject);
          addPathOrPaths(clipper, params.clipInputs, enums.PolyType.Clip);
          var result = void 0;
          var clipFillType = params.clipFillType === undefined ? params.subjectFillType : params.clipFillType;
          if (!polyTreeMode) {
              result = clipper.executeToPaths(params.clipType, params.subjectFillType, clipFillType, params.cleanDistance);
          }
          else {
              if (params.cleanDistance !== undefined) {
                  throw new ClipperError_1.ClipperError("cleaning is not available for poly tree results");
              }
              result = clipper.executeToPolyTee(params.clipType, params.subjectFillType, clipFillType);
          }
          if (result === undefined) {
              throw new ClipperError_1.ClipperError("error while performing clipping task");
          }
          return result;
      }
      finally {
          clipper.dispose();
      }
  }
  exports.clipToPathsOrPolyTree = clipToPathsOrPolyTree;
  function clipToPaths(nativeClipperLib, params) {
      return clipToPathsOrPolyTree(false, nativeClipperLib, params);
  }
  exports.clipToPaths = clipToPaths;
  function clipToPolyTree(nativeClipperLib, params) {
      return clipToPathsOrPolyTree(true, nativeClipperLib, params);
  }
  exports.clipToPolyTree = clipToPolyTree;

  });

  unwrapExports(clipFunctions);
  var clipFunctions_1 = clipFunctions.clipToPathsOrPolyTree;
  var clipFunctions_2 = clipFunctions.clipToPaths;
  var clipFunctions_3 = clipFunctions.clipToPolyTree;

  var constants = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  /**
   * Max coordinate value (both positive and negative)
   */
  exports.hiRange = 9007199254740991;

  });

  unwrapExports(constants);
  var constants_1 = constants.hiRange;

  var functions = createCommonjsModule(function (module, exports) {
  var __values = (commonjsGlobal && commonjsGlobal.__values) || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });




  function tryDelete() {
      var e_1, _a;
      var objs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          objs[_i] = arguments[_i];
      }
      try {
          for (var objs_1 = __values(objs), objs_1_1 = objs_1.next(); !objs_1_1.done; objs_1_1 = objs_1.next()) {
              var obj = objs_1_1.value;
              if (!obj.isDeleted()) {
                  obj.delete();
              }
          }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
          try {
              if (objs_1_1 && !objs_1_1.done && (_a = objs_1.return)) _a.call(objs_1);
          }
          finally { if (e_1) throw e_1.error; }
      }
  }
  function area(path) {
      // we use JS since copying structures is slower than actually doing it
      var cnt = path.length;
      if (cnt < 3) {
          return 0;
      }
      var a = 0;
      for (var i = 0, j = cnt - 1; i < cnt; ++i) {
          a += (path[j].x + path[i].x) * (path[j].y - path[i].y);
          j = i;
      }
      return -a * 0.5;
  }
  exports.area = area;
  function cleanPolygon(nativeLib, path, distance) {
      if (distance === void 0) { distance = 1.1415; }
      var nativePath = PathToNativePath.pathToNativePath(nativeLib, path);
      try {
          nativeLib.cleanPolygon(nativePath, distance);
          return PathToNativePath.nativePathToPath(nativeLib, nativePath, true); // frees nativePath
      }
      finally {
          tryDelete(nativePath);
      }
  }
  exports.cleanPolygon = cleanPolygon;
  function cleanPolygons(nativeLib, paths, distance) {
      if (distance === void 0) { distance = 1.1415; }
      var nativePaths = PathsToNativePaths.pathsToNativePaths(nativeLib, paths);
      try {
          nativeLib.cleanPolygons(nativePaths, distance);
          return PathsToNativePaths.nativePathsToPaths(nativeLib, nativePaths, true); // frees nativePath
      }
      finally {
          tryDelete(nativePaths);
      }
  }
  exports.cleanPolygons = cleanPolygons;
  function addPolyNodeToPaths(polynode, nt, paths) {
      var match = true;
      switch (nt) {
          case 1 /* Open */:
              return;
          case 2 /* Closed */:
              match = !polynode.isOpen;
              break;
      }
      if (polynode.contour.length > 0 && match) {
          paths.push(polynode.contour);
      }
      for (var ii = 0, max = polynode.childs.length; ii < max; ii++) {
          var pn = polynode.childs[ii];
          addPolyNodeToPaths(pn, nt, paths);
      }
  }
  function closedPathsFromPolyTree(polyTree) {
      // we do this in JS since copying path is more expensive than just doing it
      var result = [];
      // result.Capacity = polytree.Total;
      addPolyNodeToPaths(polyTree, 2 /* Closed */, result);
      return result;
  }
  exports.closedPathsFromPolyTree = closedPathsFromPolyTree;
  function minkowskiDiff(nativeLib, poly1, poly2) {
      var nativePath1 = PathToNativePath.pathToNativePath(nativeLib, poly1);
      var nativePath2 = PathToNativePath.pathToNativePath(nativeLib, poly2);
      var outNativePaths = new nativeLib.Paths();
      try {
          nativeLib.minkowskiDiff(nativePath1, nativePath2, outNativePaths);
          tryDelete(nativePath1, nativePath2);
          return PathsToNativePaths.nativePathsToPaths(nativeLib, outNativePaths, true); // frees outNativePaths
      }
      finally {
          tryDelete(nativePath1, nativePath2, outNativePaths);
      }
  }
  exports.minkowskiDiff = minkowskiDiff;
  function minkowskiSumPath(nativeLib, pattern, path, pathIsClosed) {
      var patternNativePath = PathToNativePath.pathToNativePath(nativeLib, pattern);
      var nativePath = PathToNativePath.pathToNativePath(nativeLib, path);
      var outNativePaths = new nativeLib.Paths();
      try {
          nativeLib.minkowskiSumPath(patternNativePath, nativePath, outNativePaths, pathIsClosed);
          tryDelete(patternNativePath, nativePath);
          return PathsToNativePaths.nativePathsToPaths(nativeLib, outNativePaths, true); // frees outNativePaths
      }
      finally {
          tryDelete(patternNativePath, nativePath, outNativePaths);
      }
  }
  exports.minkowskiSumPath = minkowskiSumPath;
  function minkowskiSumPaths(nativeLib, pattern, paths, pathIsClosed) {
      // TODO: im not sure if for this method we can reuse the input/output path
      var patternNativePath = PathToNativePath.pathToNativePath(nativeLib, pattern);
      var nativePaths = PathsToNativePaths.pathsToNativePaths(nativeLib, paths);
      try {
          nativeLib.minkowskiSumPaths(patternNativePath, nativePaths, nativePaths, pathIsClosed);
          tryDelete(patternNativePath);
          return PathsToNativePaths.nativePathsToPaths(nativeLib, nativePaths, true); // frees nativePaths
      }
      finally {
          tryDelete(patternNativePath, nativePaths);
      }
  }
  exports.minkowskiSumPaths = minkowskiSumPaths;
  function openPathsFromPolyTree(polyTree) {
      // we do this in JS since copying path is more expensive than just doing it
      var result = [];
      var len = polyTree.childs.length;
      result.length = len;
      var resultLength = 0;
      for (var i = 0; i < len; i++) {
          if (polyTree.childs[i].isOpen) {
              result[resultLength++] = polyTree.childs[i].contour;
          }
      }
      result.length = resultLength;
      return result;
  }
  exports.openPathsFromPolyTree = openPathsFromPolyTree;
  function orientation(path) {
      return area(path) >= 0;
  }
  exports.orientation = orientation;
  function pointInPolygon(point, path) {
      // we do this in JS since copying path is more expensive than just doing it
      // returns 0 if false, +1 if true, -1 if pt ON polygon boundary
      // See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
      // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
      var result = 0;
      var cnt = path.length;
      if (cnt < 3) {
          return 0;
      }
      var ip = path[0];
      for (var i = 1; i <= cnt; ++i) {
          var ipNext = i === cnt ? path[0] : path[i];
          if (ipNext.y === point.y) {
              if (ipNext.x === point.x || (ip.y === point.y && ipNext.x > point.x === ip.x < point.x)) {
                  return -1;
              }
          }
          if (ip.y < point.y !== ipNext.y < point.y) {
              if (ip.x >= point.x) {
                  if (ipNext.x > point.x) {
                      result = 1 - result;
                  }
                  else {
                      var d = (ip.x - point.x) * (ipNext.y - point.y) - (ipNext.x - point.x) * (ip.y - point.y);
                      if (d === 0) {
                          return -1;
                      }
                      else if (d > 0 === ipNext.y > ip.y) {
                          result = 1 - result;
                      }
                  }
              }
              else {
                  if (ipNext.x > point.x) {
                      var d = (ip.x - point.x) * (ipNext.y - point.y) - (ipNext.x - point.x) * (ip.y - point.y);
                      if (d === 0) {
                          return -1;
                      }
                      else if (d > 0 === ipNext.y > ip.y) {
                          result = 1 - result;
                      }
                  }
              }
          }
          ip = ipNext;
      }
      return result;
  }
  exports.pointInPolygon = pointInPolygon;
  function polyTreeToPaths(polyTree) {
      // we do this in JS since copying path is more expensive than just doing it
      var result = [];
      // result.Capacity = polytree.total;
      addPolyNodeToPaths(polyTree, 0 /* Any */, result);
      return result;
  }
  exports.polyTreeToPaths = polyTreeToPaths;
  function reversePath(path) {
      // we use JS since copying structures is slower than actually doing it
      path.reverse();
  }
  exports.reversePath = reversePath;
  function reversePaths(paths) {
      // we use JS since copying structures is slower than actually doing it
      for (var i = 0, max = paths.length; i < max; i++) {
          reversePath(paths[i]);
      }
  }
  exports.reversePaths = reversePaths;
  function simplifyPolygon(nativeLib, path, fillType) {
      if (fillType === void 0) { fillType = enums.PolyFillType.EvenOdd; }
      var nativePath = PathToNativePath.pathToNativePath(nativeLib, path);
      var outNativePaths = new nativeLib.Paths();
      try {
          nativeLib.simplifyPolygon(nativePath, outNativePaths, nativeEnumConversion.polyFillTypeToNative(nativeLib, fillType));
          tryDelete(nativePath);
          return PathsToNativePaths.nativePathsToPaths(nativeLib, outNativePaths, true); // frees outNativePaths
      }
      finally {
          tryDelete(nativePath, outNativePaths);
      }
  }
  exports.simplifyPolygon = simplifyPolygon;
  function simplifyPolygons(nativeLib, paths, fillType) {
      if (fillType === void 0) { fillType = enums.PolyFillType.EvenOdd; }
      var nativePaths = PathsToNativePaths.pathsToNativePaths(nativeLib, paths);
      try {
          nativeLib.simplifyPolygonsOverwrite(nativePaths, nativeEnumConversion.polyFillTypeToNative(nativeLib, fillType));
          return PathsToNativePaths.nativePathsToPaths(nativeLib, nativePaths, true); // frees nativePaths
      }
      finally {
          tryDelete(nativePaths);
      }
  }
  exports.simplifyPolygons = simplifyPolygons;
  function scalePath(path, scale) {
      var sol = [];
      var i = path.length;
      while (i--) {
          var p = path[i];
          sol.push({
              x: Math.round(p.x * scale),
              y: Math.round(p.y * scale)
          });
      }
      return sol;
  }
  exports.scalePath = scalePath;
  /**
   * Scales all inner paths by multiplying all its coordinates by a number and then rounding them.
   *
   * @param paths - Paths to scale
   * @param scale - Scale multiplier
   * @return {Paths} - The scaled paths
   */
  function scalePaths(paths, scale) {
      if (scale === 0) {
          return [];
      }
      var sol = [];
      var i = paths.length;
      while (i--) {
          var p = paths[i];
          sol.push(scalePath(p, scale));
      }
      return sol;
  }
  exports.scalePaths = scalePaths;

  });

  unwrapExports(functions);
  var functions_1 = functions.area;
  var functions_2 = functions.cleanPolygon;
  var functions_3 = functions.cleanPolygons;
  var functions_4 = functions.closedPathsFromPolyTree;
  var functions_5 = functions.minkowskiDiff;
  var functions_6 = functions.minkowskiSumPath;
  var functions_7 = functions.minkowskiSumPaths;
  var functions_8 = functions.openPathsFromPolyTree;
  var functions_9 = functions.orientation;
  var functions_10 = functions.pointInPolygon;
  var functions_11 = functions.polyTreeToPaths;
  var functions_12 = functions.reversePath;
  var functions_13 = functions.reversePaths;
  var functions_14 = functions.simplifyPolygon;
  var functions_15 = functions.simplifyPolygons;
  var functions_16 = functions.scalePath;
  var functions_17 = functions.scalePaths;

  var ClipperOffset_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });




  /**
   * The ClipperOffset class encapsulates the process of offsetting (inflating/deflating) both open and closed paths using a number of different join types
   * and end types.
   *
   * Preconditions for offsetting:
   * 1. The orientations of closed paths must be consistent such that outer polygons share the same orientation, and any holes have the opposite orientation
   * (ie non-zero filling). Open paths must be oriented with closed outer polygons.
   * 2. Polygons must not self-intersect.
   *
   * Limitations:
   * When offsetting, small artefacts may appear where polygons overlap. To avoid these artefacts, offset overlapping polygons separately.
   */
  var ClipperOffset = /** @class */ (function () {
      /**
       * The ClipperOffset constructor takes 2 optional parameters: MiterLimit and ArcTolerance. The two parameters corresponds to properties of the same name.
       * MiterLimit is only relevant when JoinType is Miter, and ArcTolerance is only relevant when JoinType is Round or when EndType is OpenRound.
       *
       * @param _nativeLib - Native clipper lib instance to use
       * @param miterLimit - Miter limit
       * @param arcTolerance - ArcTolerance (round precision)
       */
      function ClipperOffset(_nativeLib, miterLimit, arcTolerance) {
          if (miterLimit === void 0) { miterLimit = 2; }
          if (arcTolerance === void 0) { arcTolerance = 0.25; }
          this._nativeLib = _nativeLib;
          this._clipperOffset = new _nativeLib.ClipperOffset(miterLimit, arcTolerance);
      }
      Object.defineProperty(ClipperOffset.prototype, "arcTolerance", {
          /**
           * Firstly, this field/property is only relevant when JoinType = Round and/or EndType = Round.
           *
           * Since flattened paths can never perfectly represent arcs, this field/property specifies a maximum acceptable imprecision ('tolerance') when arcs are
           * approximated in an offsetting operation. Smaller values will increase 'smoothness' up to a point though at a cost of performance and in creating more
           * vertices to construct the arc.
           *
           * The default ArcTolerance is 0.25 units. This means that the maximum distance the flattened path will deviate from the 'true' arc will be no more
           * than 0.25 units (before rounding).
           *
           * Reducing tolerances below 0.25 will not improve smoothness since vertex coordinates will still be rounded to integer values. The only way to achieve
           * sub-integer precision is through coordinate scaling before and after offsetting (see example below).
           *
           * It's important to make ArcTolerance a sensible fraction of the offset delta (arc radius). Large tolerances relative to the offset delta will produce
           * poor arc approximations but, just as importantly, very small tolerances will substantially slow offsetting performance while providing unnecessary
           * degrees of precision. This is most likely to be an issue when offsetting polygons whose coordinates have been scaled to preserve floating point precision.
           *
           * Example: Imagine a set of polygons (defined in floating point coordinates) that is to be offset by 10 units using round joins, and the solution is to
           * retain floating point precision up to at least 6 decimal places.
           * To preserve this degree of floating point precision, and given that Clipper and ClipperOffset both operate on integer coordinates, the polygon
           * coordinates will be scaled up by 108 (and rounded to integers) prior to offsetting. Both offset delta and ArcTolerance will also need to be scaled
           * by this same factor. If ArcTolerance was left unscaled at the default 0.25 units, every arc in the solution would contain a fraction of 44 THOUSAND
           * vertices while the final arc imprecision would be 0.25 Ã— 10-8 units (ie once scaling was reversed). However, if 0.1 units was an acceptable imprecision
           * in the final unscaled solution, then ArcTolerance should be set to 0.1 Ã— scaling_factor (0.1 Ã— 108 ). Now if scaling is applied equally to both
           * ArcTolerance and to Delta Offset, then in this example the number of vertices (steps) defining each arc would be a fraction of 23.
           *
           * The formula for the number of steps in a full circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
           *
           * @return {number} - Current arc tolerance
           */
          get: function () {
              return this._clipperOffset.arcTolerance;
          },
          /**
           * Firstly, this field/property is only relevant when JoinType = Round and/or EndType = Round.
           *
           * Since flattened paths can never perfectly represent arcs, this field/property specifies a maximum acceptable imprecision ('tolerance') when arcs are
           * approximated in an offsetting operation. Smaller values will increase 'smoothness' up to a point though at a cost of performance and in creating more
           * vertices to construct the arc.
           *
           * The default ArcTolerance is 0.25 units. This means that the maximum distance the flattened path will deviate from the 'true' arc will be no more
           * than 0.25 units (before rounding).
           *
           * Reducing tolerances below 0.25 will not improve smoothness since vertex coordinates will still be rounded to integer values. The only way to achieve
           * sub-integer precision is through coordinate scaling before and after offsetting (see example below).
           *
           * It's important to make ArcTolerance a sensible fraction of the offset delta (arc radius). Large tolerances relative to the offset delta will produce
           * poor arc approximations but, just as importantly, very small tolerances will substantially slow offsetting performance while providing unnecessary
           * degrees of precision. This is most likely to be an issue when offsetting polygons whose coordinates have been scaled to preserve floating point precision.
           *
           * Example: Imagine a set of polygons (defined in floating point coordinates) that is to be offset by 10 units using round joins, and the solution is to
           * retain floating point precision up to at least 6 decimal places.
           * To preserve this degree of floating point precision, and given that Clipper and ClipperOffset both operate on integer coordinates, the polygon
           * coordinates will be scaled up by 108 (and rounded to integers) prior to offsetting. Both offset delta and ArcTolerance will also need to be scaled
           * by this same factor. If ArcTolerance was left unscaled at the default 0.25 units, every arc in the solution would contain a fraction of 44 THOUSAND
           * vertices while the final arc imprecision would be 0.25 Ã— 10-8 units (ie once scaling was reversed). However, if 0.1 units was an acceptable imprecision
           * in the final unscaled solution, then ArcTolerance should be set to 0.1 Ã— scaling_factor (0.1 Ã— 108 ). Now if scaling is applied equally to both
           * ArcTolerance and to Delta Offset, then in this example the number of vertices (steps) defining each arc would be a fraction of 23.
           *
           * The formula for the number of steps in a full circular arc is ... Pi / acos(1 - arc_tolerance / abs(delta))
           *
           * @param value - Arc tolerance to set.
           */
          set: function (value) {
              this._clipperOffset.arcTolerance = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ClipperOffset.prototype, "miterLimit", {
          /**
           * This property sets the maximum distance in multiples of delta that vertices can be offset from their original positions before squaring is applied.
           * (Squaring truncates a miter by 'cutting it off' at 1 Ã— delta distance from the original vertex.)
           *
           * The default value for MiterLimit is 2 (ie twice delta). This is also the smallest MiterLimit that's allowed. If mitering was unrestricted (ie without
           * any squaring), then offsets at very acute angles would generate unacceptably long 'spikes'.
           *
           * @return {number} - Current miter limit
           */
          get: function () {
              return this._clipperOffset.miterLimit;
          },
          /**
           * Sets the current miter limit (see getter docs for more info).
           *
           * @param value - Mit limit to set.
           */
          set: function (value) {
              this._clipperOffset.miterLimit = value;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Adds a Path to a ClipperOffset object in preparation for offsetting.
       *
       * Any number of paths can be added, and each has its own JoinType and EndType. All 'outer' Paths must have the same orientation, and any 'hole' paths must
       * have reverse orientation. Closed paths must have at least 3 vertices. Open paths may have as few as one vertex. Open paths can only be offset
       * with positive deltas.
       *
       * @param path - Path to add
       * @param joinType - Join type
       * @param endType - End type
       */
      ClipperOffset.prototype.addPath = function (path, joinType, endType) {
          var nativePath = PathToNativePath.pathToNativePath(this._nativeLib, path);
          try {
              this._clipperOffset.addPath(nativePath, nativeEnumConversion.joinTypeToNative(this._nativeLib, joinType), nativeEnumConversion.endTypeToNative(this._nativeLib, endType));
          }
          finally {
              nativePath.delete();
          }
      };
      /**
       * Adds Paths to a ClipperOffset object in preparation for offsetting.
       *
       * Any number of paths can be added, and each path has its own JoinType and EndType. All 'outer' Paths must have the same orientation, and any 'hole'
       * paths must have reverse orientation. Closed paths must have at least 3 vertices. Open paths may have as few as one vertex. Open paths can only be
       * offset with positive deltas.
       *
       * @param paths - Paths to add
       * @param joinType - Join type
       * @param endType - End type
       */
      ClipperOffset.prototype.addPaths = function (paths, joinType, endType) {
          var nativePaths = PathsToNativePaths.pathsToNativePaths(this._nativeLib, paths);
          try {
              this._clipperOffset.addPaths(nativePaths, nativeEnumConversion.joinTypeToNative(this._nativeLib, joinType), nativeEnumConversion.endTypeToNative(this._nativeLib, endType));
          }
          finally {
              nativePaths.delete();
          }
      };
      /**
       * Negative delta values shrink polygons and positive delta expand them.
       *
       * This method can be called multiple times, offsetting the same paths by different amounts (ie using different deltas).
       *
       * @param delta - Delta
       * @param cleanDistance - Clean distance over the output, or undefined for no cleaning.
       * @return {Paths} - Solution paths
       */
      ClipperOffset.prototype.executeToPaths = function (delta, cleanDistance) {
          var outNativePaths = new this._nativeLib.Paths();
          try {
              this._clipperOffset.executePaths(outNativePaths, delta);
              if (cleanDistance !== undefined) {
                  this._nativeLib.cleanPolygons(outNativePaths, cleanDistance);
              }
              return PathsToNativePaths.nativePathsToPaths(this._nativeLib, outNativePaths, true); // frees outNativePaths
          }
          finally {
              if (!outNativePaths.isDeleted()) {
                  outNativePaths.delete();
              }
          }
      };
      /**
       * This method takes two parameters. The first is the structure that receives the result of the offset operation (a PolyTree structure). The second parameter
       * is the amount to which the supplied paths will be offset. Negative delta values shrink polygons and positive delta expand them.
       *
       * This method can be called multiple times, offsetting the same paths by different amounts (ie using different deltas).
       *
       * @param delta - Delta
       * @return {Paths} - Solution paths
       */
      ClipperOffset.prototype.executeToPolyTree = function (delta) {
          var outNativePolyTree = new this._nativeLib.PolyTree();
          try {
              this._clipperOffset.executePolyTree(outNativePolyTree, delta);
              return PolyTree_1.PolyTree.fromNativePolyTree(this._nativeLib, outNativePolyTree, true); // frees outNativePolyTree
          }
          finally {
              if (!outNativePolyTree.isDeleted()) {
                  outNativePolyTree.delete();
              }
          }
      };
      /**
       * This method clears all paths from the ClipperOffset object, allowing new paths to be assigned.
       */
      ClipperOffset.prototype.clear = function () {
          this._clipperOffset.clear();
      };
      /**
       * Checks if the object has been disposed.
       *
       * @return {boolean} - true if disposed, false if not
       */
      ClipperOffset.prototype.isDisposed = function () {
          return this._clipperOffset === undefined || this._clipperOffset.isDeleted();
      };
      /**
       * Since this library uses WASM/ASM.JS internally for speed this means that you must dispose objects after you are done using them or mem leaks will occur.
       */
      ClipperOffset.prototype.dispose = function () {
          if (this._clipperOffset) {
              this._clipperOffset.delete();
              this._clipperOffset = undefined;
          }
      };
      return ClipperOffset;
  }());
  exports.ClipperOffset = ClipperOffset;

  });

  unwrapExports(ClipperOffset_1);
  var ClipperOffset_2 = ClipperOffset_1.ClipperOffset;

  var offsetFunctions = createCommonjsModule(function (module, exports) {
  var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });


  var addPathOrPaths = function (offset, inputDatas) {
      if (inputDatas === undefined) {
          return;
      }
      // add each input
      for (var i = 0, maxi = inputDatas.length; i < maxi; i++) {
          var inputData = inputDatas[i];
          // add the path/paths
          var pathOrPaths = inputData.data;
          if (!pathOrPaths || pathOrPaths.length <= 0) {
              continue;
          }
          // is it a path or paths?
          if (Array.isArray(pathOrPaths[0])) {
              // paths
              offset.addPaths(pathOrPaths, inputData.joinType, inputData.endType);
          }
          else {
              // path
              offset.addPath(pathOrPaths, inputData.joinType, inputData.endType);
          }
      }
  };
  function offsetToPathsOrPolyTree(polyTreeMode, nativeClipperLib, params) {
      var filledData = __assign({ arcTolerance: 0.25, miterLimit: 2 }, params);
      var offset = new ClipperOffset_1.ClipperOffset(nativeClipperLib, filledData.miterLimit, filledData.arcTolerance);
      //noinspection UnusedCatchParameterJS
      try {
          addPathOrPaths(offset, params.offsetInputs);
          if (!polyTreeMode) {
              return offset.executeToPaths(params.delta, params.cleanDistance);
          }
          else {
              if (params.cleanDistance !== undefined) {
                  throw new ClipperError_1.ClipperError("cleaning is not available for poly tree results");
              }
              return offset.executeToPolyTree(params.delta);
          }
      }
      catch (err) {
          return undefined;
      }
      finally {
          offset.dispose();
      }
  }
  function offsetToPaths(nativeClipperLib, params) {
      return offsetToPathsOrPolyTree(false, nativeClipperLib, params);
  }
  exports.offsetToPaths = offsetToPaths;
  function offsetToPolyTree(nativeClipperLib, params) {
      return offsetToPathsOrPolyTree(true, nativeClipperLib, params);
  }
  exports.offsetToPolyTree = offsetToPolyTree;

  });

  unwrapExports(offsetFunctions);
  var offsetFunctions_1 = offsetFunctions.offsetToPaths;
  var offsetFunctions_2 = offsetFunctions.offsetToPolyTree;

  function init(_moduleOverrides) {
    var Module = {};
    Object.keys(_moduleOverrides).forEach(function (key) {
      Module[key] = _moduleOverrides[key];
    });
  var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=true;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var readBinary;{if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);}else{scriptDirectory="";}}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var asm2wasmImports={"f64-rem":function(x,y){return x%y},"debugger":function(){}};var functionPointers=new Array(0);var setTempRet0=function(value){};var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];if(typeof WebAssembly!=="object"){err("no native wasm support detected");}var wasmMemory;var wasmTable;var ABORT=false;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else{u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else{if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple;}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}var DYNAMIC_BASE=5264304,DYNAMICTOP_PTR=21392;var INITIAL_TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"];}else{wasmMemory=new WebAssembly.Memory({"initial":INITIAL_TOTAL_MEMORY/WASM_PAGE_SIZE});}if(wasmMemory){buffer=wasmMemory.buffer;}INITIAL_TOTAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func);}else{Module["dynCall_vi"](func,callback.arg);}}else{func(callback.arg===undefined?null:callback.arg);}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){callRuntimeCallbacks(__ATINIT__);}function preMain(){callRuntimeCallbacks(__ATMAIN__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABuwIrYAF/AGAEf39/fwF/YAF/AX9gAn9/AX9gAn9/AGABfwF8YAJ/fABgA398fABgAAF/YAN/f38AYAN/f38Bf2ADf398AGAEf39/fwBgBX9/f39/AX9gBn98f39/fwF/YAAAYAZ/f39/f38AYAV/f39/fwBgAn9/AXxgA398fAF/YAZ/f39/f38Bf2ADf35/AX5gBH9/f3wAYA1/f39/f39/f39/f39/AGAIf39/f39/f38AYAp/f39/f39/f39/AGACf34AYAJ/fgF/YAR/f398AX9gA35/fwF/YAJ+fwF/YAJ8fwF8YAJ8fAF8YAJ8fwF/YAN8fH8BfGABfAF8YAd/f39/f39/AX9gB39/f39/f38AYAN/f38BfGAEf398fAF/YAd/f3x/f39/AX9gBH9/fHwAYAV/f39/fAACzgImA2VudgFiABgDZW52AWMADwNlbnYBZAAQA2VudgFlAAADZW52AWYACQNlbnYBZwAJA2VudgFoAAIDZW52AWkAGQNlbnYBagAJA2VudgFrABcDZW52AWwAEQNlbnYBbQAQA2VudgFuAAwDZW52AW8AAwNlbnYBcAADA2VudgFxAAADZW52AXIAAANlbnYBcwAAA2VudgF0AAQDZW52AXUACQNlbnYBdgARA2VudgF3AAMDZW52AXgAAwNlbnYBeQAIA2VudgF6AAADZW52AUEAAgNlbnYBQgAPA2VudgFDAAIDZW52AUQACgNlbnYBRQAIA2VudgFGAAQDZW52AUcACQNlbnYBSAAPA2VudgFJAAQDZW52DF9fdGFibGVfYmFzZQN/AANlbnYBYQN/AANlbnYGbWVtb3J5AgCAAgNlbnYFdGFibGUBcAGuBK4EA6sFqQUEAAQCAwMDAAMEAgoCCgMEBAIEBAoEAAMJEQkJAwQEAwIACQkDAwQDDQMKAwYDAwsCCgoECgIEAwkCHgACCQwMAwICAgMEAgAPBAEKIiACDQQBCQkWEhEKAgwCDQIEAAQfDQwCAAIJBBELCQwECggQAgQJCgMDBAQCAgMDBAwEAwkDAwICAgwJIQENAwQRCxYECggJAQkJCQsJBgAMDxQNEwwDCgAAJAIJBAkDCgMBAwEDAAoEAwMDDAEUBBoJAwoBAQIECQQDAgwCCQMJAwMKAgMDCgAEBAMAAAAAAAAPICMAIh8CAwkC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ACgCADYCACAFIAM2AgQgAiABKQIANwMAIAJBEGoiAyACKQIANwIAIAQgAxCcAQR/IAAgACgCACABKAIEIAEoAgBrajYCAEEBBUEACyEGIAIkAiAGC0UBAX8gACgCACgCECECIAAgASACQf8AcUHaAmoRBAAgACwABUEBRwRAIAAoAgAoAhQhAiAAIAEgAkH/AHFB2gJqEQQACwvzJQEtfyMCIQMjAkHgAmokAiADQcACaiEFIANBuAJqIQYgA0GwAmohByADQagCaiEIIANBoAJqIQkgA0EIaiEEIANBmAJqIQogA0GQAmohCyADQYgCaiEMIANBgAJqIQ0gA0H4AWohDiADQfABaiEPIANB6AFqIRAgA0HgAWohESADQdgBaiESIANB0AFqIRMgA0HIAWohFCADQcABaiEVIANBuAFqIRYgA0GwAWohFyADQagBaiEYIANBoAFqIRkgA0GYAWohGiADQZABaiEbIANBiAFqIRwgA0GAAWohHSADQfgAaiEeIANB8ABqIR8gA0HoAGohICADQeAAaiEhIANB2ABqISIgA0HQAGohIyADQcgAaiEkIANBQGshJSADQThqISYgA0EwaiEnIANBKGohKCADQSBqISkgA0EYaiEqIANBEGohKyADQcgCakGE9AAQIiADQdACaiICIAMpAsgCNwIAIANB2AJqIiwgACACECpBAXE6AAAgACgCBCAAKAIAa0ECSQR/QQAFAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAiASwAAEExaw5EEhISEhISEhISExMTExMTExMTExMTExMTExMTABMTExMTExMBExMTExMTExMTExMTAxMEBQYCBxMIExMJCgsMDQ4PEBETCyAAEOkBDBMLIAAQaAwSCwJAAkACQCAAKAIEIAAoAgAiAmtBAUsEfyACLAABBUEAC0EYdEEYdUHMAGsOJQACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgECCyAAKAIEIAAoAgAiAmtBAksEfyACLAACBUEAC0EYdEEYdUFQakEKSQ0ADAELIAAQ5AEMEgsgABCCBAwRCwJAAkACQAJAAkACQAJAAkAgASwAAUHOAGsOLQMHBwcHBAcHBwcHBwcHBwcHBwcABwcBBwcHBwcHBwcHAgcH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ayEADAELCwNAIAAgBUgEQCAAIAE2AgAgAEEEaiEADAELCwsDQCAAIARIBEAgACADOgAAIABBAWohAAwBCwsgBCACawtdAQF/IAEgAEggACABIAJqSHEEQCABIAJqIQEgACIDIAJqIQADQCACQQBKBEAgAkEBayECIABBAWsiACABQQFrIgEsAAA6AAAMAQsLIAMhAAUgACABIAIQLRoLIAALOAAgAEGYLTYCACAAQQc6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEG8NjYCACAAIAEpAgA3AggLDwAgAEHwAmogASACEPUDC4sEAQp/IwIhASMCQUBrJAIgAUEwaiEDIAFBKGohByABQRhqIQQgAUEUaiEIIAFBEGohBiABQQhqIQUCfwJAAkAgACgCBCAAKAIAIgJrQQBLBH8gAiwAAAVBAAtBGHRBGHVBxwBrDg4AAQEBAQEBAQEBAQEBAAELIAAQ7gIMAQsgByAANgIAIAQgABDtAiAIIAAgBBBJIgI2AgAgAgR/IAAgBBDsAgR/QQAFIAcQyQEEfyACBSAGQQA2AgAgBUH0kgEQIiADIAUpAgA3AgACfwJAIAAgAxAqRQ0AIABBCGoiBSICKAIEIAIoAgBrQQJ1IQICQANAIABBxQAQJ0UEQCADIAAQZSIJNgIAIAlFDQIgBSADEDIMAQsLIAMgACACEDwgBiAAQfACaiADEOYCNgIADAELQQAMAQsgA0EANgIAAn8CQCAELAAADQAgBCwAAUUNACADIAAQLiIFNgIAIAUNAEEADAELIABB9gAQJwRAIAFBADYCACABQQA2AgQgACADIAggASAGIARBBGogBEEIahDIAQwBCyAAQQhqIgUiAigCBCACKAIAa0ECdSECAkADQAJAIAEgABAuIgk2AgAgCUUNACAFIAEQMiAHEMkBRQ0BDAILC0EADAELIAEgACACEDwgACADIAggASAGIARBBGogBEEIahDIAQsLCwsFQQALCyEKIAEkAiAKC5UBAQN/IAAoAgggACgCACIDa0EEdSABTwRADwsgAUH/////AEsEQEEIEAYiAhBDIAJBsMQANgIAIAJB0CRB1wAQBAsgACgCBCADayEEIAFBBHQQJSECIARBAEoEQCACIAMgBBAtGgsgACACNgIAIAAgBEEEdUEEdCACajYCBCAAIAFBBHQgAmo2AgggA0UEQA8LIAMQIwsEAEEBC9oEAQp/IAAoAigiAyABKAJMQQJ0aigCACEFIAIoAkxBAnQgA2ooAgAhBiAFIQMCQAJAA0ACQCAGIAMoAggiA0YEQCAGIQsMAQsgAw0BDAILCwwBCyAGIQMDQCADKAIIIgMgBUYEQCAFIQsMAgsgAw0ACyAFIAYQzQEhCwsgBSgCECIIKAIcIQkgBigCECIEKAIcIQcgAigCPCEDAkAgASgCPCIMQQFGBEAgA0EBRwRAIAcgCDYCGCAIIAc2AhwgBCAJNgIcIAkgBDYCGCAFIAQ2AhAMAgsgBARAIAQhAwNAIAMoAhghCiADIAMoAhw2AhggAyAKNgIcIAQgCkcEQCAKIQMMAQsLCyAEIAg2AhggCCAENgIcIAkgBzYCGCAHIAk2AhwgBSAHNgIQBSADQQJHBEAgCSAENgIYIAQgCTYCHCAIIAc2AhwgByAINgIYDAILIAQEQCAEIQMDQCADKAIYIQogAyADKAIcNgIYIAMgCjYCHCAEIApHBEAgCiEDDAELCwsgCSAHNgIYIAcgCTYCHCAEIAg2AhggCCAENgIcCwsgBUEANgIUIAYgC0YEQCAFIAYoAggiA0cEQCAFIAM2AggLIAUgBiwABDoABAsgBkEANgIQIAZBADYCFCAGIAU2AgggASgCTCEDIAIoAkwhBCABQX82AkwgAkF/NgJMIAAoAjQiAEUEQCAGIAUoAgA2AgAPCwJAAkADQCAAKAJMIARHBEAgACgCXCIARQ0CDAELCwwBCyAGIAUoAgA2AgAPCyAAIAM2AkwgACAMNgI8IAYgBSgCADYCAAuqAQEGfyMCIQEjAkEgaiQCIAFBGGohBCABQQhqIQMgAUEQaiICQQA2AgAgACACEJ0BBH9BAAUgAigCACICQX9qIAAoAgQgACgCAGtJBH8gAyAAKAIAIgU2AgAgAyACIAVqNgIEIAAgACgCACACajYCACABQc76ABAiIAQgASkCADcCACADIAQQnAEEfyAAQfACahDjAwUgACADEPQBCwVBAAsLIQYgASQCIAYLgwECAn8BfiAApyECIABC/////w9WBEADQCABQX9qIgEgACAAQgqAIgRCCn59p0H/AXFBMHI6AAAgAEL/////nwFWBEAgBCEADAELCyAEpyECCyACBEADQCABQX9qIgEgAiACQQpuIgNBCmxrQTByOgAAIAJBCk8EQCADIQIMAQsLCyABC9gBAQR/IABB2CY2AgAgACAAKAIIIgE2AgwgACABNgIEIAAoAhwiASAAKAIYIgJGBEAgASECBQNAIANBAnQgAmooAgAiBARAIAQQIyAAKAIYIQIgACgCHCEBCyADQQFqIgMgASACa0ECdUkNAAsLIAAgAjYCHCAAQQA6ABQgAEEAOgAlIAAoAjgiAQRAIAAgATYCPCABECMLIAAoAigiAQRAIAAgATYCLCABECMLIAAoAhgiAQRAIAAgATYCHCABECMLIAAoAggiAUUEQA8LIAAgATYCDCABECMLDQAgAEEHcUEQahEIAAsTACABIAIgAEH/AHFB2gJqEQQAC7oJAwR/AX4GfCMCIQQjAkEQaiQCIAAgACgCNCIFIAIoAgAiBkEEdGorAwAiCyABQQR0IAVqKwMIIg2iIAFBBHQgBWorAwAiDiAGQQR0IAVqKwMIIgyioSIJOQNIIAkgAEFAayIHKwMAIgqimUQAAAAAAADwP2MEQCALIA6iIA0gDKKgRAAAAAAAAAAAZARAIAsgCqIgACgCHCICIAFBBHRqKQMAuaAhCSAMIAqiIAFBBHQgAmopAwi5oCIKRAAAAAAAAOC/RAAAAAAAAOA/IApEAAAAAAAAAABjG6CwIQggBCAJRAAAAAAAAOC/RAAAAAAAAOA/IAlEAAAAAAAAAABjG6CwNwMAIAQgCDcDCCAAKAIsIgEgACgCMEkEQCABIAQpAwA3AwAgASAEKQMINwMIIAAgACgCLEEQajYCLAUgAEEoaiAEEDELIAQkAg8LBQJAIAlEAAAAAAAA8D9kBEAgAEQAAAAAAADwPzkDSEQAAAAAAADwPyEJDAELIAlEAAAAAAAA8L9jBEAgAEQAAAAAAADwvzkDSEQAAAAAAADwvyEJCwsLIAogCaJEAAAAAAAAAABjBEAgAEEoaiEGIAsgCqIgACgCHCIDIAFBBHRqKQMAuaAhCSAMIAqiIAFBBHQgA2opAwi5oCIKRAAAAAAAAOC/RAAAAAAAAOA/IApEAAAAAAAAAABjG6CwIQggBCAJRAAAAAAAAOC/RAAAAAAAAOA/IAlEAAAAAAAAAABjG6CwNwMAIAQgCDcDCCAAKAIsIgMgACgCMEkEQCADIAQpAwA3AwAgAyAEKQMINwMIIAAgACgCLEEQaiIDNgIsBSAGIAQQMSAAKAIsIQMLIAAoAhwgAUEEdGohBSAAKAIwIANGBEAgBiAFEDEgACgCLCEDBSADIAUpAwA3AwAgAyAFKQMINwMIIAAgACgCLEEQaiIDNgIsCyAAKAI0IgUgAUEEdGorAwAgBysDACIKoiAAKAIcIgcgAUEEdGopAwC5oCEJIAogAUEEdCAFaisDCKIgAUEEdCAHaikDCLmgIgpEAAAAAAAA4L9EAAAAAAAA4D8gCkQAAAAAAAAAAGMboLAhCCAEIAlEAAAAAAAA4L9EAAAAAAAA4D8gCUQAAAAAAAAAAGMboLA3AwAgBCAINwMIIAMgACgCMEkEQCADIAQpAwA3AwAgAyAEKQMINwMIIAAgACgCLEEQajYCLAUgBiAEEDELBQJAAkACQAJAIAMOAwECAAMLIAsgDqIgDSAMoqBEAAAAAAAA8D+gIgkgACsDYGZFBEAgACABIAYQdAwDCyAKIAmjIgogCyAOoKIgACgCHCIDIAFBBHRqKQMAuaAhCSAKIAwgDaCiIAFBBHQgA2opAwi5oCIKRAAAAAAAAOC/RAAAAAAAAOA/IApEAAAAAAAAAABjG6CwIQggBCAJRAAAAAAAAOC/RAAAAAAAAOA/IAlEAAAAAAAAAABjG6CwNwMAIAQgCDcDCCAAKAIsIgMgACgCMEkEQCADIAQpAwA3AwAgAyAEKQMINwMIIAAgACgCLEEQajYCLAUgAEEoaiAEEDELDAILIAAgASAGEHQMAQsgACABIAYQjAELCyACIAE2AgAgBCQCC+wJAg5/BH4gASgCTCIPQX9KIQkgAigCTCIQQX9KIQogAkFAayIRKAIAIgVFIQQCQAJAAkAgAUFAaygCACIHRSIGBEAgBARADwsFIARFBEAgASgCOCILIAIoAjgiDEYiDQRAAkAgASgCRCEIIABBhAFqIgQgAEGIAWoiBiALGyIOKAIARQRAIAEgAigCRDYCRCACIAg2AkQMAQsgASAFIAhqIgVBACAIayAFGzYCRCACKAJEIgUgB2siBwRAIAIgBzYCRAUgAkEAIAVrNgJECwsFIAEgASgCSCIERSAEIAVqIABBhAFqIgQgAEGIAWoiBiAMGygCAEUbNgJIIAIoAkghBSAEIAYgCxsiDigCAARAIAIgBSAHazYCSAUgAiAFRTYCSAsLIAQgBiALRSIFGygCACEHIAQgBiAMRSIIGygCACEMIAYgBCAIGygCACEEAn4CQAJAAkAgDigCAEECaw4CAAECCyABKAJErAwCC0EAIAEoAkRrrAwBC0IAIAEoAkSsIhJ9IBIgEkIAUxsLIRUCfgJAAkACQCAEQQJrDgIAAQILIAIoAkSsDAILQQAgAigCRGusDAELQgAgAigCRKwiEn0gEiASQgBTGwshEiAPIBByQQBOBEAgEiAVhEIBWARAAkAgDUUEQCAAKAJsQQNHDQELIAAgASADEC8aDAULCyAAIAEgAxAvGiARKAIARQRAIAAgAiADEC8aCyABKAJMIgMgAigCTCIERgRAIAFBfzYCTCACQX82AkwPCyADIARIBEAgACABIAIQWgUgACACIAEQWgsPCyAJBEAgEkICWgRADwsgACABIAMQLxoMBAsgFUICVCEEIAoEQCAERQRADwsMAwsgBEUEQA8LIBJCAloEQA8LAn4CQAJAAkAgB0ECaw4CAAECCyABKAJIrAwCC0EAIAEoAkhrrAwBC0IAIAEoAkisIhN9IBMgE0IAUxsLIRMCfgJAAkACQCAMQQJrDgIAAQILIAIoAkisDAILQQAgAigCSGusDAELQgAgAigCSKwiFH0gFCAUQgBTGwshFCANRQ0EIBVCAVEgEkIBUXFFBEAgASgCPCEAIAEgAigCPDYCPCACIAA2AjwPCwJAAkACQAJAIAAoAmwOBAABAggDCyATQgBVIBRCAFVxRQRADwsMBwsgE0IBUyAUQgFTcUUEQA8LDAYLIAtBAUYgE0IAVXEgFEIAVXFFBEAgE0IBUyAFcSAUQgFTcUUEQA8LCwwFCw8LCyABKAI4IAIoAjhGBEAgBSAHRgRADwsgACgCbEEBRwRADwsgBgRAIApFBEAPCyAAIAEgAxAvGiAJRQRADwsgAUF/NgJMBSAJRQRADwsgACACIAMQLxogCkUEQA8LIAJBfzYCTAsPCyAGBEAgAigCRCIGQQAgBmsgBkF/ShtBAUYEQAJAIAAoAmxBAUYEQCACKAJIDQELIAAgASADEC8aIAlFBEAPCyABQX82AkwPCwsLIARFBEAPCyABKAJEIgRBACAEayAEQX9KG0EBRwRADwsgACgCbEEBRgRAIAEoAkgEQA8LCyAAIAIgAxAvGiAKRQRADwsgAkF/NgJMDwsgACACIAMQLxoLIAEoAjwhACABIAIoAjw2AjwgAiAANgI8IAEoAkwhACABIAIoAkw2AkwgAiAANgJMDwsgACABIAIgAxDSARoLhAEBBH8jAiECIwJBEGokAiACIAE2AgAgACgCACEEIAEEfyAAKAIEIgMoAgAEQCAEQfACakEQECYiASADKAIAIAIoAgAQmgMgACgCBCABNgIABSADIAE2AgALIAAoAggoAgAiAQRAIAFBADoAAQsgACgCBCgCAEEARwVBAAshBSACJAIgBQtoAQJ/IwIhASMCQRBqJAIgAUEANgIAIABB8gAQJwRAIAEgASgCAEEEcjYCAAsgAEHWABAnBEAgASABKAIAQQJyNgIACyAAQcsAECcEQCABIAEoAgBBAXI2AgALIAEoAgAhAiABJAIgAgufAwEFfyMCIQIjAkEQaiQCIAJBCGohAyACQQRqIQQCfwJAIAAoAgQgACgCACIBa0EASwR/IAEsAAAFQQALQf8BcUHkAEcNAAJ/AkACQAJAIAAoAgQgACgCACIBa0EBSwR/IAEsAAEFQQALQRh0QRh1QdgAaw4hAgQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQBBAsgACAAKAIAQQJqNgIAIAMgABBbIgE2AgAgAQR/IAQgABBkIgE2AgAgAQR/IAJBADoAACAAIAMgBCACENsBBUEACwVBAAsMAgsgACAAKAIAQQJqNgIAIAMgABAsIgE2AgAgAQR/IAQgABBkIgE2AgAgAQR/IAJBAToAACAAIAMgBCACENsBBUEACwVBAAsMAQsgACAAKAIAQQJqNgIAIAMgABAsIgE2AgAgAQR/IAQgABAsIgE2AgAgAQR/IAIgABBkIgE2AgAgAQR/IABB8AJqQRQQJiIAIAMoAgAgBCgCACACKAIAEOcDIAAFQQALBUEACwVBAAsLDAELIAAQLAshBSACJAIgBQvMAgEGfyMCIQIjAkEQaiQCAn8CQAJAAkACQCAAKAIEIAAoAgAiAWtBAEsEfyABLAAABUEAC0EYdEEYdUHKAGsODwEDAgMDAwMDAwMDAwMDAAMLIAAgACgCAEEBajYCACAAECwiAQR/An8gAUEAIABBxQAQJxshBSACJAIgBQsPBUEACwwDCyAAIAAoAgBBAWo2AgAgAEEIaiIBIgMoAgQgAygCAGtBAnUhAwJAA0AgAEHFABAnDQEgAiAAEGUiBDYCACAEBEAgASACEDIMAQsLQQAMAwsgAiAAIAMQPCAAQfACaiACEIQEDAILIAAoAgQgACgCACIBa0EBSwR/IAEsAAEFQQALQf8BcUHaAEcEQCAAEOkBDAILIAAgACgCAEECajYCACAAEFciAQR/IAFBACAAQcUAECcbBUEACwwBCyAAEC4LIQYgAiQCIAYLLwEBfyAALAAFIgJBAkYEfyAAKAIAKAIAIQIgACABIAJBP3FB3gBqEQMABSACRQsLvAMCBX8CfiMCIQYjAkEQaiQCIAEoAgAiAigCWCIERQRAQRAQBiIDQZ/GABCBASADQZATQQkQBAsgBCACKAJMNgJMIAIoAlwhBSACKAJgIgNB3ABqIABBNGogAxsgBDYCACAFBEAgBSABKAIAKAJYNgJgCyABKAIAIgQoAlgiAiAEKAI8NgI8IAJBQGsgBEFAaygCADYCACACIAQoAkQ2AkQgAiAEKAJINgJIIAEgAjYCACACIAIpAwA3AxAgAiACKQMINwMYIAEoAgAgAzYCYCABKAIAIAU2AlwgASgCACIBKwMwRKVcw/EpYz3IYQRAIAYkAg8LIAYgASkDKCIHNwMAIABBOGohAyAAKAI8IgEgAEFAaygCAEYEfyADIAYQciAAKAI8BSABIAc3AwAgACABQQhqIgA2AjwgAAsiASADKAIAIgVrIgBBCEoEQCAAQQN2QX5qQQJtIgNBA3QgBWoiACkDACIHIAFBeGoiASkDACIIUwRAA0ACQCABIAc3AwAgA0UNACADQX9qQQJtIgNBA3QgBWoiBCkDACIHIAhTBEAgACEBIAQhAAwCCwsLIAAgCDcDAAsLIAYkAgvgAQEEfyMCIQIjAkEQaiQCIAJBBGohASAAQdQAECcEfyABQQA2AgACfwJAIABB3wAQJwR/DAEFIAAgARCdAUUEQCABIAEoAgBBAWoiAzYCACAAQd8AECcNAgtBAAsMAQsgACwA6gIEQCAAQaTrABAoDAELIAAsAOkCBEAgAEHwAmpBFBAmIgMgASgCABC4AyACIAMiATYCACAAQcwCaiACEDIgAQwBCyADIABBoAJqIgAiASgCBCABKAIAa0ECdUkEfyAAKAIAIANBAnRqKAIABUEACwsFQQALIQQgAiQCIAQLFwAgACgCACAAQQxqRwRAIAAoAgAQIwsLNQEBf0HEnQEoAgAiAARAIAApAzBCgH6DQoDWrJn0yJOmwwBRBEAgACgCDBD2AQsLQQIQ9gELLQEBfyMCIQIjAkEQaiQCIAIgATYCAEGcKigCACIBIAAgAhCKAhogARDrBBABC8QfAwp/EX4BfCMCIQkjAkEgaiQCIANBAXMiDCACQQFGcQRAQRAQBiIFQfrFABCBASAFQZATQQkQBAsgASgCBCABKAIAIgdrIgRBBHVBf2ohBSADIARBEEpxBEACQCAHKQMAIQ4DfyAFQQR0IAdqKQMAIA5SDQEgBUEEdCAHaikDCCAHKQMIUg0BIAVBf2ohBCAFQQFKBH8gBCEFDAEFIAQLCyEFCwsgBUEASgRAAkAgBUEEdCAHaikDACEOA38gBUF/aiIEQQR0IAdqKQMAIA5SDQEgBUEEdCAHaikDCCAEQQR0IAdqKQMIUg0BIAVBAUoEfyAEIQUMAQUgBAsLIQULCyAFQQJIIAVBAUggAxsEQCAJJAJBAA8LQX8gBUEBaiIEQfAAbCAEQZLJpBJLGxAlIQYgBARAIARB8ABsIAZqIQcgBiEEA0AgBEIANwMAIARCADcDCCAEQgA3AxAgBEIANwMYIARCADcDICAEQgA3AyggBEHwAGoiBCAHRw0ACyABKAIAIQcLIAlBEGoiCyAGNgIAIAYgBykDEDcDgAEgBiAHKQMYNwOIASAHKQMAIQ4CQAJAAkAgACwAFA0AIAcpAwhC/////wN8Qv7///8HViAOQv////8DfEL+////B1ZyBEAgAEEBOgAUDAELIAVBBHQgB2opAwAhDiAFQQR0IAdqKQMIQv////8DfEL+////B1YEQCAAQQE6ABQMAgsgDkL/////A3xC/v///wdWBH8gAEEBOgAUDAIFQQALIQoMAgsgDkL/////////D1UEQEEQEAYiBEGUJzYCACAEQgA3AgQgBEEANgIMIARBMBAlIgg2AgQgBEGwgICAeDYCDCAEQSA2AgggCEG4xQApAAA3AAAgCEHAxQApAAA3AAggCEHIxQApAAA3ABAgCEHQxQApAAA3ABggCEEAOgAgIARBkBNBCRAECyAOQoGAgICAgIBwUyAHKQMIQv////////8PfEL+////////H1ZyBEBBEBAGIgRBlCc2AgAgBEIANwIEIARBADYCDCAEQTAQJSIINgIEIARBsICAgHg2AgwgBEEgNgIIIAhBuMUAKQAANwAAIAhBwMUAKQAANwAIIAhByMUAKQAANwAQIAhB0MUAKQAANwAYIAhBADoAICAEQZATQQkQBAUgBUEEdCAHaikDACEODAELDAELIA5C/////////w9VBEBBEBAGIgRBlCc2AgAgBEIANwIEIARBADYCDCAEQTAQJSIINgIEIARBsICAgHg2AgwgBEEgNgIIIAhBuMUAKQAANwAAIAhBwMUAKQAANwAIIAhByMUAKQAANwAQIAhB0MUAKQAANwAYIAhBADoAICAEQZATQQkQBAsgDkKBgICAgICAcFMgBUEEdCAHaikDCEL/////////D3xC/v///////x9WcgRAQRAQBiIEQZQnNgIAIARCADcCBCAEQQA2AgwgBEEwECUiCDYCBCAEQbCAgIB4NgIMIARBIDYCCCAIQbjFACkAADcAACAIQcDFACkAADcACCAIQcjFACkAADcAECAIQdDFACkAADcAGCAIQQA6ACAgBEGQE0EJEAQFQQEhCgsLIAZCADcDACAGQgA3AwggBkIANwMQIAZCADcDGCAGQgA3AyAgBkIANwMoIAZCADcDMCAGQgA3AzggBkFAa0IANwMAIAZCADcDSCAGQgA3A1AgBkIANwNYIAZCADcDYCAGQgA3A2ggBiAGQfAAajYCUCAGIAVB8ABsIAZqIgQ2AlQgBiAHKQMANwMQIAYgBykDCDcDGCAGQX82AkwgASgCACIHIAVBBHRqIQggBEIANwMAIARCADcDCCAEQgA3AxAgBEIANwMYIARCADcDICAEQgA3AyggBEIANwMwIARCADcDOCAEQUBrQgA3AwAgBEIANwNIIARCADcDUCAEQgA3A1ggBEIANwNgIARCADcDaCAFQfAAbCAGaiAGNgJQIAVB8ABsIAZqIAVBf2oiAUHwAGwgBmo2AlQgBUHwAGwgBmoiBCAIKQMANwMQIAQgCCkDCDcDGCAFQfAAbCAGakF/NgJMIAVBAUoEQAJAIAEhBSAKIQEDQAJAIAVBBHQgB2oiCikDACEOAkACQCABQf8BcQ0AIAVBBHQgB2opAwhC/////wN8Qv7///8HViAOQv////8DfEL+////B1ZyBH8gAEEBOgAUQQEhAQwBBUEACyEBDAELIA5C/////////w9VDQEgDkKBgICAgICAcFMgBUEEdCAHaikDCEL/////////D3xC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//8BSwRAEAELIAIgACgCCCAEayIDQQJ1IgggCCACSRtB/////wEgA0EDdUH/////AEkbIgIEQCACQf////8BSwRAQQgQBiIDEEMgA0GwxAA2AgAgA0HQJEHXABAEBSACQQN0ECUiCSEFCwsgB0EDdCAFaiIDIAEpAwA3AwAgBkEASgRAIAkgBCAGEC0aCyAAIAU2AgAgACADQQhqNgIEIAAgAkEDdCAFajYCCCAERQRADwsgBBAjC54FAgJ/AX4jAiEEIwJBEGokAiABKQMAIgYgAikDAFMhBSAAKQMAIAZTBH8CfyAFBEAgBCAAKQMANwMAIAQgACkDCDcDCCAAIAIpAwA3AwAgACACKQMINwMIIAIgBCkDADcDACACIAQpAwg3AwhBAQwBCyAEIAApAwA3AwAgBCAAKQMINwMIIAAgASkDADcDACAAIAEpAwg3AwggASAEKQMANwMAIAEgBCkDCDcDCCABKQMAIAIpAwBTBH8gBCABKQMANwMAIAQgASkDCDcDCCABIAIpAwA3AwAgASACKQMINwMIIAIgBCkDADcDACACIAQpAwg3AwhBAgVBAQsLBSAFBH8gBCABKQMANwMAIAQgASkDCDcDCCABIAIpAwA3AwAgASACKQMINwMIIAIgBCkDADcDACACIAQpAwg3AwggACkDACABKQMAUwR/IAQgACkDADcDACAEIAApAwg3AwggACABKQMANwMAIAAgASkDCDcDCCABIAQpAwA3AwAgASAEKQMINwMIQQIFQQELBUEACwshBSACKQMAIAMpAwBZBEAgBCQCIAUPCyAEIAIpAwA3AwAgBCACKQMINwMIIAIgAykDADcDACACIAMpAwg3AwggAyAEKQMANwMAIAMgBCkDCDcDCCAFQQFqIQMgASkDACACKQMAWQRAIAQkAiADDwsgBCABKQMANwMAIAQgASkDCDcDCCABIAIpAwA3AwAgASACKQMINwMIIAIgBCkDADcDACACIAQpAwg3AwggBUECaiECIAApAwAgASkDAFkEQCAEJAIgAg8LIAQgACkDADcDACAEIAApAwg3AwggACABKQMANwMAIAAgASkDCDcDCCABIAQpAwA3AwAgASAEKQMINwMIIAQkAiAFQQNqC6EEAwN/AX4FfCMCIQMjAkEQaiQCIAArA0ggACgCNCIEIAJBBHRqKwMAIggg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IwIhDCMCQRBqJAIgDAshAyAAIQQgASEAAkACQAJAAkACQAJAAkADQAJAIAAiCUFwaiEGIABBYGohCyAAIQoCfwJAAn8CQAJAAkADQAJAAkAgCSAEayIFQQR1IgEOBg8PCQsMDQALIAVB8ANIDQ0gAUECbUEEdCAEaiEAAn8gBUHw/ABKBH8gBCABQQRtIgFBBHQgBGoiByAAIAFBBHQgAGoiCBBzIQEgCCkDACAGKQMAWQRAIAEhBSAADAILIAMgCCkDADcDACADIAgpAwg3AwggCCAGKQMANwMAIAggBikDCDcDCCAGIAMpAwA3AwAgBiADKQMINwMIIAFBAWohBSAAKQMAIAgpAwBTBH8gAyAAKQMANwMAIAMgACkDCDcDCCAAIAgpAwA3AwAgACAIKQMINwMIIAggAykDADcDACAIIAMpAwg3AwggAUECaiEFIAcpAwAgACkDAFMEfyADIAcpAwA3AwAgAyAHKQMINwMIIAcgACkDADcDACAHIAApAwg3AwggACADKQMANwMAIAAgAykDCDcDCCABQQNqIQUgBCkDACAHKQMAUwRAIAMgBCkDADcDACADIAQpAwg3AwggBCAHKQMANwMAIAQgBykDCDcDCCAHIAMpAwA3AwAgByADKQMINwMIIAFBBGohBQsgAAUgAAsFIAALBSAAKQMAIg0gBikDAFMhASAEKQMAIA1ZBEAgAUUEQEEAIQUgAAwDCyADIAApAwA3AwAgAyAAKQMINwMIIAAgBikDADcDACAAIAYpAwg3AwggBiADKQMANwMAIAYgAykDCDcDCCAEKQMAIAApAwBZBEBBASEFIAAMAwsgAyAEKQMANwMAIAMgBCkDCDcDCCAEIAApAwA3AwAgBCAAKQMINwMIIAAgAykDADcDACAAIAMpAwg3AwhBAiEFIAAMAgsgAQRAIAMgBCkDADcDACADIAQpAwg3AwggBCAGKQMANwMAIAQgBikDCDcDCCAGIAMpAwA3AwAgBiADKQMINwMIQQEhBSAADAILIAMgBCkDADcDACADIAQpAwg3AwggBCAAKQMANwMAIAQgACkDCDcDCCAAIAMpAwA3AwAgACADKQMINwMIIAApAwAgBikDAFMEQCADIAApAwA3AwAgAyAAKQMINwMIIAAgBikDADcDACAAIAYpAwg3AwggBiADKQMANwMAIAYgAykD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AhggA0EANgIcIANBADYCICADQQA2AiggA0EANgIsIANBADYCMCADQQA2AjggA0EANgI8IANBQGtBADYCACADQgA3AgQgA0IANwIMIANB9CY2AgAgA0IANwJIIANCADcCUCADQgA3AlggA0IANwJgIANBADYCaCADIANB8ABqIgQ2AnAgAyAENgJ0IANBADYCeCADQQA6AIABIANBADoAFCADQQA6AIwBIANBADoAJCADQQA6ACUgA0EBOgCOASAAKAIAIgQgACgCBEcEQAJAQfQmIQUDQCADIAZBDGwgBGpBAEEBIAUoAghBB3FBrgFqEQEAGiAGQQFqIgYgACgCBCAAKAIAIgRrQQxtTw0BIAMoAgAhBQwAAAsACwsgA0EBIAEgAiACEEoaIANB9CY2AgAgA0HwAGohAiADKAJ4BEAgAygCdCIAKAIAIgEgAigCACIEKAIENgIEIAQoAgQgATYCACADQQA2AnggACACRwRAA0AgACgCBCEBIAAQIyABIAJHBEAgASEADAELCwsLIAMoAmAiAARAIAMgADYCZCAAECMLIAMoAlQiAARAIAMgADYCWCAAECMLIAMoAkgiAARAIAMgADYCTCAAECMLIANB2CY2AgAgAyADKAIIIgA2AgwgAyAANgIEIAMoAhwiASADKAIYIgBGBEAgASEABUEAIQIDQCACQQJ0IABqKAIAIgQEQCAEECMgAygCHCEBIAMoAhghAAsgAkEBaiICIAEgAGtBAnVJDQALCyADIAA2AhwgA0EAOgAUIANBADoAJSADKAI4IgAEQCADIAA2AjwgABAjCyADKAIoIgAEQCADIAA2AiwgABAjCyADKAIYIgAEQCADIAA2AhwgABAjCyADKAIIIgBFBEAgAyQCDwsgAyAANgIMIAAQIyADJAILxCUDEX8Efgd8IwIhCCMCQSBqJAIgAEEQaiIOKAIAIgYgACgCFCIDRwRAA0AgA0F0aiICKAIAIgQEQCADQXhqIAQ2AgAgBBAjCyACIAZHBEAgAiEDDAELCwsgACAGNgIUIABBQGsgATkDACABRCNCkgyhnMc7YyABRCNCkgyhnMe7ZHEEQCAOIAAoApQBIAAoApABa0ECdRBIIAAoApQBIAAoApABIgNrQQBMBEAgCCQCDwtBACECA38CfyACQQJ0IANqKAIAIhAoAixFBEACQCAQQQRq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CCAAIAIpAgA3AgwLDQAgAEHwAmogARD5AwsPACAAQfACaiABIAIQ6wMLEQAgAEHwAmogASACIAMQ2wMLEQAgAEHwAmogASACIAMQzAMLwQEBA38jAiECIwJBIGokAiACQQhqQcqFARAiIAJBEGoiASACKQIINwIAIAAgARAqBH8gABBjGiABIABBABA9IABB3wAQJwR/IAAgARDTAQVBAAsFIAJBzYUBECIgASACKQIANwIAIAAgARAqBH8gASAAQQAQPSABKAIAIAEoAgRGBH9BAAUgAEHwABAnBH8gABBjGiABIABBABA9IABB3wAQJwR/IAAgARDTAQVBAAsFQQALCwVBAAsLIQMgAiQCIAMLCwAgAEEIaiABEEALNQEBfyABKAIEIQMgACABKAIAIAIgASgCBCABKAIAayIBQX9qIAEgAksbajYCACAAIAM2AgQLdQEDfyMCIQIjAkEgaiQCIAJBEGoiBEG77gAQIiACQRhqIgMgBCkCADcCACABIAMQJCAAKAIIIAEQKyACQQhqIgRBt+4AECIgAyAEKQIANwIAIAEgAxAkIAIgACkCDDcDACADIAIpAgA3AgAgASADECQgAiQCCxsAIABB8AJqQQwQJiIAIAEoAgBBAEcQiQQgAAuFCQEWfyMCIQIjAkGgAWokAiACQZABaiEBIAJBiAFqIQMgAkGAAWohBCACQfgAaiEFIAJB8ABqIQYgAkHoAGohByACQeAAaiEIIAJB2ABqIQkgAkHQAGohCiACQcgAaiELIAJBQGshDCACQThqIQ0gAkEwaiEOIAJBKGohDyACQSBqIRAgAkEYaiERIAJBEGohEiACQQhqIRMgAEHMABAnBH8CfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIEIAAoAgAiFGtBAEsEfyAULAAABUEAC0EYdEEYdUHUAGsOJgAUFBQUFBQUFBQUExQEAgMREhAUBQgJFAoLDg8UFBQGBxQUAQwNFAtBAAwUCyAAIAAoAgBBAWo2AgAgA0HZ8AAQIiABIAMpAgA3AgAgACABED4MEwsgBEHh8AAQIiABIAQpAgA3AgAgACABECoEQCABQQA2AgAgACABEOgBDBMLIAVB5fAAECIgASAFKQIANwIAQQAgACABECpFDRIaIAFBATYCACAAIAEQ6AEMEgsgACAAKAIAQQFqNgIAIAZBy+kAECIgASAGKQIANwIAIAAgARA+DBELIAAgACgCAEEBajYCACAHQdDpABAiIAEgBykCADcCACAAIAEQPgwQCyAAIAAoAgBBAWo2AgAgCEHc6QAQIiABIAgpAgA3AgAgACABED4MDwsgACAAKAIAQQFqNgIAIAlB6ukAECIgASAJKQIANwIAIAAgARA+DA4LIAAgACgCAEEBajYCACAKQfDpABAiIAEgCikCADcCACAAIAEQPgwNCyAAIAAoAgBBAWo2AgAgC0HVnQEQIiABIAspAgA3AgAgACABED4MDAsgACAAKAIAQQFqNgIAIAxB6fAAECIgASAMKQIANwIAIAAgARA+DAsLIAAgACgCAEEBajYCACANQevwABAiIAEgDSkCADcCACAAIAEQPgwKCyAAIAAoAgBBAWo2AgAgDkHt8AAQIiABIA4pAgA3AgAgACABED4MCQsgACAAKAIAQQFqNgIAIA9B8PAAECIgASAPKQIANwIAIAAgARA+DAgLIAAgACgCAEEBajYCACAQQfPwABAiIAEgECkCADcCACAAIAEQPgwHCyAAIAAoAgBBAWo2AgAgEUGt6gAQIiABIBEpAgA3AgAgACABED4MBgsgACAAKAIAQQFqNgIAIBJBtuoAECIgASASKQIANwIAIAAgARA+DAULIAAgACgCAEEBajYCACAAEJUEDAQLIAAgACgCAEEBajYCACAAEJQEDAMLIAAgACgCAEEBajYCACAAEJMEDAILIBNBiekAECIgASATKQIANwIAQQAgACABECpFDQEaIAAQVyIBBEAgASAAQcUAECcNAhoLQQAMAQsgASAAEC4iAzYCACADBH8gAiAAQQAQPQJ/IAIoAgAgAigCBEYhFSAAQcUAECchBCAVCwR/IANBACAEGwUgBAR/IABB8AJqIAEgAhCSBAVBAAsLBUEACwsFQQALIRYgAiQCIBYLOQEBfyABQfACaiADIAJrIgFBAnUiBEECdBAmIQMgAQRAIAMgAiABEFQaCyAAIAM2AgAgACAENgIEC0oBA38jAiEBIwJBEGokAiABQQhqIQIgACgCCCIALQAEQQdGBH8gAiAAKQIINwIAIAFB9O4AECIgAiABEKEBBUEACyEDIAEkAiADC2QBAn8gACABKAIMIgQ2AgAgACABKAII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Axg3AwggACAAKQMgNwMQIAAgACkDKDcDGCAAIAIpAwA3AyAgACACKQMINwMoIAApAwAgACkDEFkNAyACIAApAwA3AwAgAiAAKQMINwMIIAAgACkDEDcDACAAIAApAxg3AwggACACKQMANwMQIAAgAikDCDcDGAwDCyAAKQMQIgkgAEEgaiIDKQMAIgpTIQQgACkDACILIAlTBEACQCAEBEAgAiAAKQMANwMAIAIgACkDCDcDCCAAIAMpAwA3AwAgACADKQMINwMIIAMgAikDADcDACADIAIpAwg3AwgMAQsgAiAAKQMANwMAIAIgACkDCDcDCCAAIAApAxA3AwAgACAAKQMYNwMIIAAgAikDADcDECAAIAIpAwg3AxggACkDECAKUwRAIAIgACkDEDcDACACIAApAxg3AwggACADKQMANwMQIAAgAykDCDcDGCADIAIpAwA3AwAgAyACKQMINwMICwsFIAQEQCACIAApAxA3AwAgAiAAKQMYNwMIIAAgAykDADcDECAAIAMpAwg3AxggAyACKQMANwMAIAMgAikDCDcDCCALIAApAxBTBEAgAiAAKQMANwMAIAIgACkDCDcDCCAAIAApAxA3AwAgACAAKQMYNwMIIAAgAikDADcDECAAIAIpAwg3AxgLCwsgASAAQTBqIgRGDQIDQAJAIAMpAwAgBCkDACIJUwRAIAIgBCkDCDcDACAEIQUCQAJAA0ACQCAFIAMpAwA3AwAgBSADKQMINwMIIAAgA0YEQCAAIgMhBQwBCyADQXBqIgcpAwAgCVkNAiADIQUgByEDDAELCwwBCyADIQULIAUgCTcDACADIAIpAwA3AwggBkEBaiIDQQhGDQEFIAYhAwsgASAEQRBqIgZGDQQCfyAEIQggBiEEIAMhBiAICyEDDAELCyACJAIgASAEQRBqRg8LIAIgACkDADcDACACIAApAwg3AwggACABKQMANwMAIAAgASkDCDcDCAsgASACKQMANwMAIAEgAikDCDcDCAsgAiQCQQELCgAgACABsDcDCAsIACAAKQMIuQsKACAAIAGwNwMACwgAIAApAwC5C9QFAQJ/IwIhAyMCQZABaiQCIAAgASACQQBBARCKASADQQA2AhggA0EANgIcIANBADYCICADQQA2AiggA0EANgIsIANBADYCMCADQQA2AjggA0EANgI8IANBQGtBADYCACADQgA3AgQgA0IANwIMIANB9CY2AgAgA0IANwJIIANCADcCUCADQgA3AlggA0IANwJgIANBADYCaCADIANB8ABqIgA2AnAgAyAANgJ0IANBADYCeCADQQA6AIABIANBADoAFCADQQA6AIwBIANBADoAjgEgA0EAOgAkIANBADoAJSACKAIAIgAgAigCBEcEQAJAQQAhAUH0JiEEA0AgAyABQQxsIABqQQBBASAEKAIIQQdxQa4BahEBABogAUEBaiIBIAIoAgQgAigCACIAa0EMbU8NASADKAIAIQQMAAALAAsLIANBASACQQFBARBKGiADQfQmNgIAIANB8ABqIQIgAygCeARAIAMoAnQiACgCACIBIAIoAgAiBCgCBDYCBCAEKAIEIAE2AgAgA0EANgJ4IAAgAkcEQANAIAAoAgQhASAAECMgASACRwRAIAEhAAwBCwsLCyADKAJgIgAEQCADIAA2AmQgABAjCyADKAJUIgAEQCADIAA2AlggABAjCyADKAJIIgAEQCADIAA2AkwgABAjCyADQdgmNgIAIAMgAygCCCIANgIMIAMgADYCBCADKAIcIgAgAygCGCIBRgRAIAAhAQVBACECA0AgAkECdCABaigCACIEBEAgBBAjIAMoAhghASADKAIcIQALIAJBAWoiAiAAIAFrQQJ1SQ0ACwsgAyABNgIcIANBADoAFCADQQA6ACUgAygCOCIABEAgAyAANgI8IAAQIwsgAygCKCIABEAgAyAANgIsIAAQIwsgAygCGCIABEAgAyAANgIcIAAQIwsgAygCCCIARQRAIAMkAg8LIAMgADYCDCAAECMgAyQCC+4IAgp/A34jAiEHIwJBsAFqJAIgB0EMaiEIIAdBGGoiBEEANgIYIARBADYCHCAEQQA2AiAgBEEANgIoIARBADYCLCAEQQA2AjAgBEEANgI4IARBADYCPCAEQUBrQQA2AgAgBEIANwIEIARCADcCDCAEQfQmNgIAIARCADcCSCAEQgA3AlAgBEIANwJYIARCADcCYCAEQQA2AmggBCAEQfAAaiIFNgJwIAQgBTYCdCAEQQA2AnggBEEAOgCAASAEQQA6ABQgBEEAOgCMASAEQQA6AI4BIARBADoAJCAEQQA6ACUgASgCACIFIAEoAgRHBEADQCAIQQA2AgAgCEEANgIEIAhBADYC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IgsgAikDCLmioCAEuSALoiAFuSAKoqChIgwgDKIgCyALoiAKIAqioKMgA2MFIAe5IAggBX25IgqiIAa5IAQgAikDCH25IguioCAEuSAKoiAFuSALoqChIgwgDKIgCiAKoiALIAuioKMgA2MLBSAEIAIpAwgiCFMgBCAHVXNFBEAgBbkgByAIfbkiCqIgBLkgAikDACAGfbkiC6KgIAa5IAqiIAe5IAuioKEiDCAMoiAKIAqiIAsgC6KgoyADYw8LIAQgB1MgByAIU3MEfyAGIAV9uSIKIAi5oiAJuSILIAIpAwC5oqAgBLkgCqIgBbkgC6KgoSIMIAyiIAogCqIgCyALoqCjIANjBSAGuSAEIAh9uSIKoiAHuSACKQMAIAV9uSILoqAgBbkgCqIgBLkgC6KgoSIMIAyiIAogCqIgCyALoqCjIANjCwsLCwAgACAAIAEQuwELHAEBfyAAKAIQIgEgACgCFEYEQEEADwsgASgCAAvwBAECfyMCIQMjAkGQAWokAiADQQA2AhggA0EANgIcIANBADYCICADQQA2AiggA0EANgIsIANBADYCMCADQQA2AjggA0EANgI8IANBQGtBADYCACADQgA3AgQgA0IANwIMIANB9CY2AgAgA0IANwJIIANCADcCUCADQgA3AlggA0IANwJgIANBADYCaCADIANB8ABqIgQ2AnAgAyAENgJ0IANBADYCeCADQQA6AIABIANBADoAFCADQQA6AIwBIANBADoAJCADQQA6ACUgA0EBOgCOASADIABBAEEBEGwaIANBASABIAIgAhBKGiADQfQmNgIAIANB8ABqIQIgAygCeARAIAMoAnQiACgCACIBIAIoAgAiBCgCBDYCBCAEKAIEIAE2AgAgA0EANgJ4IAAgAkcEQANAIAAoAgQhASAAECMgASACRwRAIAEhAAwBCwsLCyADKAJgIgAEQCADIAA2AmQgABAjCyADKAJUIgAEQCADIAA2AlggABAjCyADKAJIIgAEQCADIAA2AkwgABAjCyADQdgmNgIAIAMgAygCCCIANgIMIAMgADYCBCADKAIcIgAgAygCGCIBRgRAIAAhAQVBACECA0AgAkECdCABaigCACIEBEAgBBAjIAMoAhghASADKAIcIQALIAJBAWoiAiAAIAFrQQJ1SQ0ACwsgAyABNgIcIANBADoAFCADQQA6ACUgAygCOCIABEAgAyAANgI8IAAQIwsgAygCKCIABEAgAyAANgIsIAAQIwsgAygCGCIABEAgAyAANgIcIAAQIwsgAygCCCIARQRAIAMkAg8LIAMgADYCDCAAECMgAyQCC9ABAQZ/IwIhAyMCQRBqJAIgACgCBCICIAAoAgAiAUYEQCADJAIPCwNAIARBDGwgAWooAgQiBSAEQQxsIAFqKAIAIgZHBEAgBiAFQXBqIgVJBEAgBiEBIAUhAgNAIAMgASkDADcDACADIAEpAwg3AwggASACKQMANwMAIAEgAikDCDcDCCACIAMpAwA3AwAgAiADKQMINwMIIAFBEGoiASACQXBqIgJJDQALIAAoAgAhASAAKAIEIQILCyAEQQFqIgQgAiABa0EMbUkNAAsgAyQCC5AOAg1/CH4jAiEIIwJBsAFqJAIgASgCNCIHIAEoAjAiBkcEQANAIARBAnQgBmooAgAiBQRAIAUgBSgCACgCBEH/AHFByAFqEQAAIAEoAjQhByABKAIwIQYLIARBAWoiBCAHIAZrIgVBAnVJDQALIAUEQCABIAY2AjQLCyABQRBqIgooAgAiBCABKAIURwRAIAEgBDYCFAsgABC9ASAAIAIQvAEgCEEYaiIDQQA2AhggA0EANgIcIANBADYCICADQQA2AiggA0EANgIsIANBADYCMCADQQA2AjggA0EANgI8IANBQGtBADYCACADQgA3AgQgA0IANwIMIANB9CY2AgAgA0IANwJIIANCADcCUCADQgA3AlggA0IANwJgIANBADYCaCADIANB8ABqIgQ2AnAgAyAENgJ0IANBADYCeCADQQA6AIABIANBADoAFCADQQA6AIwBIANBADoAjgEgA0EAOgAkIANBADoAJSAAKAIQIgYgACgCFEcEQAJAQQAhB0H0JiEEA0AgAyAHQQxsIAZqQQBBASAEKAIIQQdxQa4BahEBABogB0EBaiIHIAAoAhQgACgCECIGa0EMbU8NASADKAIAIQQMAAALAAsLIAhBqAFqIQwgCEEIaiEJIAJEAAAAAAAAAABkBEAgA0EBIAFBAkECEH0aBSADKAIIIgAgAygCDCINRgRAIAhCADcDAAUgCCAAKAIIIgYpAwAiEjcDACAGKQMIIhMhFCASIRAgEyEWA0AgFiATUyEOIAAhCyAGIQQgEiERIBAhEgNAIAQpAwAiECARUyEHIAggBCgCWCIABH8gESEXA0AgECARIAcbIREgECASIBAgElUbIRIgACkDACIVIBAgFyAHGyIXUyEHIAAoAlgiBQRAIBUhECAFIQAMAQsLIAggETcDACAABSAEIgALIgUgCCAHGykDACIRNwMAIAUpAwAiECASIBIgEFMbIRUgCCAAKQMgIhAgESAQIBFTGyISNwMAIBAgFSAVIBBTGyEQIAApAygiESAUIBEgFFMbIRQgBCAGRgRAIAsoAgwhBCASIREgECESDAELCyATIBYgDhshESANIAtBEGoiAEcEQCALKAIYIgYpAwghEyARIRYMAQsLCyAJQQA2AgAgCUEANgIEIAlBADYCCCAJQcAAECUiBTYCACAJIAVBQGsiADYCCCAJIAA2AgQgBSASQnZ8IhI3AwAgBSARQgp8IhE3AwggBSAQQgp8IhA3AxAgBSARNwMYIAUgEDcDICAFIBRCdnwiEDcDKCAFIBI3AzAgBSAQNwM4IAMgCUEAQQEQbBogA0EBOgCMASADQQEgAUEDQQMQfRoCQAJ/An8CQCABKAIUIAooAgAiAGtBBEcNACAAKAIAIgQoAhQgBCgCEGsiAEEATA0AIAogAEECdhCOASAKKAIAIAQoAhAoAgA2AgAgCigCACIHKAIAIAQoAhw2AhwgBCgCFCAEKAIQIgBrQQRKBEBBASEGA0AgASgCFCEFIAwgBkECdCAAaigCACIANgIAIAEoAhggBUsEQCAFIAA2AgAgASABKAIUQQRqNgIUBSAKIAwQNAsgACABNgIcIAAgBSAHa0ECdTYCICAGQQFqIgYgBCgCFCAEKAIQIgBrQQJ1SARAIAooAgAhBwwBCwsgCSgCACIABEAgAAwDCwUgBSIADAILDAMLIAEoAjQiBiABKAIwIgBHBEBBACEEA0AgBEECdCAAaigCACIHBEAgByAHKAIAKAIEQf8AcUHIAWoRAAAgASgCNCEGIAEoAjAhAAsgBEEBaiIEIAYgAGsiB0ECdUkNAAsgBwRAIAEgADYCNAsLIAooAgAiACABKAIURwRAIAEgADYCFAsgBSIACyEPIAkgADYCBCAPCxAjCwsgA0H0JjYCACADQfAAaiEEIAMoAngEQCADKAJ0IgAoAgAiASAEKAIAIgUoAgQ2AgQgBSgCBCABNgIAIANBADYCeCAAIARHBEADQCAAKAIEIQEgABAjIAEgBEcEQCABIQAMAQsLCwsgAygCYCIABEAgAyAANgJkIAAQIwsgAygCVCIABEAgAyAANgJYIAAQIwsgAygCSCIABEAgAyAANgJMIAAQIwsgA0HYJjYCACADIAMoAggiADYCDCADIAA2AgQgAygCHCIBIAMoAhgiAEYEQCABIQAFQQAhBgNAIAZBAnQgAGooAgAiBARAIAQQIyADKAIcIQEgAygCGCEACyAGQQFqIgYgASAAa0ECdUkNAAsLIAMgADYCHCADQQA6ABQgA0EAOgAlIAMoAjgiAARAIAMgADYCPCAAECMLIAMoAigiAARAIAMgADYCLCAAECMLIAMoAhgiAARAIAMgADYCHCAAECMLIAMoAggiAEUEQCAIJAIPCyADIAA2AgwgABAjIAgkAguzAQEEfyAAQfQmNgIAIABB8ABqIQMgACgCeARAIAAoAnQiAigCACIEIAMoAgAiASgCBDYCBCABKAIEIAQ2AgAgAEEANgJ4IAIgA0cEQANAIAIoAgQhASACECMgASADRwRAIAEhAgwBCwsLCyAAKAJgIgEEQCAAIAE2AmQgARAjCyAAKAJUIgEEQCAAIAE2AlggARAjCyAAKAJIIgFFBEAgABBdDwsgACABNgJMIAEQIyAAEF0LsQwCCn8IfiMCIQkjAkGwAWokAiABKAIAIgcgASgCBCIERwRAA0AgBEF0aiIFKAIAIgYEQCAEQXhqIAY2AgAgBhAjCyAFIAdHBEAgBSEEDAELCwsgASAHNgIEIAAQvQEgACACELwBIAlBGGoiA0EANgIYIANBADYCHCADQQA2AiAgA0EANgIoIANBADYCLCADQQA2AjAgA0EANgI4IANBADYCPCADQUBrQQA2AgAgA0IANwIEIANCADcCDCADQfQmNgIAIANCADcCSCADQgA3AlAgA0IANwJYIANCADcCYCADQQA2AmggAyADQfAAaiIENgJwIAMgBDYCdCADQQA2AnggA0EAOgCAASADQQA6ABQgA0EAOgCMASADQQA6AI4BIANBADoAJCADQQA6ACUgACgCECIEIAAoAhRHBEACQEH0JiEFA0AgAyAIQQxsIARqQQBBASAFKAIIQQdxQa4BahEBABogCEEBaiIIIAAoAhQgACgCECIEa0EMbU8NASADKAIAIQUMAAALAAsLIAlBCGohCiACRAAAAAAAAAAAZARAIANBASABQQJBAhBKGgUgAygCCCIAIAMoAgwiC0YEQCAJQgA3AwAFIAkgACgCCCIEKQMAIg83AwAgBCkDCCIQIREgDyENIBAhEwNAIBMgEFMhDCAAIQYgBCEFIA8hDiANIQ8DQCAFKQMAIg0gDlMhCCAJIAUoAlgiAAR/IA4hFANAIA0gDiAIGyEOIA0gDyANIA9VGyEPIAApAwAiEiANIBQgCBsiFFMhCCAAKAJYIgcEQCASIQ0gByEADAELCyAJIA43AwAgAAUgBSIACyIHIAkgCBspAwAiDjcDACAHKQMAIg0gDyAPIA1TGyESIAkgACkDICINIA4gDSAOUxsiDzcDACANIBIgEiANUxshDSAAKQMoIg4gESAOIBFTGyERIAQgBUYEQCAGKAIMIQUgDyEOIA0hDwwBCwsgECATIAwbIQ4gCyAGQRBqIgBHBEAgBigCGCIEKQMIIRAgDiETDAELCwsgCkEANgIAIApBADYCBCAKQQA2AgggCkHAABAlIgY2AgAgCiAGQUBrIgA2AgggCiAANgIEIAYgD0J2fCIPNwMAIAYgDkIKfCIONwMIIAYgDUIKfCINNwMQIAYgDjcDGCAGIA03AyAgBiARQnZ8Ig03AyggBiAPNwMwIAYgDTcDOCADIApBAEEBEGwaIANBAToAjAEgA0EBIAFBA0EDEEoaIAEoAgAiBCEAIAEoAgQiBSEHIAQgBUcEQAJAAkAgByAAQQxqIgRGBEAgByEEDAEFA0AgACgCACIFBEAgAEEEaiIIIAU2AgAgBRAjIABBCGoiBUEANgIAIABBADYCBCAAQQA2AgAFIABBCGohBSAAQQRqIQgLIAAgBCgCADYCACAIIAQoAgQ2AgAgBSAEKAIINgIAIARBADYCCCAEQQA2AgQgBEEANgIAIABBDGohACAEQQxqIgQgB0cNAAsgACABKAIEIgRHDQELDAELA0AgBEF0aiIFKAIAIgcEQCAEQXhqIAc2AgAgBxAjCyAAIAVHBEAgBSEEDAELCwsgASAANgIECyAGECMLIANB9CY2AgAgA0HwAGohBCADKAJ4BEAgAygCdCIAKAIAIgEgBCgCACIFKAIENgIEIAUoAgQgATYCACADQQA2AnggACAERwRAA0AgACgCBCEBIAAQIyABIARHBEAgASEADAELCwsLIAMoAmAiAARAIAMgADYCZCAAECMLIAMoAlQiAARAIAMgADYCWCAAECMLIAMoAkgiAARAIAMgADYCTCAAECMLIANB2CY2AgAgAyADKAIIIgA2AgwgAyAANgIEIAMoAhwiASADKAIYIgBGBEAgASEABUEAIQQDQCAEQQJ0IABqKAIAIgUEQCAFECMgAygCHCEBIAMoAhghAAsgBEEBaiIEIAEgAGtBAnVJDQALCyADIAA2AhwgA0EAOgAUIANBADoAJSADKAI4IgAEQCADIAA2AjwgABAjCyADKAIoIgAEQCADIAA2AiwgABAjCyADKAIYIgAEQCADIAA2AhwgABAjCyADKAIIIgBFBEAgCSQCDwsgAyAANgIMIAAQIyAJJAILEAAgACgCBCAAKAIAa0ECdQuMAQECfyMCIQEjAkEQaiQCIAAoAgAiAiAAKAIEIgBGBEAgASQCDwsgAiAAQXBqIgBPBEAgASQCDwsDQCABIAIpAwA3AwAgASACKQMINwMIIAIgACkDADcDACACIAApAwg3AwggACABKQMANwMAIAAgASkDCDcDCCACQRBqIgIgAEFwaiIASQ0ACyABJAILQwECfyABKAIAIgUgASgCBEYEQA8LA0AgACAEQQxsIAVqIAIgAxC+ASAEQQFqIgQgASgCBCABKAIAIgVrQQxtSQ0ACws4AQF/IABByCY2AgAgACgCECIBBEAgACABNgIUIAEQIwsgACgCBCIBRQRADwsgACABNgIIIAEQIwuIAQEEfyAAKAKUASIDIAAoApABIgFrQQBMBEAgACABNgKUASAAQn83A3APCwNAIAJBAnQgAWooAgAiBARAIAQoAgAoAgQhASAEIAFB/wBxQcgBahEAACAAKAKQASEBIAAoApQBIQMLIAJBAWoiAiADIAFrQQJ1SA0ACyAAIAE2ApQBIABCfzcDcAvJAgEGfyAAKAKQASIFIQIgACgClAEiBCAFa0EASgRAA0AgA0ECdCAFaigCACIBBEAgASABKAIAKAIEQf8AcUHIAWoRAAAgACgCkAEiAiEFIAAoApQBIQQLIANBAWoiAyAEIAVrQQJ1SA0ACwsgACAFNgKUASAAQn83A3AgAEHIJjYCgAEgAgRAIAAgAjYClAEgAhAjCyAAKAKEASIBBEAgACABNgKIASABECMLIAAoAjQiAQRAIAAgATYCOCABECML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QQAgABCSAQ0GGkEAIAAQkgENBhogAiAAEFciATYCACABBH8gAEHwAmogAhDcAgVBAAsMBgsgACAAKAIAQQJqNgIAIAIgABAuIgE2AgAgAQR/An8gAyAAQQEQPUEAIAMoAgAgAygCBEYNABogAEHfABAnBH8gAyAAEC4iATYCACABBH8gAEHwAmpBEBAmIgAgAygCACACKAIAEN4CIAAFQQALBUEACwsFQQALDAULIAAgACgCAEECajYCACACIABBABBJIgE2AgAgAQR/IABB9ZMBIAIQ9QEFQQALDAQLIAAgACgCAEECajYCACACIABBABBJIgE2AgAgAQR/IABB8AJqIAIQ3wIFQQALDAMLIAAgACgCAEEBajYCAAJ/IAAoAgQgACgCACIBa0EASwR/IAEsAAAFQQALIQVBACAAEJIBDQMaIAULQf8BcUH2AEYhASACIAAQVyIENgIAIAQEfyABBH8gAEHwAmogAhDgAgUgAEHwAmogAhDhAgsFQQALDAILAkACQAJAIAAoAgQgACgCACIBa0EBSwR/IAEsAAEFQQALQRh0QRh1QdIAaw4FAgEBAQABCyAAIAAoAgBBAmo2AgAgAiAAQQAQSSIBNgIAIAEEfyAAQfACaiACEOMCBUEACwwDC0EADAILIAAgACgCAEECajYCACACIABBABBJIgE2AgAgAQR/IAAgAxDvASAAQd8AECdyBH8gAEHwAmogAhDkAgVBAAsFQQALDAELQQALIQYgAyQCIAYLdQEDfyMCIQIjAkEgaiQCIAAoAgggARArIAJBEGoiBEGFhAEQIiACQRhqIgMgBCkCADcCACABIAMQJCACIAApAgw3AwAgAyACKQIANwIAIAEgAxAkIAJBCGoiAEG37gAQIiADIAApAgA3AgAgASADECQgAiQCC0AAIABBmC02AgAgAEEBOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABB7MIANgIAIAAgATYCCCAAIAIpAgA3AgwLRgEBfyMCIQMjAkEQaiQCIABBFBAmIQAgASgCACEBIAMgAikCADcDACADQQhqIgIgAykCADcCACAAIAEgAhDwAiADJAIgAAs7AQJ/IwIhAiMCQRBqJAIgAiAAKQIINwMAIAJBCGoiAyACKQIANwIAIAEgAxAkIAAoAhAgARArIAIkAgtBAQF/IwIhAyMCQRBqJAIgAEEUECYhACADIAEQIiACKAIAIQEgA0EIaiICIAMpAgA3AgAgACACIAEQRSADJAIgAAvvAwIHfwF8IwIhBCMCQSBqJAIgACgCNCIDRQRAIAQkAg8LIARBEGohBiAAIAM2AnwgAyECA0AgAiACKAJgNgJoIAIgAigCXCIFNgJkIAIgASACKQMoUQR+IAIpAyAFIAIpAwAgAisDMCABIAIpAwh9uaIiCUQAAAAAAADgv0QAAAAAAADgPyAJRAAAAAAAAAAAYxugsHwLNwMQIAUEQCAFIQIMAQsLIABB4ABqIQcgAyECA0ACQCACKAJkIgUEQEEAIQMDQCAEQgA3AwAgBEIANwMIIAIpAxAgBSkDEFUEQCACIAUgBBCBBSAEKQMIIAFTBEAgBCABIAIpAyhRBH4gAikDIAUgAikDACACKwMwIAEgAikDCH25oiIJRAAAAAAAAOC/RAAAAAAAAOA/IAlEAAAAAAAAAABjG6CwfAs3AwAgBCABNwMICyAGQRgQJSIDNgIAIAMgAjYCACADIAU2AgQgAyAEKQMANwMIIAMgBCkDCDcDECAAKAJkIgggACgCaEYEQCAHIAYQNAUgCCADNgIAIAAgACgCZEEEajYCZAsgACACIAUQygFBASEDBSAFIQILIAIoAmQiBQ0ACwVBACEDCyACKAJoIgJFDQAgAkEANgJkIANFDQAgACgCfCECDAELCyAAQQA2AnwgBCQCCxgBAX4gArAhAyAAIAGwNwMAIAAgAzcDCAtWAQN/IwIhAiMCQSBqJAIgAkEIaiIEQdyRARAiIAJBEGoiAyAEKQIANwIAIAEgAxAkIAAoAgggARArIAJBt+4AECIgAyACKQIANwIAIAEgAxAkIAIkAgtLAQF/IABBDBAmIgIhACABKAIAIQEgAEGYLTYCACAAQRA6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGUwgA2AgAgACABNgIIIAILPwECfyMCIQIjAkEQaiQCIAJBnJEBECIgAkEIaiIDIAIpAgA3AgAgASADECQgAEEIaiABEEAgAUEpEDUgAiQCC2gBAX8jAiECIwJBEGokAiAAQRAQJiEAIAIgASkCADcDACACIAIpAgA3AgggAEGYLTYCACAAQRE6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHowQA2AgAgACACKQIINwIIIAIkAiAAC+kCAQV/IwIhBCMCQUBrJAIgBEEgaiEFIARBMGoiAkG77gAQIiAEQThqIgMgAikCADcCACABIAMQJCAAQQxqIAEQQCAEQShqIgJBt+4AECIgAyACKQIANwIAIAEgAxAkIAAoAggiAigCACgCFCEGIAIgASAGQf8AcUHaAmoRBAAgACgCFCICQQFxBEAgBUGajwEQIiADIAUpAgA3AgAgASADECQgACgCFCECCyAEQRhqIQUgAkECcQRAIAVBoY8BECIgAyAFKQIANwIAIAEgAxAkIAAoAhQhAgsgBEEQaiEFIAJBBHEEQCAFQauPARAiIAMgBSkCADcCACABIAMQJAsgBEEIaiECAkACQAJAIAAsABhBAWsOAgABAgsgAkHkkAEQIiADIAIpAgA3AgAgASADECQMAQsgBEHnkAEQIiADIAQpAgA3AgAgASADECQLIAAoAhwEQCABQSAQNSAAKAIcIAEQKwsgBCQCC1ABAn8jAiECIwJBEGokAiAAKAIIIgAoAgAoAhAhAyAAIAEgA0H/AHFB2gJqEQQAIAJBue4AECIgAkEIaiIAIAIpAgA3AgAgASAAECQgAiQCC1UAIABBmC02AgAgAEEPOgAEIABBADoABSAAQQE6AAYgAEEAOgAHIABBvMEANgIAIAAgATYCCCAAIAIpAgA3AgwgACADNgIUIAAgBDoAGCAAIAU2AhwLYQEBfyMCIQYjAkEQaiQCIABBIBAmIQAgASgCACEBIAYgAikCADcDACADKAIAIQIgBCwAACEDIAUoAgAhBCAGQQhqIgUgBikCADcCACAAIAEgBSACIAMgBBD8AiAGJAIgAAt1AQN/IwIhAiMCQSBqJAIgACgCCCABECsgAkEQaiIEQfHvABAiIAJBGGoiAyAEKQIANwIAIAEgAxAkIAIgACkCDDcDACADIAIpAgA3AgAgASADECQgAkEIaiIAQYbvABAiIAMgACkCADcCACABIAMQJCACJAILQAAgAEGYLTYCACAAQQo6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGQwQA2AgAgACABNgIIIAAgAikCADcCDAtGAQF/IwIhAyMCQRBqJAIgAEEUECYhACABKAIAIQEgAyACKQIANwMAIANBCGoiAiADKQIANwIAIAAgASACEP8CIAMkAiAAC1gBA38jAiECIwJBIGokAiAAKAIIIAEQKyACQQhqIgRBue4AECIgAkEQaiIDIAQpAgA3AgAgASADECQgAiAAKQIMNwMAIAMgAikCADcCACABIAMQJCACJAILQAAgAEGYLTYCACAAQQI6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHkwAA2AgAgACABNgIIIAAgAikCADcCDAtGAQF/IwIhAyMCQRBqJAIgAEEUECYhACABKAIAIQEgAyACKQIANwMAIANBCGoiAiADKQIANwIAIAAgASACEIIDIAMkAiAAC5sBAQR/IwIhAiMCQSBqJAIgAkEYaiEDIAJBEGohBCAAKAIIIgVBAXEEQCAEQZqPARAiIAMgBCkCADcCACABIAMQJCAAKAIIIQULIAJBCGohBCAFQQJxBEAgBEGhjwEQIiADIAQpAgA3AgAgASADECQgACgCCCEFCyAFQQRxBEAgAkGrjwEQIiADIAIpAgA3AgAgASADECQLIAIkAgskAQF/IAAoAgwiACgCACgCFCECIAAgASACQf8AcUHaAmoRBAALKwECfyAAKAIMIgIoAgAoAhAhAyACIAEgA0H/AHFB2gJqEQQAIAAgARCEAwsLACAAKAIMIAEQSwsLACAAKAIMIAEQRgtUAQN/IAEsAAUhAyABLAAGIQQgASwAByEFIABBmC02AgAgAEEDOgAEIAAgAzoABSAAIAQ6AAYgACAFOgAHIABBuMAANgIAIAAgAjYCCCAAIAE2AgwLOgECfyMCIQEjAkEQaiQCIABBEBAmIQAgAUHZ8AAQIiABQQhqIgIgASkCADcCACAAIAIQVSABJAIgAAs6AQJ/IwIhASMCQRBqJAIgAEEQECYhACABQf2OARAiIAFBCGoiAiABKQIANwIAIAAgAhBVIAEkAiAACzoBAn8jAiEBIwJBEGokAiAAQRAQJiEAIAFB9o4BECIgAUEIaiICIAEpAgA3AgAgACACEFUgASQCIAALOAEBfyMCIQIjAkEQaiQCIABBEBAmIQAgAiABECIgAkEIaiIBIAIpAgA3AgAgACABEFUgAiQCIAALPAEBfyMCIQIjAkEQaiQCIABBEBAmIQAgAiABKQIANwMAIAJBCGoiASACKQIANwIAIAAgARBVIAIkAiAAC3MBA38jAiECIwJBIGokAiACQRBqQaqOARAiIAJBGGoiAyACKQIQNwIAIAEgAxAkIAAoAgwhBCACIAAoAgg2AgggAiAENgIMIAMgAikCCDcCACABIAMQJCACQc3rABAiIAMgAikCADcCACABIAMQJCACJAILgQEBAX8jAiECIwJBIGokAiAAQRAQJiEAIAIgASkCADcDACACQRBqIgEgAikCADcCACACQQhqIAEQkwEgASACKQIINwIAIABBmC02AgAgAEEaOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBjMAANgIAIAAgASkCADcCCCACJAIgAAtNAQF/IwIhAyMCQRBqJAIgAEEUECYhACABKAIAIQEgAyACKAIANgIAIANBADYCBCADQQhqIgIgAykCADcCACAAIAEgAhDMASADJAIgAAu7AQEEfyMCIQIjAkEgaiQCIAJBCGohBCAAKAIIIAEQKyACQRBqQfKNARAiIAJBGGoiAyACKQIQNwIAIAEgAxAkIABBDGoiACIFKAIABH8gBSgCBEUFQQALBEAgACgCACABECsFIAAoAgQEfyAAKAIABUEACwRAIAAoAgQhBSAEIAAoAgA2AgAgBCAFNgIEIAMgBCkCADcCACABIAMQJAsLIAJBzesAECIgAyACKQIANwIAIAEgAxAkIAIkAguZAgEFfyMCIQMjAkEwaiQCIANBIGohAiADQRhqIQQgASgCBCIFBH8gASgCACAFQX9qaiwAAAVBAAtB/wFxQd0ARwRAIARBue4AECIgAiAEKQIANwIAIAEgAhAkCyADQQhqIQUgA0EQakHAjQEQIiACIAMpAhA3AgAgASACECQgAEEMaiIEIgYoAgQEfyAGKAIABUEACwRAIAQoAgQhBiAFIAQoAgA2AgAgBSAGNgIEIAIgBSkCADcCACABIAIQJAUgBCgCAAR/IAQoAgRFBUEACwRAIAQoAgAgARArCwsgA0HN6wAQIiACIAMpAgA3AgAgASACECQgACgCCCIAKAIAKAIUIQIgACABIAJB/wBxQdoCahEEACADJAILJAEBfyAAKAIIIgAoAgAoAhAhAiAAIAEgAkH/AHFB2gJqEQQACz8AIABBmC02AgAgAEEOOgAEIABBADoABSAAQQA6AAYgAEEBOgAHIABBtD82AgAgACABNgIIIAAgAikCADcCDAtGAQF/IwIhAyMCQRBqJAIgAEEUECYhACABKAIAIQEgAyACKQIANwMAIANBCGoiAiADKQIANwIAIAAgASACEJUDIAMkAiAAC3ABAn8jAiECIwJBEGokAiACQQhqIQMCQAJAIAAoAgwgARBGDQAgACgCDCABEEsNAAwBCyACQbfuABAiIAMgAikCADcCACABIAMQJAsgACgCDCIDKAIAKAIUIQAgAyABIABB/wBxQdoCahEEACACJAILtwEBBn8jAiECIwJBIGokAiACQRhqIQMgAkEQaiEEIAJBCGohBSAAKAIMIgYoAgAoAhAhByAGIAEgB0H/AHFB2gJqEQQAAkACQCAAKAIMIAEQRg0AIAAoAgwgARBLDQAgBUG57gAQIiADIAUpAgA3AgAgASADECQMAQsgBEG77gAQIiADIAQpAgA3AgAgASADECQLIAAoAgggARArIAJBhI0BECIgAyACKQIANwIAIAEgAxAkIAIkAgtFAQF/IAIsAAUhAyAAQZgtNgIAIABBDToABCAAIAM6AAUgAEEBOgAGIABBAToAByAAQYg/NgIAIAAgATYCCCAAIAI2AgwLPAAgAEGYLTYCACAAQRc6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHcPjYCACAAIAE2AgggACACNgIMC18AAkACQAJAAkACQAJAAkAgASgCCA4GAAECAwQFBgsgAEGm7AAQIgwFCyAAQbDsABAiDAQLIABBsOwAECIMAwsgAEGMigEQIgwCCyAAQZqKARAiDAELIABBqIoBECILC/oBAQd/IwIhAyMCQUBrJAIgA0EwaiECIANBKGohBCADQSBqIQUgA0EYaiEGIANBEGohByADQQhqIQgCQAJAAkACQAJAAkACQCAAKAIIDgYAAQIDBAUGCyAEQd3sABAiIAIgBCkCADcCACABIAIQJAwFCyAFQezsABAiIAIgBSkCADcCACABIAIQJAwECyAGQbeKARAiIAIgBikCADcCACABIAIQJAwDCyAHQf6KARAiIAIgBykCADcCACABIAIQJAwCCyAIQbCLARAiIAIgCCkCADcCACABIAIQJAwBCyADQeKLARAiIAIgAykCADcCACABIAIQJAsgAyQCC0oBAX8gAEEMECYiAiEAIAEoAgAhASAAQZgtNgIAIABBIzoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQbA+NgIAIAAgATYCCCACC3EBA38jAiECIwJBIGokAiACQRBqIQMgAkEIaiEEIAAsAAwEQCAEQZj0ABAiIAMgBCkCADcCACABIAMQJAsgACgCCCIAKAIAKAIYIQQgAiAAIARB/wBxQdoCahEEACADIAIpAgA3AgAgASADECQgAiQCC0YAIABBmC02AgAgAEElOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBhD42AgAgACABNgIIIAAgAkEBcToADCAAIAM2AhALkwMBBX8jAiEDIwJBEGokAiABKAIAIgQtAARBJEYEQCADIAQoAggiBDYCACAEQX5qQQRJBEAgASAAQfACaiADEJ0DNgIACwsgA0EEaiEEAn8gAEHDABAnBH8gAEHJABAnIQUCQAJAIAAoAgQgACgCACIGa0EASwR/IAYsAAAFQQALIgZBGHRBGHVBMWsOBQEBAQABAAtBAAwCCyADIAZBGHRBGHVBUGo2AgAgACAAKAIAQQFqNgIAIAIEQCACQQE6AAALAn8CQCAFRQ0AIAAgAhBJDQBBAAwBCyAEQQA6AAAgACABIAQgAxDQAQsFIAAoAgQgACgCACIFa0EASwR/IAUsAAAFQQALQf8BcUHEAEYEfwJAAkAgACgCBCAAKAIAIgVrQQFLBH8gBSwAAQVBAAsiBUEYdEEYdUEwaw4GAQEBAAABAAtBAAwDCyADIAVBGHRBGHVBUGo2AgAgACAAKAIAQQJqNgIAIAIEQCACQQE6AAALIARBAToAACAAIAEgBCADENABBUEACwsLIQcgAyQCIAcLPAAgAEGYLTYCACAAQRg6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHYPTYCACAAIAE2AgggACACNgIMC2wBA38jAiECIwJBIGokAiACQRBqIgRB3IgBECIgAkEYaiIDIAQpAgA3AgAgASADECQgAiAAKQIINwMAIAMgAikCADcCACABIAMQJCACQQhqIgBB5YgBECIgAyAAKQIANwIAIAEgAxAkIAIkAgtnAQF/IwIhAiMCQRBqJAIgAEEQECYhACACIAEpAgA3AwAgAiACKQIANwIIIABBmC02AgAgAEEnOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBrD02AgAgACACKQIINwIIIAIkAiAAC5IBAQN/IwIhAiMCQTBqJAIgAkEYaiIEQZ2IARAiIAJBIGoiAyAEKQIANwIAIAEgAxAkIAIgACkCEDcDACADIAIpAgA3AgAgASADECQgAkEQaiIEQaWIARAiIAMgBCkCADcCACABIAMQJCAAQQhqIAEQQCACQQhqIgBBt+4AECIgAyAAKQIANwIAIAEgAxAkIAIkAgtCACAAQZgtNgIAIABBKDoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQYA9NgIAIAAgASkCADcCCCAAIAIpAgA3AhALWAEBfyMCIQMjAkEgaiQCIABBGBAmIQAgAyABKQIANwMIIAMgAikCADcDACADQRBqIgEgAykCCDcCACADQRhqIgIgAykCADcCACAAIAEgAhClAyADJAIgAAsZACABQdsAEDUgAEEIaiABEEAgAUHdABA1C2cBAX8jAiECIwJBEGokAiAAQRAQJiEAIAIgASkCADcDACACIAIpAgA3AgggAEGYLTYCACAAQSk6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHUPDYCACAAIAIpAgg3AgggAiQCIAAL5wIBBn8jAiEBIwJBMGokAiABQRhqIQUgAUEIaiEDIAFBEGohBCABQSBqQZSIARAiIAFBKGoiAiABKQIgNwIAIAAgAhAqBEAgAiAAQQAQPSAAQd8AECcEfyAAQfACaiACEKMDBUEACyEABSAFQZeIARAiIAIgBSkCADcCACAAIAIQKgRAIAFBADYCACABQQA2AgQgAyAAQeoCajYCACADIAAsAOoCOgAEIANBAToABSAAQQE6AOoCIARBmogBECIgAiAEKQIANwIAAn8CQCAAIAIQKg0AIABBCGoiBSIEKAIEIAQoAgBrQQJ1IQQCQANAIAIgABAuIgY2AgAgBkUNASAFIAIQMiAAQcUAECdFDQALIAEgACAEEDwMAQtBAAwBCyACIABBABA9IABB3wAQJwR/IABB8AJqIAEgAhCmAwVBAAsLIQAgAywABQRAIAMoAgAgAywABDoAAAsFQQAhAAsLIAEkAiAACzkBAn8jAiECIwJBEGokAiACQZyHARAiIAJBCGoiAyACKQIANwIAIAEgAxAkIAAoAgggARArIAIkAgtKAQF/IABBDBAmIgIhACABKAIAIQEgAEGYLTYCACAAQSI6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGoPDYCACAAIAE2AgggAguDAQEDfyMCIQIjAkEgaiQCIAJBCGpBlYcBECIgAkEQ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AgA3AwAgAygCACECIAQoAgAhAyAFQQhqIgQgBSkCADcCACAAIAEgBCACIAMQvAMgBSQCIAALnwIBBX8jAiEDIwJBQGskAiADQTBqIQQgA0E4aiICQYbvABAiIABBDGoiBiACEKEBBEAgBEG77gAQIiACIAQpAgA3AgAgASACECQLIANBCGohBCADQShqIgVBu+4AECIgAiAFKQIANwIAIAEgAhAkIAAoAgggARArIANBIGoiBUGChAEQIiACIAUpAgA3AgAgASACECQgAyAGKQIANwMAIAIgAykCADcCACABIAIQJCADQRhqIgVBhYQBECIgAiAFKQIANwIAIAEgAhAkIAAoAhQgARArIANBEGoiAEG37gAQIiACIAApAgA3AgAgASACECQgAkGG7wAQIiAGIAIQoQEEQCAEQbfuABAiIAIgBCkCADcCACABIAIQJAsgAyQCC0YAIABBmC02AgAgAEEqOgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBzDo2AgAgACABNgIIIAAgAikCADcCDCAAIAM2AhQLTwEBfyMCIQQjAkEQaiQCIABBGBAmIQAgASgCACEBIAQgAikCADcDACADKAIAIQIgBEEIaiIDIAQpAgA3AgAgACABIAMgAhC/AyAEJAIgAAt1AQN/IwIhAiMCQSBqJAIgAiAAKQIINwMAIAJBGGoiAyACKQIANwIAIAEgAxAkIAJBEGoiBEG77gAQIiADIAQpAgA3AgAgASADECQgACgCECABECsgAkEIaiIAQbfuABAiIAMgACkCADcCACABIAMQJCACJAILPwAgAEGYLTYCACAAQTU6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGgOjYCACAAIAEpAgA3AgggACACNgIQC0YBAX8jAiEDIwJBEGokAiAAQRQQJiEAIAMgASkCADcDACACKAIAIQEgA0EIaiICIAMpAgA3AgAgACACIAEQwgMgAyQCIAALTAECfyMCIQMjAkEQaiQCIABBGBAmIQAgA0HIgwEQIiABKAIAIQEgAigCACECIANBCGoiBCADKQIANwIAIAAgBCABIAIQeyADJAIgAAtfAQN/IwIhAiMCQSBqJAIgACgCCCABECsgAkEIaiIEQbvuABAiIAJBEGoiAyAEKQIANwIAIAEgAxAkIABBDGogARBAIAJBt+4AECIgAyACKQIANwIAIAEgAxAkIAIkAgs/ACAAQZgtNgIAIABBMjoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQfQ5NgIAIAAgATYCCCAAIAIpAgA3AgwLRgEBfyMCIQMjAkEQaiQCIABBFBAmIQAgASgCACEBIAMgAikCADcDACADQQhqIgIgAykCADcCACAAIAEgAhDGAyADJAIgAAt8AQN/IwIhAiMCQSBqJAIgAkEQaiIEQbvuABAiIAJBGGoiAyAEKQIANwIAIAEgAxAkIAAoAgggARArIAJBCGoiBEHmggEQIiADIAQpAgA3AgAgASADECQgAEEMaiABEEAgAkG37gAQIiADIAIpAgA3AgAgASADECQgAiQCCz8AIABBmC02AgAgAEE3OgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABByDk2AgAgACABNgIIIAAgAikCADcCDAuHAQEDfyMCIQIjAkEgaiQCIAJBGGohAyACQRBqIQQgACwADARAIARBjfwAECIgAyAEKQIANwIAIAEgAxAkCyACQQhqIgRBqYIBECIgAyAEKQIANwIAIAEgAxAkIAAsAA0EQCACQbCCARAiIAMgAikCADcCACABIAMQJAsgACgCCCABECsgAiQCC0kAIABBmC02AgAgAEE0OgAEIABBAToABSAAQQE6AAYgAEEBOgAHIABBnDk2AgAgACABNgIIIAAgAkEBcToADCAAIANBAXE6AA0LJAAgAEEQECYiACABKAIAIAIsAABBAEcgAywAAEEARxDLAyAAC0wBAn8jAiEDIwJBEGokAiAAQRgQJiEAIANBnIIBECIgASgCACEBIAIoAgAhAiADQQhqIgQgAykCADcCACAAIAQgASACEHsgAyQCIAALPAAgAEGYLTYCACAAQRY6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHwODYCACAAIAE2AgggACACNgIMC1ABAn8jAiECIwJBEGokAiACQZj0ABAiIAJBCGoiAyACKQIANwIAIAEgAxAkIAAoAggiACgCACgCECEDIAAgASADQf8AcUHaAmoRBAAgAiQCC0oBAX8gAEEMECYiAiEAIAEoAgAhASAAQZgtNgIAIABBJjoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQcQ4NgIAIAAgATYCCCACCzkBAn8jAiECIwJBEGok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IQILIAsgAigCACICNgIAIAINACAGCwUgAEHwAGohByAAQfwAaiEIIABB+ABqCyEDIAkgACgCdDYCICAJIAc2AhwgAygCACECIAUgCSgCIDYCACAKIAkoAhw2AgAgBSAKIAIgCRC2ARogCCgCACICBEADQCACKAJoIgZB5ABqIAggBhsgAigCZCIMNgIAIAwEQCAMIAY2AmgLIAJBADYCZCACQQA2AmggACACEMsBIAgoAgAiAg0ACwsgAygCAARAIAAoAnQiAigCACIIIAAoAnAiBigCBDYCBCAGKAIEIAg2AgAgA0EANgIAIAIgB0cEQANAIAIoAgQhAyACECMgAyAHRwRAIAMhAgwBCwsLCyALIAQoAgAiAjYCACACRQRAIAkkAg8LIABByABqIQgDQCABIAIpAyhRBEAgAigCWARAAkAgAigCTEF/SgR/IAAgAiACQSBqEC8FQQALIQcgACALEGcgCygCACICKAJgIQMgAigCXCEEIAMEQCADKQMQIg4gAikDAFEEQCAHQQBHIAMpAxgiECACKQMIUXEEQCADKAJMQX9KBEAgECADKQMoIhNVBEACQCACKQMQIRIgAikDICERIAIpAxggAikDKH0hDyAOIAMpAyB9IQ4gACwAFARAQgAgD30gDyAPQgBTGyIUQiCIIRVCACAOfSAOIA5CAFMbIhdCIIghFiASIBF9IhJCP4inIBAgE30iEEI/iKdGIQZCACASfSASIBJCAFMbIhhCIIghEkIAIBB9IBAgEEIAUxsiGUIgiCETIBRC/////w+DIhAgF0L/////D4MiEX4iFCARIBV+IBAgFn58IhFCIIZ8IhAgFFStIBUgFn4gEUIgiHx8IhFCACARfSARQn+FIBBCAFEbIA9CP4inIA5CP4inRiIMGyAYQv////8PgyIPIBlC/////w+DIg5+IhEgDiASfiAPIBN+fCIOQiCGfCIPIBFUrSASIBN+IA5CIIh8fCIOQgAgDn0gDkJ/hSAPQgBRGyAGG1EEfyAPQgAgD30gBhsgEEIAIBB9IAwbUQVBAAtFDQEFIA4gD34gEiARfSAQIBN9flINAQsgAkFAaygCAARAIANBQGsoAgAEQCAAIAMgAhAvIQQgBSACKQMgNwMAIAUgAikDKDcDCCAKQRgQJSIDNgIAIAMgBzYCACADIAQ2AgQgAyAFKQMANwMIIAMgBSkDCDcDECAAKAJMIgQgACgCUEYEQCAIIAoQNAUgBCADNgIAIAAgACgCTEEEajYCTAsMCAsLCwsLCwsLIAQEQCAEKQMQIg4gAikDAFEEQCAHQQBHIAQpAxgiECACKQMIUXEEQCAEKAJMQX9KBEAgECAEKQMoIhNVBEAgAikDECESIAIpAyAhESACKQMYIAIpAyh9IQ8gDiAEKQMgfSEOIAAsABQEQEIAIA99IA8gD0IAUxsiFEIgiCEVQgAgDn0gDiAOQgBTGyIXQiCIIRYgEiARfSISQj+IpyAQIBN9IhBCP4inRiEDQgAgEn0gEiASQgBTGyIYQiCIIRJCACAQfSAQIBBCAFMbIhlCIIghEyAUQv////8PgyIQIBdC/////w+DIhF+IhQgESAVfiAQIBZ+fCIRQiCGfCIQIBRUrSAVIBZ+IBFCIIh8fCIRQgAgEX0gEUJ/hSAQQgBRGyAPQj+IpyAOQj+Ip0YiBhsgGEL/////D4MiDyAZQv////8PgyIOfiIRIA4gEn4gDyATfnwiDkIghnwiDyARVK0gEiATfiAOQiCIfHwiDkIAIA59IA5Cf4UgD0IAURsgAxtRBH8gD0IAIA99IAMbIBBCACAQfSAGG1EFQQALRQ0GBSAOIA9+IBIgEX0gECATfX5SDQYLIAJBQGsoAgAEQCAEQUBrKAIABEAgACAEIAIQLyEEIAUgAikDIDcDACAFIAIpAyg3AwggCkEYECUiAzYCACADIAc2AgAgAyAENgIEIAMgBSkDADcDCCADIAUpAwg3AxAgACgCTCIEIAAoAlBGBEAgCCAKEDQFIAQgAzYCACAAIAAoAkxBBGo2AkwLCwsLCwsLCwsLCyALIAIoAlwiAjYCACACDQALIAkkAgs/AQF/IwIhAiMCQRBqJAIgAEEUECYhACACIAEpAgA3AwAgAkEIaiIBIAIpAgA3AgAgAEEAIAEQ3wEgAiQCIAALPwAgAEGYLTYCACAAQSw6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEG4NTYCACAAIAE2AgggACACKQIANwIMC0IBAX8jAiEDIwJBEGokAiAAQRQQJiEAIAEoAgAhASADIAIQIiADQQhqIgIgAykCADcCACAAIAEgAhDqAyADJAIgAAutAgEFfyMCIQMjAkFAayQCIANBOGohAiADQTBqIQQgACwAHARAIARB8/gAECIgAiAEKQIANwIAIAEgAhAkCyADQSBqIQQgA0EoakH/+AAQIiACIAMpAig3AgAgASACECQgACwAHQRAIARBg/kAECIgAiAEKQIANwIAIAEgAhAkCyADQRhqIQQgA0EQaiEFIAFBIBA1IABBCGoiBigCBARAIARBu+4AECIgAiAEKQIANwIAIAEgAhAkIAYgARBAIAVBt+4AECIgAiAFKQIANwIAIAEgAhAkCyADQQhqIQQgACgCECABECsgAEEUaiIAKAIEBEAgBEG77gAQIiACIAQpAgA3AgAgASACECQgACABEEAgA0G37gAQIiACIAMpAgA3AgAgASACECQLIAMkAgtdACAAQZgtNgIAIABBMzoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQYw1NgIAIAAgASkCADcCCCAAIAI2AhAgACADKQIANwIUIAAgBEEBcToAHCAAIAVBAXE6AB0LYAEDfyMCIQIjAkEgaiQCIABBHBAmIQAgAkEIakHf+AAQIiABKAIAIQEgAkG37gAQIiACQRBqIgMgAikCCDcCACACQRhqIgQgAikCADcCACAAIAMgASAEEJ8BIAIkAiAAC6IBAQN/IwIhAiMCQTBqJAIgAkEYaiIEQbvuABAiIAJBIGoiAyAEKQIANwIAIAEgAxAkIAAoAgggARArIAJBEGoiBEGf+AAQIiADIAQpAgA3AgAgASADECQgACgCDCABECsgAkEIaiIEQaX4ABAiIAMgBCkCADcCACABIAMQJCAAKAIQIAEQKyACQbfuABAiIAMgAikCADcCACABIAMQJCACJAILQwAgAEGYLTYCACAAQS06AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHgNDYCACAAIAE2AgggACACNgIMIAAgAzYCEAvDAQECfyAAKAI0RQRAQQEPCyAAIAEQ9AICQAJAAkAgACgCZCIDIAAoAmAiAmtBAnUOAgACAQtBAQ8LIAAQ6wIEfyAAKAJkIQMgACgCYAVBAA8LIQILIAIgA0cEQEEAIQMDQCAAIANBAnQgAmooAgAiAigCACACKAIEIAJBCGoQYSAAIAIoAgAgAigCBBCiASACBEAgAhAjCyADQQFqIgMgACgCZCAAKAJgIgJrQQJ1SQ0ACwsgACACNgJkIABBADYCfEEBC0wBAn8jAiEDIwJBEGokAiAAQRgQJiEAIANBjvgAECIgASgCACEBIAIoAgAhAiADQQhqIgQgAykCADcCACAAIAQgASACEHsgAyQCIAALyQEBBH8jAiECIwJBMGokAiACIAApAgg3AwAgAkEgaiIDIAIpAgA3AgAgASADECQgAkEYaiIEQfHvABAiIAMgBCkCADcCACABIAMQJCAAKAIQIgQoAgAoAhAhBSAEIAEgBUH/AHFB2gJqEQQAIAJBEGoiBEHf9wAQIiADIAQpAgA3AgAgASADECQgACgCFCIAKAIAKAIQIQQgACABIARB/wBxQdoCahEEACACQQhqIgBBt+4AECIgAyAAKQIANwIAIAEgAxAkIAIkAgtMAQJ/IwIhAyMCQRBqJAIgAEEYECYhACADQdP3ABAiIAEoAgAhASACKAIAIQIgA0EIaiIEIAMpAgA3AgAgACAEIAEgAhB7IAMkAiAAC14BAn8jAiEDIwJBIGokAiAAQRwQJiEAIANBCGogARAiIAIoAgAhASADQbfuABAiIANBEGoiAiADKQIINwIAIANBGGoiBCADKQIANwIAIAAgAiABIAQQnwEgAyQCIAALYwEDfyMCIQIjAkEwaiQCIAJBGGoiA0HV9gAQIiACQSBqIgQgAykCADcCACABIAQQJCACQQhqIgMgACgCCBCeASADIAEQ3QEgAkG37gAQIiAEIAIpAgA3AgAgASAEECQgAiQCC0oBAX8gAEEMECYiAiEAIAEoAgAhASAAQZgtNgIAIABBMToABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQdwzNgIAIAAgATYCCCACC1UBAn8jAiECIwJBIGokAiACIAApAgg3AwggAkEQaiIDIAIpAgg3AgAgASADECQgACgCECABECsgAiAAKQIUNwMAIAMgAikCADcCACABIAMQJCACJAILYAEDfyMCIQIjAkEgaiQCIABBHBAmIQAgAkEIakGX9gAQIiABKAIAIQEgAkG37gAQIiACQRBqIgMgAikCCDcCACACQRhqIgQgAikCADcCACAAIAMgASAEEJ8BIAIkAiAAC2cBAX8jAiECIwJBEGokAiAAQRAQJiEAIAIgASkCADcDACACIAIpAgA3AgggAEGYLTYCACAAQQA6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEGEMzYCACAAIAIpAgg3AgggAiQC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BCADQbeEARAiIAEgAykCADcCAAJAAkAgACABECoEQCABQb/uABAiDAEFAkAgBEG6hAEQIiABIAQpAgA3AgAgACABECoEQCABQb3uABAiDAMLIAhBvYQBECIgASAIKQIANwIAIAAgARAqBEAgAUGH9AAQIgwDCyAJQcCEARAiIAEgCSkCADcCACAAIAEQKgRAIAFBivQAECIMAwsgCkHDhAEQIiABIAopAgA3AgAgACABECoEQCABQZb0ABAiDAMLIAtBxoQBECIgASALKQIANwIAIAAgARAqBEAgAUGa9AAQIgwDCyAMQcmEARAiIAEgDCkCADcCACAAIAEQKgRAIAFBnfQAECIMAwsgDUHMhAEQIiABIA0pAgA3AgAgACABECoEQCABQZ/0ABAiDAMLIA5Bz4QBECIgASAOKQIANwIAIAAgARAqBEAgAUGi9AAQIgwDCyAPQdKEARAiIAEgDykCADcCACAAIAEQKgRAIAFBpPQAECIMAwsgEEHVhAEQIiABIBApAgA3AgAgACABECoEQCABQaf0ABAiDAMLIBFB2IQBECIgASARKQIANwIAIAAgARAqBEAgAUGq9AAQIgwDCyASQduEARAiIAEgEikCADcCACAAIAEQKgRAIAFBhu8AECIMAwsgE0HehAEQIiABIBMpAgA3AgAgACABECoEQCABQa30ABAiDAMLIBRB4YQBECIgASAUKQIANwIAIAAgARAqBEAgAUGw9AAQIgwDCyAVQeSEARAiIAEgFSkCADcCACAAIAEQKgRAIAFBs/QAECIMAwsgFkHnhAEQIiABIBYpAgA3AgAgACABECoEQCABQfHvABAiDAMLIBdB6oQBECIgASAXKQIANwIAIAAgARAqBEAgAUGW8wAQIgwDCyAYQe2EARAiIAEgGCkCADcCACAAIAEQKgRAIAFBt/QAECIMAwsgGUHwhAEQIiABIBkpAgA3AgAgACABECoEQCABQYDvABAiDAMLIBpB84QBECIgASAaKQIANwIAIAAgARAqBEAgAUG69AAQIgwDCyAbQfaEARAiIAEgGykCADcCACAAIAEQKgRAIAFBwPQAECIMAwsgHEH5hAEQIiABIBwpAgA3AgAgACABECoEQCABQcX0ABAiDAMLIB1B/IQBECIgASAdKQIANwIAIAAgARAqBEAgAUHI9AAQIgwDCyAeQf+E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JAIgAAuYAQEDfyMCIQIjAkEgaiQCIAJBCGohBCACQRBqQfHvABAiIAJBGGoiAyACKQIQNwIAIAEgAxAkIABBCGogARBAIAEoAgQiAAR/IAEoAgAgAEF/amosAAAFQQALQf8BcUE+RgRAIARBue4AECIgAyAEKQIANwIAIAEgAxAkCyACQYbvABAiIAMgAikCADcCACABIAMQJCACJAILZwEBfyMCIQIjAkEQaiQCIABBEBAmIQAgAiABKQIANwMAIAIgAikCADcCCCAAQZgtNgIAIABBHjoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQaAvNgIAIAAgAikCCDcCCCACJAIgAAuhAgECfyAAKAIAIABBDGpGIQIgASgCACABQQxqRgRAIAJFBEAgACgCABAjIAAgAEEMaiICNgIAIAAgAjYCBCAAIABBLGo2AggLIAEoAgQgASgCACICayIDBEAgACgCACACIAMQVBoLIAAgACgCACABKAIEIAEoAgBrQQJ1QQJ0ajYCBCABIAEoAgA2AgQFIAIEQCAAIAEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCABIAFBDGoiADYCACABIAA2AgQgASABQSxqNgIIBSAAKAIAIQIgACABKAIANgIAIAEgAjYCACAAKAIEIQIgACABKAIENgIEIAEgAjYCBCAAKAIIIQIgACABKAIINgIIIAEgAjYCCCABIAEoAgA2AgQLCwuvAQECfyAAIABBDGoiAjYCACAAIAI2AgQgACAAQSxqNgIIIAEoAgAgAUEMakYEQCABKAIEIAEoAgAiAmsiAwRAIAAoAgAgAiADEFQaCyAAIAAoAgAgASgCBCABKAIAa0ECdUECdGo2AgQgASABKAIANgIEBSAAIAEoAgA2AgAgACABKAIENgIEIAAgASgCCDYCCCABIAFBDGoiADYCACABIAA2AgQgASABQSxqNgIICwsUACAAKAIIIAEQKyAAKAIMIAEQKws8ACAAQZgtNgIAIABBIDoABCAAQQE6AAUgAEEBOgAGIABBAToAByAAQfQuNgIAIAAgATYCCCAAIAI2AgwLlgEBA38jAiEDIwJBEGokAiADQQhqIQQCQAJAIAAoAggiAi0ABEEKRw0AIAIQ6wFFBEAgACgCCCECDAELDAELAkACQCACIAEQRg0AIAAoAgggARBLDQAMAQsgA0G37gAQIiAEIAMpAgA3AgAgASAEECQLIAAoAggiACgCACgCFCECIAAgASACQf8AcUHaAmoRBAALIAMkAgvAAgEIfyMCIQMjAkFAayQCIANBMGohAiADQShqIQUgA0EgaiEGIANBGGohByADQRBqIQggA0EIaiEJAkACQCAAKAIIIgQtAARBCkcNACAEEOsBBEAgACgCCCEAIAhBgu8AECIgAiAIKQIANwIAIAEgAhAkIAMgACkCDDcDACACIAMpAgA3AgAgASACECQgCUGG7wAQIiACIAkpAgA3AgAgASACECQFIAAoAgghBAwBCwwBCyAEIAEgBCgCACgCEEH/AHFB2gJqEQQAIAAoAgggARBGBEAgBUG57gAQIiACIAUpAgA3AgAgASACECQLAkACQCAAKAIIIAEQRg0AIAAoAgggARBLDQAMAQsgBkG77gAQIiACIAYpAgA3AgAgASACECQLIAdBgO8AECIgAiAHKQIANwIAIAEgAhAkCyADJAILUQEDfyAAQQwQJiIDIgIhACABKAIAIgEsAAUhBCAAQZgtNgIAIABBCzoABCAAIAQ6AAUgAEEBOgAGIABBAToAByACQcguNgIAIAIgATYCCCADCw4AIAAgASACIAMgAxBKC78BAQV/IwIhAiMCQSBqJAIgAkEYaiEFIAJBEGohAyACQQhqIQYgAEEQaiIELAAARQRAIAMgBDYCACADIAQsAAA6AAQgA0EBOgAFIARBAToAACAGIAAgARDsAQJAAkAgBigCBCIAIAEQRg0AIAAgARBLDQAMAQsgAkG37gAQIiAFIAIpAgA3AgAgASAFECQLIAAgASAAKAIAKAIUQf8AcUHaAmoRBAAgAywABQRAIAMoAgAgAywABDoAAAsLIAIkAguUAgEHfyMCIQIjAkEwaiQCIAJBKGohAyACQRhqIQQgAkEIaiEGIAJBIGohByACQRBqIQggAEEQaiIFLAAARQRAIAQgBTYCACAEIAUsAAA6AAQgBEEBOgAFIAVBAToAACAGIAAgARDsASAGKAIEIgAoAgAoAhAhBSAAIAEgBUH/AHFB2gJqEQQAIAAgARBGBEAgB0G57gAQIiADIAcpAgA3AgAgASADECQLAkACQCAAIAEQRg0AIAAgARBLDQAMAQsgCEG77gAQIiADIAgpAgA3AgAgASADECQLIAJBv+4AQb3uACAGKAIAGxAiIAMgAikCADcCACABIAMQJCAELAAFBEAgBCgCACAELAAEOgAACwsgAiQCC0wBAX8gASwABSEDIABBmC02AgAgAEEMOgAEIAAgAzoABSAAQQE6AAYgAEEBOgAHIABBnC42AgAgACABNgIIIAAgAjYCDCAAQQA6ABALRAECfyMCIQIjAkEQaiQCIABBFBAmIQAgASgCACEBIAJBru4AECIgAkEIaiIDIAIpAgA3AgAgACABIAMQ7gEgAiQCIAALUgEDfyMCIQIjAkEQaiQCIAAoAggiAygCACgCECEEIAMgASAEQf8AcUHaAmoRBAAgAiAAKQIMNwMAIAJBCGoiACACKQIANwIAIAEgABAkIAIkAgtEAQJ/IwIhAiMCQRBqJAIgAEEUECYhACABKAIAIQEgAkHq7QAQIiACQQhqIgMgAikCADcCACAAIAEgAxDuASACJAIgAAtfAAJAAkACQAJAAkACQAJAIAEoAggOBgABAgMEBQYLIABBpuwAECIMBQsgAEGw7AAQIgwECyAAQb3sABAiDAMLIABBxOwAECIMAgsgAEHM7AAQIgwBCyAAQdTsABAiCwv6AQEHfyMCIQMjAkFAayQCIANBMGohAiADQShqIQQgA0EgaiEFIANBGGohBiADQRBqIQcgA0EIaiEIAkACQAJAAkACQAJAAkAgACgCCA4GAAECAwQFBgsgBEHd7AAQIiACIAQpAgA3AgAgASACECQMBQsgBUHs7AAQIiACIAUpAgA3AgAgASACECQMBAsgBkH+7AAQIiACIAYpAgA3AgAgASACECQMAwsgB0GK7QAQIiACIAcpAgA3AgAgASACECQMAgsgCEGX7QAQIiACIAgpAgA3AgAgASACECQMAQsgA0Gk7QAQIiACIAMpAgA3AgAgASACECQLIAMkAgtKAQF/IABBDBAmIgIhACABKAIAIQEgAEGYLTYCACAAQSQ6AAQgAEEBOgAFIABBAToABiAAQQE6AAcgAEHELTYCACAAIAE2AgggAgsvAQF/QYAgEEIiAQRAIAEgAEGAIGoiACgCADYCACABQQA2AgQgACABNgIABRBqCws6ACABQQhqEEIiAQRAIAEgAEGAIGooAgAiACgCADYCACABQQA2AgQgACABNgIAIAFBCGoPBRBqC0EACwQAEBoLEAAgAEEANgIAIABB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QQF1aiEAIAFBAXEEQCAFIAAoAgBqKAIAIQULIAQgAzYCACAAIAIgBCAFQR9xQeoDahEJACAEJAILVgECfyMCIQMjAkEQaiQCIAAoAgAhBCABIAAoAgQiAUEBdWohACABQQFxBEAgBCAAKAIAaigCACEECyADIAI2AgAgACADIARB/wBxQdoCahEEACADJAILBQBBiBYLwgIBBX8gACgCCCIEIAAoAgQiA2tBAnUgAU8EQANAIAMgAigCADYCACAAIAAoAgRBBGoiAzYCBCABQX9qIgENAAsPCyABIAMgACgCACIDa0ECdSIFaiIGQf////8DSwRAEAELIAYgBCADayIDQQF1IgQgBCAGSRtB/////wMgA0ECdUH/////AUkbIgQEQCAEQf////8DSwRAQQgQBiIDEEMgA0GwxAA2AgAgA0HQJEHXABAEBSAEQQJ0ECUhBwsLIAVBAnQgB2oiBSEDA0AgAyACKAIANgIAIANBBGohAyABQX9qIgENAAtBACAAKAIEIAAoAgAiAWsiAkECdWtBAnQgBWohAyACQQBKBEAgAyABIAIQLRoLIAAgAzYCACAAIAZBAnQgB2o2AgQgACAEQQJ0IAdqNgIIIAFFBEAPCyABECMLFwAgACgCACABQQJ0aiACKAIANgIAQQELUQEBfyMCIQMjAkEQaiQCIAEoAgQgASgCACIBa0ECdSACTQRAIABBATYCACADJAIPCyADIAJBAnQgAWooAgA2AgAgAEHQFSADEA02AgAgAyQCCz8BAn8gACgCBCAAKAIAIgRrQQJ1IgMgAUkEQCAAIAEgA2sgAhCNBQ8LIAMgAU0EQA8LIAAgAUECdCAEajYCBAvUAgEGfyAAKAIAIgQhByACIAEiBWsiBkECdSIDIAAoAggiASAEa0ECdU0EQCADIAAoAgQgBGtBAnUiA0shASADQQJ0IAVqIAIgARsiBiIIIAVrIgMEQCAEIAUgAxBUGgsgA0ECdSEFIAFFBEAgACAFQQJ0IAdqNgIEDwsgAiAIayIBQQBMBEAPCyAAKAIEIAYgARAtGiAAIAAoAgQgAUECdkECdGo2AgQPCyAEBEAgACAENgIEIAQQIyAAQQA2AgggAEEANgIEIABBADYCAEEAIQELIANB/////wNLBEAQAQsgAyABQQF1IgIgAiADSRtB/////wMgAUECdUH/////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AAABAAAAAgAAAAMAAAAEAAAAAQAAAAIAAAADAAAAEgAAABMAAAAAAAAAGA4AAAEAAAACAAAAAwAAAAQAAAABAAAAAgAAAAMAAAASAAAAFAAAAAAAAAAgDgAAAQAAAAIAAAADAAAABAAAAAQAAAACAAAABQAAABIAAAAVAAAAAAAAADAOAAABAAAAAgAAAAMAAAAEAAAABgAAAAIAAAADAAAAEgAAABYAAAAAAAAAQA4AAAUAAAACAAAAAwAAAAQAAAAHAAAACAAAAAMAAAASAAAAFwAAAAAAAABQDgAABgAAAAIAAAADAAAABAAAAAkAAAAKAAAAAwAAABIAAAAYAAAAAAAAAGAOAAABAAAAAgAAAAMAAAAEAAAACwAAAAIAAAAMAAAAEgAAABkAAAAAAAAAcA4AAAEAAAACAAAAAwAAAAQAAAANAAAAAgAAAAMAAAASAAAAGgAAAAAAAACADgAABwAAAAgAAAAJAAAACgAAAA4AAAAPAAAAAwAAABIAAAAbAAAAAAAAAJAOAAABAAAAAgAAAAMAAAAEAAAAEAAAAAIAAAADAAAAEgAAABwAAAAAAAAAoA4AAAEAAAACAAAAAwAAAAQAAAARAAAAAgAAAAMAAAASAAAAHQAAAAAAAACwDgAAAQAAAAIAAAADAAAABAAAABIAAAACAAAAAwAAABIAAAAeAAAAAAAAAMAOAAABAAAAAgAAAAMAAAAEAAAAEwAAAAIAAAADAAAAEgAAAB8AAAAAAAAA0A4AAAEAAAACAAAAAwAAAAQAAAAUAAAAAgAAAAMAAAASAAAAIAAAAAAAAADgDgAAAQAAAAIAAAADAAAABAAAABUAAAACAAAAAwAAABIAAAAhAAAAAAAAAPAOAAABAAAAAgAAAAMAAAAEAAAAFgAAAAIAAAADAAAAEgAAACIAQakyC7gFDwAAAQAAAAIAAAADAAAABAAAABcAAAACAAAAAwAAABIAAAAjAAAAAAAAABAPAAABAAAAAgAAAAMAAAAEAAAAGAAAAAIAAAADAAAAEgAAACQAAAAAAAAAIA8AAAEAAAACAAAAAwAAAAQAAAAZAAAAAgAAAAMAAAASAAAAJQAAAAAAAAAwDwAAAQAAAAIAAAADAAAABAAAABoAAAACAAAAAwAAABIAAAAmAAAAAAAAAEAPAAABAAAAAgAAAAMAAAAEAAAAGwAAAAIAAAADAAAAEgAAACcAAAAAAAAAUA8AAAEAAAACAAAAAwAAAAQAAAAcAAAAAgAAAAMAAAASAAAAKAAAAAAAAABgDwAAAQAAAAIAAAADAAAABAAAAB0AAAACAAAAAwAAABIAAAApAAAAAAAAAHAPAAABAAAAAgAAAAMAAAAEAAAAHgAAAAIAAAADAAAAEgAAACoAAAAAAAAAgA8AAAEAAAACAAAAAwAAAAQAAAAfAAAAAgAAAAMAAAASAAAAKwAAAAAAAACQDwAAAQAAAAIAAAADAAAABAAAACAAAAACAAAAAwAAABIAAAAsAAAAAAAAAKAPAAABAAAAAgAAAAMAAAAEAAAAIQAAAAIAAAADAAAAEgAAAC0AAAAAAAAAsA8AAAEAAAACAAAAAwAAAAQAAAAiAAAAAgAAAAMAAAASAAAALgAAAAAAAADADwAAAQAAAAIAAAADAAAABAAAACMAAAACAAAAJAAAABIAAAAvAAAAAAAAANAPAAABAAAAAgAAAAMAAAAEAAAAJQAAAAIAAAADAAAAEgAAADAAAAAAAAAA4A8AAAEAAAACAAAAAwAAAAQAAAAmAAAAAgAAAAMAAAASAAAAMQAAAAAAAADwDwAAAQAAAAIAAAADAAAABAAAACcAAAACAAAAKAAAABIAAAAyAEHpNwu4BRAAAAEAAAACAAAAAwAAAAQAAAApAAAAAgAAAAMAAAASAAAAMwAAAAAAAAAQEAAAAQAAAAIAAAADAAAABAAAACoAAAACAAAAAwAAABIAAAA0AAAAAAAAACAQAAABAAAAAgAAAAMAAAAEAAAAKwAAAAIAAAADAAAAEgAAADUAAAAAAAAAMBAAAAEAAAACAAAAAwAAAAQAAAAsAAAAAgAAAC0AAAASAAAANgAAAAAAAABAEAAAAQAAAAIAAAADAAAABAAAAC4AAAACAAAAAwAAABIAAAA3AAAAAAAAAFAQAAABAAAAAgAAAAMAAAAEAAAALwAAAAIAAAADAAAAEgAAADgAAAAAAAAAYBAAAAEAAAACAAAAAwAAAAQAAAAwAAAAAgAAAAMAAAASAAAAOQAAAAAAAABwEAAAAQAAAAIAAAADAAAABAAAADEAAAACAAAAAwAAABIAAAA6AAAAAAAAAIAQAAABAAAAAgAAAAMAAAAEAAAAMgAAAAIAAAADAAAAEgAAADsAAAAAAAAAkBAAAAEAAAACAAAAAwAAAAQAAAAzAAAAAgAAAAMAAAASAAAAPAAAAAAAAACgEAAAAQAAAAIAAAADAAAABAAAADQAAAACAAAAAwAAABIAAAA9AAAAAAAAALAQAAALAAAADAAAAA0AAAAOAAAANQAAADYAAAADAAAAEgAAAD4AAAAAAAAAwBAAAAEAAAACAAAAAwAAAAQAAAA3AAAAAgAAAAMAAAASAAAAPwAAAAAAAADQEAAAAQAAAAIAAAADAAAABAAAADgAAAACAAAAOQAAABIAAABAAAAAAAAAAOAQAAABAAAAAgAAAAMAAAAEAAAAOgAAAAIAAAADAAAAEgAAAEEAAAAAAAAA8BAAAAEAAAACAAAAAwAAAAQAAAA7AAAAAgAAAAMAAAASAAAAQgBBqT0LuAURAAABAAAAAgAAAAMAAAAEAAAAPAAAAAIAAAADAAAAEgAAAEMAAAAAAAAAEBEAAAEAAAACAAAAAwAAAAQAAAA9AAAAAgAAAAMAAAASAAAARAAAAAAAAAAgEQAAAQAAAAIAAAADAAAABAAAAD4AAAACAAAAAwAAABIAAABFAAAAAAAAADARAAABAAAAAgAAAAMAAAAEAAAAPwAAAAIAAABAAAAAEgAAAEYAAAAAAAAAQBEAAAEAAAACAAAAAwAAAAQAAABBAAAAAgAAAEIAAAASAAAARwAAAAAAAABQEQAADwAAAAIAAAADAAAABAAAAEMAAABEAAAAAwAAABIAAABIAAAAAAAAAGARAAAQAAAAEQAAAAMAAAAEAAAARQAAAEYAAAADAAAAEgAAAEkAAAAAAAAAcBEAAAEAAAACAAAAAwAAAAQAAABHAAAAAgAAAAMAAAASAAAASgAAAAAAAACAEQAAAQAAAAIAAAADAAAABAAAAEgAAAACAAAAAwAAABIAAABLAAAAAAAAAJARAAASAAAAEwAAABQAAAAEAAAASQAAAEoAAAADAAAAEgAAAEwAAAAAAAAAoBEAAAEAAAACAAAAAwAAAAQAAABLAAAAAgAAAAMAAAASAAAATQAAAAAAAACwEQAAAQAAAAIAAAADAAAABAAAAEwAAAACAAAAAwAAABIAAABOAAAAAAAAAMARAAAVAAAAAgAAABYAAAAEAAAATQAAAE4AAAADAAAAEgAAAE8AAAAAAAAA0BEAAAEAAAACAAAAAwAAAAQAAABPAAAAAgAAAAMAAAASAAAAUAAAAAAAAADgEQAAAQAAAAIAAAADAAAABAAAAFAAAAACAAAAAwAAABIAAABRAAAAAAAAAPARAAABAAAAAgAAAAMAAAAEAAAAUQAAAAIAAAADAAAAEgAAAFIAQenCAAuYVhIAAAEAAAACAAAAAwAAAAQAAABSAAAAAgAAAAMAAAASAAAAUwAAAAAAAAAQEgAAFwAAAAIAAAAYAAAABAAAAFMAAABUAAAAAwAAABIAAABUAAAAAAAAACASAAABAAAAAgAAAAMAAAAEAAAAVQAAAAIAAAADAAAAEgAAAFUAAAAAAAAAMBIAAAEAAAACAAAAAwAAAAQAAABWAAAAAgAAAAMAAAASAAAAVgAAAAAAAABAEgAAVwAAAFgAAAAEAAAAAAAAAFASAABXAAAAWQAAAAQAAAAAAAAAoBIAAA0AAABaAAAADwAAABAAAAAEAAAAAAAAAHASAAANAAAAWwAAAA8AAAAQAAAABQAAAAAAAAAgEwAADQAAAFwAAAAPAAAAEAAAAAYAAAAAAAAAMBMAAA0AAABdAAAADwAAABAAAAADAAAAAwAAAAMAAAADAAAAQ29vcmRpbmF0ZSBvdXRzaWRlIGFsbG93ZWQgcmFuZ2UATjEwQ2xpcHBlckxpYjE2Y2xpcHBlckV4Y2VwdGlvbkUAQWRkUGF0aDogT3BlbiBwYXRocyBtdXN0IGJlIHN1YmplY3QuAFVwZGF0ZUVkZ2VJbnRvQUVMOiBpbnZhbGlkIGNhbGwARXJyb3I6IFBvbHlUcmVlIHN0cnVjdCBpcyBuZWVkZWQgZm9yIG9wZW4gcGF0aCBjbGlwcGluZy4ARG9NYXhpbWEgZXJyb3IAdG9QYXRoAHRvUGF0aHMAZnJvbVBhdGgAZnJvbVBhdGhzAENsaXBUeXBlAEludGVyc2VjdGlvbgBVbmlvbgBEaWZmZXJlbmNlAFhvcgBQb2x5VHlwZQBTdWJqZWN0AENsaXAAUG9seUZpbGxUeXBlAEV2ZW5PZGQATm9uWmVybwBQb3NpdGl2ZQBOZWdhdGl2ZQBJbnRQb2ludAB4AHkAbmV3SW50UG9pbnQAUGF0aABQYXRocwBJbml0T3B0aW9ucwBSZXZlcnNlU29sdXRpb24AU3RyaWN0bHlTaW1wbGUAUHJlc2VydmVDb2xsaW5lYXIASm9pblR5cGUAU3F1YXJlAFJvdW5kAE1pdGVyAEVuZFR5cGUAQ2xvc2VkUG9seWdvbgBDbG9zZWRMaW5lAE9wZW5CdXR0AE9wZW5TcXVhcmUAT3BlblJvdW5kAFBvbHlOb2RlAGNvbnRvdXIAY2hpbGRzAGdldFBhcmVudABnZXROZXh0AGlzSG9sZQBpc09wZW4AY2hpbGRDb3VudABQb2x5Tm9kZXMAUG9seVRyZWUAZ2V0Rmlyc3QAY2xlYXIAdG90YWwAb3JpZW50YXRpb24AYXJlYQBwb2ludEluUG9seWdvbgBzaW1wbGlmeVBvbHlnb24Ac2ltcGxpZnlQb2x5Z29uc0luT3V0AHNpbXBsaWZ5UG9seWdvbnNPdmVyd3JpdGUAY2xlYW5Qb2x5Z29uAGNsZWFuUG9seWdvbnMAbWlua293c2tpU3VtUGF0aABtaW5rb3dza2lTdW1QYXRocwBtaW5rb3dza2lEaWZmAHBvbHlUcmVlVG9QYXRocwBjbG9zZWRQYXRoc0Zyb21Qb2x5VHJlZQBvcGVuUGF0aHNGcm9tUG9seVRyZWUAcmV2ZXJzZVBhdGgAcmV2ZXJzZVBhdGhzAEludFJlY3QAbGVmdAB0b3AAcmlnaHQAYm90dG9tAENsaXBwZXJCYXNlAGFkZFBhdGgAYWRkUGF0aHMAZ2V0Qm91bmRzAHByZXNlcnZlQ29sbGluZWFyAENsaXBwZXIAZXhlY3V0ZVBhdGhzAGV4ZWN1dGVQYXRoc1dpdGhGaWxsVHlwZXMAZXhlY3V0ZVBvbHlUcmVlAGV4ZWN1dGVQb2x5VHJlZVdpdGhGaWxsVHlwZXMAcmV2ZXJzZVNvbHV0aW9uAHN0cmljdGx5U2ltcGxlAENsaXBwZXJPZmZzZXQAbWl0ZXJMaW1pdABhcmNUb2xlcmFuY2UATjEwQ2xpcHBlckxpYjExQ2xpcHBlckJhc2VFAE4xMENsaXBwZXJMaWI3Q2xpcHBlckUATjEwQ2xpcHBlckxpYjhQb2x5Tm9kZUUAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUATlN0M19fMjZ2ZWN0b3JJTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMyX0VFRUUATlN0M19fMjEzX192ZWN0b3JfYmFzZUlOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQBOU3QzX18yMjBfX3ZlY3Rvcl9iYXNlX2NvbW1vbklMYjFFRUUAdmlpaQBOU3QzX18yNnZlY3RvcklOUzBfSU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFTlMzX0lTNV9FRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJTlNfNnZlY3RvcklOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzNfRUVFRU5TNF9JUzZfRUVFRQBOMTBlbXNjcmlwdGVuM3ZhbEUAaWlpAE4xMENsaXBwZXJMaWI4Q2xpcFR5cGVFAE4xMENsaXBwZXJMaWI4UG9seVR5cGVFAE4xMENsaXBwZXJMaWIxMlBvbHlGaWxsVHlwZUUATjEwQ2xpcHBlckxpYjhJbnRQb2ludEUAUE4xMENsaXBwZXJMaWI4SW50UG9pbnRFAFBLTjEwQ2xpcHBlckxpYjhJbnRQb2ludEUAaWkAdgB2aQBkaWkAdmlpZABpaWRkAHB1c2hfYmFjawByZXNpemUAc2l6ZQBnZXQAc2V0AFBOU3QzX18yNnZlY3RvcklOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQBQS05TdDNfXzI2dmVjdG9ySU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAHZpaWlpAGlpaWkAaWlpaWkAUE5TdDNfXzI2dmVjdG9ySU5TMF9JTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMyX0VFRUVOUzNfSVM1X0VFRUUAUEtOU3QzX18yNnZlY3RvcklOUzBfSU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFTlMzX0lTNV9FRUVFAE4xMENsaXBwZXJMaWIxMUluaXRPcHRpb25zRQBOMTBDbGlwcGVyTGliOEpvaW5UeXBlRQBOMTBDbGlwcGVyTGliN0VuZFR5cGVFAFBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRQBQS04xMENsaXBwZXJMaWI4UG9seU5vZGVFAE5TdDNfXzI2dmVjdG9ySVBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBOU3QzX18yMTNfX3ZlY3Rvcl9iYXNlSVBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBQTlN0M19fMjZ2ZWN0b3JJUE4xMENsaXBwZXJMaWI4UG9seU5vZGVFTlNfOWFsbG9jYXRvcklTM19FRUVFAFBLTlN0M19fMjZ2ZWN0b3JJUE4xMENsaXBwZXJMaWI4UG9seU5vZGVFTlNfOWFsbG9jYXRvcklTM19FRUVFAE4xMENsaXBwZXJMaWI4UG9seVRyZWVFAFBOMTBDbGlwcGVyTGliOFBvbHlUcmVlRQBQS04xMENsaXBwZXJMaWI4UG9seVRyZWVFAHZpaQB2aWlpZAB2aWlpaWkATjEwQ2xpcHBlckxpYjdJbnRSZWN0RQBQTjEwQ2xpcHBlckxpYjdJbnRSZWN0RQBQS04xMENsaXBwZXJMaWI3SW50UmVjdEUAUE4xMENsaXBwZXJMaWIxMUNsaXBwZXJCYXNlRQBQS04xMENsaXBwZXJMaWIxMUNsaXBwZXJCYXNlRQBpaWlpaWkAUE4xMENsaXBwZXJMaWI3Q2xpcHBlckUAUEtOMTBDbGlwcGVyTGliN0NsaXBwZXJFAGlpaWlpaWkATjEwQ2xpcHBlckxpYjEzQ2xpcHBlck9mZnNldEUAUE4xMENsaXBwZXJMaWIxM0NsaXBwZXJPZmZzZXRFAFBLTjEwQ2xpcHBlckxpYjEzQ2xpcHBlck9mZnNldEUALSsgICAwWDB4AChudWxsKQAtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nIGRvdWJsZT4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQBOU3QzX18yMjFfX2Jhc2ljX3N0cmluZ19jb21tb25JTGIxRUVFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAHRlcm1pbmF0aW5nIHdpdGggJXMgZXhjZXB0aW9uIG9mIHR5cGUgJXM6ICVzAHRlcm1pbmF0aW5nIHdpdGggJXMgZXhjZXB0aW9uIG9mIHR5cGUgJXMAdGVybWluYXRpbmcgd2l0aCAlcyBmb3JlaWduIGV4Y2VwdGlvbgB0ZXJtaW5hdGluZwB1bmNhdWdodABTdDlleGNlcHRpb24ATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAU3Q5dHlwZV9pbmZvAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAdGVybWluYXRlX2hhbmRsZXIgdW5leHBlY3RlZGx5IHJldHVybmVkAF9aAF9fX1oAX2Jsb2NrX2ludm9rZQBpbnZvY2F0aW9uIGZ1bmN0aW9uIGZvciBibG9jayBpbiAAdm9pZABib29sAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBsb25nIGxvbmcAX19pbnQxMjgAdW5zaWduZWQgX19pbnQxMjgAZmxvYXQAbG9uZyBkb3VibGUAX19mbG9hdDEyOAAuLi4AZGVjaW1hbDY0AGRlY2ltYWwxMjgAZGVjaW1hbDMyAGRlY2ltYWwxNgBjaGFyMzJfdABjaGFyMTZfdABhdXRvAGRlY2x0eXBlKGF1dG8pAHN0ZDo6bnVsbHB0cl90AFthYmk6AF0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBBYmlUYWdBdHRyRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU0Tm9kZUUAYWxsb2NhdG9yAGJhc2ljX3N0cmluZwBzdHJpbmcAaXN0cmVhbQBvc3RyZWFtAGlvc3RyZWFtAHN0ZDo6YWxsb2NhdG9yAHN0ZDo6YmFzaWNfc3RyaW5nAHN0ZDo6c3RyaW5nAHN0ZDo6aXN0cmVhbQBzdGQ6Om9zdHJlYW0Ac3RkOjppb3N0cmVhbQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOVNwZWNpYWxTdWJzdGl0dXRpb25FACBpbWFnaW5hcnkATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBQb3N0Zml4UXVhbGlmaWVkVHlwZUUAIGNvbXBsZXgAKQAgACgAJgAmJgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM1JlZmVyZW5jZVR5cGVFAG9iamNfb2JqZWN0ACoAaWQ8AD4ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTFQb2ludGVyVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBOYW1lV2l0aFRlbXBsYXRlQXJnc0UAPAAsIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMlRlbXBsYXRlQXJnc0UATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNQYXJhbWV0ZXJQYWNrRQB3Y2hhcl90AGIwRQBiMUUAdQBsAHVsAGxsAHVsbABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUludGVnZXJDYXN0RXhwckUAJUxhTABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZUVFACVhAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RmxvYXRMaXRlcmFsSW1wbElkRUUAJWFmAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RmxvYXRMaXRlcmFsSW1wbElmRUUAdHJ1ZQBmYWxzZQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4Qm9vbEV4cHJFAC0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTRJbnRlZ2VyTGl0ZXJhbEUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBUZW1wbGF0ZUFyZ3VtZW50UGFja0UAZ3MAJj0APQBhbGlnbm9mICgALAB+AC4qAC8ALz0AXgBePQA9PQA+PQA8PQA8PAA8PD0ALT0AKj0ALS0AIT0AIQB8fAB8AHw9AC0+KgArACs9ACsrAC0+ACUAJT0APj4APj49AHNpemVvZiAoAHR5cGVpZCAoAHRocm93AHRocm93IABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5VGhyb3dFeHByRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMkluaXRMaXN0RXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNOb2RlQXJyYXlOb2RlRQBzaXplb2YuLi4gKABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM0VuY2xvc2luZ0V4cHJFAHNpemVvZi4uLigATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjJQYXJhbWV0ZXJQYWNrRXhwYW5zaW9uRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOVNpemVvZlBhcmFtUGFja0V4cHJFAHN0YXRpY19jYXN0AD4oAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThDYXN0RXhwckUAcmVpbnRlcnByZXRfY2FzdAApID8gKAApIDogKABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUNvbmRpdGlvbmFsRXhwckUAbm9leGNlcHQgKABudwBuYQBwaQA6Om9wZXJhdG9yIABuZXcAW10ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlN05ld0V4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTExUG9zdGZpeEV4cHJFACAuLi4gACA9IABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUJyYWNlZFJhbmdlRXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBCcmFjZWRFeHByRQBfR0xPQkFMX19OAChhbm9ueW1vdXMgbmFtZXNwYWNlKQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4TmFtZVR5cGVFAClbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE4QXJyYXlTdWJzY3JpcHRFeHByRQAuAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwTWVtYmVyRXhwckUAc3JOAHNyADo6AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE5R2xvYmFsUXVhbGlmaWVkTmFtZUUAZG4Ab24Ab3BlcmF0b3ImJgBvcGVyYXRvciYAb3BlcmF0b3ImPQBvcGVyYXRvcj0Ab3BlcmF0b3IoKQBvcGVyYXRvciwAb3BlcmF0b3J+AG9wZXJhdG9yIGRlbGV0ZVtdAG9wZXJhdG9yKgBvcGVyYXRvci8Ab3BlcmF0b3IvPQBvcGVyYXRvcl4Ab3BlcmF0b3JePQBvcGVyYXRvcj09AG9wZXJhdG9yPj0Ab3BlcmF0b3I+AG9wZXJhdG9yW10Ab3BlcmF0b3I8PQBvcGVyYXRvcjw8AG9wZXJhdG9yPDw9AG9wZXJhdG9yPABvcGVyYXRvci0Ab3BlcmF0b3ItPQBvcGVyYXRvcio9AG9wZXJhdG9yLS0Ab3BlcmF0b3IgbmV3W10Ab3BlcmF0b3IhPQBvcGVyYXRvciEAb3BlcmF0b3IgbmV3AG9wZXJhdG9yfHwAb3BlcmF0b3J8AG9wZXJhdG9yfD0Ab3BlcmF0b3ItPioAb3BlcmF0b3IrAG9wZXJhdG9yKz0Ab3BlcmF0b3IrKwBvcGVyYXRvci0+AG9wZXJhdG9yPwBvcGVyYXRvciUAb3BlcmF0b3IlPQBvcGVyYXRvcj4+AG9wZXJhdG9yPj49AG9wZXJhdG9yPD0+AG9wZXJhdG9yIiIgAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1TGl0ZXJhbE9wZXJhdG9yRQBvcGVyYXRvciBkZWxldGUAb3BlcmF0b3IgAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIyQ29udmVyc2lvbk9wZXJhdG9yVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOER0b3JOYW1lRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM1F1YWxpZmllZE5hbWVFAGR5bmFtaWNfY2FzdABkZWxldGUAW10gAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwRGVsZXRlRXhwckUAY3YAKSgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTRDb252ZXJzaW9uRXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOENhbGxFeHByRQBjb25zdF9jYXN0AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwUHJlZml4RXhwckUAKSAAICgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBCaW5hcnlFeHByRQBhYQBhbgBhTgBhUwBjbQBkcwBkdgBkVgBlbwBlTwBlcQBnZQBndABsZQBscwBsUwBsdABtaQBtSQBtbABtTABuZQBvbwBvcgBvUgBwbABwTABybQByTQBycwByUwAuLi4gACAuLi4ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOEZvbGRFeHByRQBmcABmTABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM0Z1bmN0aW9uUGFyYW1FAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTI0Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlRQBUcwBzdHJ1Y3QAVHUAdW5pb24AVGUAZW51bQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMkVsYWJvcmF0ZWRUeXBlU3BlZlR5cGVFAFN0TABTdABzdGQ6OgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNlN0ZFF1YWxpZmllZE5hbWVFAERDAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIxU3RydWN0dXJlZEJpbmRpbmdOYW1lRQBVdABVbAB2RQAnbGFtYmRhACcoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1Q2xvc3VyZVR5cGVOYW1lRQAndW5uYW1lZAAnAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1VW5uYW1lZFR5cGVOYW1lRQBzdHJpbmcgbGl0ZXJhbABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5TG9jYWxOYW1lRQBzdGQATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJDdG9yRHRvck5hbWVFAGJhc2ljX2lzdHJlYW0AYmFzaWNfb3N0cmVhbQBiYXNpY19pb3N0cmVhbQBzdGQ6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6OmFsbG9jYXRvcjxjaGFyPiA+AHN0ZDo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4Ac3RkOjpiYXNpY19vc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBzdGQ6OmJhc2ljX2lvc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyN0V4cGFuZGVkU3BlY2lhbFN1YnN0aXR1dGlvbkUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBOZXN0ZWROYW1lRQA6OioATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlQb2ludGVyVG9NZW1iZXJUeXBlRQBbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTlBcnJheVR5cGVFAER2ACB2ZWN0b3JbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwVmVjdG9yVHlwZUUAcGl4ZWwgdmVjdG9yWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNVBpeGVsVmVjdG9yVHlwZUUAZGVjbHR5cGUoAGRvdWJsZQB1bnNpZ25lZCBsb25nIGxvbmcAb2JqY3Byb3RvACBjb25zdAAgdm9sYXRpbGUAIHJlc3RyaWN0AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThRdWFsVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTdWZW5kb3JFeHRRdWFsVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNPYmpDUHJvdG9OYW1lRQBEbwBub2V4Y2VwdABETwBEdwBEeABSRQBPRQAgJgAgJiYATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJGdW5jdGlvblR5cGVFAHRocm93KABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMER5bmFtaWNFeGNlcHRpb25TcGVjRQBub2V4Y2VwdCgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJOb2V4Y2VwdFNwZWNFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTExU3BlY2lhbE5hbWVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTlEb3RTdWZmaXhFAFVhOWVuYWJsZV9pZkkATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZGdW5jdGlvbkVuY29kaW5nRQAgW2VuYWJsZV9pZjoATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJFbmFibGVJZkF0dHJFAHRocmVhZC1sb2NhbCB3cmFwcGVyIHJvdXRpbmUgZm9yIAByZWZlcmVuY2UgdGVtcG9yYXJ5IGZvciAAZ3VhcmQgdmFyaWFibGUgZm9yIABub24tdmlydHVhbCB0aHVuayB0byAAdmlydHVhbCB0aHVuayB0byAAdGhyZWFkLWxvY2FsIGluaXRpYWxpemF0aW9uIHJvdXRpbmUgZm9yIABjb25zdHJ1Y3Rpb24gdnRhYmxlIGZvciAALWluLQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMUN0b3JWdGFibGVTcGVjaWFsTmFtZUUAY292YXJpYW50IHJldHVybiB0aHVuayB0byAAdHlwZWluZm8gbmFtZSBmb3IgAHR5cGVpbmZvIGZvciAAVlRUIGZvciAAdnRhYmxlIGZvciAAU3QxMWxvZ2ljX2Vycm9yAFN0MTJsZW5ndGhfZXJyb3IATjEwX19jeHhhYml2MTE3X19wYmFzZV90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExOV9fcG9pbnRlcl90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyMF9fZnVuY3Rpb25fdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjlfX3BvaW50ZXJfdG9fbWVtYmVyX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAHYARG4AYgBjAGgAYQBzAHQAaQBqAG0AZgBkAE4xMF9fY3h4YWJpdjExNl9fZW51bV90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyMV9fdm1pX2NsYXNzX3R5cGVfaW5mb0U=";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinary(){try{if(wasmBinary){return new Uint8Array(wasmBinary)}var binary=tryParseAsDataURI(wasmBinaryFile);if(binary){return binary}if(readBinary){return readBinary(wasmBinaryFile)}else{throw "both async and sync fetching of the wasm failed"}}catch(err){abort(err);}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw "failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary()})}return new Promise(function(resolve,reject){resolve(getBinary());})}function createWasm(env){var info={"env":env,"global":{"NaN":NaN,Infinity:Infinity},"global.Math":Math,"asm2wasm":asm2wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;removeRunDependency();}addRunDependency();function receiveInstantiatedSource(output){receiveInstance(output["instance"]);}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason);})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&typeof fetch==="function"){fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiatedSource,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");instantiateArrayBuffer(receiveInstantiatedSource);})});}else{return instantiateArrayBuffer(receiveInstantiatedSource)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync();return {}}Module["asm"]=function(global,env,providedBuffer){env["memory"]=wasmMemory;env["table"]=wasmTable=new WebAssembly.Table({"initial":558,"maximum":558,"element":"anyfunc"});env["__memory_base"]=1024;env["__table_base"]=0;var exports=createWasm(env);return exports};__ATINIT__.push({func:function(){globalCtors();}});function ___cxa_allocate_exception(size){return _malloc(size)}function ___cxa_pure_virtual(){ABORT=true;throw "Pure virtual function called!"}function ___cxa_throw(ptr,type,destructor){if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exceptions=1;}else{__ZSt18uncaught_exceptionv.uncaught_exceptions++;}throw ptr}function ___cxa_uncaught_exceptions(){return __ZSt18uncaught_exceptionv.uncaught_exceptions}var SYSCALLS={buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0;}else{buffer.push(curr);}},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();return low},getZero:function(){SYSCALLS.get();}};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(stream,HEAPU8[ptr+j]);}ret+=len;}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i);}embind_charCodes=codes;}var embind_charCodes=undefined;function readLatin1String(ptr){var ret="";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]];}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return "_unknown"}name=name.replace(/[^a-zA-Z0-9_]/g,"$");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return "_"+name}else{return name}}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return new Function("body","return function "+name+"() {\n"+'    "use strict";'+"    return body.apply(this, arguments);\n"+"};\n")(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+"\n"+stack.replace(/^Error(:[^\n]*)?\n/,"");}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else{return this.name+": "+this.message}};return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes;});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError("Mismatched type converter count");}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i]);}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach(function(dt,i){if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt];}else{unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[];}awaitingDependencies[dt].push(function(){typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters);}});}});if(0===unregisteredTypes.length){onComplete(typeConverters);}}function registerType(rawType,registeredInstance,options){options=options||{};if(!("argPackAdvance"in registeredInstance)){throw new TypeError("registerType registeredInstance requires argPackAdvance")}var name=registeredInstance.name;if(!rawType){throwBindingError('type "'+name+'" must have a positive integer typeid pointer');}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else{throwBindingError("Cannot register type '"+name+"' twice");}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(function(cb){cb();});}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(wt){return !!wt},"toWireType":function(destructors,o){return o?trueValue:falseValue},"argPackAdvance":8,"readValueFromPointer":function(pointer){var heap;if(size===1){heap=HEAP8;}else if(size===2){heap=HEAP16;}else if(size===4){heap=HEAP32;}else{throw new TypeError("Unknown boolean type size: "+name)}return this["fromWireType"](heap[pointer>>shift])},destructorFunction:null});}function ClassHandle_isAliasOf(other){if(!(this instanceof ClassHandle)){return false}if(!(other instanceof ClassHandle)){return false}var leftClass=this.$$.ptrType.registeredClass;var left=this.$$.ptr;var rightClass=other.$$.ptrType.registeredClass;var right=other.$$.ptr;while(leftClass.baseClass){left=leftClass.upcast(left);leftClass=leftClass.baseClass;}while(rightClass.baseClass){right=rightClass.upcast(right);rightClass=rightClass.baseClass;}return leftClass===rightClass&&left===right}function shallowCopyInternalPointer(o){return {count:o.count,deleteScheduled:o.deleteScheduled,preservePointerOnDelete:o.preservePointerOnDelete,ptr:o.ptr,ptrType:o.ptrType,smartPtr:o.smartPtr,smartPtrType:o.smartPtrType}}function throwInstanceAlreadyDeleted(obj){function getInstanceTypeName(handle){return handle.$$.ptrType.registeredClass.name}throwBindingError(getInstanceTypeName(obj)+" instance already deleted");}var finalizationGroup=false;function detachFinalizer(handle){}function runDestructor($$){if($$.smartPtr){$$.smartPtrType.rawDestructor($$.smartPtr);}else{$$.ptrType.registeredClass.rawDestructor($$.ptr);}}function releaseClassHandle($$){$$.count.value-=1;var toDelete=0===$$.count.value;if(toDelete){runDestructor($$);}}function attachFinalizer(handle){if("undefined"===typeof FinalizationGroup){attachFinalizer=function(handle){return handle};return handle}finalizationGroup=new FinalizationGroup(function(iter){for(var result=iter.next();!result.done;result=iter.next()){var $$=result.value;if(!$$.ptr){console.warn("object already deleted: "+$$.ptr);}else{releaseClassHandle($$);}}});attachFinalizer=function(handle){finalizationGroup.register(handle,handle.$$,handle.$$);return handle};detachFinalizer=function(handle){finalizationGroup.unregister(handle.$$);};return attachFinalizer(handle)}function ClassHandle_clone(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.preservePointerOnDelete){this.$$.count.value+=1;return this}else{var clone=attachFinalizer(Object.create(Object.getPrototypeOf(this),{$$:{value:shallowCopyInternalPointer(this.$$)}}));clone.$$.count.value+=1;clone.$$.deleteScheduled=false;return clone}}function ClassHandle_delete(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}detachFinalizer(this);releaseClassHandle(this.$$);if(!this.$$.preservePointerOnDelete){this.$$.smartPtr=undefined;this.$$.ptr=undefined;}}function ClassHandle_isDeleted(){return !this.$$.ptr}var delayFunction=undefined;var deletionQueue=[];function flushPendingDeletes(){while(deletionQueue.length){var obj=deletionQueue.pop();obj.$$.deleteScheduled=false;obj["delete"]();}}function ClassHandle_deleteLater(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}deletionQueue.push(this);if(deletionQueue.length===1&&delayFunction){delayFunction(flushPendingDeletes);}this.$$.deleteScheduled=true;return this}function init_ClassHandle(){ClassHandle.prototype["isAliasOf"]=ClassHandle_isAliasOf;ClassHandle.prototype["clone"]=ClassHandle_clone;ClassHandle.prototype["delete"]=ClassHandle_delete;ClassHandle.prototype["isDeleted"]=ClassHandle_isDeleted;ClassHandle.prototype["deleteLater"]=ClassHandle_deleteLater;}function ClassHandle(){}var registeredPointers={};function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError("Function '"+humanName+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+proto[methodName].overloadTable+")!");}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc;}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError("Cannot register public name '"+name+"' twice");}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError("Cannot register multiple overloads of a function with the same number of arguments ("+numArguments+")!");}Module[name].overloadTable[numArguments]=value;}else{Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments;}}}function RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast){this.name=name;this.constructor=constructor;this.instancePrototype=instancePrototype;this.rawDestructor=rawDestructor;this.baseClass=baseClass;this.getActualType=getActualType;this.upcast=upcast;this.downcast=downcast;this.pureVirtualFunctions=[];}function upcastPointer(ptr,ptrClass,desiredClass){while(ptrClass!==desiredClass){if(!ptrClass.upcast){throwBindingError("Expected null or instance of "+desiredClass.name+", got an instance of "+ptrClass.name);}ptr=ptrClass.upcast(ptr);ptrClass=ptrClass.baseClass;}return ptr}function constNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function genericPointerToWireType(destructors,handle){var ptr;if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}if(this.isSmartPointer){ptr=this.rawConstructor();if(destructors!==null){destructors.push(this.rawDestructor,ptr);}return ptr}else{return 0}}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(!this.isConst&&handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);if(this.isSmartPointer){if(undefined===handle.$$.smartPtr){throwBindingError("Passing raw pointer to smart pointer is illegal");}switch(this.sharingPolicy){case 0:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else{throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}break;case 1:ptr=handle.$$.smartPtr;break;case 2:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else{var clonedHandle=handle["clone"]();ptr=this.rawShare(ptr,__emval_register(function(){clonedHandle["delete"]();}));if(destructors!==null){destructors.push(this.rawDestructor,ptr);}}break;default:throwBindingError("Unsupporting sharing policy");}}return ptr}function nonConstNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+handle.$$.ptrType.name+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function simpleReadValueFromPointer(pointer){return this["fromWireType"](HEAPU32[pointer>>2])}function RegisteredPointer_getPointee(ptr){if(this.rawGetPointee){ptr=this.rawGetPointee(ptr);}return ptr}function RegisteredPointer_destructor(ptr){if(this.rawDestructor){this.rawDestructor(ptr);}}function RegisteredPointer_deleteObject(handle){if(handle!==null){handle["delete"]();}}function downcastPointer(ptr,ptrClass,desiredClass){if(ptrClass===desiredClass){return ptr}if(undefined===desiredClass.baseClass){return null}var rv=downcastPointer(ptr,ptrClass,desiredClass.baseClass);if(rv===null){return null}return desiredClass.downcast(rv)}function getInheritedInstanceCount(){return Object.keys(registeredInstances).length}function getLiveInheritedInstances(){var rv=[];for(var k in registeredInstances){if(registeredInstances.hasOwnProperty(k)){rv.push(registeredInstances[k]);}}return rv}function setDelayFunction(fn){delayFunction=fn;if(deletionQueue.length&&delayFunction){delayFunction(flushPendingDeletes);}}function init_embind(){Module["getInheritedInstanceCount"]=getInheritedInstanceCount;Module["getLiveInheritedInstances"]=getLiveInheritedInstances;Module["flushPendingDeletes"]=flushPendingDeletes;Module["setDelayFunction"]=setDelayFunction;}var registeredInstances={};function getBasestPointer(class_,ptr){if(ptr===undefined){throwBindingError("ptr should not be undefined");}while(class_.baseClass){ptr=class_.upcast(ptr);class_=class_.baseClass;}return ptr}function getInheritedInstance(class_,ptr){ptr=getBasestPointer(class_,ptr);return registeredInstances[ptr]}function makeClassHandle(prototype,record){if(!record.ptrType||!record.ptr){throwInternalError("makeClassHandle requires ptr and ptrType");}var hasSmartPtrType=!!record.smartPtrType;var hasSmartPtr=!!record.smartPtr;if(hasSmartPtrType!==hasSmartPtr){throwInternalError("Both smartPtrType and smartPtr must be specified");}record.count={value:1};return attachFinalizer(Object.create(prototype,{$$:{value:record}}))}function RegisteredPointer_fromWireType(ptr){var rawPointer=this.getPointee(ptr);if(!rawPointer){this.destructor(ptr);return null}var registeredInstance=getInheritedInstance(this.registeredClass,rawPointer);if(undefined!==registeredInstance){if(0===registeredInstance.$$.count.value){registeredInstance.$$.ptr=rawPointer;registeredInstance.$$.smartPtr=ptr;return registeredInstance["clone"]()}else{var rv=registeredInstance["clone"]();this.destructor(ptr);return rv}}function makeDefaultHandle(){if(this.isSmartPointer){return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:rawPointer,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this,ptr:ptr})}}var actualType=this.registeredClass.getActualType(rawPointer);var registeredPointerRecord=registeredPointers[actualType];if(!registeredPointerRecord){return makeDefaultHandle.call(this)}var toType;if(this.isConst){toType=registeredPointerRecord.constPointerType;}else{toType=registeredPointerRecord.pointerType;}var dp=downcastPointer(rawPointer,this.registeredClass,toType.registeredClass);if(dp===null){return makeDefaultHandle.call(this)}if(this.isSmartPointer){return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp})}}function init_RegisteredPointer(){RegisteredPointer.prototype.getPointee=RegisteredPointer_getPointee;RegisteredPointer.prototype.destructor=RegisteredPointer_destructor;RegisteredPointer.prototype["argPackAdvance"]=8;RegisteredPointer.prototype["readValueFromPointer"]=simpleReadValueFromPointer;RegisteredPointer.prototype["deleteObject"]=RegisteredPointer_deleteObject;RegisteredPointer.prototype["fromWireType"]=RegisteredPointer_fromWireType;}function RegisteredPointer(name,registeredClass,isReference,isConst,isSmartPointer,pointeeType,sharingPolicy,rawGetPointee,rawConstructor,rawShare,rawDestructor){this.name=name;this.registeredClass=registeredClass;this.isReference=isReference;this.isConst=isConst;this.isSmartPointer=isSmartPointer;this.pointeeType=pointeeType;this.sharingPolicy=sharingPolicy;this.rawGetPointee=rawGetPointee;this.rawConstructor=rawConstructor;this.rawShare=rawShare;this.rawDestructor=rawDestructor;if(!isSmartPointer&&registeredClass.baseClass===undefined){if(isConst){this["toWireType"]=constNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}else{this["toWireType"]=nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}}else{this["toWireType"]=genericPointerToWireType;}}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError("Replacing nonexistant public symbol");}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value;}else{Module[name]=value;Module[name].argCount=numArguments;}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(dynCall){var args=[];for(var i=1;i<signature.length;++i){args.push("a"+i);}var name="dynCall_"+signature+"_"+rawFunction;var body="return function "+name+"("+args.join(", ")+") {\n";body+="    return dynCall(rawFunction"+(args.length?", ":"")+args.join(", ")+");\n";body+="};\n";return new Function("dynCall","rawFunction",body)(dynCall,rawFunction)}var fp;if(Module["FUNCTION_TABLE_"+signature]!==undefined){fp=Module["FUNCTION_TABLE_"+signature][rawFunction];}else if(typeof FUNCTION_TABLE!=="undefined"){fp=FUNCTION_TABLE[rawFunction];}else{var dc=Module["dynCall_"+signature];if(dc===undefined){dc=Module["dynCall_"+signature.replace(/f/g,"d")];if(dc===undefined){throwBindingError("No dynCall invoker for signature: "+signature);}}fp=makeDynCaller(dc);}if(typeof fp!=="function"){throwBindingError("unknown function pointer with signature "+signature+": "+rawFunction);}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true;}types.forEach(visit);throw new UnboundTypeError(message+": "+unboundTypes.map(getTypeName).join([", "]))}function __embind_register_class(rawType,rawPointerType,rawConstPointerType,baseClassRawType,getActualTypeSignature,getActualType,upcastSignature,upcast,downcastSignature,downcast,name,destructorSignature,rawDestructor){name=readLatin1String(name);getActualType=embind__requireFunction(getActualTypeSignature,getActualType);if(upcast){upcast=embind__requireFunction(upcastSignature,upcast);}if(downcast){downcast=embind__requireFunction(downcastSignature,downcast);}rawDestructor=embind__requireFunction(destructorSignature,rawDestructor);var legalFunctionName=makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName,function(){throwUnboundTypeError("Cannot construct "+name+" due to unbound types",[baseClassRawType]);});whenDependentTypesAreResolved([rawType,rawPointerType,rawConstPointerType],baseClassRawType?[baseClassRawType]:[],function(base){base=base[0];var baseClass;var basePrototype;if(baseClassRawType){baseClass=base.registeredClass;basePrototype=baseClass.instancePrototype;}else{basePrototype=ClassHandle.prototype;}var constructor=createNamedFunction(legalFunctionName,function(){if(Object.getPrototypeOf(this)!==instancePrototype){throw new BindingError("Use 'new' to construct "+name)}if(undefined===registeredClass.constructor_body){throw new BindingError(name+" has no accessible constructor")}var body=registeredClass.constructor_body[arguments.length];if(undefined===body){throw new BindingError("Tried to invoke ctor of "+name+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(registeredClass.constructor_body).toString()+") parameters instead!")}return body.apply(this,arguments)});var instancePrototype=Object.create(basePrototype,{constructor:{value:constructor}});constructor.prototype=instancePrototype;var registeredClass=new RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast);var referenceConverter=new RegisteredPointer(name,registeredClass,true,false,false);var pointerConverter=new RegisteredPointer(name+"*",registeredClass,false,false,false);var constPointerConverter=new RegisteredPointer(name+" const*",registeredClass,false,true,false);registeredPointers[rawType]={pointerType:pointerConverter,constPointerType:constPointerConverter};replacePublicSymbol(legalFunctionName,constructor);return [referenceConverter,pointerConverter,constPointerConverter]});}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i]);}return array}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr);}}function __embind_register_class_constructor(rawClassType,argCount,rawArgTypesAddr,invokerSignature,invoker,rawConstructor){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);invoker=embind__requireFunction(invokerSignature,invoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName="constructor "+classType.name;if(undefined===classType.registeredClass.constructor_body){classType.registeredClass.constructor_body=[];}if(undefined!==classType.registeredClass.constructor_body[argCount-1]){throw new BindingError("Cannot register multiple constructors with identical number of parameters ("+(argCount-1)+") for class '"+classType.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!")}classType.registeredClass.constructor_body[argCount-1]=function unboundTypeHandler(){throwUnboundTypeError("Cannot construct "+classType.name+" due to unbound types",rawArgTypes);};whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){classType.registeredClass.constructor_body[argCount-1]=function constructor_body(){if(arguments.length!==argCount-1){throwBindingError(humanName+" called with "+arguments.length+" arguments, expected "+(argCount-1));}var destructors=[];var args=new Array(argCount);args[0]=rawConstructor;for(var i=1;i<argCount;++i){args[i]=argTypes[i]["toWireType"](destructors,arguments[i-1]);}var ptr=invoker.apply(null,args);runDestructors(destructors);return argTypes[0]["fromWireType"](ptr)};return []});return []});}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError("new_ called with constructor type "+typeof constructor+" which is not a function")}var dummy=createNamedFunction(constructor.name||"unknownFunctionName",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!=="void";var argsList="";var argsListWired="";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?", ":"")+"arg"+i;argsListWired+=(i!==0?", ":"")+"arg"+i+"Wired";}var invokerFnBody="return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n"+"if (arguments.length !== "+(argCount-2)+") {\n"+"throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount-2)+" args!');\n"+"}\n";if(needsDestructorStack){invokerFnBody+="var destructors = [];\n";}var dtorStack=needsDestructorStack?"destructors":"null";var args1=["throwBindingError","invoker","fn","runDestructors","retType","classParam"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+="var thisWired = classParam.toWireType("+dtorStack+", this);\n";}for(var i=0;i<argCount-2;++i){invokerFnBody+="var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";args1.push("argType"+i);args2.push(argTypes[i+2]);}if(isClassMethodFunc){argsListWired="thisWired"+(argsListWired.length>0?", ":"")+argsListWired;}invokerFnBody+=(returns?"var rv = ":"")+"invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";if(needsDestructorStack){invokerFnBody+="runDestructors(destructors);\n";}else{for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?"thisWired":"arg"+(i-2)+"Wired";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";args1.push(paramName+"_dtor");args2.push(argTypes[i].destructorFunction);}}}if(returns){invokerFnBody+="var ret = retType.fromWireType(rv);\n"+"return ret;\n";}invokerFnBody+="}\n";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function __embind_register_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,context,isPureVirtual){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName=classType.name+"."+methodName;if(isPureVirtual){classType.registeredClass.pureVirtualFunctions.push(methodName);}function unboundTypesHandler(){throwUnboundTypeError("Cannot call "+humanName+" due to unbound types",rawArgTypes);}var proto=classType.registeredClass.instancePrototype;var method=proto[methodName];if(undefined===method||undefined===method.overloadTable&&method.className!==classType.name&&method.argCount===argCount-2){unboundTypesHandler.argCount=argCount-2;unboundTypesHandler.className=classType.name;proto[methodName]=unboundTypesHandler;}else{ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-2]=unboundTypesHandler;}whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){var memberFunction=craftInvokerFunction(humanName,argTypes,classType,rawInvoker,context);if(undefined===proto[methodName].overloadTable){memberFunction.argCount=argCount-2;proto[methodName]=memberFunction;}else{proto[methodName].overloadTable[argCount-2]=memberFunction;}return []});return []});}function validateThis(this_,classType,humanName){if(!(this_ instanceof Object)){throwBindingError(humanName+' with invalid "this": '+this_);}if(!(this_ instanceof classType.registeredClass.constructor)){throwBindingError(humanName+' incompatible with "this" of type '+this_.constructor.name);}if(!this_.$$.ptr){throwBindingError("cannot call emscripten binding method "+humanName+" on deleted object");}return upcastPointer(this_.$$.ptr,this_.$$.ptrType.registeredClass,classType.registeredClass)}function __embind_register_class_property(classType,fieldName,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){fieldName=readLatin1String(fieldName);getter=embind__requireFunction(getterSignature,getter);whenDependentTypesAreResolved([],[classType],function(classType){classType=classType[0];var humanName=classType.name+"."+fieldName;var desc={get:function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[getterReturnType,setterArgumentType]);},enumerable:true,configurable:true};if(setter){desc.set=function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[getterReturnType,setterArgumentType]);};}else{desc.set=function(v){throwBindingError(humanName+" is a read-only property");};}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);whenDependentTypesAreResolved([],setter?[getterReturnType,setterArgumentType]:[getterReturnType],function(types){var getterReturnType=types[0];var desc={get:function(){var ptr=validateThis(this,classType,humanName+" getter");return getterReturnType["fromWireType"](getter(getterContext,ptr))},enumerable:true};if(setter){setter=embind__requireFunction(setterSignature,setter);var setterArgumentType=types[1];desc.set=function(v){var ptr=validateThis(this,classType,humanName+" setter");var destructors=[];setter(setterContext,ptr,setterArgumentType["toWireType"](destructors,v));runDestructors(destructors);};}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);return []});return []});}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle);}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count;}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module["count_emval_handles"]=count_emval_handles;Module["get_first_emval"]=get_first_emval;}function __emval_register(value){switch(value){case undefined:{return 1}case null:{return 2}case true:{return 3}case false:{return 4}default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(handle){var rv=emval_handle_array[handle].value;__emval_decref(handle);return rv},"toWireType":function(destructors,value){return __emval_register(value)},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:null});}function enumReadValueFromPointer(name,shift,signed){switch(shift){case 0:return function(pointer){var heap=signed?HEAP8:HEAPU8;return this["fromWireType"](heap[pointer])};case 1:return function(pointer){var heap=signed?HEAP16:HEAPU16;return this["fromWireType"](heap[pointer>>1])};case 2:return function(pointer){var heap=signed?HEAP32:HEAPU32;return this["fromWireType"](heap[pointer>>2])};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_enum(rawType,name,size,isSigned){var shift=getShiftFromSize(size);name=readLatin1String(name);function ctor(){}ctor.values={};registerType(rawType,{name:name,constructor:ctor,"fromWireType":function(c){return this.constructor.values[c]},"toWireType":function(destructors,c){return c.value},"argPackAdvance":8,"readValueFromPointer":enumReadValueFromPointer(name,shift,isSigned),destructorFunction:null});exposePublicSymbol(name,ctor);}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+" has unknown type "+getTypeName(rawType));}return impl}function __embind_register_enum_value(rawEnumType,name,enumValue){var enumType=requireRegisteredType(rawEnumType,"enum");name=readLatin1String(name);var Enum=enumType.constructor;var Value=Object.create(enumType.constructor.prototype,{value:{value:enumValue},constructor:{value:createNamedFunction(enumType.name+"_"+name,function(){})}});Enum.values[enumValue]=Value;Enum[name]=Value;}function _embind_repr(v){if(v===null){return "null"}var t=typeof v;if(t==="object"||t==="array"||t==="function"){return v.toString()}else{return ""+v}}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this["fromWireType"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this["fromWireType"](HEAPF64[pointer>>3])};default:throw new TypeError("Unknown float type: "+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(value){return value},"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}return value},"argPackAdvance":8,"readValueFromPointer":floatReadValueFromPointer(name,shift),destructorFunction:null});}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError("Cannot call "+name+" due to unbound types",argTypes);},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return []});}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295;}var shift=getShiftFromSize(size);var fromWireType=function(value){return value};if(minRange===0){var bitshift=32-8*size;fromWireType=function(value){return value<<bitshift>>>bitshift};}var isUnsignedType=name.indexOf("unsigned")!=-1;registerType(primitiveType,{name:name,"fromWireType":fromWireType,"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}if(value<minRange||value>maxRange){throw new TypeError('Passing a number "'+_embind_repr(value)+'" from JS side to C/C++ side to an argument of type "'+name+'", which is outside the valid range ['+minRange+", "+maxRange+"]!")}return isUnsignedType?value>>>0:value|0},"argPackAdvance":8,"readValueFromPointer":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null});}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(heap["buffer"],data,size)}name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":decodeMemoryView,"argPackAdvance":8,"readValueFromPointer":decodeMemoryView},{ignoreDuplicateRegistrations:true});}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name==="std::string";registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var str;if(stdStringIsUTF8){var endChar=HEAPU8[value+4+length];var endCharSwap=0;if(endChar!=0){endCharSwap=endChar;HEAPU8[value+4+length]=0;}var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(HEAPU8[currentBytePtr]==0){var stringSegment=UTF8ToString(decodeStartPtr);if(str===undefined)str=stringSegment;else{str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+1;}}if(endCharSwap!=0)HEAPU8[value+4+length]=endCharSwap;}else{var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i]);}str=a.join("");}_free(value);return str},"toWireType":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value);}var getLength;var valueIsOfTypeString=typeof value==="string";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError("Cannot pass non-string to std::string");}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=function(){return lengthBytesUTF8(value)};}else{getLength=function(){return value.length};}var length=getLength();var ptr=_malloc(4+length+1);HEAPU32[ptr>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1);}else{if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits");}HEAPU8[ptr+4+i]=charCode;}}else{for(var i=0;i<length;++i){HEAPU8[ptr+4+i]=value[i];}}}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var getHeap,shift;if(charSize===2){getHeap=function(){return HEAPU16};shift=1;}else if(charSize===4){getHeap=function(){return HEAPU32};shift=2;}registerType(rawType,{name:name,"fromWireType":function(value){var HEAP=getHeap();var length=HEAPU32[value>>2];var a=new Array(length);var start=value+4>>shift;for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAP[start+i]);}_free(value);return a.join("")},"toWireType":function(destructors,value){var HEAP=getHeap();var length=value.length;var ptr=_malloc(4+length*charSize);HEAPU32[ptr>>2]=length;var start=ptr+4>>shift;for(var i=0;i<length;++i){HEAP[start+i]=value.charCodeAt(i);}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,"argPackAdvance":0,"fromWireType":function(){return undefined},"toWireType":function(destructors,o){return undefined}});}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1;}}function __emval_take_value(type,argv){type=requireRegisteredType(type,"_emval_take_value");var v=type["readValueFromPointer"](argv);return __emval_register(v)}function _abort(){Module["abort"]();}function _emscripten_get_heap_size(){return HEAP8.length}function _llvm_trap(){abort("trap!");}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}function abortOnCannotGrowMemory(requestedSize){abort("OOM");}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();var PAGE_MULTIPLE=65536;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE);}else{newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT);}}var replacement=emscripten_realloc_buffer(newSize);if(!replacement){return false}return true}embind_init_charCodes();BindingError=Module["BindingError"]=extendError(Error,"BindingError");InternalError=Module["InternalError"]=extendError(Error,"InternalError");init_ClassHandle();init_RegisteredPointer();init_embind();UnboundTypeError=Module["UnboundTypeError"]=extendError(Error,"UnboundTypeError");init_emval();var decodeBase64=typeof atob==="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2);}if(enc4!==64){output=output+String.fromCharCode(chr3);}}while(i<input.length);return output};function intArrayFromBase64(s){try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}var asmGlobalArg={};var asmLibraryArg={"e":abort,"z":setTempRet0,"h":___cxa_allocate_exception,"H":___cxa_pure_virtual,"f":___cxa_throw,"y":___cxa_uncaught_exceptions,"q":___setErrNo,"x":___syscall140,"p":___syscall146,"w":___syscall6,"v":__embind_register_bool,"k":__embind_register_class,"m":__embind_register_class_constructor,"b":__embind_register_class_function,"i":__embind_register_class_property,"I":__embind_register_emval,"n":__embind_register_enum,"g":__embind_register_enum_value,"u":__embind_register_float,"d":__embind_register_function,"l":__embind_register_integer,"j":__embind_register_memory_view,"t":__embind_register_std_string,"G":__embind_register_std_wstring,"F":__embind_register_void,"s":__emval_decref,"r":__emval_incref,"o":__emval_take_value,"c":_abort,"E":_emscripten_get_heap_size,"D":_emscripten_memcpy_big,"C":_emscripten_resize_heap,"B":_llvm_trap,"A":abortOnCannotGrowMemory,"a":DYNAMICTOP_PTR};var asm=Module["asm"](asmGlobalArg,asmLibraryArg,buffer);Module["asm"]=asm;var __ZSt18uncaught_exceptionv=Module["__ZSt18uncaught_exceptionv"]=function(){return Module["asm"]["J"].apply(null,arguments)};var ___embind_register_native_and_builtin_types=Module["___embind_register_native_and_builtin_types"]=function(){return Module["asm"]["K"].apply(null,arguments)};var ___getTypeName=Module["___getTypeName"]=function(){return Module["asm"]["L"].apply(null,arguments)};var _free=Module["_free"]=function(){return Module["asm"]["M"].apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return Module["asm"]["N"].apply(null,arguments)};var globalCtors=Module["globalCtors"]=function(){return Module["asm"]["ja"].apply(null,arguments)};var dynCall_di=Module["dynCall_di"]=function(){return Module["asm"]["O"].apply(null,arguments)};var dynCall_dii=Module["dynCall_dii"]=function(){return Module["asm"]["P"].apply(null,arguments)};var dynCall_i=Module["dynCall_i"]=function(){return Module["asm"]["Q"].apply(null,arguments)};var dynCall_ii=Module["dynCall_ii"]=function(){return Module["asm"]["R"].apply(null,arguments)};var dynCall_iidd=Module["dynCall_iidd"]=function(){return Module["asm"]["S"].apply(null,arguments)};var dynCall_iidiiii=Module["dynCall_iidiiii"]=function(){return Module["asm"]["T"].apply(null,arguments)};var dynCall_iii=Module["dynCall_iii"]=function(){return Module["asm"]["U"].apply(null,arguments)};var dynCall_iiii=Module["dynCall_iiii"]=function(){return Module["asm"]["V"].apply(null,arguments)};var dynCall_iiiii=Module["dynCall_iiiii"]=function(){return Module["asm"]["W"].apply(null,arguments)};var dynCall_iiiiii=Module["dynCall_iiiiii"]=function(){return Module["asm"]["X"].apply(null,arguments)};var dynCall_iiiiiii=Module["dynCall_iiiiiii"]=function(){return Module["asm"]["Y"].apply(null,arguments)};var dynCall_jiji=Module["dynCall_jiji"]=function(){return Module["asm"]["Z"].apply(null,arguments)};var dynCall_v=Module["dynCall_v"]=function(){return Module["asm"]["_"].apply(null,arguments)};var dynCall_vi=Module["dynCall_vi"]=function(){return Module["asm"]["$"].apply(null,arguments)};var dynCall_vid=Module["dynCall_vid"]=function(){return Module["asm"]["aa"].apply(null,arguments)};var dynCall_vidd=Module["dynCall_vidd"]=function(){return Module["asm"]["ba"].apply(null,arguments)};var dynCall_vii=Module["dynCall_vii"]=function(){return Module["asm"]["ca"].apply(null,arguments)};var dynCall_viid=Module["dynCall_viid"]=function(){return Module["asm"]["da"].apply(null,arguments)};var dynCall_viii=Module["dynCall_viii"]=function(){return Module["asm"]["ea"].apply(null,arguments)};var dynCall_viiid=Module["dynCall_viiid"]=function(){return Module["asm"]["fa"].apply(null,arguments)};var dynCall_viiii=Module["dynCall_viiii"]=function(){return Module["asm"]["ga"].apply(null,arguments)};var dynCall_viiiii=Module["dynCall_viiiii"]=function(){return Module["asm"]["ha"].apply(null,arguments)};var dynCall_viiiiii=Module["dynCall_viiiiii"]=function(){return Module["asm"]["ia"].apply(null,arguments)};Module["asm"]=asm;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else{doRun();}}Module["run"]=run;function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what+="";out(what);err(what);ABORT=true;throw "abort("+what+"). Build with -s ASSERTIONS=1 for more info."}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}noExitRuntime=true;run();

    return Module;
  }

  var clipperWasm = { init: init };

  function init$1(_moduleOverrides) {
    var Module = {};
    Object.keys(_moduleOverrides).forEach(function (key) {
      Module[key] = _moduleOverrides[key];
    });
  var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var readAsync;{if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);}else{scriptDirectory="";}readAsync=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror();};xhr.onerror=onerror;xhr.send(null);};}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var functionPointers=new Array(0);var tempRet0=0;var setTempRet0=function(value){tempRet0=value;};var getTempRet0=function(){return tempRet0};var GLOBAL_BASE=8;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];var ABORT=false;var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else{u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else{if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple;}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}var DYNAMIC_BASE=5261872,DYNAMICTOP_PTR=18960;var INITIAL_TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(Module["buffer"]){buffer=Module["buffer"];}else{buffer=new ArrayBuffer(INITIAL_TOTAL_MEMORY);}INITIAL_TOTAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func);}else{Module["dynCall_vi"](func,callback.arg);}}else{func(callback.arg===undefined?null:callback.arg);}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){callRuntimeCallbacks(__ATINIT__);}function preMain(){callRuntimeCallbacks(__ATMAIN__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}__ATINIT__.push({func:function(){globalCtors();}});memoryInitializer="data:application/octet-stream;base64,AAAAAAAAAAAgDQAA6AQAAHgNAADABAAAMA0AAFgEAAB4DQAAwAQAACANAAAIBQAAeA0AAFgEAAAwDQAAiAQAAHgNAABYBAAAIA0AAJAFAAB4DQAAQAUAADANAAB4BQAAeA0AAEAFAAAgDQAAWAQAAIgEAAC4BAAAIA0AAIgEAACIBAAAuAQAACANAABYBAAAWAQAAIgNAAAgDQAAiAQAAIgEAACIDQAAIA0AAFgEAABYBAAAiAQAADANAAAAAAAAAAAAAAAAAAAgDQAAWAQAAIgEAACIBAAAMA0AAAAAAAAAAAAAAAAAACANAABYBAAAWAQAAIgEAAAwDQAACAYAAFgEAACwBAAAMA0AAAAAAAAAAAAAAAAAADANAAAIBgAAiAQAALAEAAAwDQAAAAAAAAAAAAAAAAAAMA0AACgGAACoBAAAiAQAALgEAAAAAAAAAAAAAAAAAAAwDQAAKAYAAKgEAACIBAAAuAQAALgEAAAAAAAAAAAAADANAAAoBgAAqAQAALAFAAC4BAAAAAAAAAAAAAAAAAAAMA0AACgGAACoBAAAsAUAALgEAAC4BAAAAAAAAAAAAAAgDQAAUAYAAFgEAAAwBQAAOAUAAAAAAAAAAAAAAAAAACANAABQBgAAiAQAADAFAAA4BQAAAAAAAAAAAAAAAAAAIA0AAFAGAACIBAAAiA0AACANAABQBgAAsAUAAIgNAAARAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABEADwoREREDCgcAARMJCwsAAAkGCwAACwAGEQAAABEREQAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAARAAoKERERAAoAAAIACQsAAAAJAAsAAAsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAA0AAAAEDQAAAAAJDgAAAAAADgAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAPAAAAAA8AAAAACRAAAAAAABAAABAAABIAAAASEhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAABISEgAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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aA0AACANAACIBAAAaA0AAKAEAABYBAAAoAQAAIgEAADABAAAiA0AAIgNAADoBAAAIA0AAOgEAADABAAAeA0AAPgEAACgBAAAWAQAAHgNAAAIBQAAIA0AAAgFAABYBAAAeA0AABgFAACgBAAAiAQAAHgNAABABQAAQAUAAFAFAAAwDQAAUAUAAGANAABQBQAAkAUAACANAACQBQAAQAUAAHgNAACgBQAAoAQAAHgFAAB4DQAAwAUAAAAAAACwBQAACwAAAAwAAABABQAA0AUAACANAADABQAAYA0AANAFAAAwDQAAWAQAAIgNAABYBAAAYA0AAMAEAABYBAAAIA0AAIgEAAC4BAAAIA0AAFgEAACIDQAAIA0AAIgEAACIDQAAIA0AALAFAACIBAAAIA0AALAFAACIBAAAIA0AAFgEAAAgDQAAiAQAACANAAAIBgAA4AUAAAgGAAAoBgAAYA0AAFAGAACIDQAAiA0AACANAABQBgAAcAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKEcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAgAAA0AAAAOAAAADwAAABAAAAADAAAAAQAAAAEAAAABAAAAAAAAAGgIAAANAAAAEQAAAA8AAAAQAAAAAwAAAAIAAAACAAAAAgAAAAAAAAB4CAAAAQAAAAIAAAADAAAABAAAAAEAAAACAAAAAwAAABIAAAATAAAAAAAAAIgIAAABAAAAAgAAAAMAAAAEAAAAAQAAAAIAAAADAAAAEgAAABQAAAAAAAAAkAgAAAEAAAACAAAAAwAAAAQAAAAEAAAAAgAAAAUAAAASAAAAFQAAAAAAAACgCAAAAQAAAAIAAAADAAAABAAAAAYAAAACAAAAAwAAABIAAAAWAAAAAAAAALAIAAAFAAAAAgAAAAMAAAAEAAAABwAAAAgAAAADAAAAEgAAABcAAAAAAAAAwAgAAAYAAAACAAAAAwAAAAQAAAAJAAAACgAAAAMAAAASAAAAGAAAAAAAAADQCAAAAQAAAAIAAAADAAAABAAAAAsAAAACAAAADAAAABIAAAAZAAAAAAAAAOAIAAABAAAAAgAAAAMAAAAEAAAADQAAAAIAAAADAAAAEgAAABoAAAAAAAAA8AgAAAcAAAAIAAAACQAAAAoAAAAOAAAADwAAAAMAAAASAAAAGwAAAAAAAAAACQAAAQAAAAIAAAADAAAABAAAABAAAAACAAAAAwAAABIAAAAcAAAAAAAAABAJAAABAAAAAgAAAAMAAAAEAAAAEQAAAAIAAAADAAAAEgAAAB0AAAAAAAAAIAkAAAEAAAACAAAAAwAAAAQAAAASAAAAAgAAAAMAAAASAAAAHgAAAAAAAAAwCQAAAQAAAAIAAAADAAAABAAAABMAAAACAAAAAwAAABIAAAAfAAAAAAAAAEAJAAABAAAAAgAAAAMAAAAEAAAAFAAAAAIAAAADAAAAEgAAACAAAAAAAAAAUAkAAAEAAAACAAAAAwAAAAQAAAAVAAAAAgAAAAMAAAASAAAAIQAAAAAAAABgCQAAAQAAAAIAAAADAAAABAAAABYAAAACAAAAAwAAABIAAAAiAAAAAAAAAHAJAAABAAAAAgAAAAMAAAAEAAAAFwAAAAIAAAADAAAAEgAAACMAAAAAAAAAgAkAAAEAAAACAAAAAwAAAAQAAAAYAAAAAgAAAAMAAAASAAAAJAAAAAAAAACQCQAAAQAAAAIAAAADAAAABAAAABkAAAACAAAAAwAAABIAAAAlAAAAAAAAAKAJAAABAAAAAgAAAAMAAAAEAAAAGgAAAAIAAAADAAAAEgAAACYAAAAAAAAAsAkAAAEAAAACAAAAAwAAAAQAAAAbAAAAAgAAAAMAAAASAAAAJwAAAAAAAADACQAAAQAAAAIAAAADAAAABAAAABwAAAACAAAAAwAAABIAAAAoAAAAAAAAANAJAAABAAAAAgAAAAMAAAAEAAAAHQAAAAIAAAADAAAAEgAAACkAAAAAAAAA4AkAAAEAAAACAAAAAwAAAAQAAAAeAAAAAgAAAAMAAAASAAAAKgAAAAAAAADwCQAAAQAAAAIAAAADAAAABAAAAB8AAAACAAAAAwAAABIAAAArAAAAAAAAAAAKAAABAAAAAgAAAAMAAAAEAAAAIAAAAAIAAAADAAAAEgAAACwAAAAAAAAAEAoAAAEAAAACAAAAAwAAAAQAAAAhAAAAAgAAAAMAAAASAAAALQAAAAAAAAAgCgAAAQAAAAIAAAADAAAABAAAACIAAAACAAAAAwAAABIAAAAuAAAAAAAAADAKAAABAAAAAgAAAAMAAAAEAAAAIwAAAAIAAAAkAAAAEgAAAC8AAAAAAAAAQAoAAAEAAAACAAAAAwAAAAQAAAAlAAAAAgAAAAMAAAASAAAAMAAAAAAAAABQCgAAAQAAAAIAAAADAAAABAAAACYAAAACAAAAAwAAABIAAAAxAAAAAAAAAGAKAAABAAAAAgAAAAMAAAAEAAAAJwAAAAIAAAAoAAAAEgAAADIAAAAAAAAAcAoAAAEAAAACAAAAAwAAAAQAAAApAAAAAgAAAAMAAAASAAAAMwAAAAAAAACACgAAAQAAAAIAAAADAAAABAAAACoAAAACAAAAAwAAABIAAAA0AAAAAAAAAJAKAAABAAAAAgAAAAMAAAAEAAAAKwAAAAIAAAADAAAAEgAAADUAAAAAAAAAoAoAAAEAAAACAAAAAwAAAAQAAAAsAAAAAgAAAC0AAAASAAAANgAAAAAAAACwCgAAAQAAAAIAAAADAAAABAAAAC4AAAACAAAAAwAAABIAAAA3AAAAAAAAAMAKAAABAAAAAgAAAAMAAAAEAAAALwAAAAIAAAADAAAAEgAAADgAAAAAAAAA0AoAAAEAAAACAAAAAwAAAAQAAAAwAAAAAgAAAAMAAAASAAAAOQAAAAAAAADgCgAAAQAAAAIAAAADAAAABAAAADEAAAACAAAAAwAAABIAAAA6AAAAAAAAAPAKAAABAAAAAgAAAAMAAAAEAAAAMgAAAAIAAAADAAAAEgAAADsAAAAAAAAAAAsAAAEAAAACAAAAAwAAAAQAAAAzAAAAAgAAAAMAAAASAAAAPAAAAAAAAAAQCwAAAQAAAAIAAAADAAAABAAAADQAAAACAAAAAwAAABIAAAA9AAAAAAAAACALAAALAAAADAAAAA0AAAAOAAAANQAAADYAAAADAAAAEgAAAD4AAAAAAAAAMAsAAAEAAAACAAAAAwAAAAQAAAA3AAAAAgAAAAMAAAASAAAAPwAAAAAAAABACwAAAQAAAAIAAAADAAAABAAAADgAAAACAAAAOQAAABIAAABAAAAAAAAAAFALAAABAAAAAgAAAAMAAAAEAAAAOgAAAAIAAAADAAAAEgAAAEEAAAAAAAAAYAsAAAEAAAACAAAAAwAAAAQAAAA7AAAAAgAAAAMAAAASAAAAQgAAAAAAAABwCwAAAQAAAAIAAAADAAAABAAAADwAAAACAAAAAwAAABIAAABDAAAAAAAAAIALAAABAAAAAgAAAAMAAAAEAAAAPQAAAAIAAAADAAAAEgAAAEQAAAAAAAAAkAsAAAEAAAACAAAAAwAAAAQAAAA+AAAAAgAAAAMAAAASAAAARQAAAAAAAACgCwAAAQAAAAIAAAADAAAABAAAAD8AAAACAAAAQAAAABIAAABGAAAAAAAAALALAAABAAAAAgAAAAMAAAAEAAAAQQAAAAIAAABCAAAAEgAAAEcAAAAAAAAAwAsAAA8AAAACAAAAAwAAAAQAAABDAAAARAAAAAMAAAASAAAASAAAAAAAAADQCwAAEAAAABEAAAADAAAABAAAAEUAAABGAAAAAwAAABIAAABJAAAAAAAAAOALAAABAAAAAgAAAAMAAAAEAAAARwAAAAIAAAADAAAAEgAAAEoAAAAAAAAA8AsAAAEAAAACAAAAAwAAAAQAAABIAAAAAgAAAAMAAAASAAAASwAAAAAAAAAADAAAEgAAABMAAAAUAAAABAAAAEkAAABKAAAAAwAAABIAAABMAAAAAAAAABAMAAABAAAAAgAAAAMAAAAEAAAASwAAAAIAAAADAAAAEgAAAE0AAAAAAAAAIAwAAAEAAAACAAAAAwAAAAQAAABMAAAAAgAAAAMAAAASAAAATgAAAAAAAAAwDAAAFQAAAAIAAAAWAAAABAAAAE0AAABOAAAAAwAAABIAAABPAAAAAAAAAEAMAAABAAAAAgAAAAMAAAAEAAAATwAAAAIAAAADAAAAEgAAAFAAAAAAAAAAUAwAAAEAAAACAAAAAwAAAAQAAABQAAAAAgAAAAMAAAASAAAAUQAAAAAAAABgDAAAAQAAAAIAAAADAAAABAAAAFEAAAACAAAAAwAAABIAAABSAAAAAAAAAHAMAAABAAAAAgAAAAMAAAAEAAAAUgAAAAIAAAADAAAAEgAAAFMAAAAAAAAAgAwAABcAAAACAAAAGAAAAAQAAABTAAAAVAAAAAMAAAASAAAAVAAAAAAAAACQDAAAAQAAAAIAAAADAAAABAAAAFUAAAACAAAAAwAAABIAAABVAAAAAAAAAKAMAAABAAAAAgAAAAMAAAAEAAAAVgAAAAIAAAADAAAAEgAAAFYAAAAAAAAAsAwAAFcAAABYAAAABAAAAAAAAADADAAAVwAAAFkAAAAEAAAAAAAAABANAAANAAAAWgAAAA8AAAAQAAAABAAAAAAAAADgDAAADQAAAFsAAAAPAAAAEAAAAAUAAAAAAAAAkA0AAA0AAABcAAAADwAAABAAAAAGAAAAAAAAAKANAAANAAAAXQAAAA8AAAAQAAAAAwAAAAMAAAADAAAAAwAAAENvb3JkaW5hdGUgb3V0c2lkZSBhbGxvd2VkIHJhbmdlAE4xMENsaXBwZXJMaWIxNmNsaXBwZXJFeGNlcHRpb25FAEFkZFBhdGg6IE9wZW4gcGF0aHMgbXVzdCBiZSBzdWJqZWN0LgBVcGRhdGVFZGdlSW50b0FFTDogaW52YWxpZCBjYWxsAEVycm9yOiBQb2x5VHJlZSBzdHJ1Y3QgaXMgbmVlZGVkIGZvciBvcGVuIHBhdGggY2xpcHBpbmcuAERvTWF4aW1hIGVycm9yAHRvUGF0aAB0b1BhdGhzAGZyb21QYXRoAGZyb21QYXRocwBDbGlwVHlwZQBJbnRlcnNlY3Rpb24AVW5pb24ARGlmZmVyZW5jZQBYb3IAUG9seVR5cGUAU3ViamVjdABDbGlwAFBvbHlGaWxsVHlwZQBFdmVuT2RkAE5vblplcm8AUG9zaXRpdmUATmVnYXRpdmUASW50UG9pbnQAeAB5AG5ld0ludFBvaW50AFBhdGgAUGF0aHMASW5pdE9wdGlvbnMAUmV2ZXJzZVNvbHV0aW9uAFN0cmljdGx5U2ltcGxlAFByZXNlcnZlQ29sbGluZWFyAEpvaW5UeXBlAFNxdWFyZQBSb3VuZABNaXRlcgBFbmRUeXBlAENsb3NlZFBvbHlnb24AQ2xvc2VkTGluZQBPcGVuQnV0dABPcGVuU3F1YXJlAE9wZW5Sb3VuZABQb2x5Tm9kZQBjb250b3VyAGNoaWxkcwBnZXRQYXJlbnQAZ2V0TmV4dABpc0hvbGUAaXNPcGVuAGNoaWxkQ291bnQAUG9seU5vZGVzAFBvbHlUcmVlAGdldEZpcnN0AGNsZWFyAHRvdGFsAG9yaWVudGF0aW9uAGFyZWEAcG9pbnRJblBvbHlnb24Ac2ltcGxpZnlQb2x5Z29uAHNpbXBsaWZ5UG9seWdvbnNJbk91dABzaW1wbGlmeVBvbHlnb25zT3ZlcndyaXRlAGNsZWFuUG9seWdvbgBjbGVhblBvbHlnb25zAG1pbmtvd3NraVN1bVBhdGgAbWlua293c2tpU3VtUGF0aHMAbWlua293c2tpRGlmZgBwb2x5VHJlZVRvUGF0aHMAY2xvc2VkUGF0aHNGcm9tUG9seVRyZWUAb3BlblBhdGhzRnJvbVBvbHlUcmVlAHJldmVyc2VQYXRoAHJldmVyc2VQYXRocwBJbnRSZWN0AGxlZnQAdG9wAHJpZ2h0AGJvdHRvbQBDbGlwcGVyQmFzZQBhZGRQYXRoAGFkZFBhdGhzAGdldEJvdW5kcwBwcmVzZXJ2ZUNvbGxpbmVhcgBDbGlwcGVyAGV4ZWN1dGVQYXRocwBleGVjdXRlUGF0aHNXaXRoRmlsbFR5cGVzAGV4ZWN1dGVQb2x5VHJlZQBleGVjdXRlUG9seVRyZWVXaXRoRmlsbFR5cGVzAHJldmVyc2VTb2x1dGlvbgBzdHJpY3RseVNpbXBsZQBDbGlwcGVyT2Zmc2V0AG1pdGVyTGltaXQAYXJjVG9sZXJhbmNlAE4xMENsaXBwZXJMaWIxMUNsaXBwZXJCYXNlRQBOMTBDbGlwcGVyTGliN0NsaXBwZXJFAE4xMENsaXBwZXJMaWI4UG9seU5vZGVFAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAE5TdDNfXzI2dmVjdG9ySU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMyX0VFRUUATlN0M19fMjIwX192ZWN0b3JfYmFzZV9jb21tb25JTGIxRUVFAHZpaWkATlN0M19fMjZ2ZWN0b3JJTlMwX0lOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRU5TM19JUzVfRUVFRQBOU3QzX18yMTNfX3ZlY3Rvcl9iYXNlSU5TXzZ2ZWN0b3JJTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMzX0VFRUVOUzRfSVM2X0VFRUUATjEwZW1zY3JpcHRlbjN2YWxFAGlpaQBOMTBDbGlwcGVyTGliOENsaXBUeXBlRQBOMTBDbGlwcGVyTGliOFBvbHlUeXBlRQBOMTBDbGlwcGVyTGliMTJQb2x5RmlsbFR5cGVFAE4xMENsaXBwZXJMaWI4SW50UG9pbnRFAFBOMTBDbGlwcGVyTGliOEludFBvaW50RQBQS04xMENsaXBwZXJMaWI4SW50UG9pbnRFAGlpAHYAdmkAZGlpAHZpaWQAaWlkZABwdXNoX2JhY2sAcmVzaXplAHNpemUAZ2V0AHNldABQTlN0M19fMjZ2ZWN0b3JJTjEwQ2xpcHBlckxpYjhJbnRQb2ludEVOU185YWxsb2NhdG9ySVMyX0VFRUUAUEtOU3QzX18yNnZlY3RvcklOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRQB2aWlpaQBpaWlpAGlpaWlpAFBOU3QzX18yNnZlY3RvcklOUzBfSU4xMENsaXBwZXJMaWI4SW50UG9pbnRFTlNfOWFsbG9jYXRvcklTMl9FRUVFTlMzX0lTNV9FRUVFAFBLTlN0M19fMjZ2ZWN0b3JJTlMwX0lOMTBDbGlwcGVyTGliOEludFBvaW50RU5TXzlhbGxvY2F0b3JJUzJfRUVFRU5TM19JUzVfRUVFRQBOMTBDbGlwcGVyTGliMTFJbml0T3B0aW9uc0UATjEwQ2xpcHBlckxpYjhKb2luVHlwZUUATjEwQ2xpcHBlckxpYjdFbmRUeXBlRQBQTjEwQ2xpcHBlckxpYjhQb2x5Tm9kZUUAUEtOMTBDbGlwcGVyTGliOFBvbHlOb2RlRQBOU3QzX18yNnZlY3RvcklQTjEwQ2xpcHBlckxpYjhQb2x5Tm9kZUVOU185YWxsb2NhdG9ySVMzX0VFRUUATlN0M19fMjEzX192ZWN0b3JfYmFzZUlQTjEwQ2xpcHBlckxpYjhQb2x5Tm9kZUVOU185YWxsb2NhdG9ySVMzX0VFRUUAUE5TdDNfXzI2dmVjdG9ySVBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBQS05TdDNfXzI2dmVjdG9ySVBOMTBDbGlwcGVyTGliOFBvbHlOb2RlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBOMTBDbGlwcGVyTGliOFBvbHlUcmVlRQBQTjEwQ2xpcHBlckxpYjhQb2x5VHJlZUUAUEtOMTBDbGlwcGVyTGliOFBvbHlUcmVlRQB2aWkAdmlpaWQAdmlpaWlpAE4xMENsaXBwZXJMaWI3SW50UmVjdEUAUE4xMENsaXBwZXJMaWI3SW50UmVjdEUAUEtOMTBDbGlwcGVyTGliN0ludFJlY3RFAFBOMTBDbGlwcGVyTGliMTFDbGlwcGVyQmFzZUUAUEtOMTBDbGlwcGVyTGliMTFDbGlwcGVyQmFzZUUAaWlpaWlpAFBOMTBDbGlwcGVyTGliN0NsaXBwZXJFAFBLTjEwQ2xpcHBlckxpYjdDbGlwcGVyRQBpaWlpaWlpAE4xMENsaXBwZXJMaWIxM0NsaXBwZXJPZmZzZXRFAFBOMTBDbGlwcGVyTGliMTNDbGlwcGVyT2Zmc2V0RQBQS04xMENsaXBwZXJMaWIxM0NsaXBwZXJPZmZzZXRFAC0rICAgMFgweAAobnVsbCkALTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBzdGQ6OndzdHJpbmcAZW1zY3JpcHRlbjo6dmFsAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZyBkb3VibGU+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWVFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQB0ZXJtaW5hdGluZyB3aXRoICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzOiAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzAHRlcm1pbmF0aW5nIHdpdGggJXMgZm9yZWlnbiBleGNlcHRpb24AdGVybWluYXRpbmcAdW5jYXVnaHQAU3Q5ZXhjZXB0aW9uAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAFN0OXR5cGVfaW5mbwBOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZABfWgBfX19aAF9ibG9ja19pbnZva2UAaW52b2NhdGlvbiBmdW5jdGlvbiBmb3IgYmxvY2sgaW4gAHZvaWQAYm9vbABjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAaW50AHVuc2lnbmVkIGludABsb25nAHVuc2lnbmVkIGxvbmcAbG9uZyBsb25nAF9faW50MTI4AHVuc2lnbmVkIF9faW50MTI4AGZsb2F0AGxvbmcgZG91YmxlAF9fZmxvYXQxMjgALi4uAGRlY2ltYWw2NABkZWNpbWFsMTI4AGRlY2ltYWwzMgBkZWNpbWFsMTYAY2hhcjMyX3QAY2hhcjE2X3QAYXV0bwBkZWNsdHlwZShhdXRvKQBzdGQ6Om51bGxwdHJfdABbYWJpOgBdAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwQWJpVGFnQXR0ckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlNE5vZGVFAGFsbG9jYXRvcgBiYXNpY19zdHJpbmcAc3RyaW5nAGlzdHJlYW0Ab3N0cmVhbQBpb3N0cmVhbQBzdGQ6OmFsbG9jYXRvcgBzdGQ6OmJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OmlzdHJlYW0Ac3RkOjpvc3RyZWFtAHN0ZDo6aW9zdHJlYW0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlTcGVjaWFsU3Vic3RpdHV0aW9uRQAgaW1hZ2luYXJ5AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIwUG9zdGZpeFF1YWxpZmllZFR5cGVFACBjb21wbGV4ACkAIAAoACYAJiYATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNSZWZlcmVuY2VUeXBlRQBvYmpjX29iamVjdAAqAGlkPAA+AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTExUG9pbnRlclR5cGVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIwTmFtZVdpdGhUZW1wbGF0ZUFyZ3NFADwALCAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJUZW1wbGF0ZUFyZ3NFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzUGFyYW1ldGVyUGFja0UAd2NoYXJfdABiMEUAYjFFAHUAbAB1bABsbAB1bGwATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVJbnRlZ2VyQ2FzdEV4cHJFACVMYUwATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZGbG9hdExpdGVyYWxJbXBsSWVFRQAlYQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZEVFACVhZgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZkVFAHRydWUAZmFsc2UATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOEJvb2xFeHByRQAtAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE0SW50ZWdlckxpdGVyYWxFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIwVGVtcGxhdGVBcmd1bWVudFBhY2tFAGdzACY9AD0AYWxpZ25vZiAoACwAfgAuKgAvAC89AF4AXj0APT0APj0APD0APDwAPDw9AC09ACo9AC0tACE9ACEAfHwAfAB8PQAtPioAKwArPQArKwAtPgAlACU9AD4+AD4+PQBzaXplb2YgKAB0eXBlaWQgKAB0aHJvdwB0aHJvdyAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOVRocm93RXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJJbml0TGlzdEV4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzTm9kZUFycmF5Tm9kZUUAc2l6ZW9mLi4uICgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNFbmNsb3NpbmdFeHByRQBzaXplb2YuLi4oAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIyUGFyYW1ldGVyUGFja0V4cGFuc2lvbkUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlTaXplb2ZQYXJhbVBhY2tFeHByRQBzdGF0aWNfY2FzdAA+KABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4Q2FzdEV4cHJFAHJlaW50ZXJwcmV0X2Nhc3QAKSA/ICgAKSA6ICgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVDb25kaXRpb25hbEV4cHJFAG5vZXhjZXB0ICgAbncAbmEAcGkAOjpvcGVyYXRvciAAbmV3AFtdAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTdOZXdFeHByRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMVBvc3RmaXhFeHByRQAgLi4uIAAgPSAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVCcmFjZWRSYW5nZUV4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwQnJhY2VkRXhwckUAX0dMT0JBTF9fTgAoYW5vbnltb3VzIG5hbWVzcGFjZSkATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOE5hbWVUeXBlRQApWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOEFycmF5U3Vic2NyaXB0RXhwckUALgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxME1lbWJlckV4cHJFAHNyTgBzcgA6OgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOUdsb2JhbFF1YWxpZmllZE5hbWVFAGRuAG9uAG9wZXJhdG9yJiYAb3BlcmF0b3ImAG9wZXJhdG9yJj0Ab3BlcmF0b3I9AG9wZXJhdG9yKCkAb3BlcmF0b3IsAG9wZXJhdG9yfgBvcGVyYXRvciBkZWxldGVbXQBvcGVyYXRvcioAb3BlcmF0b3IvAG9wZXJhdG9yLz0Ab3BlcmF0b3JeAG9wZXJhdG9yXj0Ab3BlcmF0b3I9PQBvcGVyYXRvcj49AG9wZXJhdG9yPgBvcGVyYXRvcltdAG9wZXJhdG9yPD0Ab3BlcmF0b3I8PABvcGVyYXRvcjw8PQBvcGVyYXRvcjwAb3BlcmF0b3ItAG9wZXJhdG9yLT0Ab3BlcmF0b3IqPQBvcGVyYXRvci0tAG9wZXJhdG9yIG5ld1tdAG9wZXJhdG9yIT0Ab3BlcmF0b3IhAG9wZXJhdG9yIG5ldwBvcGVyYXRvcnx8AG9wZXJhdG9yfABvcGVyYXRvcnw9AG9wZXJhdG9yLT4qAG9wZXJhdG9yKwBvcGVyYXRvcis9AG9wZXJhdG9yKysAb3BlcmF0b3ItPgBvcGVyYXRvcj8Ab3BlcmF0b3IlAG9wZXJhdG9yJT0Ab3BlcmF0b3I+PgBvcGVyYXRvcj4+PQBvcGVyYXRvcjw9PgBvcGVyYXRvciIiIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUxpdGVyYWxPcGVyYXRvckUAb3BlcmF0b3IgZGVsZXRlAG9wZXJhdG9yIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMkNvbnZlcnNpb25PcGVyYXRvclR5cGVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThEdG9yTmFtZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNRdWFsaWZpZWROYW1lRQBkeW5hbWljX2Nhc3QAZGVsZXRlAFtdIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMERlbGV0ZUV4cHJFAGN2ACkoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE0Q29udmVyc2lvbkV4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThDYWxsRXhwckUAY29uc3RfY2FzdABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMFByZWZpeEV4cHJFACkgACAoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwQmluYXJ5RXhwckUAYWEAYW4AYU4AYVMAY20AZHMAZHYAZFYAZW8AZU8AZXEAZ2UAZ3QAbGUAbHMAbFMAbHQAbWkAbUkAbWwAbUwAbmUAb28Ab3IAb1IAcGwAcEwAcm0Ack0AcnMAclMALi4uIAAgLi4uAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThGb2xkRXhwckUAZnAAZkwATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNGdW5jdGlvblBhcmFtRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyNEZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZUUAVHMAc3RydWN0AFR1AHVuaW9uAFRlAGVudW0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjJFbGFib3JhdGVkVHlwZVNwZWZUeXBlRQBTdEwAU3QAc3RkOjoATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZTdGRRdWFsaWZpZWROYW1lRQBEQwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMVN0cnVjdHVyZWRCaW5kaW5nTmFtZUUAVXQAVWwAdkUAJ2xhbWJkYQAnKABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUNsb3N1cmVUeXBlTmFtZUUAJ3VubmFtZWQAJwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNVVubmFtZWRUeXBlTmFtZUUAc3RyaW5nIGxpdGVyYWwATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOUxvY2FsTmFtZUUAc3RkAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyQ3RvckR0b3JOYW1lRQBiYXNpY19pc3RyZWFtAGJhc2ljX29zdHJlYW0AYmFzaWNfaW9zdHJlYW0Ac3RkOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjphbGxvY2F0b3I8Y2hhcj4gPgBzdGQ6OmJhc2ljX2lzdHJlYW08Y2hhciwgc3RkOjpjaGFyX3RyYWl0czxjaGFyPiA+AHN0ZDo6YmFzaWNfb3N0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4Ac3RkOjpiYXNpY19pb3N0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjdFeHBhbmRlZFNwZWNpYWxTdWJzdGl0dXRpb25FAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwTmVzdGVkTmFtZUUAOjoqAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE5UG9pbnRlclRvTWVtYmVyVHlwZUUAWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5QXJyYXlUeXBlRQBEdgAgdmVjdG9yWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMFZlY3RvclR5cGVFAHBpeGVsIHZlY3RvclsATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVQaXhlbFZlY3RvclR5cGVFAGRlY2x0eXBlKABkb3VibGUAdW5zaWduZWQgbG9uZyBsb25nAG9iamNwcm90bwAgY29uc3QAIHZvbGF0aWxlACByZXN0cmljdABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4UXVhbFR5cGVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE3VmVuZG9yRXh0UXVhbFR5cGVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzT2JqQ1Byb3RvTmFtZUUARG8Abm9leGNlcHQARE8ARHcARHgAUkUAT0UAICYAICYmAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyRnVuY3Rpb25UeXBlRQB0aHJvdygATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBEeW5hbWljRXhjZXB0aW9uU3BlY0UAbm9leGNlcHQoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyTm9leGNlcHRTcGVjRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMVNwZWNpYWxOYW1lRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5RG90U3VmZml4RQBVYTllbmFibGVfaWZJAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RnVuY3Rpb25FbmNvZGluZ0UAIFtlbmFibGVfaWY6AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyRW5hYmxlSWZBdHRyRQB0aHJlYWQtbG9jYWwgd3JhcHBlciByb3V0aW5lIGZvciAAcmVmZXJlbmNlIHRlbXBvcmFyeSBmb3IgAGd1YXJkIHZhcmlhYmxlIGZvciAAbm9uLXZpcnR1YWwgdGh1bmsgdG8gAHZpcnR1YWwgdGh1bmsgdG8gAHRocmVhZC1sb2NhbCBpbml0aWFsaXphdGlvbiByb3V0aW5lIGZvciAAY29uc3RydWN0aW9uIHZ0YWJsZSBmb3IgAC1pbi0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjFDdG9yVnRhYmxlU3BlY2lhbE5hbWVFAGNvdmFyaWFudCByZXR1cm4gdGh1bmsgdG8gAHR5cGVpbmZvIG5hbWUgZm9yIAB0eXBlaW5mbyBmb3IgAFZUVCBmb3IgAHZ0YWJsZSBmb3IgAFN0MTFsb2dpY19lcnJvcgBTdDEybGVuZ3RoX2Vycm9yAE4xMF9fY3h4YWJpdjExN19fcGJhc2VfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQB2AERuAGIAYwBoAGEAcwB0AGkAagBtAGYAZABOMTBfX2N4eGFiaXYxMTZfX2VudW1fdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9F";var tempDoublePtr=18976;function demangle(func){return func}function demangleAll(text){var regex=/\b__Z[\w\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e;}if(!err.stack){return "(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}function ___cxa_allocate_exception(size){return _malloc(size)}var ___exception_infos={};function ___exception_addRef(ptr){if(!ptr)return;var info=___exception_infos[ptr];info.refcount++;}function ___exception_deAdjust(adjusted){if(!adjusted||___exception_infos[adjusted])return adjusted;for(var key in ___exception_infos){var ptr=+key;var adj=___exception_infos[ptr].adjusted;var len=adj.length;for(var i=0;i<len;i++){if(adj[i]===adjusted){return ptr}}}return adjusted}function ___cxa_begin_catch(ptr){var info=___exception_infos[ptr];if(info&&!info.caught){info.caught=true;__ZSt18uncaught_exceptionv.uncaught_exceptions--;}if(info)info.rethrown=false;___exception_addRef(___exception_deAdjust(ptr));return ptr}function ___cxa_pure_virtual(){ABORT=true;throw "Pure virtual function called!"}function ___cxa_throw(ptr,type,destructor){___exception_infos[ptr]={ptr:ptr,adjusted:[ptr],type:type,destructor:destructor,refcount:0,caught:false,rethrown:false};if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exceptions=1;}else{__ZSt18uncaught_exceptionv.uncaught_exceptions++;}throw ptr}function ___cxa_uncaught_exceptions(){return __ZSt18uncaught_exceptionv.uncaught_exceptions}function ___gxx_personality_v0(){}var SYSCALLS={buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0;}else{buffer.push(curr);}},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();return low},getZero:function(){SYSCALLS.get();}};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function flush_NO_FILESYSTEM(){var fflush=Module["_fflush"];if(fflush)fflush(0);var buffers=SYSCALLS.buffers;if(buffers[1].length)SYSCALLS.printChar(1,10);if(buffers[2].length)SYSCALLS.printChar(2,10);}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.get(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(stream,HEAPU8[ptr+j]);}ret+=len;}return ret}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return -e.errno}}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i);}embind_charCodes=codes;}var embind_charCodes=undefined;function readLatin1String(ptr){var ret="";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]];}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return "_unknown"}name=name.replace(/[^a-zA-Z0-9_]/g,"$");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return "_"+name}else{return name}}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return new Function("body","return function "+name+"() {\n"+'    "use strict";'+"    return body.apply(this, arguments);\n"+"};\n")(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+"\n"+stack.replace(/^Error(:[^\n]*)?\n/,"");}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else{return this.name+": "+this.message}};return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes;});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError("Mismatched type converter count");}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i]);}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach(function(dt,i){if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt];}else{unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[];}awaitingDependencies[dt].push(function(){typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters);}});}});if(0===unregisteredTypes.length){onComplete(typeConverters);}}function registerType(rawType,registeredInstance,options){options=options||{};if(!("argPackAdvance"in registeredInstance)){throw new TypeError("registerType registeredInstance requires argPackAdvance")}var name=registeredInstance.name;if(!rawType){throwBindingError('type "'+name+'" must have a positive integer typeid pointer');}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else{throwBindingError("Cannot register type '"+name+"' twice");}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(function(cb){cb();});}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(wt){return !!wt},"toWireType":function(destructors,o){return o?trueValue:falseValue},"argPackAdvance":8,"readValueFromPointer":function(pointer){var heap;if(size===1){heap=HEAP8;}else if(size===2){heap=HEAP16;}else if(size===4){heap=HEAP32;}else{throw new TypeError("Unknown boolean type size: "+name)}return this["fromWireType"](heap[pointer>>shift])},destructorFunction:null});}function ClassHandle_isAliasOf(other){if(!(this instanceof ClassHandle)){return false}if(!(other instanceof ClassHandle)){return false}var leftClass=this.$$.ptrType.registeredClass;var left=this.$$.ptr;var rightClass=other.$$.ptrType.registeredClass;var right=other.$$.ptr;while(leftClass.baseClass){left=leftClass.upcast(left);leftClass=leftClass.baseClass;}while(rightClass.baseClass){right=rightClass.upcast(right);rightClass=rightClass.baseClass;}return leftClass===rightClass&&left===right}function shallowCopyInternalPointer(o){return {count:o.count,deleteScheduled:o.deleteScheduled,preservePointerOnDelete:o.preservePointerOnDelete,ptr:o.ptr,ptrType:o.ptrType,smartPtr:o.smartPtr,smartPtrType:o.smartPtrType}}function throwInstanceAlreadyDeleted(obj){function getInstanceTypeName(handle){return handle.$$.ptrType.registeredClass.name}throwBindingError(getInstanceTypeName(obj)+" instance already deleted");}var finalizationGroup=false;function detachFinalizer(handle){}function runDestructor($$){if($$.smartPtr){$$.smartPtrType.rawDestructor($$.smartPtr);}else{$$.ptrType.registeredClass.rawDestructor($$.ptr);}}function releaseClassHandle($$){$$.count.value-=1;var toDelete=0===$$.count.value;if(toDelete){runDestructor($$);}}function attachFinalizer(handle){if("undefined"===typeof FinalizationGroup){attachFinalizer=function(handle){return handle};return handle}finalizationGroup=new FinalizationGroup(function(iter){for(var result=iter.next();!result.done;result=iter.next()){var $$=result.value;if(!$$.ptr){console.warn("object already deleted: "+$$.ptr);}else{releaseClassHandle($$);}}});attachFinalizer=function(handle){finalizationGroup.register(handle,handle.$$,handle.$$);return handle};detachFinalizer=function(handle){finalizationGroup.unregister(handle.$$);};return attachFinalizer(handle)}function ClassHandle_clone(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.preservePointerOnDelete){this.$$.count.value+=1;return this}else{var clone=attachFinalizer(Object.create(Object.getPrototypeOf(this),{$$:{value:shallowCopyInternalPointer(this.$$)}}));clone.$$.count.value+=1;clone.$$.deleteScheduled=false;return clone}}function ClassHandle_delete(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}detachFinalizer(this);releaseClassHandle(this.$$);if(!this.$$.preservePointerOnDelete){this.$$.smartPtr=undefined;this.$$.ptr=undefined;}}function ClassHandle_isDeleted(){return !this.$$.ptr}var delayFunction=undefined;var deletionQueue=[];function flushPendingDeletes(){while(deletionQueue.length){var obj=deletionQueue.pop();obj.$$.deleteScheduled=false;obj["delete"]();}}function ClassHandle_deleteLater(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}deletionQueue.push(this);if(deletionQueue.length===1&&delayFunction){delayFunction(flushPendingDeletes);}this.$$.deleteScheduled=true;return this}function init_ClassHandle(){ClassHandle.prototype["isAliasOf"]=ClassHandle_isAliasOf;ClassHandle.prototype["clone"]=ClassHandle_clone;ClassHandle.prototype["delete"]=ClassHandle_delete;ClassHandle.prototype["isDeleted"]=ClassHandle_isDeleted;ClassHandle.prototype["deleteLater"]=ClassHandle_deleteLater;}function ClassHandle(){}var registeredPointers={};function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError("Function '"+humanName+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+proto[methodName].overloadTable+")!");}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc;}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError("Cannot register public name '"+name+"' twice");}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError("Cannot register multiple overloads of a function with the same number of arguments ("+numArguments+")!");}Module[name].overloadTable[numArguments]=value;}else{Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments;}}}function RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast){this.name=name;this.constructor=constructor;this.instancePrototype=instancePrototype;this.rawDestructor=rawDestructor;this.baseClass=baseClass;this.getActualType=getActualType;this.upcast=upcast;this.downcast=downcast;this.pureVirtualFunctions=[];}function upcastPointer(ptr,ptrClass,desiredClass){while(ptrClass!==desiredClass){if(!ptrClass.upcast){throwBindingError("Expected null or instance of "+desiredClass.name+", got an instance of "+ptrClass.name);}ptr=ptrClass.upcast(ptr);ptrClass=ptrClass.baseClass;}return ptr}function constNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function genericPointerToWireType(destructors,handle){var ptr;if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}if(this.isSmartPointer){ptr=this.rawConstructor();if(destructors!==null){destructors.push(this.rawDestructor,ptr);}return ptr}else{return 0}}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(!this.isConst&&handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);if(this.isSmartPointer){if(undefined===handle.$$.smartPtr){throwBindingError("Passing raw pointer to smart pointer is illegal");}switch(this.sharingPolicy){case 0:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else{throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}break;case 1:ptr=handle.$$.smartPtr;break;case 2:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else{var clonedHandle=handle["clone"]();ptr=this.rawShare(ptr,__emval_register(function(){clonedHandle["delete"]();}));if(destructors!==null){destructors.push(this.rawDestructor,ptr);}}break;default:throwBindingError("Unsupporting sharing policy");}}return ptr}function nonConstNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+handle.$$.ptrType.name+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function simpleReadValueFromPointer(pointer){return this["fromWireType"](HEAPU32[pointer>>2])}function RegisteredPointer_getPointee(ptr){if(this.rawGetPointee){ptr=this.rawGetPointee(ptr);}return ptr}function RegisteredPointer_destructor(ptr){if(this.rawDestructor){this.rawDestructor(ptr);}}function RegisteredPointer_deleteObject(handle){if(handle!==null){handle["delete"]();}}function downcastPointer(ptr,ptrClass,desiredClass){if(ptrClass===desiredClass){return ptr}if(undefined===desiredClass.baseClass){return null}var rv=downcastPointer(ptr,ptrClass,desiredClass.baseClass);if(rv===null){return null}return desiredClass.downcast(rv)}function getInheritedInstanceCount(){return Object.keys(registeredInstances).length}function getLiveInheritedInstances(){var rv=[];for(var k in registeredInstances){if(registeredInstances.hasOwnProperty(k)){rv.push(registeredInstances[k]);}}return rv}function setDelayFunction(fn){delayFunction=fn;if(deletionQueue.length&&delayFunction){delayFunction(flushPendingDeletes);}}function init_embind(){Module["getInheritedInstanceCount"]=getInheritedInstanceCount;Module["getLiveInheritedInstances"]=getLiveInheritedInstances;Module["flushPendingDeletes"]=flushPendingDeletes;Module["setDelayFunction"]=setDelayFunction;}var registeredInstances={};function getBasestPointer(class_,ptr){if(ptr===undefined){throwBindingError("ptr should not be undefined");}while(class_.baseClass){ptr=class_.upcast(ptr);class_=class_.baseClass;}return ptr}function getInheritedInstance(class_,ptr){ptr=getBasestPointer(class_,ptr);return registeredInstances[ptr]}function makeClassHandle(prototype,record){if(!record.ptrType||!record.ptr){throwInternalError("makeClassHandle requires ptr and ptrType");}var hasSmartPtrType=!!record.smartPtrType;var hasSmartPtr=!!record.smartPtr;if(hasSmartPtrType!==hasSmartPtr){throwInternalError("Both smartPtrType and smartPtr must be specified");}record.count={value:1};return attachFinalizer(Object.create(prototype,{$$:{value:record}}))}function RegisteredPointer_fromWireType(ptr){var rawPointer=this.getPointee(ptr);if(!rawPointer){this.destructor(ptr);return null}var registeredInstance=getInheritedInstance(this.registeredClass,rawPointer);if(undefined!==registeredInstance){if(0===registeredInstance.$$.count.value){registeredInstance.$$.ptr=rawPointer;registeredInstance.$$.smartPtr=ptr;return registeredInstance["clone"]()}else{var rv=registeredInstance["clone"]();this.destructor(ptr);return rv}}function makeDefaultHandle(){if(this.isSmartPointer){return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:rawPointer,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this,ptr:ptr})}}var actualType=this.registeredClass.getActualType(rawPointer);var registeredPointerRecord=registeredPointers[actualType];if(!registeredPointerRecord){return makeDefaultHandle.call(this)}var toType;if(this.isConst){toType=registeredPointerRecord.constPointerType;}else{toType=registeredPointerRecord.pointerType;}var dp=downcastPointer(rawPointer,this.registeredClass,toType.registeredClass);if(dp===null){return makeDefaultHandle.call(this)}if(this.isSmartPointer){return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp})}}function init_RegisteredPointer(){RegisteredPointer.prototype.getPointee=RegisteredPointer_getPointee;RegisteredPointer.prototype.destructor=RegisteredPointer_destructor;RegisteredPointer.prototype["argPackAdvance"]=8;RegisteredPointer.prototype["readValueFromPointer"]=simpleReadValueFromPointer;RegisteredPointer.prototype["deleteObject"]=RegisteredPointer_deleteObject;RegisteredPointer.prototype["fromWireType"]=RegisteredPointer_fromWireType;}function RegisteredPointer(name,registeredClass,isReference,isConst,isSmartPointer,pointeeType,sharingPolicy,rawGetPointee,rawConstructor,rawShare,rawDestructor){this.name=name;this.registeredClass=registeredClass;this.isReference=isReference;this.isConst=isConst;this.isSmartPointer=isSmartPointer;this.pointeeType=pointeeType;this.sharingPolicy=sharingPolicy;this.rawGetPointee=rawGetPointee;this.rawConstructor=rawConstructor;this.rawShare=rawShare;this.rawDestructor=rawDestructor;if(!isSmartPointer&&registeredClass.baseClass===undefined){if(isConst){this["toWireType"]=constNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}else{this["toWireType"]=nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}}else{this["toWireType"]=genericPointerToWireType;}}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError("Replacing nonexistant public symbol");}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value;}else{Module[name]=value;Module[name].argCount=numArguments;}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(dynCall){var args=[];for(var i=1;i<signature.length;++i){args.push("a"+i);}var name="dynCall_"+signature+"_"+rawFunction;var body="return function "+name+"("+args.join(", ")+") {\n";body+="    return dynCall(rawFunction"+(args.length?", ":"")+args.join(", ")+");\n";body+="};\n";return new Function("dynCall","rawFunction",body)(dynCall,rawFunction)}var fp;if(Module["FUNCTION_TABLE_"+signature]!==undefined){fp=Module["FUNCTION_TABLE_"+signature][rawFunction];}else if(typeof FUNCTION_TABLE!=="undefined"){fp=FUNCTION_TABLE[rawFunction];}else{var dc=Module["dynCall_"+signature];if(dc===undefined){dc=Module["dynCall_"+signature.replace(/f/g,"d")];if(dc===undefined){throwBindingError("No dynCall invoker for signature: "+signature);}}fp=makeDynCaller(dc);}if(typeof fp!=="function"){throwBindingError("unknown function pointer with signature "+signature+": "+rawFunction);}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true;}types.forEach(visit);throw new UnboundTypeError(message+": "+unboundTypes.map(getTypeName).join([", "]))}function __embind_register_class(rawType,rawPointerType,rawConstPointerType,baseClassRawType,getActualTypeSignature,getActualType,upcastSignature,upcast,downcastSignature,downcast,name,destructorSignature,rawDestructor){name=readLatin1String(name);getActualType=embind__requireFunction(getActualTypeSignature,getActualType);if(upcast){upcast=embind__requireFunction(upcastSignature,upcast);}if(downcast){downcast=embind__requireFunction(downcastSignature,downcast);}rawDestructor=embind__requireFunction(destructorSignature,rawDestructor);var legalFunctionName=makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName,function(){throwUnboundTypeError("Cannot construct "+name+" due to unbound types",[baseClassRawType]);});whenDependentTypesAreResolved([rawType,rawPointerType,rawConstPointerType],baseClassRawType?[baseClassRawType]:[],function(base){base=base[0];var baseClass;var basePrototype;if(baseClassRawType){baseClass=base.registeredClass;basePrototype=baseClass.instancePrototype;}else{basePrototype=ClassHandle.prototype;}var constructor=createNamedFunction(legalFunctionName,function(){if(Object.getPrototypeOf(this)!==instancePrototype){throw new BindingError("Use 'new' to construct "+name)}if(undefined===registeredClass.constructor_body){throw new BindingError(name+" has no accessible constructor")}var body=registeredClass.constructor_body[arguments.length];if(undefined===body){throw new BindingError("Tried to invoke ctor of "+name+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(registeredClass.constructor_body).toString()+") parameters instead!")}return body.apply(this,arguments)});var instancePrototype=Object.create(basePrototype,{constructor:{value:constructor}});constructor.prototype=instancePrototype;var registeredClass=new RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast);var referenceConverter=new RegisteredPointer(name,registeredClass,true,false,false);var pointerConverter=new RegisteredPointer(name+"*",registeredClass,false,false,false);var constPointerConverter=new RegisteredPointer(name+" const*",registeredClass,false,true,false);registeredPointers[rawType]={pointerType:pointerConverter,constPointerType:constPointerConverter};replacePublicSymbol(legalFunctionName,constructor);return [referenceConverter,pointerConverter,constPointerConverter]});}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i]);}return array}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr);}}function __embind_register_class_constructor(rawClassType,argCount,rawArgTypesAddr,invokerSignature,invoker,rawConstructor){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);invoker=embind__requireFunction(invokerSignature,invoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName="constructor "+classType.name;if(undefined===classType.registeredClass.constructor_body){classType.registeredClass.constructor_body=[];}if(undefined!==classType.registeredClass.constructor_body[argCount-1]){throw new BindingError("Cannot register multiple constructors with identical number of parameters ("+(argCount-1)+") for class '"+classType.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!")}classType.registeredClass.constructor_body[argCount-1]=function unboundTypeHandler(){throwUnboundTypeError("Cannot construct "+classType.name+" due to unbound types",rawArgTypes);};whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){classType.registeredClass.constructor_body[argCount-1]=function constructor_body(){if(arguments.length!==argCount-1){throwBindingError(humanName+" called with "+arguments.length+" arguments, expected "+(argCount-1));}var destructors=[];var args=new Array(argCount);args[0]=rawConstructor;for(var i=1;i<argCount;++i){args[i]=argTypes[i]["toWireType"](destructors,arguments[i-1]);}var ptr=invoker.apply(null,args);runDestructors(destructors);return argTypes[0]["fromWireType"](ptr)};return []});return []});}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError("new_ called with constructor type "+typeof constructor+" which is not a function")}var dummy=createNamedFunction(constructor.name||"unknownFunctionName",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!=="void";var argsList="";var argsListWired="";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?", ":"")+"arg"+i;argsListWired+=(i!==0?", ":"")+"arg"+i+"Wired";}var invokerFnBody="return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n"+"if (arguments.length !== "+(argCount-2)+") {\n"+"throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount-2)+" args!');\n"+"}\n";if(needsDestructorStack){invokerFnBody+="var destructors = [];\n";}var dtorStack=needsDestructorStack?"destructors":"null";var args1=["throwBindingError","invoker","fn","runDestructors","retType","classParam"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+="var thisWired = classParam.toWireType("+dtorStack+", this);\n";}for(var i=0;i<argCount-2;++i){invokerFnBody+="var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";args1.push("argType"+i);args2.push(argTypes[i+2]);}if(isClassMethodFunc){argsListWired="thisWired"+(argsListWired.length>0?", ":"")+argsListWired;}invokerFnBody+=(returns?"var rv = ":"")+"invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";if(needsDestructorStack){invokerFnBody+="runDestructors(destructors);\n";}else{for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?"thisWired":"arg"+(i-2)+"Wired";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";args1.push(paramName+"_dtor");args2.push(argTypes[i].destructorFunction);}}}if(returns){invokerFnBody+="var ret = retType.fromWireType(rv);\n"+"return ret;\n";}invokerFnBody+="}\n";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function __embind_register_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,context,isPureVirtual){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName=classType.name+"."+methodName;if(isPureVirtual){classType.registeredClass.pureVirtualFunctions.push(methodName);}function unboundTypesHandler(){throwUnboundTypeError("Cannot call "+humanName+" due to unbound types",rawArgTypes);}var proto=classType.registeredClass.instancePrototype;var method=proto[methodName];if(undefined===method||undefined===method.overloadTable&&method.className!==classType.name&&method.argCount===argCount-2){unboundTypesHandler.argCount=argCount-2;unboundTypesHandler.className=classType.name;proto[methodName]=unboundTypesHandler;}else{ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-2]=unboundTypesHandler;}whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){var memberFunction=craftInvokerFunction(humanName,argTypes,classType,rawInvoker,context);if(undefined===proto[methodName].overloadTable){memberFunction.argCount=argCount-2;proto[methodName]=memberFunction;}else{proto[methodName].overloadTable[argCount-2]=memberFunction;}return []});return []});}function validateThis(this_,classType,humanName){if(!(this_ instanceof Object)){throwBindingError(humanName+' with invalid "this": '+this_);}if(!(this_ instanceof classType.registeredClass.constructor)){throwBindingError(humanName+' incompatible with "this" of type '+this_.constructor.name);}if(!this_.$$.ptr){throwBindingError("cannot call emscripten binding method "+humanName+" on deleted object");}return upcastPointer(this_.$$.ptr,this_.$$.ptrType.registeredClass,classType.registeredClass)}function __embind_register_class_property(classType,fieldName,getterReturnType,getterSignature,getter,getterContext,setterArgumentType,setterSignature,setter,setterContext){fieldName=readLatin1String(fieldName);getter=embind__requireFunction(getterSignature,getter);whenDependentTypesAreResolved([],[classType],function(classType){classType=classType[0];var humanName=classType.name+"."+fieldName;var desc={get:function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[getterReturnType,setterArgumentType]);},enumerable:true,configurable:true};if(setter){desc.set=function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[getterReturnType,setterArgumentType]);};}else{desc.set=function(v){throwBindingError(humanName+" is a read-only property");};}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);whenDependentTypesAreResolved([],setter?[getterReturnType,setterArgumentType]:[getterReturnType],function(types){var getterReturnType=types[0];var desc={get:function(){var ptr=validateThis(this,classType,humanName+" getter");return getterReturnType["fromWireType"](getter(getterContext,ptr))},enumerable:true};if(setter){setter=embind__requireFunction(setterSignature,setter);var setterArgumentType=types[1];desc.set=function(v){var ptr=validateThis(this,classType,humanName+" setter");var destructors=[];setter(setterContext,ptr,setterArgumentType["toWireType"](destructors,v));runDestructors(destructors);};}Object.defineProperty(classType.registeredClass.instancePrototype,fieldName,desc);return []});return []});}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle);}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count;}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module["count_emval_handles"]=count_emval_handles;Module["get_first_emval"]=get_first_emval;}function __emval_register(value){switch(value){case undefined:{return 1}case null:{return 2}case true:{return 3}case false:{return 4}default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(handle){var rv=emval_handle_array[handle].value;__emval_decref(handle);return rv},"toWireType":function(destructors,value){return __emval_register(value)},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:null});}function enumReadValueFromPointer(name,shift,signed){switch(shift){case 0:return function(pointer){var heap=signed?HEAP8:HEAPU8;return this["fromWireType"](heap[pointer])};case 1:return function(pointer){var heap=signed?HEAP16:HEAPU16;return this["fromWireType"](heap[pointer>>1])};case 2:return function(pointer){var heap=signed?HEAP32:HEAPU32;return this["fromWireType"](heap[pointer>>2])};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_enum(rawType,name,size,isSigned){var shift=getShiftFromSize(size);name=readLatin1String(name);function ctor(){}ctor.values={};registerType(rawType,{name:name,constructor:ctor,"fromWireType":function(c){return this.constructor.values[c]},"toWireType":function(destructors,c){return c.value},"argPackAdvance":8,"readValueFromPointer":enumReadValueFromPointer(name,shift,isSigned),destructorFunction:null});exposePublicSymbol(name,ctor);}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+" has unknown type "+getTypeName(rawType));}return impl}function __embind_register_enum_value(rawEnumType,name,enumValue){var enumType=requireRegisteredType(rawEnumType,"enum");name=readLatin1String(name);var Enum=enumType.constructor;var Value=Object.create(enumType.constructor.prototype,{value:{value:enumValue},constructor:{value:createNamedFunction(enumType.name+"_"+name,function(){})}});Enum.values[enumValue]=Value;Enum[name]=Value;}function _embind_repr(v){if(v===null){return "null"}var t=typeof v;if(t==="object"||t==="array"||t==="function"){return v.toString()}else{return ""+v}}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this["fromWireType"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this["fromWireType"](HEAPF64[pointer>>3])};default:throw new TypeError("Unknown float type: "+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(value){return value},"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}return value},"argPackAdvance":8,"readValueFromPointer":floatReadValueFromPointer(name,shift),destructorFunction:null});}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError("Cannot call "+name+" due to unbound types",argTypes);},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return []});}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295;}var shift=getShiftFromSize(size);var fromWireType=function(value){return value};if(minRange===0){var bitshift=32-8*size;fromWireType=function(value){return value<<bitshift>>>bitshift};}var isUnsignedType=name.indexOf("unsigned")!=-1;registerType(primitiveType,{name:name,"fromWireType":fromWireType,"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}if(value<minRange||value>maxRange){throw new TypeError('Passing a number "'+_embind_repr(value)+'" from JS side to C/C++ side to an argument of type "'+name+'", which is outside the valid range ['+minRange+", "+maxRange+"]!")}return isUnsignedType?value>>>0:value|0},"argPackAdvance":8,"readValueFromPointer":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null});}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(heap["buffer"],data,size)}name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":decodeMemoryView,"argPackAdvance":8,"readValueFromPointer":decodeMemoryView},{ignoreDuplicateRegistrations:true});}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name==="std::string";registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var str;if(stdStringIsUTF8){var endChar=HEAPU8[value+4+length];var endCharSwap=0;if(endChar!=0){endCharSwap=endChar;HEAPU8[value+4+length]=0;}var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(HEAPU8[currentBytePtr]==0){var stringSegment=UTF8ToString(decodeStartPtr);if(str===undefined)str=stringSegment;else{str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+1;}}if(endCharSwap!=0)HEAPU8[value+4+length]=endCharSwap;}else{var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i]);}str=a.join("");}_free(value);return str},"toWireType":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value);}var getLength;var valueIsOfTypeString=typeof value==="string";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError("Cannot pass non-string to std::string");}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=function(){return lengthBytesUTF8(value)};}else{getLength=function(){return value.length};}var length=getLength();var ptr=_malloc(4+length+1);HEAPU32[ptr>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1);}else{if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits");}HEAPU8[ptr+4+i]=charCode;}}else{for(var i=0;i<length;++i){HEAPU8[ptr+4+i]=value[i];}}}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var getHeap,shift;if(charSize===2){getHeap=function(){return HEAPU16};shift=1;}else if(charSize===4){getHeap=function(){return HEAPU32};shift=2;}registerType(rawType,{name:name,"fromWireType":function(value){var HEAP=getHeap();var length=HEAPU32[value>>2];var a=new Array(length);var start=value+4>>shift;for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAP[start+i]);}_free(value);return a.join("")},"toWireType":function(destructors,value){var HEAP=getHeap();var length=value.length;var ptr=_malloc(4+length*charSize);HEAPU32[ptr>>2]=length;var start=ptr+4>>shift;for(var i=0;i<length;++i){HEAP[start+i]=value.charCodeAt(i);}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,"argPackAdvance":0,"fromWireType":function(){return undefined},"toWireType":function(destructors,o){return undefined}});}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1;}}function __emval_take_value(type,argv){type=requireRegisteredType(type,"_emval_take_value");var v=type["readValueFromPointer"](argv);return __emval_register(v)}function _abort(){Module["abort"]();}function _emscripten_get_heap_size(){return HEAP8.length}function _llvm_trap(){abort("trap!");}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}function abortOnCannotGrowMemory(requestedSize){abort("OOM");}function emscripten_realloc_buffer(size){try{var newBuffer=new ArrayBuffer(size);if(newBuffer.byteLength!=size)return;new Int8Array(newBuffer).set(HEAP8);_emscripten_replace_memory(newBuffer);updateGlobalBufferAndViews(newBuffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();var PAGE_MULTIPLE=16777216;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE);}else{newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT);}}var replacement=emscripten_realloc_buffer(newSize);if(!replacement){return false}return true}embind_init_charCodes();BindingError=Module["BindingError"]=extendError(Error,"BindingError");InternalError=Module["InternalError"]=extendError(Error,"InternalError");init_ClassHandle();init_RegisteredPointer();init_embind();UnboundTypeError=Module["UnboundTypeError"]=extendError(Error,"UnboundTypeError");init_emval();var decodeBase64=typeof atob==="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2);}if(enc4!==64){output=output+String.fromCharCode(chr3);}}while(i<input.length);return output};function intArrayFromBase64(s){try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}var asmGlobalArg={"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Float32Array":Float32Array,"Float64Array":Float64Array};var asmLibraryArg={"a":abort,"b":setTempRet0,"c":getTempRet0,"d":ClassHandle,"e":ClassHandle_clone,"f":ClassHandle_delete,"g":ClassHandle_deleteLater,"h":ClassHandle_isAliasOf,"i":ClassHandle_isDeleted,"j":RegisteredClass,"k":RegisteredPointer,"l":RegisteredPointer_deleteObject,"m":RegisteredPointer_destructor,"n":RegisteredPointer_fromWireType,"o":RegisteredPointer_getPointee,"p":___cxa_allocate_exception,"q":___cxa_begin_catch,"r":___cxa_pure_virtual,"s":___cxa_throw,"t":___cxa_uncaught_exceptions,"u":___exception_addRef,"v":___exception_deAdjust,"w":___gxx_personality_v0,"x":___setErrNo,"y":___syscall140,"z":___syscall146,"A":___syscall6,"B":__embind_register_bool,"C":__embind_register_class,"D":__embind_register_class_constructor,"E":__embind_register_class_function,"F":__embind_register_class_property,"G":__embind_register_emval,"H":__embind_register_enum,"I":__embind_register_enum_value,"J":__embind_register_float,"K":__embind_register_function,"L":__embind_register_integer,"M":__embind_register_memory_view,"N":__embind_register_std_string,"O":__embind_register_std_wstring,"P":__embind_register_void,"Q":__emval_decref,"R":__emval_incref,"S":__emval_register,"T":__emval_take_value,"U":_abort,"V":_embind_repr,"W":_emscripten_get_heap_size,"X":_emscripten_memcpy_big,"Y":_emscripten_resize_heap,"Z":_llvm_trap,"_":abortOnCannotGrowMemory,"$":attachFinalizer,"aa":constNoSmartPtrRawPointerToWireType,"ab":count_emval_handles,"ac":craftInvokerFunction,"ad":createNamedFunction,"ae":demangle,"af":demangleAll,"ag":detachFinalizer,"ah":downcastPointer,"ai":embind__requireFunction,"aj":embind_init_charCodes,"ak":emscripten_realloc_buffer,"al":ensureOverloadTable,"am":enumReadValueFromPointer,"an":exposePublicSymbol,"ao":extendError,"ap":floatReadValueFromPointer,"aq":flushPendingDeletes,"ar":flush_NO_FILESYSTEM,"as":genericPointerToWireType,"at":getBasestPointer,"au":getInheritedInstance,"av":getInheritedInstanceCount,"aw":getLiveInheritedInstances,"ax":getShiftFromSize,"ay":getTypeName,"az":get_first_emval,"aA":heap32VectorToArray,"aB":init_ClassHandle,"aC":init_RegisteredPointer,"aD":init_embind,"aE":init_emval,"aF":integerReadValueFromPointer,"aG":jsStackTrace,"aH":makeClassHandle,"aI":makeLegalFunctionName,"aJ":new_,"aK":nonConstNoSmartPtrRawPointerToWireType,"aL":readLatin1String,"aM":registerType,"aN":releaseClassHandle,"aO":replacePublicSymbol,"aP":requireRegisteredType,"aQ":runDestructor,"aR":runDestructors,"aS":setDelayFunction,"aT":shallowCopyInternalPointer,"aU":simpleReadValueFromPointer,"aV":stackTrace,"aW":throwBindingError,"aX":throwInstanceAlreadyDeleted,"aY":throwInternalError,"aZ":throwUnboundTypeError,"a_":upcastPointer,"a$":validateThis,"ba":whenDependentTypesAreResolved,"bb":tempDoublePtr,"bc":DYNAMICTOP_PTR};// EMSCRIPTEN_START_ASM
  var asm=(/** @suppress {uselessCode} */ function(global,env,buffer) {
  "almost asm";var a=new global.Int8Array(buffer),b=new global.Int16Array(buffer),c=new global.Int32Array(buffer),d=new global.Uint8Array(buffer),e=new global.Uint16Array(buffer),f=new global.Float32Array(buffer),g=new global.Float64Array(buffer),h=env.bb|0,i=env.bc|0,r=global.Math.floor,s=global.Math.abs,t=global.Math.sqrt,u=global.Math.cos,v=global.Math.sin,w=global.Math.tan,x=global.Math.acos,y=global.Math.atan2,z=global.Math.ceil,A=global.Math.imul,B=global.Math.min,C=global.Math.clz32,D=env.a,E=env.b,F=env.c,G=env.d,H=env.e,I=env.f,J=env.g,K=env.h,L=env.i,M=env.j,N=env.k,O=env.l,P=env.m,Q=env.n,R=env.o,S=env.p,T=env.q,U=env.r,V=env.s,W=env.t,X=env.u,Y=env.v,Z=env.w,_=env.x,$=env.y,aa=env.z,ba=env.A,ca=env.B,da=env.C,ea=env.D,fa=env.E,ga=env.F,ha=env.G,ia=env.H,ja=env.I,ka=env.J,la=env.K,ma=env.L,na=env.M,oa=env.N,pa=env.O,qa=env.P,ra=env.Q,sa=env.R,ta=env.S,ua=env.T,va=env.U,wa=env.V,xa=env.W,ya=env.X,za=env.Y,Aa=env.Z,Ba=env._,Ca=env.$,Da=env.aa,Ea=env.ab,Fa=env.ac,Ga=env.ad,Ha=env.ae,Ia=env.af,Ja=env.ag,Ka=env.ah,La=env.ai,Ma=env.aj,Na=env.ak,Oa=env.al,Pa=env.am,Qa=env.an,Ra=env.ao,Sa=env.ap,Ta=env.aq,Ua=env.ar,Va=env.as,Wa=env.at,Xa=env.au,Ya=env.av,Za=env.aw,_a=env.ax,$a=env.ay,ab=env.az,bb=env.aA,cb=env.aB,db=env.aC,eb=env.aD,fb=env.aE,gb=env.aF,hb=env.aG,ib=env.aH,jb=env.aI,kb=env.aJ,lb=env.aK,mb=env.aL,nb=env.aM,ob=env.aN,pb=env.aO,qb=env.aP,rb=env.aQ,sb=env.aR,tb=env.aS,ub=env.aT,vb=env.aU,wb=env.aV,xb=env.aW,yb=env.aX,zb=env.aY,Ab=env.aZ,Bb=env.a_,Cb=env.a$,Db=env.ba,Eb=18992;function Hb(newBuffer){a=new Int8Array(newBuffer);d=new Uint8Array(newBuffer);b=new Int16Array(newBuffer);e=new Uint16Array(newBuffer);c=new Int32Array(newBuffer);f=new Float32Array(newBuffer);g=new Float64Array(newBuffer);buffer=newBuffer;return true}
  // EMSCRIPTEN_START_FUNCS
  function ld(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;d=c[b+80>>2]|0;m=d+32|0;f=b+32|0;e=c[f>>2]|0;f=c[f+4>>2]|0;if((((c[m>>2]|0)==(e|0)?(c[m+4>>2]|0)==(f|0):0)?(l=d+40|0,m=b+40|0,(c[l>>2]|0)==(c[m>>2]|0)?(c[l+4>>2]|0)==(c[m+4>>2]|0):0):0)?(c[d+88>>2]|0)==0:0){n=d;d=7;}else d=4;if((((d|0)==4?(h=c[b+84>>2]|0,m=h+32|0,(c[m>>2]|0)==(e|0)?(c[m+4>>2]|0)==(f|0):0):0)?(l=h+40|0,m=b+40|0,(c[l>>2]|0)==(c[m>>2]|0)?(c[l+4>>2]|0)==(c[m+4>>2]|0):0):0)?(c[h+88>>2]|0)==0:0){n=h;d=7;}do if((d|0)==7?(j=n+76|0,(c[j>>2]|0)!=-2):0){l=n+92|0;m=n+96|0;if((c[l>>2]|0)==(c[m>>2]|0)?!(+g[n+48>>3]==-1.e+40):0)break;k=b+92|0;d=c[k>>2]|0;if((d|0)!=(n|0)&(d|0)!=0){e=b+32|0;do{ed(a,b,d,e);Lc(a,b,d);d=c[k>>2]|0;}while((d|0)!=(n|0)&(d|0)!=0)}f=b+76|0;e=c[f>>2]|0;if((e|0)==-1)if((c[j>>2]|0)==-1){e=b+96|0;f=c[e>>2]|0;h=(f|0)!=0;i=(d|0)!=0;if(!(!(i|h)?(c[a+52>>2]|0)!=(b|0):0)){c[(h?f+92|0:a+52|0)>>2]=d;if(i)c[d+96>>2]=f;c[k>>2]=0;c[e>>2]=0;}d=c[m>>2]|0;e=c[l>>2]|0;f=(d|0)!=0;h=(e|0)!=0;if(!(f|h)?(c[a+52>>2]|0)!=(n|0):0)return;c[(f?d+92|0:a+52|0)>>2]=e;if(h)c[e+96>>2]=d;c[l>>2]=0;c[m>>2]=0;return}else e=0;else if((e|0)>-1)if((c[j>>2]|0)>-1){d=b+32|0;bd(a,b,d)|0;if(!(c[n+64>>2]|0))bd(a,n,d)|0;d=c[f>>2]|0;e=c[j>>2]|0;do if((d|0)!=(e|0))if((d|0)<(e|0)){cd(a,b,n);break}else{cd(a,n,b);break}else{c[f>>2]=-1;c[j>>2]=-1;}while(0);d=b+96|0;e=c[d>>2]|0;f=c[k>>2]|0;h=(e|0)!=0;i=(f|0)!=0;if(!(!(h|i)?(c[a+52>>2]|0)!=(b|0):0)){c[(h?e+92|0:a+52|0)>>2]=f;if(i)c[f+96>>2]=e;c[k>>2]=0;c[d>>2]=0;}d=c[m>>2]|0;e=c[l>>2]|0;f=(d|0)!=0;h=(e|0)!=0;if(!(f|h)?(c[a+52>>2]|0)!=(n|0):0)return;c[(f?d+92|0:a+52|0)>>2]=e;if(h)c[e+96>>2]=d;c[l>>2]=0;c[m>>2]=0;return}else e=1;else e=0;if(c[b+64>>2]|0){a=S(16)|0;Bc(a,7656);V(a|0,1024,9);}if(e){bd(a,b,b+32|0)|0;c[f>>2]=-1;d=c[k>>2]|0;}e=b+96|0;f=c[e>>2]|0;h=(f|0)!=0;i=(d|0)!=0;if(!(!(h|i)?(c[a+52>>2]|0)!=(b|0):0)){c[(h?f+92|0:a+52|0)>>2]=d;if(i)c[d+96>>2]=f;c[k>>2]=0;c[e>>2]=0;}if((c[j>>2]|0)>-1){bd(a,n,b+32|0)|0;c[j>>2]=-1;}d=c[m>>2]|0;e=c[l>>2]|0;f=(d|0)!=0;h=(e|0)!=0;if(!(f|h)?(c[a+52>>2]|0)!=(n|0):0)return;c[(f?d+92|0:a+52|0)>>2]=e;if(h)c[e+96>>2]=d;c[l>>2]=0;c[m>>2]=0;return}while(0);if((c[b+76>>2]|0)>-1)bd(a,b,b+32|0)|0;d=b+96|0;e=c[d>>2]|0;f=b+92|0;h=c[f>>2]|0;i=(e|0)!=0;j=(h|0)!=0;if(!(i|j)?(c[a+52>>2]|0)!=(b|0):0)return;c[(i?e+92|0:a+52|0)>>2]=h;if(j)c[h+96>>2]=e;c[f>>2]=0;c[d>>2]=0;return}function md(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;j=a+8|0;d=c[a>>2]|0;f=d;if((((c[j>>2]|0)-d|0)/12|0)>>>0>=b>>>0)return;k=a+4|0;if(b>>>0>357913941){k=S(8)|0;dk(k,8694);c[k>>2]=7328;V(k|0,3264,87);}g=c[k>>2]|0;h=Zj(b*12|0)|0;e=h+(((g-d|0)/12|0)*12|0)|0;i=e;h=h+(b*12|0)|0;b=g;if((b|0)!=(f|0)){d=b;do{l=e;e=e+-12|0;b=d;d=d+-12|0;c[e>>2]=0;m=l+-8|0;c[m>>2]=0;l=l+-4|0;c[l>>2]=0;c[e>>2]=c[d>>2];g=b+-8|0;c[m>>2]=c[g>>2];b=b+-4|0;c[l>>2]=c[b>>2];c[b>>2]=0;c[g>>2]=0;c[d>>2]=0;}while((d|0)!=(f|0));d=c[a>>2]|0;b=c[k>>2]|0;g=d;c[a>>2]=e;c[k>>2]=i;c[j>>2]=h;if((b|0)!=(g|0))do{e=b;b=b+-12|0;f=c[b>>2]|0;if(f|0){c[e+-8>>2]=f;$j(f);}}while((b|0)!=(g|0))}else{c[a>>2]=i;c[k>>2]=i;c[j>>2]=h;}if(!d)return;$j(d);return}function nd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;f=a+8|0;g=c[a>>2]|0;if((c[f>>2]|0)-g>>4>>>0>=b>>>0)return;h=a+4|0;if(b>>>0>268435455){h=S(8)|0;dk(h,8694);c[h>>2]=7328;V(h|0,3264,87);}d=(c[h>>2]|0)-g|0;e=Zj(b<<4)|0;if((d|0)>0)ax(e|0,g|0,d|0)|0;c[a>>2]=e;c[h>>2]=e+(d>>4<<4);c[f>>2]=e+(b<<4);if(!g)return;$j(g);return}function od(a,b){a=a|0;b=b|0;var d=0,e=0;d=a+4|0;e=c[d>>2]|0;if((e|0)==(c[a+8>>2]|0)){Ge(a,b);return}else{c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];c[e+8>>2]=c[b+8>>2];c[e+12>>2]=c[b+12>>2];c[d>>2]=(c[d>>2]|0)+16;return}}function pd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;j=a+4|0;g=c[j>>2]|0;if((g|0)==(c[a+8>>2]|0)){He(a,b);return}c[g>>2]=0;i=g+4|0;c[i>>2]=0;e=g+8|0;c[e>>2]=0;h=b+4|0;a=(c[h>>2]|0)-(c[b>>2]|0)|0;d=a>>4;if(a|0){if(d>>>0>268435455)gk();f=Zj(a)|0;c[i>>2]=f;c[g>>2]=f;c[e>>2]=f+(d<<4);d=c[b>>2]|0;a=(c[h>>2]|0)-d|0;if((a|0)>0){ax(f|0,d|0,a|0)|0;c[i>>2]=f+(a>>>4<<4);}}c[j>>2]=(c[j>>2]|0)+12;return}function qd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;f=a+8|0;g=c[a>>2]|0;if((c[f>>2]|0)-g>>2>>>0>=b>>>0)return;h=a+4|0;if(b>>>0>1073741823){h=S(8)|0;dk(h,8694);c[h>>2]=7328;V(h|0,3264,87);}d=(c[h>>2]|0)-g|0;e=Zj(b<<2)|0;if((d|0)>0)ax(e|0,g|0,d|0)|0;c[a>>2]=e;c[h>>2]=e+(d>>2<<2);c[f>>2]=e+(b<<2);if(!g)return;$j(g);return}function rd(a,b){a=a|0;b=b|0;var d=0,e=0;d=a+4|0;e=c[d>>2]|0;if((e|0)==(c[a+8>>2]|0)){Ye(a,b);return}else{c[e>>2]=c[b>>2];c[d>>2]=(c[d>>2]|0)+4;return}}function sd(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;m=a+8|0;n=c[m>>2]|0;m=c[m+4>>2]|0;B=b+8|0;u=c[B+4>>2]|0;B=(m|0)<(u|0)|((m|0)==(u|0)?n>>>0<=(c[B>>2]|0)>>>0:0);u=d+8|0;t=c[u>>2]|0;u=c[u+4>>2]|0;s=e+8|0;l=c[s+4>>2]|0;s=(u|0)<(l|0)|((u|0)==(l|0)?t>>>0<=(c[s>>2]|0)>>>0:0);if(!(B^s)){g=0;return g|0}e=c[a+24>>2]|0;l=e+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;i=f;b=c[i>>2]|0;i=c[i+4>>2]|0;do if(B){a:do if(!((l|0)>(i|0)|(l|0)==(i|0)&k>>>0>b>>>0)?(r=f+8|0,q=c[r>>2]|0,r=c[r+4>>2]|0,!((l|0)<(m|0)|(l|0)==(m|0)&k>>>0<n>>>0)):0)while(1){p=e+16|0;if(!((c[p>>2]|0)==(q|0)?(c[p+4>>2]|0)==(r|0):0))break a;l=c[e+24>>2]|0;k=l+8|0;a=c[k>>2]|0;k=c[k+4>>2]|0;if((k|0)>(i|0)|(k|0)==(i|0)&a>>>0>b>>>0){a=e;e=l;break a}p=e+8|0;o=c[p+4>>2]|0;if((k|0)<(o|0)|((k|0)==(o|0)?a>>>0<(c[p>>2]|0)>>>0:0)){a=e;e=l;break}else{a=e;e=l;}}while(0);if(g){r=a+8|0;a=((c[r>>2]|0)==(b|0)?(c[r+4>>2]|0)==(i|0):0)?a:e;}l=Zj(32)|0;e=l+8|0;k=a+8|0;c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];c[e+8>>2]=c[k+8>>2];c[e+12>>2]=c[k+12>>2];k=c[a>>2]|0;c[l>>2]=k;if(g){r=a+28|0;q=c[r>>2]|0;c[l+28>>2]=q;c[l+24>>2]=a;c[q+24>>2]=l;c[r>>2]=l;}else{r=a+24|0;q=c[r>>2]|0;c[l+24>>2]=q;c[l+28>>2]=a;c[q+28>>2]=l;c[r>>2]=l;}r=e;if(((c[r>>2]|0)==(b|0)?(c[r+4>>2]|0)==(i|0):0)?(q=l+16|0,r=f+8|0,(c[q>>2]|0)==(c[r>>2]|0)?(c[q+4>>2]|0)==(c[r+4>>2]|0):0):0){m=l;l=a;break}c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];e=Zj(32)|0;r=e+8|0;c[r>>2]=c[f>>2];c[r+4>>2]=c[f+4>>2];c[r+8>>2]=c[f+8>>2];c[r+12>>2]=c[f+12>>2];c[e>>2]=k;if(g){m=l+28|0;r=c[m>>2]|0;c[e+28>>2]=r;c[e+24>>2]=l;c[r+24>>2]=e;c[m>>2]=e;m=e;break}else{m=l+24|0;r=c[m>>2]|0;c[e+24>>2]=r;c[e+28>>2]=l;c[r+28>>2]=e;c[m>>2]=e;m=e;break}}else{b:do if(!((l|0)<(i|0)|(l|0)==(i|0)&k>>>0<b>>>0)?(p=f+8|0,o=c[p>>2]|0,p=c[p+4>>2]|0,!((l|0)>(m|0)|(l|0)==(m|0)&k>>>0>n>>>0)):0)while(1){r=e+16|0;if(!((c[r>>2]|0)==(o|0)?(c[r+4>>2]|0)==(p|0):0))break b;l=c[e+24>>2]|0;k=l+8|0;a=c[k>>2]|0;k=c[k+4>>2]|0;if((k|0)<(i|0)|(k|0)==(i|0)&a>>>0<b>>>0){a=e;e=l;break b}r=e+8|0;q=c[r+4>>2]|0;if((k|0)>(q|0)|((k|0)==(q|0)?a>>>0>(c[r>>2]|0)>>>0:0)){a=e;e=l;break}else{a=e;e=l;}}while(0);if(!g){r=a+8|0;a=((c[r>>2]|0)==(b|0)?(c[r+4>>2]|0)==(i|0):0)?a:e;}l=Zj(32)|0;e=l+8|0;k=a+8|0;c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];c[e+8>>2]=c[k+8>>2];c[e+12>>2]=c[k+12>>2];k=c[a>>2]|0;c[l>>2]=k;if(g){r=a+24|0;q=c[r>>2]|0;c[l+24>>2]=q;c[l+28>>2]=a;c[q+28>>2]=l;c[r>>2]=l;}else{r=a+28|0;q=c[r>>2]|0;c[l+28>>2]=q;c[l+24>>2]=a;c[q+24>>2]=l;c[r>>2]=l;}r=e;if(((c[r>>2]|0)==(b|0)?(c[r+4>>2]|0)==(i|0):0)?(q=l+16|0,r=f+8|0,(c[q>>2]|0)==(c[r>>2]|0)?(c[q+4>>2]|0)==(c[r+4>>2]|0):0):0){m=l;l=a;break}c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];e=Zj(32)|0;r=e+8|0;c[r>>2]=c[f>>2];c[r+4>>2]=c[f+4>>2];c[r+8>>2]=c[f+8>>2];c[r+12>>2]=c[f+12>>2];c[e>>2]=k;if(g){m=l+24|0;r=c[m>>2]|0;c[e+24>>2]=r;c[e+28>>2]=l;c[r+28>>2]=e;c[m>>2]=e;m=e;break}else{m=l+28|0;r=c[m>>2]|0;c[e+28>>2]=r;c[e+24>>2]=l;c[r+24>>2]=e;c[m>>2]=e;m=e;break}}while(0);e=c[d+24>>2]|0;k=e+8|0;a=c[k>>2]|0;k=c[k+4>>2]|0;do if(s){c:do if(!((k|0)>(i|0)|(k|0)==(i|0)&a>>>0>b>>>0)?(w=f+8|0,v=c[w>>2]|0,w=c[w+4>>2]|0,h=f,j=c[h>>2]|0,h=c[h+4>>2]|0,!((k|0)<(u|0)|(k|0)==(u|0)&a>>>0<t>>>0)):0){a=e;while(1){A=a+16|0;if(!((c[A>>2]|0)==(v|0)?(c[A+4>>2]|0)==(w|0):0)){e=a;j=b;h=i;break c}e=c[a+24>>2]|0;b=e+8|0;d=c[b>>2]|0;b=c[b+4>>2]|0;if((b|0)>(h|0)|(b|0)==(h|0)&d>>>0>j>>>0){d=a;break c}A=a+8|0;z=c[A+4>>2]|0;if((b|0)<(z|0)|((b|0)==(z|0)?d>>>0<(c[A>>2]|0)>>>0:0)){d=a;break}else{d=a;a=e;b=j;i=h;}}}else{j=b;h=i;}while(0);if(g){A=d+8|0;d=((c[A>>2]|0)==(j|0)?(c[A+4>>2]|0)==(h|0):0)?d:e;}i=Zj(32)|0;b=i+8|0;e=d+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=c[e+4>>2];c[b+8>>2]=c[e+8>>2];c[b+12>>2]=c[e+12>>2];e=c[d>>2]|0;c[i>>2]=e;if(g){A=d+28|0;z=c[A>>2]|0;c[i+28>>2]=z;c[i+24>>2]=d;c[z+24>>2]=i;c[A>>2]=i;}else{A=d+24|0;z=c[A>>2]|0;c[i+24>>2]=z;c[i+28>>2]=d;c[z+28>>2]=i;c[A>>2]=i;}A=b;if(((c[A>>2]|0)==(j|0)?(c[A+4>>2]|0)==(h|0):0)?(z=i+16|0,A=f+8|0,(c[z>>2]|0)==(c[A>>2]|0)?(c[z+4>>2]|0)==(c[A+4>>2]|0):0):0){b=i;e=68;break}c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];c[b+8>>2]=c[f+8>>2];c[b+12>>2]=c[f+12>>2];b=Zj(32)|0;A=b+8|0;c[A>>2]=c[f>>2];c[A+4>>2]=c[f+4>>2];c[A+8>>2]=c[f+8>>2];c[A+12>>2]=c[f+12>>2];c[b>>2]=e;if(g){f=i+28|0;A=c[f>>2]|0;c[b+28>>2]=A;c[b+24>>2]=i;c[A+24>>2]=b;c[f>>2]=b;if(B^g){d=i;e=70;break}else{d=i;e=69;break}}else{f=i+24|0;A=c[f>>2]|0;c[b+24>>2]=A;c[b+28>>2]=i;c[A+28>>2]=b;c[f>>2]=b;if(B^g){d=i;e=70;break}else{d=i;e=69;break}}}else{d:do if(!((k|0)<(i|0)|(k|0)==(i|0)&a>>>0<b>>>0)?(y=f+8|0,x=c[y>>2]|0,y=c[y+4>>2]|0,A=f,z=c[A>>2]|0,A=c[A+4>>2]|0,!((k|0)>(u|0)|(k|0)==(u|0)&a>>>0>t>>>0)):0){j=b;h=i;while(1){w=e+16|0;if(!((c[w>>2]|0)==(x|0)?(c[w+4>>2]|0)==(y|0):0))break d;h=c[e+24>>2]|0;b=h+8|0;d=c[b>>2]|0;b=c[b+4>>2]|0;if((b|0)<(A|0)|(b|0)==(A|0)&d>>>0<z>>>0){d=e;e=h;j=z;h=A;break d}w=e+8|0;v=c[w+4>>2]|0;if((b|0)>(v|0)|((b|0)==(v|0)?d>>>0>(c[w>>2]|0)>>>0:0)){d=e;e=h;j=z;h=A;break}else{d=e;e=h;j=z;h=A;}}}else{j=b;h=i;}while(0);if(!g){A=d+8|0;d=((c[A>>2]|0)==(j|0)?(c[A+4>>2]|0)==(h|0):0)?d:e;}i=Zj(32)|0;b=i+8|0;e=d+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=c[e+4>>2];c[b+8>>2]=c[e+8>>2];c[b+12>>2]=c[e+12>>2];e=c[d>>2]|0;c[i>>2]=e;if(g){A=d+24|0;z=c[A>>2]|0;c[i+24>>2]=z;c[i+28>>2]=d;c[z+28>>2]=i;c[A>>2]=i;}else{A=d+28|0;z=c[A>>2]|0;c[i+28>>2]=z;c[i+24>>2]=d;c[z+24>>2]=i;c[A>>2]=i;}A=b;if(((c[A>>2]|0)==(j|0)?(c[A+4>>2]|0)==(h|0):0)?(z=i+16|0,A=f+8|0,(c[z>>2]|0)==(c[A>>2]|0)?(c[z+4>>2]|0)==(c[A+4>>2]|0):0):0){b=i;e=68;break}c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];c[b+8>>2]=c[f+8>>2];c[b+12>>2]=c[f+12>>2];b=Zj(32)|0;A=b+8|0;c[A>>2]=c[f>>2];c[A+4>>2]=c[f+4>>2];c[A+8>>2]=c[f+8>>2];c[A+12>>2]=c[f+12>>2];c[b>>2]=e;if(g){g=i+24|0;f=c[g>>2]|0;c[b+24>>2]=f;c[b+28>>2]=i;c[f+28>>2]=b;c[g>>2]=b;if(B){d=i;e=69;break}else{d=i;e=70;break}}else{g=i+28|0;f=c[g>>2]|0;c[b+28>>2]=f;c[b+24>>2]=i;c[f+24>>2]=b;c[g>>2]=b;if(B){d=i;e=70;break}else{d=i;e=69;break}}}while(0);if((e|0)==68)if(B^g)e=70;else e=69;if((e|0)==69){c[l+28>>2]=d;c[d+24>>2]=l;c[m+24>>2]=b;c[b+28>>2]=m;g=1;return g|0}else if((e|0)==70){c[l+24>>2]=d;c[d+28>>2]=l;c[m+28>>2]=b;c[b+24>>2]=m;g=1;return g|0}return 0}function td(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0;O=Eb;Eb=Eb+32|0;H=O+16|0;I=O;G=c[d>>2]|0;N=d+4|0;A=c[N>>2]|0;M=G+8|0;i=G+16|0;L=i;K=c[L>>2]|0;L=c[L+4>>2]|0;E=d+16|0;D=c[E>>2]|0;E=c[E+4>>2]|0;if(!((K|0)==(D|0)&(L|0)==(E|0))){C=G+24|0;g=c[C>>2]|0;i=g+8|0;h=c[i>>2]|0;i=c[i+4>>2]|0;u=M;t=c[u>>2]|0;u=c[u+4>>2]|0;a:do if((h|0)==(t|0)&(i|0)==(u|0))do{I=g+16|0;if((g|0)==(G|0)|((c[I>>2]|0)!=(K|0)?1:(c[I+4>>2]|0)!=(L|0)))break a;g=c[g+24>>2]|0;I=g+8|0;}while((c[I>>2]|0)==(h|0)?(c[I+4>>2]|0)==(i|0):0);else{h=t;i=u;}while(0);k=g+16|0;j=c[k>>2]|0;k=c[k+4>>2]|0;do if(!((L|0)<(k|0)|(L|0)==(k|0)&K>>>0<j>>>0)){m=g+8|0;l=c[m>>2]|0;m=c[m+4>>2]|0;s=d+8|0;r=c[s>>2]|0;s=c[s+4>>2]|0;I=(a[b+20>>0]|0)==0;n=Ww(K|0,L|0,j|0,k|0)|0;o=F()|0;p=Ww(l|0,m|0,r|0,s|0)|0;q=F()|0;if(I){B=Uw(p|0,q|0,n|0,o|0)|0;I=F()|0;y=Ww(t|0,u|0,l|0,m|0)|0;z=F()|0;H=Ww(j|0,k|0,D|0,E|0)|0;H=Uw(y|0,z|0,H|0,F()|0)|0;if((B|0)==(H|0)&(I|0)==(F()|0)){z=g;B=0;y=0;p=r;q=s;break}else{J=56;break}}else{Q=(o|0)<0;S=_w(n|0,o|0,63)|0;F()|0;w=(q|0)<0;v=_w(p|0,q|0,63)|0;F()|0;v=(S|0)==(v|0);S=Ww(0,0,n|0,o|0)|0;P=F()|0;S=Q?S:n;P=Q?P:o;Q=Ww(0,0,p|0,q|0)|0;n=F()|0;Q=w?Q:p;n=w?n:q;w=Uw(n|0,0,P|0,0)|0;R=F()|0;o=Uw(Q|0,0,S|0,0)|0;y=F()|0;P=Uw(Q|0,0,P|0,0)|0;Q=F()|0;S=Uw(n|0,0,S|0,0)|0;S=Vw(P|0,Q|0,S|0,F()|0)|0;R=Vw(F()|0,0,w|0,R|0)|0;w=F()|0;S=Vw(0,S|0,o|0,y|0)|0;Q=F()|0;o=Vw(R|0,w|0,(Q>>>0<y>>>0|(Q|0)==(y|0)&S>>>0<o>>>0)&1|0,0)|0;y=F()|0;w=(S|0)==0&(Q|0)==0;R=Ww(0,0,S|0,Q|0)|0;P=F()|0;n=Ww(0,0,o|0,y|0)|0;x=F()|0;p=Ww(t|0,u|0,l|0,m|0)|0;l=F()|0;m=Ww(j|0,k|0,D|0,E|0)|0;j=F()|0;B=(l|0)<0;I=_w(p|0,l|0,63)|0;F()|0;k=(j|0)<0;z=_w(m|0,j|0,63)|0;F()|0;z=(I|0)==(z|0);I=Ww(0,0,p|0,l|0)|0;q=F()|0;p=B?I:p;l=B?q:l;q=Ww(0,0,m|0,j|0)|0;B=F()|0;m=k?q:m;j=k?B:j;B=Uw(l|0,0,j|0,0)|0;k=F()|0;q=Uw(p|0,0,m|0,0)|0;I=F()|0;m=Uw(l|0,0,m|0,0)|0;l=F()|0;j=Uw(p|0,0,j|0,0)|0;j=Vw(m|0,l|0,j|0,F()|0)|0;k=Vw(F()|0,0,B|0,k|0)|0;B=F()|0;j=Vw(0,j|0,q|0,I|0)|0;l=F()|0;q=Vw(k|0,B|0,(l>>>0<I>>>0|(l|0)==(I|0)&j>>>0<q>>>0)&1|0,0)|0;I=F()|0;B=(j|0)==0&(l|0)==0;k=Ww(0,0,j|0,l|0)|0;m=F()|0;p=Ww(0,0,q|0,I|0)|0;H=F()|0;if((((v?S:R)|0)==((z?j:k)|0)?((v?Q:P)|0)==((z?l:m)|0):0)&(((v?o:w?n:~o)|0)==((z?q:B?p:~q)|0)?((v?y:w?x:~y)|0)==((z?I:B?H:~I)|0):0)){z=g;B=0;y=1;p=r;q=s;break}else{J=56;break}}}else J=56;while(0);do if((J|0)==56){g=c[G+28>>2]|0;S=g+8|0;b:do if((c[S>>2]|0)==(h|0)?(c[S+4>>2]|0)==(i|0):0)do{S=g+16|0;if((g|0)==(G|0)|((c[S>>2]|0)!=(K|0)?1:(c[S+4>>2]|0)!=(L|0)))break b;g=c[g+28>>2]|0;S=g+8|0;}while((c[S>>2]|0)==(h|0)?(c[S+4>>2]|0)==(i|0):0);while(0);m=g+16|0;l=c[m>>2]|0;m=c[m+4>>2]|0;if((L|0)<(m|0)|(L|0)==(m|0)&K>>>0<l>>>0){S=0;Eb=O;return S|0}o=g+8|0;n=c[o>>2]|0;o=c[o+4>>2]|0;q=d+8|0;p=c[q>>2]|0;q=c[q+4>>2]|0;S=(a[b+20>>0]|0)==0;h=Ww(K|0,L|0,l|0,m|0)|0;i=F()|0;j=Ww(n|0,o|0,p|0,q|0)|0;k=F()|0;if(S){Q=Uw(j|0,k|0,h|0,i|0)|0;S=F()|0;L=Ww(t|0,u|0,n|0,o|0)|0;P=F()|0;R=Ww(l|0,m|0,D|0,E|0)|0;R=Uw(L|0,P|0,R|0,F()|0)|0;if((Q|0)==(R|0)&(S|0)==(F()|0)){z=g;B=1;y=0;break}else g=0;Eb=O;return g|0}else{b=(i|0)<0;r=_w(h|0,i|0,63)|0;F()|0;d=(k|0)<0;I=_w(j|0,k|0,63)|0;F()|0;I=(r|0)==(I|0);r=Ww(0,0,h|0,i|0)|0;v=F()|0;r=b?r:h;v=b?v:i;b=Ww(0,0,j|0,k|0)|0;y=F()|0;b=d?b:j;y=d?y:k;d=Uw(y|0,0,v|0,0)|0;s=F()|0;z=Uw(b|0,0,r|0,0)|0;L=F()|0;v=Uw(b|0,0,v|0,0)|0;b=F()|0;r=Uw(y|0,0,r|0,0)|0;r=Vw(v|0,b|0,r|0,F()|0)|0;s=Vw(F()|0,0,d|0,s|0)|0;d=F()|0;r=Vw(0,r|0,z|0,L|0)|0;b=F()|0;z=Vw(s|0,d|0,(b>>>0<L>>>0|(b|0)==(L|0)&r>>>0<z>>>0)&1|0,0)|0;L=F()|0;d=(r|0)==0&(b|0)==0;s=Ww(0,0,r|0,b|0)|0;v=F()|0;y=Ww(0,0,z|0,L|0)|0;K=F()|0;B=Ww(t|0,u|0,n|0,o|0)|0;w=F()|0;x=Ww(l|0,m|0,D|0,E|0)|0;t=F()|0;Q=(w|0)<0;S=_w(B|0,w|0,63)|0;F()|0;u=(t|0)<0;P=_w(x|0,t|0,63)|0;F()|0;P=(S|0)==(P|0);S=Ww(0,0,B|0,w|0)|0;H=F()|0;B=Q?S:B;w=Q?H:w;H=Ww(0,0,x|0,t|0)|0;Q=F()|0;x=u?H:x;t=u?Q:t;Q=Uw(w|0,0,t|0,0)|0;u=F()|0;H=Uw(B|0,0,x|0,0)|0;S=F()|0;x=Uw(w|0,0,x|0,0)|0;w=F()|0;t=Uw(B|0,0,t|0,0)|0;t=Vw(x|0,w|0,t|0,F()|0)|0;u=Vw(F()|0,0,Q|0,u|0)|0;Q=F()|0;t=Vw(0,t|0,H|0,S|0)|0;w=F()|0;H=Vw(u|0,Q|0,(w>>>0<S>>>0|(w|0)==(S|0)&t>>>0<H>>>0)&1|0,0)|0;S=F()|0;Q=(t|0)==0&(w|0)==0;u=Ww(0,0,t|0,w|0)|0;x=F()|0;B=Ww(0,0,H|0,S|0)|0;R=F()|0;if((((I?r:s)|0)==((P?t:u)|0)?((I?b:v)|0)==((P?w:x)|0):0)&(((I?z:d?y:~z)|0)==((P?H:Q?B:~H)|0)?((I?L:d?K:~L)|0)==((P?S:Q?R:~S)|0):0)){z=g;B=1;y=1;break}else g=0;Eb=O;return g|0}}while(0);w=A+24|0;g=c[w>>2]|0;x=A+8|0;i=g+8|0;h=c[i>>2]|0;i=c[i+4>>2]|0;v=x;b=c[v>>2]|0;v=c[v+4>>2]|0;u=A+16|0;t=c[u>>2]|0;u=c[u+4>>2]|0;c:do if((h|0)==(b|0)&(i|0)==(v|0))do{S=g+16|0;if((g|0)==(A|0)|((c[S>>2]|0)!=(t|0)?1:(c[S+4>>2]|0)!=(u|0)))break c;g=c[g+24>>2]|0;S=g+8|0;}while((c[S>>2]|0)==(h|0)?(c[S+4>>2]|0)==(i|0):0);else{h=b;i=v;}while(0);k=g+16|0;j=c[k>>2]|0;k=c[k+4>>2]|0;do if(!((u|0)<(k|0)|(u|0)==(k|0)&t>>>0<j>>>0)){m=g+8|0;l=c[m>>2]|0;m=c[m+4>>2]|0;n=Ww(t|0,u|0,j|0,k|0)|0;o=F()|0;r=Ww(l|0,m|0,p|0,q|0)|0;s=F()|0;if(!(y<<24>>24)){Q=Uw(r|0,s|0,n|0,o|0)|0;S=F()|0;L=Ww(b|0,v|0,l|0,m|0)|0;P=F()|0;R=Ww(j|0,k|0,D|0,E|0)|0;R=Uw(L|0,P|0,R|0,F()|0)|0;if((Q|0)==(R|0)&(S|0)==(F()|0)){h=0;break}else{J=72;break}}else{U=(o|0)<0;W=_w(n|0,o|0,63)|0;F()|0;d=(s|0)<0;I=_w(r|0,s|0,63)|0;F()|0;I=(W|0)==(I|0);W=Ww(0,0,n|0,o|0)|0;T=F()|0;W=U?W:n;T=U?T:o;U=Ww(0,0,r|0,s|0)|0;o=F()|0;U=d?U:r;o=d?o:s;d=Uw(o|0,0,T|0,0)|0;V=F()|0;r=Uw(U|0,0,W|0,0)|0;L=F()|0;T=Uw(U|0,0,T|0,0)|0;U=F()|0;W=Uw(o|0,0,W|0,0)|0;W=Vw(T|0,U|0,W|0,F()|0)|0;V=Vw(F()|0,0,d|0,V|0)|0;d=F()|0;W=Vw(0,W|0,r|0,L|0)|0;U=F()|0;r=Vw(V|0,d|0,(U>>>0<L>>>0|(U|0)==(L|0)&W>>>0<r>>>0)&1|0,0)|0;L=F()|0;d=(W|0)==0&(U|0)==0;V=Ww(0,0,W|0,U|0)|0;T=F()|0;o=Ww(0,0,r|0,L|0)|0;K=F()|0;s=Ww(b|0,v|0,l|0,m|0)|0;m=F()|0;n=Ww(j|0,k|0,D|0,E|0)|0;k=F()|0;Q=(m|0)<0;S=_w(s|0,m|0,63)|0;F()|0;l=(k|0)<0;P=_w(n|0,k|0,63)|0;F()|0;P=(S|0)==(P|0);S=Ww(0,0,s|0,m|0)|0;H=F()|0;s=Q?S:s;m=Q?H:m;H=Ww(0,0,n|0,k|0)|0;Q=F()|0;n=l?H:n;k=l?Q:k;Q=Uw(m|0,0,k|0,0)|0;l=F()|0;H=Uw(s|0,0,n|0,0)|0;S=F()|0;n=Uw(m|0,0,n|0,0)|0;m=F()|0;k=Uw(s|0,0,k|0,0)|0;k=Vw(n|0,m|0,k|0,F()|0)|0;l=Vw(F()|0,0,Q|0,l|0)|0;Q=F()|0;k=Vw(0,k|0,H|0,S|0)|0;m=F()|0;H=Vw(l|0,Q|0,(m>>>0<S>>>0|(m|0)==(S|0)&k>>>0<H>>>0)&1|0,0)|0;S=F()|0;Q=(k|0)==0&(m|0)==0;l=Ww(0,0,k|0,m|0)|0;n=F()|0;s=Ww(0,0,H|0,S|0)|0;R=F()|0;if((((I?W:V)|0)==((P?k:l)|0)?((I?U:T)|0)==((P?m:n)|0):0)&(((I?r:d?o:~r)|0)==((P?H:Q?s:~H)|0)?((I?L:d?K:~L)|0)==((P?S:Q?R:~S)|0):0)){h=0;break}else{J=72;break}}}else J=72;while(0);do if((J|0)==72){g=c[A+28>>2]|0;W=g+8|0;d:do if((c[W>>2]|0)==(h|0)?(c[W+4>>2]|0)==(i|0):0)do{W=g+16|0;if((g|0)==(A|0)|((c[W>>2]|0)!=(t|0)?1:(c[W+4>>2]|0)!=(u|0)))break d;g=c[g+28>>2]|0;W=g+8|0;}while((c[W>>2]|0)==(h|0)?(c[W+4>>2]|0)==(i|0):0);while(0);m=g+16|0;l=c[m>>2]|0;m=c[m+4>>2]|0;if((u|0)<(m|0)|(u|0)==(m|0)&t>>>0<l>>>0){W=0;Eb=O;return W|0}o=g+8|0;n=c[o>>2]|0;o=c[o+4>>2]|0;j=Ww(t|0,u|0,l|0,m|0)|0;k=F()|0;h=Ww(n|0,o|0,p|0,q|0)|0;i=F()|0;if(!(y<<24>>24)){U=Uw(h|0,i|0,j|0,k|0)|0;W=F()|0;S=Ww(b|0,v|0,n|0,o|0)|0;T=F()|0;V=Ww(l|0,m|0,D|0,E|0)|0;V=Uw(S|0,T|0,V|0,F()|0)|0;if((U|0)==(V|0)&(W|0)==(F()|0)){h=1;break}else g=0;Eb=O;return g|0}else{u=(k|0)<0;s=_w(j|0,k|0,63)|0;F()|0;Q=(i|0)<0;P=_w(h|0,i|0,63)|0;F()|0;P=(s|0)==(P|0);s=Ww(0,0,j|0,k|0)|0;y=F()|0;s=u?s:j;y=u?y:k;u=Ww(0,0,h|0,i|0)|0;d=F()|0;u=Q?u:h;d=Q?d:i;Q=Uw(d|0,0,y|0,0)|0;t=F()|0;J=Uw(u|0,0,s|0,0)|0;S=F()|0;y=Uw(u|0,0,y|0,0)|0;u=F()|0;s=Uw(d|0,0,s|0,0)|0;s=Vw(y|0,u|0,s|0,F()|0)|0;t=Vw(F()|0,0,Q|0,t|0)|0;Q=F()|0;s=Vw(0,s|0,J|0,S|0)|0;u=F()|0;J=Vw(t|0,Q|0,(u>>>0<S>>>0|(u|0)==(S|0)&s>>>0<J>>>0)&1|0,0)|0;S=F()|0;Q=(s|0)==0&(u|0)==0;t=Ww(0,0,s|0,u|0)|0;y=F()|0;d=Ww(0,0,J|0,S|0)|0;R=F()|0;K=Ww(b|0,v|0,n|0,o|0)|0;H=F()|0;I=Ww(l|0,m|0,D|0,E|0)|0;D=F()|0;U=(H|0)<0;W=_w(K|0,H|0,63)|0;F()|0;E=(D|0)<0;T=_w(I|0,D|0,63)|0;F()|0;T=(W|0)==(T|0);W=Ww(0,0,K|0,H|0)|0;L=F()|0;K=U?W:K;H=U?L:H;L=Ww(0,0,I|0,D|0)|0;U=F()|0;I=E?L:I;D=E?U:D;U=Uw(H|0,0,D|0,0)|0;E=F()|0;L=Uw(K|0,0,I|0,0)|0;W=F()|0;I=Uw(H|0,0,I|0,0)|0;H=F()|0;D=Uw(K|0,0,D|0,0)|0;D=Vw(I|0,H|0,D|0,F()|0)|0;E=Vw(F()|0,0,U|0,E|0)|0;U=F()|0;D=Vw(0,D|0,L|0,W|0)|0;H=F()|0;L=Vw(E|0,U|0,(H>>>0<W>>>0|(H|0)==(W|0)&D>>>0<L>>>0)&1|0,0)|0;W=F()|0;U=(D|0)==0&(H|0)==0;E=Ww(0,0,D|0,H|0)|0;I=F()|0;K=Ww(0,0,L|0,W|0)|0;V=F()|0;if((((P?s:t)|0)==((T?D:E)|0)?((P?u:y)|0)==((T?H:I)|0):0)&(((P?J:Q?d:~J)|0)==((T?L:U?K:~L)|0)?((P?S:Q?R:~S)|0)==((T?W:U?V:~W)|0):0)){h=1;break}else g=0;Eb=O;return g|0}}while(0);if((z|0)==(g|0)|((z|0)==(G|0)|(g|0)==(A|0))){W=0;Eb=O;return W|0}if(!((e|0)!=(f|0)|B^h)){W=0;Eb=O;return W|0}g=Zj(32)|0;W=g+8|0;c[W>>2]=c[M>>2];c[W+4>>2]=c[M+4>>2];c[W+8>>2]=c[M+8>>2];c[W+12>>2]=c[M+12>>2];c[g>>2]=c[G>>2];if(B){U=G+28|0;W=c[U>>2]|0;c[g+28>>2]=W;V=g+24|0;c[V>>2]=G;c[W+24>>2]=g;c[U>>2]=g;W=Zj(32)|0;T=W+8|0;c[T>>2]=c[x>>2];c[T+4>>2]=c[x+4>>2];c[T+8>>2]=c[x+8>>2];c[T+12>>2]=c[x+12>>2];c[W>>2]=c[A>>2];T=c[w>>2]|0;c[W+24>>2]=T;c[T+28>>2]=W;c[U>>2]=A;c[w>>2]=G;c[V>>2]=W;c[W+28>>2]=g;c[N>>2]=g;W=1;Eb=O;return W|0}else{W=c[C>>2]|0;c[g+24>>2]=W;V=g+28|0;c[V>>2]=G;c[W+28>>2]=g;c[C>>2]=g;W=Zj(32)|0;U=W+8|0;c[U>>2]=c[x>>2];c[U+4>>2]=c[x+4>>2];c[U+8>>2]=c[x+8>>2];c[U+12>>2]=c[x+12>>2];c[W>>2]=c[A>>2];U=A+28|0;T=c[U>>2]|0;c[W+28>>2]=T;c[T+24>>2]=W;c[C>>2]=A;c[U>>2]=G;c[V>>2]=W;c[W+24>>2]=g;c[N>>2]=g;W=1;Eb=O;return W|0}}m=d+8|0;l=c[m>>2]|0;m=c[m+4>>2]|0;W=M;if((((l|0)==(c[W>>2]|0)?(m|0)==(c[W+4>>2]|0):0)?(o=A+8|0,W=o,(l|0)==(c[W>>2]|0)?(m|0)==(c[W+4>>2]|0):0):0)?(n=A+16|0,W=n,(K|0)==(c[W>>2]|0)?(L|0)==(c[W+4>>2]|0):0):0){if((e|0)!=(f|0)){W=0;Eb=O;return W|0}k=G+24|0;g=c[k>>2]|0;if((g|0)==(G|0)){g=L;h=K;}else{h=g;while(1){W=h+8|0;g=h+16|0;if(!((c[W>>2]|0)==(l|0)?(c[W+4>>2]|0)==(m|0):0))break;W=g;if(!((c[W>>2]|0)==(K|0)?(c[W+4>>2]|0)==(L|0):0)){J=12;break}g=c[h+24>>2]|0;if((g|0)==(G|0)){g=i;break}else h=g;}if((J|0)==12)g=h+16|0;h=g;g=c[h+4>>2]|0;h=c[h>>2]|0;}j=(g|0)>(L|0)|(g|0)==(L|0)&h>>>0>K>>>0;i=A+24|0;g=c[i>>2]|0;if((g|0)==(A|0)){if(!j){W=0;Eb=O;return W|0}}else{h=g;while(1){W=h+8|0;g=h+16|0;if(!((c[W>>2]|0)==(l|0)?(c[W+4>>2]|0)==(m|0):0))break;W=g;if(!((c[W>>2]|0)==(K|0)?(c[W+4>>2]|0)==(L|0):0)){J=20;break}g=c[h+24>>2]|0;if((g|0)==(A|0)){g=n;break}else h=g;}if((J|0)==20)g=h+16|0;W=g;V=c[W+4>>2]|0;if(!(j^((V|0)>(L|0)|((V|0)==(L|0)?(c[W>>2]|0)>>>0>K>>>0:0)))){W=0;Eb=O;return W|0}}g=Zj(32)|0;W=g+8|0;c[W>>2]=c[M>>2];c[W+4>>2]=c[M+4>>2];c[W+8>>2]=c[M+8>>2];c[W+12>>2]=c[M+12>>2];c[g>>2]=c[G>>2];if(j){U=G+28|0;W=c[U>>2]|0;c[g+28>>2]=W;V=g+24|0;c[V>>2]=G;c[W+24>>2]=g;c[U>>2]=g;W=Zj(32)|0;T=W+8|0;c[T>>2]=c[o>>2];c[T+4>>2]=c[o+4>>2];c[T+8>>2]=c[o+8>>2];c[T+12>>2]=c[o+12>>2];c[W>>2]=c[A>>2];T=c[i>>2]|0;c[W+24>>2]=T;c[T+28>>2]=W;c[U>>2]=A;c[i>>2]=G;c[V>>2]=W;c[W+28>>2]=g;c[N>>2]=g;W=1;Eb=O;return W|0}else{W=c[k>>2]|0;c[g+24>>2]=W;V=g+28|0;c[V>>2]=G;c[W+28>>2]=g;c[k>>2]=g;W=Zj(32)|0;U=W+8|0;c[U>>2]=c[o>>2];c[U+4>>2]=c[o+4>>2];c[U+8>>2]=c[o+8>>2];c[U+12>>2]=c[o+12>>2];c[W>>2]=c[A>>2];U=A+28|0;T=c[U>>2]|0;c[W+28>>2]=T;c[T+24>>2]=W;c[k>>2]=A;c[U>>2]=G;c[V>>2]=W;c[W+24>>2]=g;c[N>>2]=g;W=1;Eb=O;return W|0}}e=G;while(1){g=c[e+28>>2]|0;W=g+16|0;if((g|0)==(A|0)|((g|0)==(G|0)|((c[W>>2]|0)!=(K|0)?1:(c[W+4>>2]|0)!=(L|0))))break;else e=g;}D=K;E=L;while(1){g=c[G+24>>2]|0;i=g+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;j=(g|0)==(e|0);if((g|0)!=(A|0)&((j|((h|0)!=(D|0)|(i|0)!=(E|0)))^1)){G=g;D=h;E=i;}else break}if(j|(g|0)==(A|0)){W=0;Eb=O;return W|0}g=A+16|0;B=c[g>>2]|0;g=c[g+4>>2]|0;C=A;while(1){h=c[C+28>>2]|0;W=h+16|0;if((h|0)==(G|0)|((h|0)==(A|0)|((c[W>>2]|0)!=(B|0)?1:(c[W+4>>2]|0)!=(g|0))))break;else C=h;}y=B;z=g;while(1){h=c[A+24>>2]|0;j=h+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;k=(h|0)==(C|0);if((h|0)!=(e|0)&((k|((i|0)!=(y|0)|(j|0)!=(z|0)))^1)){A=h;y=i;z=j;}else break}if(k|(h|0)==(e|0)){W=0;Eb=O;return W|0}i=e+8|0;j=i;h=c[j>>2]|0;j=c[j+4>>2]|0;v=G+8|0;l=v;k=c[l>>2]|0;l=c[l+4>>2]|0;w=C+8|0;n=w;m=c[n>>2]|0;n=c[n+4>>2]|0;x=A+8|0;p=x;o=c[p>>2]|0;p=c[p+4>>2]|0;q=(j|0)<(l|0)|(j|0)==(l|0)&h>>>0<k>>>0;r=(n|0)<(p|0)|(n|0)==(p|0)&m>>>0<o>>>0;do if(q)if(r){u=(j|0)<(n|0)|(j|0)==(n|0)&h>>>0<m>>>0;b=(p|0)<(l|0)|(p|0)==(l|0)&o>>>0<k>>>0;s=u?n:j;t=b?p:l;u=u?m:h;b=b?o:k;break}else{u=(j|0)<(p|0)|(j|0)==(p|0)&h>>>0<o>>>0;b=(n|0)<(l|0)|(n|0)==(l|0)&m>>>0<k>>>0;s=u?p:j;t=b?n:l;u=u?o:h;b=b?m:k;break}else if(r){u=(l|0)<(n|0)|(l|0)==(n|0)&k>>>0<m>>>0;b=(p|0)<(j|0)|(p|0)==(j|0)&o>>>0<h>>>0;s=u?n:l;t=b?p:j;u=u?m:k;b=b?o:h;break}else{u=(l|0)<(p|0)|(l|0)==(p|0)&k>>>0<o>>>0;b=(n|0)<(j|0)|(n|0)==(j|0)&m>>>0<h>>>0;s=u?p:l;t=b?n:j;u=u?o:k;b=b?m:h;break}while(0);if(!((s|0)<(t|0)|(s|0)==(t|0)&u>>>0<b>>>0)){W=0;Eb=O;return W|0}do if((j|0)>(t|0)|(j|0)==(t|0)&h>>>0>b>>>0|((j|0)<(s|0)|(j|0)==(s|0)&h>>>0<u>>>0))if((n|0)>(t|0)|(n|0)==(t|0)&m>>>0>b>>>0|((n|0)<(s|0)|(n|0)==(s|0)&m>>>0<u>>>0)){g=(l|0)>(t|0)|(l|0)==(t|0)&k>>>0>b>>>0|((l|0)<(s|0)|(l|0)==(s|0)&k>>>0<u>>>0);j=g?r:q;i=g?x:v;h=g?y:D;g=g?z:E;break}else{j=(n|0)>(p|0)|(n|0)==(p|0)&m>>>0>o>>>0;i=w;h=B;break}else{j=(j|0)>(l|0)|(j|0)==(l|0)&h>>>0>k>>>0;h=K;g=L;}while(0);V=i;U=c[V>>2]|0;V=c[V+4>>2]|0;c[d>>2]=e;c[N>>2]=C;W=I;c[W>>2]=U;c[W+4>>2]=V;W=I+8|0;c[W>>2]=h;c[W+4>>2]=g;c[H>>2]=c[I>>2];c[H+4>>2]=c[I+4>>2];c[H+8>>2]=c[I+8>>2];c[H+12>>2]=c[I+12>>2];W=sd(e,G,C,A,H,j)|0;Eb=O;return W|0}function ud(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;o=c[d+8>>2]|0;e=c[a+44>>2]|0;a=c[a+40>>2]|0;l=a;if((e|0)==(a|0))return;m=b+16|0;n=d+16|0;j=e-a>>2;i=0;do{a=c[l+(i<<2)>>2]|0;k=c[a+16>>2]|0;do if(!((a|0)==(b|0)|((a|0)==(d|0)|(k|0)==0))){g=a+8|0;h=c[g>>2]|0;a:do if(!h)a=0;else{a=h;while(1){if(c[a+16>>2]|0)break a;a=c[a+8>>2]|0;if(!a){a=0;break}}}while(0);if((a|0)==(d|0)|((a|0)==(o|0)|(a|0)==(b|0))){e=c[m>>2]|0;a=k;do{f=uc(a+8|0,e)|0;if((f|0)>-1){p=13;break}a=c[a+24>>2]|0;}while((a|0)!=(k|0));if((p|0)==13?(p=0,(f|0)==0):0){e=c[n>>2]|0;a=k;do{f=uc(a+8|0,e)|0;if((f|0)>-1){p=18;break}a=c[a+24>>2]|0;}while((a|0)!=(k|0));if((p|0)==18?(p=0,(f|0)==0):0){if(!((h|0)==(b|0)|(h|0)==(d|0)))break;c[g>>2]=o;break}c[g>>2]=d;break}c[g>>2]=b;}}while(0);i=i+1|0;}while(i>>>0<j>>>0);return}function vd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=a+144|0;i=a+148|0;e=c[i>>2]|0;d=c[h>>2]|0;b=d;if((e-d|0)>0){g=0;f=e;while(1){e=c[d+(g<<2)>>2]|0;if(!e)e=f;else{Ub[c[(c[e>>2]|0)+4>>2]&127](e);b=c[h>>2]|0;d=b;e=c[i>>2]|0;}g=g+1|0;if((g|0)>=(e-d>>2|0))break;else f=e;}}c[i>>2]=d;h=a+112|0;c[h>>2]=-1;c[h+4>>2]=-1;c[a+128>>2]=3512;if(b|0){c[i>>2]=b;$j(b);}b=c[a+132>>2]|0;if(b|0){c[a+136>>2]=b;$j(b);}b=c[a+52>>2]|0;if(b|0){c[a+56>>2]=b;$j(b);}b=c[a+40>>2]|0;if(b|0){c[a+44>>2]=b;$j(b);}b=c[a+28>>2]|0;if(b|0){c[a+32>>2]=b;$j(b);}f=a+16|0;h=c[f>>2]|0;if(!h)return;g=a+20|0;b=c[g>>2]|0;if((b|0)==(h|0))b=h;else{do{d=b;b=b+-12|0;e=c[b>>2]|0;if(e|0){c[d+-8>>2]=e;$j(e);}}while((b|0)!=(h|0));b=c[f>>2]|0;}c[g>>2]=h;$j(b);return}function wd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=a+144|0;h=a+148|0;d=c[h>>2]|0;b=c[g>>2]|0;if((d-b|0)>0){f=0;e=d;while(1){d=c[b+(f<<2)>>2]|0;if(!d)d=e;else{Ub[c[(c[d>>2]|0)+4>>2]&127](d);b=c[g>>2]|0;d=c[h>>2]|0;}f=f+1|0;if((f|0)>=(d-b>>2|0))break;else e=d;}}c[h>>2]=b;h=a+112|0;c[h>>2]=-1;c[h+4>>2]=-1;return}function xd(a){a=a|0;var b=0;c[a>>2]=3512;b=c[a+16>>2]|0;if(b|0){c[a+20>>2]=b;$j(b);}b=c[a+4>>2]|0;if(!b)return;c[a+8>>2]=b;$j(b);return}function yd(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=Eb;Eb=Eb+16|0;t=v;k=c[d>>2]|0;g=(c[d+4>>2]|0)-k|0;j=(g>>4)+-1|0;if((g|0)<16){Eb=v;return}s=Zj(48)|0;c[s>>2]=3512;u=s+4|0;c[u>>2]=0;c[u+4>>2]=0;c[u+8>>2]=0;c[u+12>>2]=0;c[u+16>>2]=0;c[u+20>>2]=0;c[u+24>>2]=0;c[u+28>>2]=0;a[u+32>>0]=0;c[s+40>>2]=e;c[s+44>>2]=f;r=(f|0)==0;a:do if(f>>>0<2&(g|0)!=16){h=k;g=c[h>>2]|0;h=c[h+4>>2]|0;i=k+8|0;e=j;while(1){p=k+(e<<4)|0;if(!((g|0)==(c[p>>2]|0)?(h|0)==(c[p+4>>2]|0):0))break a;o=i;p=k+(e<<4)+8|0;if(!((c[o>>2]|0)==(c[p>>2]|0)?(c[o+4>>2]|0)==(c[p+4>>2]|0):0))break a;f=e+-1|0;if((e|0)>1)e=f;else{e=f;break}}}else e=j;while(0);n=e+1|0;nd(u,n);f=c[d>>2]|0;o=s+8|0;g=c[o>>2]|0;p=s+12|0;if((g|0)==(c[p>>2]|0))Ge(u,f);else{c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[o>>2]=(c[o>>2]|0)+16;}if((e|0)<1){p=0;e=0;}else{m=1;l=0;e=0;h=c[d>>2]|0;f=c[u>>2]|0;while(1){g=h+(m<<4)|0;j=f+(e<<4)|0;k=g;if(((c[j>>2]|0)==(c[k>>2]|0)?(c[j+4>>2]|0)==(c[k+4>>2]|0):0)?(j=f+(e<<4)+8|0,k=h+(m<<4)+8|0,(c[j>>2]|0)==(c[k>>2]|0)?(c[j+4>>2]|0)==(c[k+4>>2]|0):0):0){i=l;g=h;}else q=15;do if((q|0)==15){q=0;e=e+1|0;f=c[o>>2]|0;if((f|0)==(c[p>>2]|0))Ge(u,g);else{c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[o>>2]=(c[o>>2]|0)+16;}k=c[d>>2]|0;h=k+(m<<4)+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;f=c[u>>2]|0;j=f+(l<<4)+8|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((h|0)>(j|0)|(h|0)==(j|0)&g>>>0>i>>>0)){if(!((g|0)==(i|0)&(h|0)==(j|0))){i=l;g=k;break}i=k+(m<<4)|0;g=c[i+4>>2]|0;j=f+(l<<4)|0;h=c[j+4>>2]|0;if(!((g|0)<(h|0)|((g|0)==(h|0)?(c[i>>2]|0)>>>0<(c[j>>2]|0)>>>0:0))){i=l;g=k;break}}i=e;g=k;}while(0);m=m+1|0;if((m|0)==(n|0)){p=i;break}else{l=i;h=g;}}}if(r&(e|0)<2){Ub[c[(c[s>>2]|0)+4>>2]&127](s);Eb=v;return}g=b+144|0;o=b+148|0;e=c[o>>2]|0;f=e-(c[g>>2]|0)>>2;c[t>>2]=s;if((c[b+152>>2]|0)>>>0>e>>>0){c[e>>2]=s;c[o>>2]=(c[o>>2]|0)+4;}else Ie(g,t);c[s+28>>2]=b+128;c[s+32>>2]=f;if(!r){Eb=v;return}n=b+112|0;t=n;e=c[t>>2]|0;if((c[t+4>>2]|0)<0){t=((c[o>>2]|0)-(c[g>>2]|0)>>2)+-1|0;u=n;c[u>>2]=t;c[u+4>>2]=((t|0)<0)<<31>>31;u=b+120|0;c[u>>2]=p;c[u+4>>2]=((p|0)<0)<<31>>31;Eb=v;return}h=c[b+144>>2]|0;m=b+120|0;l=c[m>>2]|0;k=c[(c[h+(e<<2)>>2]|0)+4>>2]|0;j=k+(l<<4)|0;i=c[j>>2]|0;j=c[j+4>>2]|0;l=k+(l<<4)+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;e=c[u>>2]|0;g=e+(p<<4)+8|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if(!((g|0)>(l|0)|(g|0)==(l|0)&f>>>0>k>>>0)){if(!((f|0)==(k|0)&(g|0)==(l|0))){Eb=v;return}u=e+(p<<4)|0;b=c[u+4>>2]|0;if(!((b|0)<(j|0)|((b|0)==(j|0)?(c[u>>2]|0)>>>0<i>>>0:0))){Eb=v;return}}b=((c[o>>2]|0)-h>>2)+-1|0;u=n;c[u>>2]=b;c[u+4>>2]=((b|0)<0)<<31>>31;u=m;c[u>>2]=p;c[u+4>>2]=((p|0)<0)<<31>>31;Eb=v;return}function zd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;h=b+4|0;f=c[b>>2]|0;if((c[h>>2]|0)==(f|0))return;g=0;do{yd(a,f+(g*12|0)|0,d,e);g=g+1|0;f=c[b>>2]|0;}while(g>>>0<(((c[h>>2]|0)-f|0)/12|0)>>>0);return}function Ad(a){a=a|0;var b=0,d=0,e=0,f=0.0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;u=Eb;Eb=Eb+16|0;t=u;m=a+112|0;d=c[m>>2]|0;m=c[m+4>>2]|0;if((m|0)>-1|(m|0)==-1&d>>>0>4294967295){b=c[a+144>>2]|0;m=c[b+(d<<2)>>2]|0;g=c[m+4>>2]|0;m=(c[m+8>>2]|0)-g|0;e=m>>4;l=b;if((m|0)>=48){k=e+-1|0;i=g+(k<<4)|0;k=g+(k<<4)+8|0;d=0;f=0.0;h=c[i+4>>2]|0;i=c[i>>2]|0;j=c[k+4>>2]|0;k=c[k>>2]|0;do{y=g+(d<<4)|0;x=i;i=c[y>>2]|0;w=h;h=c[y+4>>2]|0;y=g+(d<<4)+8|0;v=k;k=c[y>>2]|0;m=j;j=c[y+4>>2]|0;f=f+(+(x>>>0)+4294967296.0*+(w|0)+(+(i>>>0)+4294967296.0*+(h|0)))*(+(v>>>0)+4294967296.0*+(m|0)-(+(k>>>0)+4294967296.0*+(j|0)));d=d+1|0;}while((d|0)<(e|0));if(!(f*-.5>=0.0)){o=a+144|0;n=a+148|0;d=c[n>>2]|0;if((d-l|0)<=0){Eb=u;return}m=0;a=d;while(1){d=c[b+(m<<2)>>2]|0;switch(c[d+44>>2]|0){case 0:{b=c[d+4>>2]|0;d=c[d+8>>2]|0;s=15;break}case 1:{x=c[d+8>>2]|0;b=c[d+4>>2]|0;y=x-b|0;k=y>>4;d=x;if((y|0)>=48){j=k+-1|0;h=b+(j<<4)|0;j=b+(j<<4)+8|0;e=0;f=0.0;g=c[h+4>>2]|0;h=c[h>>2]|0;i=c[j+4>>2]|0;j=c[j>>2]|0;do{q=b+(e<<4)|0;v=h;h=c[q>>2]|0;w=g;g=c[q+4>>2]|0;q=b+(e<<4)+8|0;x=j;j=c[q>>2]|0;y=i;i=c[q+4>>2]|0;f=f+(+(v>>>0)+4294967296.0*+(w|0)+(+(h>>>0)+4294967296.0*+(g|0)))*(+(x>>>0)+4294967296.0*+(y|0)-(+(j>>>0)+4294967296.0*+(i|0)));e=e+1|0;}while((e|0)<(k|0));if(!(f*-.5>=0.0)){d=l;b=a;}else s=15;}else s=15;break}default:{d=l;b=a;}}if((s|0)==15){s=0;if((b|0)!=(d|0)?(r=d+-16|0,b>>>0<r>>>0):0){d=r;do{c[t>>2]=c[b>>2];c[t+4>>2]=c[b+4>>2];c[t+8>>2]=c[b+8>>2];c[t+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[t>>2];c[d+4>>2]=c[t+4>>2];c[d+8>>2]=c[t+8>>2];c[d+12>>2]=c[t+12>>2];b=b+16|0;d=d+-16|0;}while(b>>>0<d>>>0);d=c[o>>2]|0;b=c[n>>2]|0;}else{d=l;b=a;}}m=m+1|0;if((m|0)>=(b-d>>2|0))break;else{l=d;a=b;b=d;}}Eb=u;return}else d=l;}else d=l;}else{b=c[a+144>>2]|0;d=b;}m=a+144|0;l=a+148|0;e=c[l>>2]|0;if((e-d|0)<=0){Eb=u;return}k=0;while(1){b=c[b+(k<<2)>>2]|0;if((c[b+44>>2]|0)==1?(p=c[b+8>>2]|0,o=c[b+4>>2]|0,y=p-o|0,n=y>>4,(y|0)>=48):0){j=n+-1|0;h=o+(j<<4)|0;j=o+(j<<4)+8|0;b=0;f=0.0;g=c[h+4>>2]|0;h=c[h>>2]|0;i=c[j+4>>2]|0;j=c[j>>2]|0;do{s=o+(b<<4)|0;v=h;h=c[s>>2]|0;w=g;g=c[s+4>>2]|0;s=o+(b<<4)+8|0;x=j;j=c[s>>2]|0;y=i;i=c[s+4>>2]|0;f=f+(+(v>>>0)+4294967296.0*+(w|0)+(+(h>>>0)+4294967296.0*+(g|0)))*(+(x>>>0)+4294967296.0*+(y|0)-(+(j>>>0)+4294967296.0*+(i|0)));b=b+1|0;}while((b|0)<(n|0));if(!(f*-.5>=0.0|(o|0)==(p|0))?(q=p+-16|0,q>>>0>o>>>0):0){b=o;d=q;do{c[t>>2]=c[b>>2];c[t+4>>2]=c[b+4>>2];c[t+8>>2]=c[b+8>>2];c[t+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[t>>2];c[d+4>>2]=c[t+4>>2];c[d+8>>2]=c[t+8>>2];c[d+12>>2]=c[t+12>>2];b=b+16|0;d=d+-16|0;}while(b>>>0<d>>>0);d=c[m>>2]|0;e=c[l>>2]|0;}}k=k+1|0;if((k|0)>=(e-d>>2|0))break;else b=d;}Eb=u;return}function Bd(a){a=a|0;var b=0,d=0,e=0;e=Eb;Eb=Eb+16|0;d=e;b=c[a>>2]|0;a=c[a+4>>2]|0;if((b|0)==(a|0)){Eb=e;return}a=a+-16|0;if(b>>>0>=a>>>0){Eb=e;return}do{c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];c[b>>2]=c[a>>2];c[b+4>>2]=c[a+4>>2];c[b+8>>2]=c[a+8>>2];c[b+12>>2]=c[a+12>>2];c[a>>2]=c[d>>2];c[a+4>>2]=c[d+4>>2];c[a+8>>2]=c[d+8>>2];c[a+12>>2]=c[d+12>>2];b=b+16|0;a=a+-16|0;}while(b>>>0<a>>>0);Eb=e;return}function Cd(b,d,e){b=b|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;U=Eb;Eb=Eb+176|0;M=U+24|0;B=U;D=U+8|0;i=c[d>>2]|0;J=d+4|0;f=c[J>>2]|0;if((f|0)!=(i|0))do{g=f;f=f+-12|0;h=c[f>>2]|0;if(h|0){c[g+-8>>2]=h;$j(h);}}while((f|0)!=(i|0));c[J>>2]=i;Ad(b);Dd(b,e);c[M+24>>2]=0;T=M+28|0;c[T>>2]=0;c[M+32>>2]=0;Q=M+40|0;c[Q>>2]=0;S=M+44|0;c[S>>2]=0;c[M+48>>2]=0;P=M+56|0;c[P>>2]=0;R=M+60|0;c[R>>2]=0;c[M+64>>2]=0;L=M+4|0;c[L>>2]=0;c[L+4>>2]=0;c[L+8>>2]=0;c[L+12>>2]=0;c[M>>2]=3556;I=M+72|0;h=M+112|0;f=I;g=f+36|0;do{c[f>>2]=0;f=f+4|0;}while((f|0)<(g|0));c[h>>2]=h;G=M+116|0;c[G>>2]=h;E=M+120|0;c[E>>2]=0;a[M+128>>0]=0;N=M+20|0;a[N>>0]=0;C=M+140|0;a[C>>0]=0;a[M+142>>0]=0;a[M+36>>0]=0;O=M+37|0;a[O>>0]=0;j=b+16|0;i=b+20|0;f=c[j>>2]|0;a:do if((c[i>>2]|0)!=(f|0)){g=0;h=3556;while(1){Qb[c[h+8>>2]&15](M,f+(g*12|0)|0,0,1)|0;g=g+1|0;f=c[j>>2]|0;if(g>>>0>=(((c[i>>2]|0)-f|0)/12|0)>>>0)break a;h=c[M>>2]|0;}}while(0);if(e>0.0)Oc(M,1,d,2,2)|0;else{f=c[M+8>>2]|0;A=c[M+12>>2]|0;b:do if((f|0)==(A|0)){l=B;c[l>>2]=0;c[l+4>>2]=0;l=0;k=0;b=0;j=0;i=0;h=0;g=0;f=0;}else{z=c[f+8>>2]|0;h=z;i=c[h>>2]|0;h=c[h+4>>2]|0;x=B;c[x>>2]=i;c[x+4>>2]=h;x=z+8|0;v=c[x>>2]|0;x=c[x+4>>2]|0;l=i;k=h;g=v;m=x;j=x;b=v;while(1){y=(j|0)<(x|0)|(j|0)==(x|0)&b>>>0<v>>>0;w=f+12|0;u=z;while(1){q=c[u+88>>2]|0;p=u;n=c[p>>2]|0;p=c[p+4>>2]|0;o=(p|0)<(k|0)|(p|0)==(k|0)&n>>>0<l>>>0;if(!q){n=u;l=o;k=u;}else{t=l;s=k;r=l;l=k;while(1){t=o?n:t;s=o?p:s;r=o?n:r;l=o?p:l;k=(p|0)>(h|0)|(p|0)==(h|0)&n>>>0>i>>>0;i=k?n:i;h=k?p:h;k=c[q+88>>2]|0;V=q;n=c[V>>2]|0;p=c[V+4>>2]|0;o=(p|0)<(l|0)|(p|0)==(l|0)&n>>>0<r>>>0;if(!k)break;else q=k;}n=B;c[n>>2]=t;c[n+4>>2]=s;n=q;l=o;k=q;}s=l?k:B;l=c[s>>2]|0;s=c[s+4>>2]|0;V=B;c[V>>2]=l;c[V+4>>2]=s;V=k;o=c[V>>2]|0;V=c[V+4>>2]|0;t=(h|0)<(V|0)|(h|0)==(V|0)&i>>>0<o>>>0;o=t?o:i;h=t?V:h;V=n+32|0;t=c[V>>2]|0;V=c[V+4>>2]|0;k=(V|0)<(s|0)|(V|0)==(s|0)&t>>>0<l>>>0;l=k?t:l;k=k?V:s;s=B;c[s>>2]=l;c[s+4>>2]=k;s=(h|0)<(V|0)|(h|0)==(V|0)&o>>>0<t>>>0;o=s?t:o;h=s?V:h;V=n+40|0;s=c[V>>2]|0;V=c[V+4>>2]|0;t=(V|0)<(m|0)|(V|0)==(m|0)&s>>>0<g>>>0;g=t?s:g;m=t?V:m;if((u|0)!=(z|0))break;u=c[w>>2]|0;i=o;}b=y?v:b;j=y?x:j;i=f+16|0;if((i|0)==(A|0)){i=o;f=m;break b}z=c[f+24>>2]|0;v=z+8|0;f=i;i=o;x=c[v+4>>2]|0;v=c[v>>2]|0;}}while(0);c[D>>2]=0;A=D+4|0;c[A>>2]=0;w=D+8|0;c[w>>2]=0;m=Zj(64)|0;c[D>>2]=m;B=m+64|0;c[w>>2]=B;c[A>>2]=B;A=Vw(l|0,k|0,-10,-1)|0;B=F()|0;w=Vw(b|0,j|0,10,0)|0;x=F()|0;y=m;c[y>>2]=A;c[y+4>>2]=B;y=m+8|0;c[y>>2]=w;c[y+4>>2]=x;y=Vw(i|0,h|0,10,0)|0;z=F()|0;V=m+16|0;c[V>>2]=y;c[V+4>>2]=z;V=m+24|0;c[V>>2]=w;c[V+4>>2]=x;g=Vw(g|0,f|0,-10,-1)|0;f=F()|0;V=m+32|0;c[V>>2]=y;c[V+4>>2]=z;V=m+40|0;c[V>>2]=g;c[V+4>>2]=f;V=m+48|0;c[V>>2]=A;c[V+4>>2]=B;V=m+56|0;c[V>>2]=g;c[V+4>>2]=f;Ec(M,D,0,1)|0;a[C>>0]=1;Oc(M,1,d,3,3)|0;D=c[J>>2]|0;V=c[d>>2]|0;f=V;g=D;if((D|0)!=(V|0)){h=f+12|0;if((h|0)!=(g|0)){do{i=c[f>>2]|0;if(!i){i=f+8|0;j=f+4|0;}else{j=f+4|0;c[j>>2]=i;$j(i);i=f+8|0;c[i>>2]=0;c[j>>2]=0;c[f>>2]=0;}c[f>>2]=c[h>>2];V=h+4|0;c[j>>2]=c[V>>2];D=h+8|0;c[i>>2]=c[D>>2];c[D>>2]=0;c[V>>2]=0;c[h>>2]=0;h=h+12|0;f=f+12|0;}while((h|0)!=(g|0));g=c[J>>2]|0;if((g|0)!=(f|0))H=32;}else H=32;if((H|0)==32)do{h=g;g=g+-12|0;i=c[g>>2]|0;if(i|0){c[h+-8>>2]=i;$j(i);}}while((g|0)!=(f|0));c[J>>2]=f;}$j(m);}c[M>>2]=3556;g=M+112|0;if(c[E>>2]|0?(K=c[G>>2]|0,V=(c[g>>2]|0)+4|0,J=c[K>>2]|0,c[J+4>>2]=c[V>>2],c[c[V>>2]>>2]=J,c[E>>2]=0,(K|0)!=(g|0)):0){f=K;do{V=f;f=c[f+4>>2]|0;$j(V);}while((f|0)!=(g|0))}f=c[M+96>>2]|0;if(f|0){c[M+100>>2]=f;$j(f);}f=c[M+84>>2]|0;if(f|0){c[M+88>>2]=f;$j(f);}f=c[I>>2]|0;if(f|0){c[M+76>>2]=f;$j(f);}c[M>>2]=3528;b=M+8|0;j=c[b>>2]|0;k=M+12|0;c[k>>2]=j;c[L>>2]=j;j=M+24|0;f=c[T>>2]|0;g=c[j>>2]|0;if((f|0)!=(g|0)){i=0;do{h=c[g+(i<<2)>>2]|0;if(h){ak(h);g=c[j>>2]|0;f=c[T>>2]|0;}i=i+1|0;}while(i>>>0<f-g>>2>>>0);f=g;}c[T>>2]=f;a[N>>0]=0;a[O>>0]=0;f=c[P>>2]|0;if(f|0){c[R>>2]=f;$j(f);}f=c[Q>>2]|0;if(f|0){c[S>>2]=f;$j(f);}f=c[j>>2]|0;if(f|0){c[T>>2]=f;$j(f);}f=c[b>>2]|0;if(!f){Eb=U;return}c[k>>2]=f;$j(f);Eb=U;return}function Dd(a,b){a=a|0;b=+b;var d=0.0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,w=0.0,y=0.0,A=0.0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0.0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0.0;ka=Eb;Eb=Eb+32|0;ga=ka+16|0;ha=ka;ia=a+16|0;i=c[ia>>2]|0;ja=a+20|0;e=c[ja>>2]|0;if((e|0)!=(i|0))do{f=e;e=e+-12|0;h=c[e>>2]|0;if(h|0){c[f+-8>>2]=h;$j(h);}}while((e|0)!=(i|0));c[ja>>2]=i;g[a+64>>3]=b;if(b>-1.0e-20&b<1.0e-20){n=a+144|0;o=a+148|0;md(ia,(c[o>>2]|0)-(c[n>>2]|0)>>2);e=c[n>>2]|0;if(((c[o>>2]|0)-e|0)<=0){Eb=ka;return}p=a+24|0;m=0;a:while(1){e=c[e+(m<<2)>>2]|0;do if(!(c[e+44>>2]|0)){h=e+4|0;q=c[ja>>2]|0;if((q|0)==(c[p>>2]|0)){He(ia,h);break}c[q>>2]=0;l=q+4|0;c[l>>2]=0;i=q+8|0;c[i>>2]=0;j=e+8|0;e=(c[j>>2]|0)-(c[h>>2]|0)|0;f=e>>4;if(e|0){if(f>>>0>268435455){e=13;break a}k=Zj(e)|0;c[l>>2]=k;c[q>>2]=k;c[i>>2]=k+(f<<4);f=c[h>>2]|0;e=(c[j>>2]|0)-f|0;if((e|0)>0){ax(k|0,f|0,e|0)|0;c[l>>2]=k+(e>>>4<<4);}}c[ja>>2]=(c[ja>>2]|0)+12;}while(0);m=m+1|0;e=c[n>>2]|0;if((m|0)>=((c[o>>2]|0)-e>>2|0)){e=153;break}}if((e|0)==13)gk();else if((e|0)==153){Eb=ka;return}}d=+g[a>>3];if(d>2.0)d=2.0/(d*d);else d=.5;g[a+96>>3]=d;_=+g[a+8>>3];A=+s(+b);d=A*.25;_=3.141592653589793/+x(+(1.0-(!(_<=0.0)?(_>d?d:_):.25)/A));A=A*3.141592653589793;_=_>A?A:_;A=6.283185307179586/_;d=+v(+A);$=a+80|0;g[$>>3]=d;A=+u(+A);aa=a+88|0;g[aa>>3]=A;g[a+104>>3]=_/6.283185307179586;if(b<0.0)g[$>>3]=-d;Y=a+144|0;Z=a+148|0;md(ia,(c[Z>>2]|0)-(c[Y>>2]|0)>>1);e=c[Y>>2]|0;if(((c[Z>>2]|0)-e|0)<=0){Eb=ka;return}G=a+28|0;H=a+32|0;I=!(b<=0.0);J=a+40|0;K=a+44|0;L=a+52|0;M=a+56|0;N=a+60|0;O=ga+8|0;P=!(_>=1.0);Q=a+24|0;R=ga+8|0;S=a+48|0;T=ga+8|0;U=ga+8|0;V=ha+8|0;W=a+72|0;X=a+40|0;E=0;b:while(1){D=c[e+(E<<2)>>2]|0;e=D+4|0;if((G|0)!=(e|0))Ze(G,c[e>>2]|0,c[D+8>>2]|0);f=c[G>>2]|0;p=(c[H>>2]|0)-f|0;q=p>>4;c:do if(p|0){if(I){e=c[J>>2]|0;c[K>>2]=e;h=e;if((p|0)==16){d:do if((c[D+40>>2]|0)==1){if(!P){y=0.0;A=1.0;i=f;e=h;h=1;f=0;while(1){C=i;d=A*b+(+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0));d=d+(d<0.0?-.5:.5);C=+s(d)>=1.0?(d>0.0?~~+B(+r(d/4294967296.0),4294967295.0)>>>0:~~+z((d-+(~~d>>>0))/4294967296.0)>>>0):0;D=i+8|0;w=y*b+(+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0));w=w+(w<0.0?-.5:.5);D=+s(w)>=1.0?(w>0.0?~~+B(+r(w/4294967296.0),4294967295.0)>>>0:~~+z((w-+(~~w>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~d>>>0;c[ba+4>>2]=C;ba=T;c[ba>>2]=~~w>>>0;c[ba+4>>2]=D;if(e>>>0<(c[S>>2]|0)>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];c[K>>2]=(c[K>>2]|0)+16;}else _e(J,ga);d=+g[aa>>3];w=+g[$>>3];h=Vw(h|0,f|0,1,0)|0;f=F()|0;if(!(_>=+(h>>>0)+4294967296.0*+(f|0)))break d;la=A*d-y*w;y=y*d+A*w;A=la;i=c[G>>2]|0;e=c[K>>2]|0;}}}else{C=f;A=+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0)-b;A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=f+8|0;la=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)-b;la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~A>>>0;c[ba+4>>2]=C;ba=R;c[ba>>2]=~~la>>>0;c[ba+4>>2]=D;if((c[S>>2]|0)>>>0>h>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];e=(c[K>>2]|0)+16|0;c[K>>2]=e;}else{_e(J,ga);e=c[K>>2]|0;}D=c[G>>2]|0;C=D;A=+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0)+b;A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=D+8|0;la=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)-b;la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~A>>>0;c[ba+4>>2]=C;ba=R;c[ba>>2]=~~la>>>0;c[ba+4>>2]=D;if(e>>>0<(c[S>>2]|0)>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];e=(c[K>>2]|0)+16|0;c[K>>2]=e;}else{_e(J,ga);e=c[K>>2]|0;}D=c[G>>2]|0;C=D;A=+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0)+b;A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=D+8|0;la=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)+b;la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~A>>>0;c[ba+4>>2]=C;ba=R;c[ba>>2]=~~la>>>0;c[ba+4>>2]=D;if(e>>>0<(c[S>>2]|0)>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];e=(c[K>>2]|0)+16|0;c[K>>2]=e;}else{_e(J,ga);e=c[K>>2]|0;}D=c[G>>2]|0;C=D;A=+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0)-b;A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=D+8|0;la=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)+b;la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ba=ga;c[ba>>2]=~~A>>>0;c[ba+4>>2]=C;ba=R;c[ba>>2]=~~la>>>0;c[ba+4>>2]=D;if(e>>>0<(c[S>>2]|0)>>>0){c[e>>2]=c[ga>>2];c[e+4>>2]=c[ga+4>>2];c[e+8>>2]=c[ga+8>>2];c[e+12>>2]=c[ga+12>>2];c[K>>2]=(c[K>>2]|0)+16;}else _e(J,ga);}while(0);ba=c[ja>>2]|0;if((ba|0)==(c[Q>>2]|0)){He(ia,J);break}c[ba>>2]=0;j=ba+4|0;c[j>>2]=0;f=ba+8|0;c[f>>2]=0;e=(c[K>>2]|0)-(c[J>>2]|0)|0;h=e>>4;if(e|0){if(h>>>0>268435455){e=48;break b}i=Zj(e)|0;c[j>>2]=i;c[ba>>2]=i;c[f>>2]=i+(h<<4);e=c[J>>2]|0;f=(c[K>>2]|0)-e|0;if((f|0)>0){ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}}c[ja>>2]=(c[ja>>2]|0)+12;break}}else{if((p|0)<48)break;if(c[D+44>>2]|0)break;c[K>>2]=c[J>>2];}c[M>>2]=c[L>>2];Gd(L,q);e=q+-1|0;C=(p|0)>16;if(C){o=0;do{m=c[G>>2]|0;n=o;o=o+1|0;h=m+(o<<4)|0;f=c[h>>2]|0;h=c[h+4>>2]|0;j=m+(n<<4)|0;i=c[j>>2]|0;j=c[j+4>>2]|0;l=m+(o<<4)+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;n=m+(n<<4)+8|0;m=c[n>>2]|0;n=c[n+4>>2]|0;if((f|0)==(i|0)&(h|0)==(j|0)&((k|0)==(m|0)&(l|0)==(n|0))){c[ga>>2]=0;c[ga+4>>2]=0;c[ga+8>>2]=0;c[ga+12>>2]=0;}else{j=Ww(f|0,h|0,i|0,j|0)|0;la=+(j>>>0)+4294967296.0*+(F()|0);n=Ww(k|0,l|0,m|0,n|0)|0;y=+(n>>>0)+4294967296.0*+(F()|0);A=1.0/+t(+(la*la+y*y));g[ga>>3]=A*y;g[O>>3]=-(A*la);}f=c[M>>2]|0;if(f>>>0<(c[N>>2]|0)>>>0){c[f>>2]=c[ga>>2];c[f+4>>2]=c[ga+4>>2];c[f+8>>2]=c[ga+8>>2];c[f+12>>2]=c[ga+12>>2];c[M>>2]=(c[M>>2]|0)+16;}else $e(L,ga);}while((o|0)<(e|0))}o=D+44|0;if((c[o>>2]|0)>>>0<2){n=c[G>>2]|0;h=n;f=c[h>>2]|0;h=c[h+4>>2]|0;j=n+(e<<4)|0;i=c[j>>2]|0;j=c[j+4>>2]|0;l=n+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;n=n+(e<<4)+8|0;m=c[n>>2]|0;n=c[n+4>>2]|0;if((f|0)==(i|0)&(h|0)==(j|0)&((k|0)==(m|0)&(l|0)==(n|0))){c[ga>>2]=0;c[ga+4>>2]=0;c[ga+8>>2]=0;c[ga+12>>2]=0;}else{j=Ww(f|0,h|0,i|0,j|0)|0;la=+(j>>>0)+4294967296.0*+(F()|0);n=Ww(k|0,l|0,m|0,n|0)|0;y=+(n>>>0)+4294967296.0*+(F()|0);A=1.0/+t(+(la*la+y*y));g[ga>>3]=A*y;g[U>>3]=-(A*la);}f=c[M>>2]|0;if(f>>>0<(c[N>>2]|0)>>>0){c[f>>2]=c[ga>>2];c[f+4>>2]=c[ga+4>>2];c[f+8>>2]=c[ga+8>>2];c[f+12>>2]=c[ga+12>>2];c[M>>2]=(c[M>>2]|0)+16;}else $e(L,ga);}else{f=(c[L>>2]|0)+(q+-2<<4)|0;c[ga>>2]=c[f>>2];c[ga+4>>2]=c[f+4>>2];c[ga+8>>2]=c[f+8>>2];c[ga+12>>2]=c[f+12>>2];f=c[M>>2]|0;if(f>>>0<(c[N>>2]|0)>>>0){c[f>>2]=c[ga>>2];c[f+4>>2]=c[ga+4>>2];c[f+8>>2]=c[ga+8>>2];c[f+12>>2]=c[ga+12>>2];c[M>>2]=(c[M>>2]|0)+16;}else $e(L,ga);}f=c[o>>2]|0;switch(f|0){case 0:{c[ga>>2]=e;if((p|0)>0){f=D+40|0;e=0;do{Hd(a,e,ga,c[f>>2]|0);e=e+1|0;}while((e|0)<(q|0))}ea=c[ja>>2]|0;if((ea|0)==(c[Q>>2]|0))He(ia,J);else{c[ea>>2]=0;j=ea+4|0;c[j>>2]=0;f=ea+8|0;c[f>>2]=0;e=(c[K>>2]|0)-(c[J>>2]|0)|0;h=e>>4;if(e|0){if(h>>>0>268435455){e=80;break b}i=Zj(e)|0;c[j>>2]=i;c[ea>>2]=i;c[f>>2]=i+(h<<4);e=c[X>>2]|0;f=(c[K>>2]|0)-e|0;if((f|0)>0){ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}}c[ja>>2]=(c[ja>>2]|0)+12;}break c}case 1:{c[ga>>2]=e;l=(p|0)>0;if(l){h=D+40|0;f=0;do{Hd(a,f,ga,c[h>>2]|0);f=f+1|0;}while((f|0)<(q|0))}fa=c[ja>>2]|0;if((fa|0)==(c[Q>>2]|0))He(ia,J);else{c[fa>>2]=0;k=fa+4|0;c[k>>2]=0;h=fa+8|0;c[h>>2]=0;f=(c[K>>2]|0)-(c[J>>2]|0)|0;i=f>>4;if(f|0){if(i>>>0>268435455){e=92;break b}j=Zj(f)|0;c[k>>2]=j;c[fa>>2]=j;c[h>>2]=j+(i<<4);f=c[X>>2]|0;h=(c[K>>2]|0)-f|0;if((h|0)>0){ax(j|0,f|0,h|0)|0;c[k>>2]=j+(h>>>4<<4);}}c[ja>>2]=(c[ja>>2]|0)+12;}c[K>>2]=c[J>>2];f=c[L>>2]|0;d=+g[f+(e<<4)>>3];w=+g[f+(e<<4)+8>>3];if(C){h=e;do{da=h;h=h+-1|0;la=-+g[f+(h<<4)+8>>3];g[f+(da<<4)>>3]=-+g[f+(h<<4)>>3];g[f+(da<<4)+8>>3]=la;f=c[L>>2]|0;}while((da|0)>1)}g[f>>3]=-d;g[f+8>>3]=-w;c[ga>>2]=0;if(l){f=D+40|0;while(1){Hd(a,e,ga,c[f>>2]|0);if((e|0)>0)e=e+-1|0;else break}}da=c[ja>>2]|0;if((da|0)==(c[Q>>2]|0))He(ia,J);else{c[da>>2]=0;j=da+4|0;c[j>>2]=0;f=da+8|0;c[f>>2]=0;e=(c[K>>2]|0)-(c[J>>2]|0)|0;h=e>>4;do if(e|0){if(h>>>0>268435455){e=106;break b}i=Zj(e)|0;c[j>>2]=i;c[da>>2]=i;c[f>>2]=i+(h<<4);e=c[X>>2]|0;f=(c[K>>2]|0)-e|0;if((f|0)<=0)break;ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}while(0);c[ja>>2]=(c[ja>>2]|0)+12;}break c}default:{c[ga>>2]=0;i=(p|0)>32;if(i){h=D+40|0;f=1;do{Hd(a,f,ga,c[h>>2]|0);f=f+1|0;}while((f|0)<(e|0));f=c[o>>2]|0;}c[ha>>2]=0;c[ha+4>>2]=0;c[ha+8>>2]=0;c[ha+12>>2]=0;do if((f|0)==2){ca=c[G>>2]|0;p=ca+(e<<4)|0;f=c[L>>2]|0;A=+g[f+(e<<4)>>3]*b+(+((c[p>>2]|0)>>>0)+4294967296.0*+(c[p+4>>2]|0));A=A+(A<0.0?-.5:.5);p=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;ca=ca+(e<<4)+8|0;la=+g[f+(e<<4)+8>>3]*b+(+((c[ca>>2]|0)>>>0)+4294967296.0*+(c[ca+4>>2]|0));la=la+(la<0.0?-.5:.5);ca=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;f=ha;c[f>>2]=~~A>>>0;c[f+4>>2]=p;f=V;c[f>>2]=~~la>>>0;c[f+4>>2]=ca;f=c[K>>2]|0;if((f|0)==(c[S>>2]|0)){Ge(J,ha);f=c[K>>2]|0;}else{c[f>>2]=c[ha>>2];c[f+4>>2]=c[ha+4>>2];c[f+8>>2]=c[ha+8>>2];c[f+12>>2]=c[ha+12>>2];f=(c[K>>2]|0)+16|0;c[K>>2]=f;}ca=c[G>>2]|0;n=ca+(e<<4)|0;p=c[L>>2]|0;A=+((c[n>>2]|0)>>>0)+4294967296.0*+(c[n+4>>2]|0)-+g[p+(e<<4)>>3]*b;A=A+(A<0.0?-.5:.5);n=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;ca=ca+(e<<4)+8|0;la=+((c[ca>>2]|0)>>>0)+4294967296.0*+(c[ca+4>>2]|0)-+g[p+(e<<4)+8>>3]*b;la=la+(la<0.0?-.5:.5);p=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ca=ha;c[ca>>2]=~~A>>>0;c[ca+4>>2]=n;ca=V;c[ca>>2]=~~la>>>0;c[ca+4>>2]=p;if((f|0)==(c[S>>2]|0)){Ge(J,ha);break}else{c[f>>2]=c[ha>>2];c[f+4>>2]=c[ha+4>>2];c[f+8>>2]=c[ha+8>>2];c[f+12>>2]=c[ha+12>>2];c[K>>2]=(c[K>>2]|0)+16;break}}else{f=q+-2|0;c[ga>>2]=f;g[W>>3]=0.0;ca=c[L>>2]|0;p=ca+(e<<4)|0;ca=ca+(e<<4)+8|0;la=-+g[ca>>3];g[p>>3]=-+g[p>>3];g[ca>>3]=la;if((c[o>>2]|0)==3){Id(a,e,f);break}else{Jd(a,e,f);break}}while(0);if(C){f=e;do{ca=f;f=f+-1|0;C=c[L>>2]|0;la=-+g[C+(f<<4)+8>>3];g[C+(ca<<4)>>3]=-+g[C+(f<<4)>>3];g[C+(ca<<4)+8>>3]=la;}while((ca|0)>1)}ca=c[L>>2]|0;la=-+g[ca+24>>3];g[ca>>3]=-+g[ca+16>>3];g[ca+8>>3]=la;c[ga>>2]=e;if(i){f=D+40|0;e=q+-2|0;while(1){Hd(a,e,ga,c[f>>2]|0);if((e|0)>1)e=e+-1|0;else break}}e=c[o>>2]|0;do if((e|0)==2){e=c[G>>2]|0;D=e;ca=c[L>>2]|0;A=+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0)-+g[ca>>3]*b;A=A+(A<0.0?-.5:.5);D=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;e=e+8|0;la=+((c[e>>2]|0)>>>0)+4294967296.0*+(c[e+4>>2]|0)-+g[ca+8>>3]*b;la=la+(la<0.0?-.5:.5);ca=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;e=ha;c[e>>2]=~~A>>>0;c[e+4>>2]=D;e=V;c[e>>2]=~~la>>>0;c[e+4>>2]=ca;e=c[K>>2]|0;if((e|0)==(c[S>>2]|0)){Ge(J,ha);e=c[K>>2]|0;}else{c[e>>2]=c[ha>>2];c[e+4>>2]=c[ha+4>>2];c[e+8>>2]=c[ha+8>>2];c[e+12>>2]=c[ha+12>>2];e=(c[K>>2]|0)+16|0;c[K>>2]=e;}D=c[G>>2]|0;C=D;ca=c[L>>2]|0;A=+g[ca>>3]*b+(+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0));A=A+(A<0.0?-.5:.5);C=+s(A)>=1.0?(A>0.0?~~+B(+r(A/4294967296.0),4294967295.0)>>>0:~~+z((A-+(~~A>>>0))/4294967296.0)>>>0):0;D=D+8|0;la=+g[ca+8>>3]*b+(+((c[D>>2]|0)>>>0)+4294967296.0*+(c[D+4>>2]|0));la=la+(la<0.0?-.5:.5);D=+s(la)>=1.0?(la>0.0?~~+B(+r(la/4294967296.0),4294967295.0)>>>0:~~+z((la-+(~~la>>>0))/4294967296.0)>>>0):0;ca=ha;c[ca>>2]=~~A>>>0;c[ca+4>>2]=C;ca=V;c[ca>>2]=~~la>>>0;c[ca+4>>2]=D;if((e|0)==(c[S>>2]|0)){Ge(J,ha);break}else{c[e>>2]=c[ha>>2];c[e+4>>2]=c[ha+4>>2];c[e+8>>2]=c[ha+8>>2];c[e+12>>2]=c[ha+12>>2];c[K>>2]=(c[K>>2]|0)+16;break}}else{c[ga>>2]=1;g[W>>3]=0.0;if((e|0)==3){Id(a,0,1);break}else{Jd(a,0,1);break}}while(0);ca=c[ja>>2]|0;if((ca|0)==(c[Q>>2]|0))He(ia,J);else{c[ca>>2]=0;j=ca+4|0;c[j>>2]=0;f=ca+8|0;c[f>>2]=0;e=(c[K>>2]|0)-(c[J>>2]|0)|0;h=e>>4;do if(e|0){if(h>>>0>268435455){e=146;break b}i=Zj(e)|0;c[j>>2]=i;c[ca>>2]=i;c[f>>2]=i+(h<<4);e=c[X>>2]|0;f=(c[K>>2]|0)-e|0;if((f|0)<=0)break;ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}while(0);c[ja>>2]=(c[ja>>2]|0)+12;}break c}}}while(0);E=E+1|0;e=c[Y>>2]|0;if((E|0)>=((c[Z>>2]|0)-e>>2|0)){e=153;break}}if((e|0)==48)gk();else if((e|0)==80)gk();else if((e|0)==92)gk();else if((e|0)==106)gk();else if((e|0)==146)gk();else if((e|0)==153){Eb=ka;return}}function Ed(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;c[a>>2]=3556;e=a+112|0;d=a+120|0;if(c[d>>2]|0?(b=c[a+116>>2]|0,f=(c[e>>2]|0)+4|0,g=c[b>>2]|0,c[g+4>>2]=c[f>>2],c[c[f>>2]>>2]=g,c[d>>2]=0,(b|0)!=(e|0)):0)do{g=b;b=c[b+4>>2]|0;$j(g);}while((b|0)!=(e|0));b=c[a+96>>2]|0;if(b|0){c[a+100>>2]=b;$j(b);}b=c[a+84>>2]|0;if(b|0){c[a+88>>2]=b;$j(b);}b=c[a+72>>2]|0;if(!b){yc(a);return}c[a+76>>2]=b;$j(b);yc(a);return}function Fd(b,d,e){b=b|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0;aa=Eb;Eb=Eb+176|0;L=aa+168|0;X=aa+24|0;D=aa;N=aa+8|0;H=d+48|0;I=d+52|0;h=c[I>>2]|0;g=c[H>>2]|0;if((h|0)!=(g|0)){j=0;i=h;do{h=c[g+(j<<2)>>2]|0;if(h){Ub[c[(c[h>>2]|0)+4>>2]&127](h);g=c[H>>2]|0;i=c[I>>2]|0;}j=j+1|0;h=i-g|0;}while(j>>>0<h>>2>>>0);if(h|0)c[I>>2]=g;}J=d+16|0;O=d+20|0;g=c[J>>2]|0;if((c[O>>2]|0)!=(g|0))c[O>>2]=g;Ad(b);Dd(b,e);c[X+24>>2]=0;$=X+28|0;c[$>>2]=0;c[X+32>>2]=0;Y=X+40|0;c[Y>>2]=0;_=X+44|0;c[_>>2]=0;c[X+48>>2]=0;W=X+56|0;c[W>>2]=0;Z=X+60|0;c[Z>>2]=0;c[X+64>>2]=0;T=X+4|0;c[T>>2]=0;c[T+4>>2]=0;c[T+8>>2]=0;c[T+12>>2]=0;c[X>>2]=3556;S=X+72|0;i=X+112|0;g=S;h=g+36|0;do{c[g>>2]=0;g=g+4|0;}while((g|0)<(h|0));c[i>>2]=i;Q=X+116|0;c[Q>>2]=i;P=X+120|0;c[P>>2]=0;a[X+128>>0]=0;U=X+20|0;a[U>>0]=0;C=X+140|0;a[C>>0]=0;a[X+142>>0]=0;a[X+36>>0]=0;V=X+37|0;a[V>>0]=0;k=b+16|0;j=b+20|0;g=c[k>>2]|0;a:do if((c[j>>2]|0)!=(g|0)){h=0;i=3556;while(1){Qb[c[i+8>>2]&15](X,g+(h*12|0)|0,0,1)|0;h=h+1|0;g=c[k>>2]|0;if(h>>>0>=(((c[j>>2]|0)-g|0)/12|0)>>>0)break a;i=c[X>>2]|0;}}while(0);if(!(e>0.0)){g=c[X+8>>2]|0;B=c[X+12>>2]|0;b:do if((g|0)==(B|0)){m=D;c[m>>2]=0;c[m+4>>2]=0;m=0;l=0;b=0;k=0;j=0;i=0;h=0;g=0;}else{A=c[g+8>>2]|0;i=A;j=c[i>>2]|0;i=c[i+4>>2]|0;y=D;c[y>>2]=j;c[y+4>>2]=i;y=A+8|0;b=c[y>>2]|0;y=c[y+4>>2]|0;z=b;m=j;l=i;h=b;n=y;k=y;while(1){x=(k|0)<(y|0)|(k|0)==(y|0)&b>>>0<z>>>0;w=g+12|0;v=A;u=n;while(1){q=c[v+88>>2]|0;p=v;n=c[p>>2]|0;p=c[p+4>>2]|0;o=(p|0)<(l|0)|(p|0)==(l|0)&n>>>0<m>>>0;if(!q){n=v;m=o;l=v;}else{t=m;s=l;r=m;m=l;while(1){t=o?n:t;s=o?p:s;r=o?n:r;m=o?p:m;l=(p|0)>(i|0)|(p|0)==(i|0)&n>>>0>j>>>0;j=l?n:j;i=l?p:i;l=c[q+88>>2]|0;ba=q;n=c[ba>>2]|0;p=c[ba+4>>2]|0;o=(p|0)<(m|0)|(p|0)==(m|0)&n>>>0<r>>>0;if(!l)break;else q=l;}n=D;c[n>>2]=t;c[n+4>>2]=s;n=q;m=o;l=q;}ba=m?l:D;m=c[ba>>2]|0;ba=c[ba+4>>2]|0;o=D;c[o>>2]=m;c[o+4>>2]=ba;o=l;s=c[o>>2]|0;o=c[o+4>>2]|0;t=(i|0)<(o|0)|(i|0)==(o|0)&j>>>0<s>>>0;j=t?s:j;o=t?o:i;t=n+32|0;s=c[t>>2]|0;t=c[t+4>>2]|0;l=(t|0)<(ba|0)|(t|0)==(ba|0)&s>>>0<m>>>0;m=l?s:m;l=l?t:ba;ba=D;c[ba>>2]=m;c[ba+4>>2]=l;ba=(o|0)<(t|0)|(o|0)==(t|0)&j>>>0<s>>>0;j=ba?s:j;o=ba?t:o;n=n+40|0;t=c[n>>2]|0;n=c[n+4>>2]|0;ba=(n|0)<(u|0)|(n|0)==(u|0)&t>>>0<h>>>0;h=ba?t:h;n=ba?n:u;if((v|0)!=(A|0))break;v=c[w>>2]|0;u=n;i=o;}b=x?z:b;k=x?y:k;i=g+16|0;if((i|0)==(B|0)){i=o;g=n;break b}A=c[g+24>>2]|0;y=A+8|0;g=i;z=c[y>>2]|0;i=o;y=c[y+4>>2]|0;}}while(0);c[N>>2]=0;o=N+4|0;c[o>>2]=0;B=N+8|0;c[B>>2]=0;n=Zj(64)|0;c[N>>2]=n;A=n+64|0;c[B>>2]=A;c[o>>2]=A;A=Vw(m|0,l|0,-10,-1)|0;B=F()|0;x=Vw(b|0,k|0,10,0)|0;ba=F()|0;y=n;c[y>>2]=A;c[y+4>>2]=B;y=n+8|0;c[y>>2]=x;c[y+4>>2]=ba;y=Vw(j|0,i|0,10,0)|0;z=F()|0;D=n+16|0;c[D>>2]=y;c[D+4>>2]=z;D=n+24|0;c[D>>2]=x;c[D+4>>2]=ba;D=Vw(h|0,g|0,-10,-1)|0;ba=F()|0;g=n+32|0;c[g>>2]=y;c[g+4>>2]=z;g=n+40|0;c[g>>2]=D;c[g+4>>2]=ba;g=n+48|0;c[g>>2]=A;c[g+4>>2]=B;g=n+56|0;c[g>>2]=D;c[g+4>>2]=ba;Ec(X,N,0,1)|0;a[C>>0]=1;Qc(X,1,d,3,3)|0;g=c[J>>2]|0;if(((c[O>>2]|0)-g|0)==4?(G=c[g>>2]|0,K=G+16|0,M=G+20|0,E=(c[M>>2]|0)-(c[K>>2]|0)|0,(E|0)>0):0){qd(J,E>>>2);c[c[J>>2]>>2]=c[c[K>>2]>>2];j=c[J>>2]|0;c[(c[j>>2]|0)+28>>2]=c[G+28>>2];h=c[K>>2]|0;if(((c[M>>2]|0)-h|0)>4){k=d+24|0;g=1;while(1){h=c[h+(g<<2)>>2]|0;i=c[O>>2]|0;c[L>>2]=h;if((c[k>>2]|0)>>>0>i>>>0){c[i>>2]=h;c[O>>2]=(c[O>>2]|0)+4;}else Ie(J,L);c[h+28>>2]=d;c[h+32>>2]=i-j>>2;g=g+1|0;h=c[K>>2]|0;if((g|0)>=((c[M>>2]|0)-h>>2|0))break;j=c[J>>2]|0;}g=c[N>>2]|0;if(g|0){h=g;R=47;}}else{h=n;g=n;R=47;}}else{h=c[I>>2]|0;g=c[H>>2]|0;if((h|0)!=(g|0)){j=0;do{i=c[g+(j<<2)>>2]|0;if(i){Ub[c[(c[i>>2]|0)+4>>2]&127](i);g=c[H>>2]|0;h=c[I>>2]|0;}j=j+1|0;i=h-g|0;}while(j>>>0<i>>2>>>0);if(i|0)c[I>>2]=g;}g=c[J>>2]|0;if((c[O>>2]|0)==(g|0)){h=n;g=n;R=47;}else{c[O>>2]=g;h=n;g=n;R=47;}}if((R|0)==47){c[o>>2]=h;$j(g);}}else Qc(X,1,d,2,2)|0;c[X>>2]=3556;g=X+112|0;if(c[P>>2]|0?(f=c[Q>>2]|0,ba=(c[g>>2]|0)+4|0,R=c[f>>2]|0,c[R+4>>2]=c[ba>>2],c[c[ba>>2]>>2]=R,c[P>>2]=0,(f|0)!=(g|0)):0)do{ba=f;f=c[f+4>>2]|0;$j(ba);}while((f|0)!=(g|0));f=c[X+96>>2]|0;if(f|0){c[X+100>>2]=f;$j(f);}f=c[X+84>>2]|0;if(f|0){c[X+88>>2]=f;$j(f);}f=c[S>>2]|0;if(f|0){c[X+76>>2]=f;$j(f);}c[X>>2]=3528;k=X+8|0;j=c[k>>2]|0;b=X+12|0;c[b>>2]=j;c[T>>2]=j;j=X+24|0;f=c[$>>2]|0;g=c[j>>2]|0;if((f|0)!=(g|0)){i=0;do{h=c[g+(i<<2)>>2]|0;if(h){ak(h);g=c[j>>2]|0;f=c[$>>2]|0;}i=i+1|0;}while(i>>>0<f-g>>2>>>0);f=g;}c[$>>2]=f;a[U>>0]=0;a[V>>0]=0;f=c[W>>2]|0;if(f|0){c[Z>>2]=f;$j(f);}f=c[Y>>2]|0;if(f|0){c[_>>2]=f;$j(f);}f=c[j>>2]|0;if(f|0){c[$>>2]=f;$j(f);}f=c[k>>2]|0;if(!f){Eb=aa;return}c[b>>2]=f;$j(f);Eb=aa;return}function Gd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;f=a+8|0;g=c[a>>2]|0;if((c[f>>2]|0)-g>>4>>>0>=b>>>0)return;h=a+4|0;if(b>>>0>268435455){h=S(8)|0;dk(h,8694);c[h>>2]=7328;V(h|0,3264,87);}d=(c[h>>2]|0)-g|0;e=Zj(b<<4)|0;if((d|0)>0)ax(e|0,g|0,d|0)|0;c[a>>2]=e;c[h>>2]=e+(d>>4<<4);c[f>>2]=e+(b<<4);if(!g)return;$j(g);return}function Hd(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0.0,i=0,j=0,k=0.0,l=0.0,m=0,n=0,o=0.0,p=0.0,q=0.0,t=0,u=0,v=0,w=0;w=Eb;Eb=Eb+16|0;v=w;i=c[d>>2]|0;u=a+52|0;f=c[u>>2]|0;q=+g[f+(i<<4)>>3];k=+g[f+(b<<4)+8>>3];l=+g[f+(b<<4)>>3];o=+g[f+(i<<4)+8>>3];h=q*k-l*o;f=a+72|0;g[f>>3]=h;t=a+64|0;p=+g[t>>3];do if(+s(+(h*p))<1.0){if(q*l+k*o>0.0){e=c[a+28>>2]|0;d=e+(b<<4)|0;l=q*p+(+((c[d>>2]|0)>>>0)+4294967296.0*+(c[d+4>>2]|0));l=l+(l<0.0?-.5:.5);d=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;e=e+(b<<4)+8|0;q=o*p+(+((c[e>>2]|0)>>>0)+4294967296.0*+(c[e+4>>2]|0));q=q+(q<0.0?-.5:.5);e=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;f=v;c[f>>2]=~~l>>>0;c[f+4>>2]=d;f=v+8|0;c[f>>2]=~~q>>>0;c[f+4>>2]=e;f=a+44|0;e=c[f>>2]|0;if(e>>>0<(c[a+48>>2]|0)>>>0){c[e>>2]=c[v>>2];c[e+4>>2]=c[v+4>>2];c[e+8>>2]=c[v+8>>2];c[e+12>>2]=c[v+12>>2];c[f>>2]=(c[f>>2]|0)+16;}else _e(a+40|0,v);Eb=w;return}}else{if(h>1.0){g[f>>3]=1.0;h=1.0;break}if(h<-1.0){g[f>>3]=-1.0;h=-1.0;}}while(0);a:do if(p*h<0.0){m=a+40|0;n=a+28|0;f=c[n>>2]|0;i=f+(b<<4)|0;l=q*p+(+((c[i>>2]|0)>>>0)+4294967296.0*+(c[i+4>>2]|0));l=l+(l<0.0?-.5:.5);i=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;f=f+(b<<4)+8|0;q=o*p+(+((c[f>>2]|0)>>>0)+4294967296.0*+(c[f+4>>2]|0));q=q+(q<0.0?-.5:.5);f=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;j=v;c[j>>2]=~~l>>>0;c[j+4>>2]=i;j=v+8|0;c[j>>2]=~~q>>>0;c[j+4>>2]=f;j=a+44|0;f=c[j>>2]|0;i=a+48|0;if(f>>>0<(c[i>>2]|0)>>>0){c[f>>2]=c[v>>2];c[f+4>>2]=c[v+4>>2];c[f+8>>2]=c[v+8>>2];c[f+12>>2]=c[v+12>>2];e=(c[j>>2]|0)+16|0;c[j>>2]=e;}else{_e(m,v);e=c[j>>2]|0;}f=(c[n>>2]|0)+(b<<4)|0;if((e|0)==(c[i>>2]|0)){Ge(m,f);f=c[j>>2]|0;}else{c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];f=(c[j>>2]|0)+16|0;c[j>>2]=f;}n=c[n>>2]|0;e=n+(b<<4)|0;a=c[u>>2]|0;q=+g[t>>3];p=+g[a+(b<<4)>>3]*q+(+((c[e>>2]|0)>>>0)+4294967296.0*+(c[e+4>>2]|0));p=p+(p<0.0?-.5:.5);t=+s(p)>=1.0?(p>0.0?~~+B(+r(p/4294967296.0),4294967295.0)>>>0:~~+z((p-+(~~p>>>0))/4294967296.0)>>>0):0;u=n+(b<<4)+8|0;q=q*+g[a+(b<<4)+8>>3]+(+((c[u>>2]|0)>>>0)+4294967296.0*+(c[u+4>>2]|0));q=q+(q<0.0?-.5:.5);u=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;a=v;c[a>>2]=~~p>>>0;c[a+4>>2]=t;a=v+8|0;c[a>>2]=~~q>>>0;c[a+4>>2]=u;if(f>>>0<(c[i>>2]|0)>>>0){c[f>>2]=c[v>>2];c[f+4>>2]=c[v+4>>2];c[f+8>>2]=c[v+8>>2];c[f+12>>2]=c[v+12>>2];c[j>>2]=(c[j>>2]|0)+16;}else _e(m,v);}else switch(e|0){case 2:{h=q*l+k*o+1.0;if(!(h>=+g[a+96>>3])){Id(a,b,i);break a}h=p/h;e=c[a+28>>2]|0;u=e+(b<<4)|0;p=h*(q+l)+(+((c[u>>2]|0)>>>0)+4294967296.0*+(c[u+4>>2]|0));p=p+(p<0.0?-.5:.5);u=+s(p)>=1.0?(p>0.0?~~+B(+r(p/4294967296.0),4294967295.0)>>>0:~~+z((p-+(~~p>>>0))/4294967296.0)>>>0):0;e=e+(b<<4)+8|0;q=h*(o+k)+(+((c[e>>2]|0)>>>0)+4294967296.0*+(c[e+4>>2]|0));q=q+(q<0.0?-.5:.5);e=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;f=v;c[f>>2]=~~p>>>0;c[f+4>>2]=u;f=v+8|0;c[f>>2]=~~q>>>0;c[f+4>>2]=e;f=a+44|0;e=c[f>>2]|0;if(e>>>0<(c[a+48>>2]|0)>>>0){c[e>>2]=c[v>>2];c[e+4>>2]=c[v+4>>2];c[e+8>>2]=c[v+8>>2];c[e+12>>2]=c[v+12>>2];c[f>>2]=(c[f>>2]|0)+16;}else _e(a+40|0,v);break a}case 0:{Id(a,b,i);break a}case 1:{Jd(a,b,i);break a}default:break a}while(0);c[d>>2]=b;Eb=w;return}function Id(a,b,d){a=a|0;b=b|0;d=d|0;var e=0.0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0.0,o=0,p=0.0,q=0.0,t=0.0;m=Eb;Eb=Eb+16|0;k=m;l=a+52|0;f=c[l>>2]|0;q=+g[f+(d<<4)>>3];t=+g[f+(d<<4)+8>>3];e=+w(+(+y(+(+g[a+72>>3]),+(q*+g[f+(b<<4)>>3]+t*+g[f+(b<<4)+8>>3]))*.25));f=a+40|0;h=a+28|0;d=c[h>>2]|0;o=d+(b<<4)|0;i=a+64|0;n=+g[i>>3];p=(q-t*e)*n+(+((c[o>>2]|0)>>>0)+4294967296.0*+(c[o+4>>2]|0));p=p+(p<0.0?-.5:.5);o=+s(p)>=1.0?(p>0.0?~~+B(+r(p/4294967296.0),4294967295.0)>>>0:~~+z((p-+(~~p>>>0))/4294967296.0)>>>0):0;d=d+(b<<4)+8|0;n=(t+q*e)*n+(+((c[d>>2]|0)>>>0)+4294967296.0*+(c[d+4>>2]|0));n=n+(n<0.0?-.5:.5);d=+s(n)>=1.0?(n>0.0?~~+B(+r(n/4294967296.0),4294967295.0)>>>0:~~+z((n-+(~~n>>>0))/4294967296.0)>>>0):0;j=k;c[j>>2]=~~p>>>0;c[j+4>>2]=o;j=k+8|0;c[j>>2]=~~n>>>0;c[j+4>>2]=d;j=a+44|0;d=c[j>>2]|0;a=a+48|0;if(d>>>0<(c[a>>2]|0)>>>0){c[d>>2]=c[k>>2];c[d+4>>2]=c[k+4>>2];c[d+8>>2]=c[k+8>>2];c[d+12>>2]=c[k+12>>2];d=(c[j>>2]|0)+16|0;c[j>>2]=d;}else{_e(f,k);d=c[j>>2]|0;}o=c[h>>2]|0;h=o+(b<<4)|0;n=+g[i>>3];i=c[l>>2]|0;t=+g[i+(b<<4)>>3];p=+g[i+(b<<4)+8>>3];q=n*(t+e*p)+(+((c[h>>2]|0)>>>0)+4294967296.0*+(c[h+4>>2]|0));q=q+(q<0.0?-.5:.5);i=+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0;l=o+(b<<4)+8|0;t=n*(p-e*t)+(+((c[l>>2]|0)>>>0)+4294967296.0*+(c[l+4>>2]|0));t=t+(t<0.0?-.5:.5);l=+s(t)>=1.0?(t>0.0?~~+B(+r(t/4294967296.0),4294967295.0)>>>0:~~+z((t-+(~~t>>>0))/4294967296.0)>>>0):0;o=k;c[o>>2]=~~q>>>0;c[o+4>>2]=i;o=k+8|0;c[o>>2]=~~t>>>0;c[o+4>>2]=l;if(d>>>0<(c[a>>2]|0)>>>0){c[d>>2]=c[k>>2];c[d+4>>2]=c[k+4>>2];c[d+8>>2]=c[k+8>>2];c[d+12>>2]=c[k+12>>2];c[j>>2]=(c[j>>2]|0)+16;Eb=m;return}else{_e(f,k);Eb=m;return}}function Jd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0.0,f=0.0,h=0,i=0,j=0,k=0.0,l=0.0,m=0.0,n=0,o=0,p=0,q=0,t=0,u=0,v=0,w=0,x=0,A=0,C=0;x=Eb;Eb=Eb+16|0;w=x;u=a+52|0;t=c[u>>2]|0;l=+g[t+(d<<4)>>3];f=+g[t+(b<<4)>>3];k=+g[t+(d<<4)+8>>3];e=+g[t+(b<<4)+8>>3];m=+y(+(+g[a+72>>3]),+(l*f+k*e));m=+g[a+104>>3]*+s(+m);t=~~(m+(m<0.0?-.5:.5))>>>0;t=(t|0)>1?t:1;v=a+40|0;if((t|0)>0){j=a+28|0;d=a+64|0;p=w+8|0;i=a+44|0;h=a+48|0;q=a+88|0;o=a+80|0;m=k;n=0;while(1){A=c[j>>2]|0;C=A+(b<<4)|0;k=+g[d>>3];f=l*k+(+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0));f=f+(f<0.0?-.5:.5);C=+s(f)>=1.0?(f>0.0?~~+B(+r(f/4294967296.0),4294967295.0)>>>0:~~+z((f-+(~~f>>>0))/4294967296.0)>>>0):0;A=A+(b<<4)+8|0;k=m*k+(+((c[A>>2]|0)>>>0)+4294967296.0*+(c[A+4>>2]|0));k=k+(k<0.0?-.5:.5);A=+s(k)>=1.0?(k>0.0?~~+B(+r(k/4294967296.0),4294967295.0)>>>0:~~+z((k-+(~~k>>>0))/4294967296.0)>>>0):0;a=w;c[a>>2]=~~f>>>0;c[a+4>>2]=C;a=p;c[a>>2]=~~k>>>0;c[a+4>>2]=A;a=c[i>>2]|0;if(a>>>0<(c[h>>2]|0)>>>0){c[a>>2]=c[w>>2];c[a+4>>2]=c[w+4>>2];c[a+8>>2]=c[w+8>>2];c[a+12>>2]=c[w+12>>2];c[i>>2]=(c[i>>2]|0)+16;}else _e(v,w);e=+g[q>>3];f=+g[o>>3];k=m*e+l*f;n=n+1|0;if(n>>>0>=t>>>0)break;else{l=l*e-m*f;m=k;}}C=c[u>>2]|0;f=+g[C+(b<<4)>>3];e=+g[C+(b<<4)+8>>3];}else{j=a+28|0;d=a+64|0;i=a+44|0;h=a+48|0;}C=c[j>>2]|0;A=C+(b<<4)|0;m=+g[d>>3];l=f*m+(+((c[A>>2]|0)>>>0)+4294967296.0*+(c[A+4>>2]|0));l=l+(l<0.0?-.5:.5);A=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;C=C+(b<<4)+8|0;m=m*e+(+((c[C>>2]|0)>>>0)+4294967296.0*+(c[C+4>>2]|0));m=m+(m<0.0?-.5:.5);C=+s(m)>=1.0?(m>0.0?~~+B(+r(m/4294967296.0),4294967295.0)>>>0:~~+z((m-+(~~m>>>0))/4294967296.0)>>>0):0;d=w;c[d>>2]=~~l>>>0;c[d+4>>2]=A;d=w+8|0;c[d>>2]=~~m>>>0;c[d+4>>2]=C;d=c[i>>2]|0;if(d>>>0<(c[h>>2]|0)>>>0){c[d>>2]=c[w>>2];c[d+4>>2]=c[w+4>>2];c[d+8>>2]=c[w+8>>2];c[d+12>>2]=c[w+12>>2];c[i>>2]=(c[i>>2]|0)+16;Eb=x;return}else{_e(v,w);Eb=x;return}}function Kd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=Eb;Eb=Eb+16|0;h=k;j=a+4|0;b=c[j>>2]|0;d=c[a>>2]|0;if((b|0)==(d|0)){Eb=k;return}g=0;f=b;while(1){e=d;b=c[e+(g*12|0)>>2]|0;e=c[e+(g*12|0)+4>>2]|0;if((b|0)!=(e|0)?(i=e+-16|0,b>>>0<i>>>0):0){d=i;do{c[h>>2]=c[b>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+12>>2]=c[h+12>>2];b=b+16|0;d=d+-16|0;}while(b>>>0<d>>>0);d=c[a>>2]|0;b=c[j>>2]|0;}else b=f;g=g+1|0;if(g>>>0>=((b-d|0)/12|0)>>>0)break;else f=b;}Eb=k;return}function Ld(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;u=Eb;Eb=Eb+144|0;m=u;c[m+24>>2]=0;t=m+28|0;c[t>>2]=0;c[m+32>>2]=0;r=m+40|0;c[r>>2]=0;s=m+44|0;c[s>>2]=0;c[m+48>>2]=0;p=m+56|0;c[p>>2]=0;q=m+60|0;c[q>>2]=0;c[m+64>>2]=0;l=m+4|0;c[l>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;c[m>>2]=3556;k=m+72|0;i=m+112|0;g=k;h=g+36|0;do{c[g>>2]=0;g=g+4|0;}while((g|0)<(h|0));c[i>>2]=i;j=m+116|0;c[j>>2]=i;h=m+120|0;c[h>>2]=0;a[m+128>>0]=0;n=m+20|0;a[n>>0]=0;a[m+140>>0]=0;a[m+36>>0]=0;o=m+37|0;a[o>>0]=0;a[m+142>>0]=1;Ec(m,b,0,1)|0;Oc(m,1,d,e,e)|0;c[m>>2]=3556;g=m+112|0;if(c[h>>2]|0?(f=c[j>>2]|0,e=(c[g>>2]|0)+4|0,d=c[f>>2]|0,c[d+4>>2]=c[e>>2],c[c[e>>2]>>2]=d,c[h>>2]=0,(f|0)!=(g|0)):0)do{e=f;f=c[f+4>>2]|0;$j(e);}while((f|0)!=(g|0));f=c[m+96>>2]|0;if(f|0){c[m+100>>2]=f;$j(f);}f=c[m+84>>2]|0;if(f|0){c[m+88>>2]=f;$j(f);}f=c[k>>2]|0;if(f|0){c[m+76>>2]=f;$j(f);}c[m>>2]=3528;b=m+8|0;j=c[b>>2]|0;d=m+12|0;c[d>>2]=j;c[l>>2]=j;j=m+24|0;f=c[t>>2]|0;g=c[j>>2]|0;if((f|0)!=(g|0)){i=0;do{h=c[g+(i<<2)>>2]|0;if(h){ak(h);g=c[j>>2]|0;f=c[t>>2]|0;}i=i+1|0;}while(i>>>0<f-g>>2>>>0);f=g;}c[t>>2]=f;a[n>>0]=0;a[o>>0]=0;f=c[p>>2]|0;if(f|0){c[q>>2]=f;$j(f);}f=c[r>>2]|0;if(f|0){c[s>>2]=f;$j(f);}f=c[j>>2]|0;if(f|0){c[t>>2]=f;$j(f);}f=c[b>>2]|0;if(!f){Eb=u;return}c[d>>2]=f;$j(f);Eb=u;return}function Md(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;w=Eb;Eb=Eb+144|0;o=w;c[o+24>>2]=0;v=o+28|0;c[v>>2]=0;c[o+32>>2]=0;t=o+40|0;c[t>>2]=0;u=o+44|0;c[u>>2]=0;c[o+48>>2]=0;r=o+56|0;c[r>>2]=0;s=o+60|0;c[s>>2]=0;c[o+64>>2]=0;n=o+4|0;c[n>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[n+12>>2]=0;c[o>>2]=3556;m=o+72|0;i=o+112|0;g=m;h=g+36|0;do{c[g>>2]=0;g=g+4|0;}while((g|0)<(h|0));c[i>>2]=i;l=o+116|0;c[l>>2]=i;k=o+120|0;c[k>>2]=0;a[o+128>>0]=0;p=o+20|0;a[p>>0]=0;a[o+140>>0]=0;a[o+36>>0]=0;q=o+37|0;a[q>>0]=0;a[o+142>>0]=1;j=b+4|0;g=c[b>>2]|0;a:do if((c[j>>2]|0)!=(g|0)){h=0;i=3556;while(1){Qb[c[i+8>>2]&15](o,g+(h*12|0)|0,0,1)|0;h=h+1|0;g=c[b>>2]|0;if(h>>>0>=(((c[j>>2]|0)-g|0)/12|0)>>>0)break a;i=c[o>>2]|0;}}while(0);Oc(o,1,d,e,e)|0;c[o>>2]=3556;g=o+112|0;if(c[k>>2]|0?(f=c[l>>2]|0,e=(c[g>>2]|0)+4|0,d=c[f>>2]|0,c[d+4>>2]=c[e>>2],c[c[e>>2]>>2]=d,c[k>>2]=0,(f|0)!=(g|0)):0)do{e=f;f=c[f+4>>2]|0;$j(e);}while((f|0)!=(g|0));f=c[o+96>>2]|0;if(f|0){c[o+100>>2]=f;$j(f);}f=c[o+84>>2]|0;if(f|0){c[o+88>>2]=f;$j(f);}f=c[m>>2]|0;if(f|0){c[o+76>>2]=f;$j(f);}c[o>>2]=3528;k=o+8|0;j=c[k>>2]|0;l=o+12|0;c[l>>2]=j;c[n>>2]=j;j=o+24|0;f=c[v>>2]|0;g=c[j>>2]|0;if((f|0)!=(g|0)){i=0;do{h=c[g+(i<<2)>>2]|0;if(h){ak(h);g=c[j>>2]|0;f=c[v>>2]|0;}i=i+1|0;}while(i>>>0<f-g>>2>>>0);f=g;}c[v>>2]=f;a[p>>0]=0;a[q>>0]=0;f=c[r>>2]|0;if(f|0){c[s>>2]=f;$j(f);}f=c[t>>2]|0;if(f|0){c[u>>2]=f;$j(f);}f=c[j>>2]|0;if(f|0){c[v>>2]=f;$j(f);}f=c[k>>2]|0;if(!f){Eb=w;return}c[l>>2]=f;$j(f);Eb=w;return}function Nd(a,b){a=a|0;b=b|0;Md(a,a,b);return}function Od(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0.0,v=0.0,w=0.0;o=a;n=c[o>>2]|0;o=c[o+4>>2]|0;m=b;l=c[m>>2]|0;m=c[m+4>>2]|0;p=Ww(n|0,o|0,l|0,m|0)|0;t=F()|0;r=(t|0)<0;q=Ww(0,0,p|0,t|0)|0;k=F()|0;t=r?k:t;k=a+8|0;j=c[k>>2]|0;k=c[k+4>>2]|0;g=b+8|0;f=c[g>>2]|0;g=c[g+4>>2]|0;h=Ww(j|0,k|0,f|0,g|0)|0;i=F()|0;a=(i|0)<0;b=Ww(0,0,h|0,i|0)|0;s=F()|0;s=a?s:i;if((t|0)>(s|0)|((t|0)==(s|0)?(r?q:p)>>>0>(a?b:h)>>>0:0)){b=d;a=c[b>>2]|0;b=c[b+4>>2]|0;if(!(((m|0)<(o|0)|(m|0)==(o|0)&l>>>0<n>>>0)^((b|0)>(o|0)|(b|0)==(o|0)&a>>>0>n>>>0))){t=d+8|0;t=Ww(f|0,g|0,c[t>>2]|0,c[t+4>>2]|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=Ww(a|0,b|0,l|0,m|0)|0;w=+(t>>>0)+4294967296.0*+(F()|0);v=(+(j>>>0)+4294967296.0*+(k|0))*w+(+(n>>>0)+4294967296.0*+(o|0))*u-((+(f>>>0)+4294967296.0*+(g|0))*w+(+(l>>>0)+4294967296.0*+(m|0))*u);v=v*v;w=w*w;u=u*u;u=w+u;u=v/u;t=u<e;return t|0}if(((m|0)>(o|0)|(m|0)==(o|0)&l>>>0>n>>>0)^((b|0)>(m|0)|(b|0)==(m|0)&a>>>0>l>>>0)){w=+(h>>>0)+4294967296.0*+(i|0);t=Ww(l|0,m|0,n|0,o|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=d+8|0;v=w*(+(a>>>0)+4294967296.0*+(b|0))+u*(+((c[t>>2]|0)>>>0)+4294967296.0*+(c[t+4>>2]|0))-((+(j>>>0)+4294967296.0*+(k|0))*u+(+(n>>>0)+4294967296.0*+(o|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}else{t=d+8|0;t=Ww(j|0,k|0,c[t>>2]|0,c[t+4>>2]|0)|0;w=+(t>>>0)+4294967296.0*+(F()|0);t=Ww(a|0,b|0,n|0,o|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);v=(+(f>>>0)+4294967296.0*+(g|0))*u+(+(l>>>0)+4294967296.0*+(m|0))*w-((+(j>>>0)+4294967296.0*+(k|0))*u+(+(n>>>0)+4294967296.0*+(o|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}}else{b=d+8|0;a=c[b>>2]|0;b=c[b+4>>2]|0;if(!(((k|0)>(g|0)|(k|0)==(g|0)&j>>>0>f>>>0)^((k|0)<(b|0)|(k|0)==(b|0)&j>>>0<a>>>0))){t=Ww(f|0,g|0,a|0,b|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=d;t=Ww(c[t>>2]|0,c[t+4>>2]|0,l|0,m|0)|0;w=+(t>>>0)+4294967296.0*+(F()|0);v=(+(n>>>0)+4294967296.0*+(o|0))*u+(+(j>>>0)+4294967296.0*+(k|0))*w-((+(l>>>0)+4294967296.0*+(m|0))*u+(+(f>>>0)+4294967296.0*+(g|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}if(((k|0)<(g|0)|(k|0)==(g|0)&j>>>0<f>>>0)^((g|0)<(b|0)|(g|0)==(b|0)&f>>>0<a>>>0)){w=+(h>>>0)+4294967296.0*+(i|0);t=Ww(l|0,m|0,n|0,o|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=d;v=u*(+(a>>>0)+4294967296.0*+(b|0))+w*(+((c[t>>2]|0)>>>0)+4294967296.0*+(c[t+4>>2]|0))-((+(j>>>0)+4294967296.0*+(k|0))*u+(+(n>>>0)+4294967296.0*+(o|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}else{t=Ww(j|0,k|0,a|0,b|0)|0;u=+(t>>>0)+4294967296.0*+(F()|0);t=d;t=Ww(c[t>>2]|0,c[t+4>>2]|0,n|0,o|0)|0;w=+(t>>>0)+4294967296.0*+(F()|0);v=(+(l>>>0)+4294967296.0*+(m|0))*u+(+(f>>>0)+4294967296.0*+(g|0))*w-((+(n>>>0)+4294967296.0*+(o|0))*u+(+(j>>>0)+4294967296.0*+(k|0))*w);v=v*v;u=u*u;w=w*w;w=u+w;w=v/w;t=w<e;return t|0}}}function Pd(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,g=0,h=0,i=0.0,j=0,k=0,l=0,m=0,n=0.0,o=0,p=0,q=0.0,r=0.0,s=0,t=0,u=0;p=(c[a+4>>2]|0)-(c[a>>2]|0)|0;e=p>>4;if(!p){c[b+4>>2]=c[b>>2];return}p=_j(e>>>0>134217727?-1:e<<5)|0;f=p+(e<<5)|0;g=p;do{m=g+8|0;c[m>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;g=g+32|0;}while((g|0)!=(f|0));f=c[a>>2]|0;a=0;do{l=f+(a<<4)|0;m=p+(a<<5)|0;k=p+(a<<5)+8|0;c[k>>2]=c[l>>2];c[k+4>>2]=c[l+4>>2];c[k+8>>2]=c[l+8>>2];c[k+12>>2]=c[l+12>>2];k=a;a=a+1|0;l=(a>>>0)%(e>>>0)|0;c[p+(k<<5)+24>>2]=p+(l<<5);c[p+(l<<5)+28>>2]=m;c[m>>2]=0;}while(a>>>0<e>>>0);n=d*d;a:do if(!(c[p>>2]|0)){f=p;g=p;while(1){a=f+24|0;m=c[a>>2]|0;h=f+28|0;l=c[h>>2]|0;j=m;if((m|0)==(l|0)){h=f;break a}k=f+8|0;t=f+8|0;f=f+16|0;u=l+8|0;s=l+16|0;d=+((c[u>>2]|0)>>>0)+4294967296.0*+(c[u+4>>2]|0);r=+((c[t>>2]|0)>>>0)+4294967296.0*+(c[t+4>>2]|0)-d;i=+((c[s>>2]|0)>>>0)+4294967296.0*+(c[s+4>>2]|0);q=+((c[f>>2]|0)>>>0)+4294967296.0*+(c[f+4>>2]|0)-i;do if(!(r*r+q*q<=n)){t=m+8|0;u=m+16|0;q=d-(+((c[t>>2]|0)>>>0)+4294967296.0*+(c[t+4>>2]|0));r=i-(+((c[u>>2]|0)>>>0)+4294967296.0*+(c[u+4>>2]|0));if(q*q+r*r<=n){g=c[m+28>>2]|0;f=m+24|0;c[g+24>>2]=c[f>>2];c[(c[f>>2]|0)+28>>2]=g;c[g>>2]=0;g=c[h>>2]|0;c[g+24>>2]=c[a>>2];c[(c[a>>2]|0)+28>>2]=g;c[g>>2]=0;f=g;e=e+-2|0;a=0;break}if(Od(l+8|0,k,m+8|0,n)|0){c[l+24>>2]=j;c[(c[a>>2]|0)+28>>2]=l;c[l>>2]=0;f=l;e=e+-1|0;g=l;a=0;break}else{c[g>>2]=1;f=m;g=m;a=c[m>>2]|0;break}}else{c[l+24>>2]=j;c[(c[a>>2]|0)+28>>2]=l;c[l>>2]=0;f=l;e=e+-1|0;g=l;a=0;}while(0);if(a){h=f;break}}}else h=p;while(0);g=e>>>0<3?0:e;e=b+4|0;a=c[b>>2]|0;f=(c[e>>2]|0)-a>>4;if(g>>>0<=f>>>0){if(g>>>0<f>>>0)c[e>>2]=a+(g<<4);if(g|0)o=23;}else{af(b,g-f|0);o=23;}if((o|0)==23){a=0;e=h;while(1){t=e+8|0;u=(c[b>>2]|0)+(a<<4)|0;c[u>>2]=c[t>>2];c[u+4>>2]=c[t+4>>2];c[u+8>>2]=c[t+8>>2];c[u+12>>2]=c[t+12>>2];a=a+1|0;if((a|0)==(g|0))break;else e=c[e+24>>2]|0;}}ak(p);return}function Qd(a,b){a=a|0;b=+b;Pd(a,a,b);return}function Rd(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,g=0,h=0,i=0,j=0;j=a+4|0;h=((c[j>>2]|0)-(c[a>>2]|0)|0)/12|0;i=b+4|0;e=c[i>>2]|0;g=c[b>>2]|0;f=(e-g|0)/12|0;if(h>>>0<=f>>>0){if(h>>>0<f>>>0){h=g+(h*12|0)|0;if((h|0)!=(e|0))do{f=e;e=e+-12|0;g=c[e>>2]|0;if(g|0){c[f+-8>>2]=g;$j(g);}}while((e|0)!=(h|0));c[i>>2]=h;}}else Qe(b,h-f|0);e=c[a>>2]|0;if((c[j>>2]|0)==(e|0))return;f=0;do{Pd(e+(f*12|0)|0,(c[b>>2]|0)+(f*12|0)|0,d);f=f+1|0;e=c[a>>2]|0;}while(f>>>0<(((c[j>>2]|0)-e|0)/12|0)>>>0);return}function Sd(a,b){a=a|0;b=+b;Rd(a,a,b);return}function Td(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0.0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0;D=Eb;Eb=Eb+48|0;y=D+16|0;C=D+32|0;z=D;s=f&1;r=a+4|0;u=(c[r>>2]|0)-(c[a>>2]|0)|0;v=u>>4;f=(c[b+4>>2]|0)-(c[b>>2]|0)|0;w=f>>4;c[C>>2]=0;B=C+4|0;c[B>>2]=0;q=C+8|0;c[q>>2]=0;md(C,w);f=(f|0)!=0;a:do if(e){if(f){n=y+4|0;o=y+8|0;p=z+8|0;m=0;while(1){c[y>>2]=0;c[n>>2]=0;c[o>>2]=0;nd(y,v);f=c[a>>2]|0;if((c[r>>2]|0)!=(f|0)){e=0;do{t=f;l=c[b>>2]|0;i=l+(m<<4)|0;j=t+(e<<4)|0;i=Vw(c[j>>2]|0,c[j+4>>2]|0,c[i>>2]|0,c[i+4>>2]|0)|0;j=F()|0;l=l+(m<<4)+8|0;t=t+(e<<4)+8|0;l=Vw(c[t>>2]|0,c[t+4>>2]|0,c[l>>2]|0,c[l+4>>2]|0)|0;t=F()|0;f=z;c[f>>2]=i;c[f+4>>2]=j;f=p;c[f>>2]=l;c[f+4>>2]=t;f=c[n>>2]|0;if(f>>>0<(c[o>>2]|0)>>>0){c[f>>2]=c[z>>2];c[f+4>>2]=c[z+4>>2];c[f+8>>2]=c[z+8>>2];c[f+12>>2]=c[z+12>>2];c[n>>2]=f+16;}else _e(y,z);e=e+1|0;f=c[a>>2]|0;}while(e>>>0<(c[r>>2]|0)-f>>4>>>0)}e=c[B>>2]|0;if((e|0)==(c[q>>2]|0)){He(C,y);f=c[y>>2]|0;}else{c[e>>2]=0;l=e+4|0;c[l>>2]=0;h=e+8|0;c[h>>2]=0;f=c[y>>2]|0;g=(c[n>>2]|0)-f|0;i=g>>4;if(g){if(i>>>0>268435455)break;j=Zj(g)|0;c[l>>2]=j;c[e>>2]=j;c[h>>2]=j+(i<<4);f=c[y>>2]|0;g=(c[n>>2]|0)-f|0;if((g|0)>0){ax(j|0,f|0,g|0)|0;c[l>>2]=j+(g>>>4<<4);e=c[B>>2]|0;}}c[B>>2]=e+12;}if(f|0){c[n>>2]=f;$j(f);}m=m+1|0;if(m>>>0>=w>>>0)break a}gk();}}else if(f){n=y+4|0;o=y+8|0;p=z+8|0;m=0;while(1){c[y>>2]=0;c[n>>2]=0;c[o>>2]=0;nd(y,v);f=c[a>>2]|0;if((c[r>>2]|0)!=(f|0)){e=0;do{l=f;t=c[b>>2]|0;j=t+(m<<4)|0;i=l+(e<<4)|0;i=Ww(c[j>>2]|0,c[j+4>>2]|0,c[i>>2]|0,c[i+4>>2]|0)|0;j=F()|0;t=t+(m<<4)+8|0;l=l+(e<<4)+8|0;l=Ww(c[t>>2]|0,c[t+4>>2]|0,c[l>>2]|0,c[l+4>>2]|0)|0;t=F()|0;f=z;c[f>>2]=i;c[f+4>>2]=j;f=p;c[f>>2]=l;c[f+4>>2]=t;f=c[n>>2]|0;if(f>>>0<(c[o>>2]|0)>>>0){c[f>>2]=c[z>>2];c[f+4>>2]=c[z+4>>2];c[f+8>>2]=c[z+8>>2];c[f+12>>2]=c[z+12>>2];c[n>>2]=f+16;}else _e(y,z);e=e+1|0;f=c[a>>2]|0;}while(e>>>0<(c[r>>2]|0)-f>>4>>>0)}e=c[B>>2]|0;if((e|0)==(c[q>>2]|0)){He(C,y);f=c[y>>2]|0;}else{c[e>>2]=0;l=e+4|0;c[l>>2]=0;h=e+8|0;c[h>>2]=0;f=c[y>>2]|0;g=(c[n>>2]|0)-f|0;i=g>>4;if(g){if(i>>>0>268435455)break;j=Zj(g)|0;c[l>>2]=j;c[e>>2]=j;c[h>>2]=j+(i<<4);f=c[y>>2]|0;g=(c[n>>2]|0)-f|0;if((g|0)>0){ax(j|0,f|0,g|0)|0;c[l>>2]=j+(g>>>4<<4);e=c[B>>2]|0;}}c[B>>2]=e+12;}if(f|0){c[n>>2]=f;$j(f);}m=m+1|0;if(m>>>0>=w>>>0)break a}gk();}while(0);h=c[d>>2]|0;t=d+4|0;f=c[t>>2]|0;if((f|0)!=(h|0))do{e=f;f=f+-12|0;g=c[f>>2]|0;if(g|0){c[e+-8>>2]=g;$j(g);}}while((f|0)!=(h|0));c[t>>2]=h;s=w+s|0;md(d,A(s,v+1|0)|0);s=s+-1|0;b:do if(s|0){q=(u|0)==0;r=z+4|0;a=z+8|0;b=d+8|0;o=0;c:while(1){p=o;o=o+1|0;if(!q){n=0;do{c[z>>2]=0;c[r>>2]=0;c[a>>2]=0;g=Zj(64)|0;c[z>>2]=g;c[r>>2]=g;c[a>>2]=g+64;h=(p>>>0)%(w>>>0)|0;m=c[C>>2]|0;u=(n>>>0)%(v>>>0)|0;f=(c[m+(h*12|0)>>2]|0)+(u<<4)|0;c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];f=g+16|0;c[r>>2]=f;l=m+(((o>>>0)%(w>>>0)|0)*12|0)|0;u=(c[l>>2]|0)+(u<<4)|0;c[f>>2]=c[u>>2];c[f+4>>2]=c[u+4>>2];c[f+8>>2]=c[u+8>>2];c[f+12>>2]=c[u+12>>2];f=g+32|0;c[r>>2]=f;n=n+1|0;u=(n>>>0)%(v>>>0)|0;l=(c[l>>2]|0)+(u<<4)|0;c[f>>2]=c[l>>2];c[f+4>>2]=c[l+4>>2];c[f+8>>2]=c[l+8>>2];c[f+12>>2]=c[l+12>>2];f=g+48|0;c[r>>2]=f;u=(c[m+(h*12|0)>>2]|0)+(u<<4)|0;c[f>>2]=c[u>>2];c[f+4>>2]=c[u+4>>2];c[f+8>>2]=c[u+8>>2];c[f+12>>2]=c[u+12>>2];g=g+64|0;c[r>>2]=g;f=c[z>>2]|0;u=g-f|0;h=u>>4;if((u|0)>=48){m=h+-1|0;j=f+(m<<4)|0;m=f+(m<<4)+8|0;e=0;k=0.0;i=c[j+4>>2]|0;j=c[j>>2]|0;l=c[m+4>>2]|0;m=c[m>>2]|0;do{I=f+(e<<4)|0;H=j;j=c[I>>2]|0;G=i;i=c[I+4>>2]|0;I=f+(e<<4)+8|0;E=m;m=c[I>>2]|0;u=l;l=c[I+4>>2]|0;k=k+(+(H>>>0)+4294967296.0*+(G|0)+(+(j>>>0)+4294967296.0*+(i|0)))*(+(E>>>0)+4294967296.0*+(u|0)-(+(m>>>0)+4294967296.0*+(l|0)));e=e+1|0;}while((e|0)<(h|0));if(!(k*-.5>=0.0|(g|0)==(f|0))?(x=g+-16|0,x>>>0>f>>>0):0){e=x;do{c[y>>2]=c[f>>2];c[y+4>>2]=c[f+4>>2];c[y+8>>2]=c[f+8>>2];c[y+12>>2]=c[f+12>>2];c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[e>>2]=c[y>>2];c[e+4>>2]=c[y+4>>2];c[e+8>>2]=c[y+8>>2];c[e+12>>2]=c[y+12>>2];f=f+16|0;e=e+-16|0;}while(f>>>0<e>>>0)}}g=c[t>>2]|0;if((g|0)==(c[b>>2]|0)){He(d,z);f=c[z>>2]|0;}else{c[g>>2]=0;l=g+4|0;c[l>>2]=0;h=g+8|0;c[h>>2]=0;f=c[z>>2]|0;e=(c[r>>2]|0)-f|0;i=e>>4;if(e){if(i>>>0>268435455)break c;j=Zj(e)|0;c[l>>2]=j;c[g>>2]=j;c[h>>2]=j+(i<<4);f=c[z>>2]|0;e=(c[r>>2]|0)-f|0;if((e|0)>0){ax(j|0,f|0,e|0)|0;c[l>>2]=j+(e>>>4<<4);}}c[t>>2]=(c[t>>2]|0)+12;}if(f|0){c[r>>2]=f;$j(f);}}while(n>>>0<v>>>0)}if(o>>>0>=s>>>0)break b}gk();}while(0);h=c[C>>2]|0;if(!h){Eb=D;return}f=c[B>>2]|0;if((f|0)==(h|0))f=h;else{do{e=f;f=f+-12|0;g=c[f>>2]|0;if(g|0){c[e+-8>>2]=g;$j(g);}}while((f|0)!=(h|0));f=c[C>>2]|0;}c[B>>2]=h;$j(f);Eb=D;return}function Ud(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;u=Eb;Eb=Eb+144|0;m=u;Td(b,d,e,1,f);c[m+24>>2]=0;t=m+28|0;c[t>>2]=0;c[m+32>>2]=0;r=m+40|0;c[r>>2]=0;s=m+44|0;c[s>>2]=0;c[m+48>>2]=0;p=m+56|0;c[p>>2]=0;q=m+60|0;c[q>>2]=0;c[m+64>>2]=0;l=m+4|0;c[l>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;c[m>>2]=3556;j=m+72|0;f=m+112|0;b=j;d=b+36|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(d|0));c[f>>2]=f;i=m+116|0;c[i>>2]=f;h=m+120|0;c[h>>2]=0;a[m+128>>0]=0;n=m+20|0;a[n>>0]=0;a[m+140>>0]=0;a[m+142>>0]=0;a[m+36>>0]=0;o=m+37|0;a[o>>0]=0;g=e+4|0;b=c[e>>2]|0;a:do if((c[g>>2]|0)!=(b|0)){d=0;f=3556;while(1){Qb[c[f+8>>2]&15](m,b+(d*12|0)|0,0,1)|0;d=d+1|0;b=c[e>>2]|0;if(d>>>0>=(((c[g>>2]|0)-b|0)/12|0)>>>0)break a;f=c[m>>2]|0;}}while(0);Oc(m,1,e,1,1)|0;c[m>>2]=3556;d=m+112|0;if(c[h>>2]|0?(k=c[i>>2]|0,e=(c[d>>2]|0)+4|0,i=c[k>>2]|0,c[i+4>>2]=c[e>>2],c[c[e>>2]>>2]=i,c[h>>2]=0,(k|0)!=(d|0)):0){b=k;do{k=b;b=c[b+4>>2]|0;$j(k);}while((b|0)!=(d|0))}b=c[m+96>>2]|0;if(b|0){c[m+100>>2]=b;$j(b);}b=c[m+84>>2]|0;if(b|0){c[m+88>>2]=b;$j(b);}b=c[j>>2]|0;if(b|0){c[m+76>>2]=b;$j(b);}c[m>>2]=3528;i=m+8|0;h=c[i>>2]|0;e=m+12|0;c[e>>2]=h;c[l>>2]=h;h=m+24|0;b=c[t>>2]|0;d=c[h>>2]|0;if((b|0)!=(d|0)){g=0;do{f=c[d+(g<<2)>>2]|0;if(f){ak(f);d=c[h>>2]|0;b=c[t>>2]|0;}g=g+1|0;}while(g>>>0<b-d>>2>>>0);b=d;}c[t>>2]=b;a[n>>0]=0;a[o>>0]=0;b=c[p>>2]|0;if(b|0){c[q>>2]=b;$j(b);}b=c[r>>2]|0;if(b|0){c[s>>2]=b;$j(b);}b=c[h>>2]|0;if(b|0){c[t>>2]=b;$j(b);}b=c[i>>2]|0;if(!b){Eb=u;return}c[e>>2]=b;$j(b);Eb=u;return}function Vd(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0;L=Eb;Eb=Eb+176|0;C=L+24|0;y=L+12|0;z=L;c[C+24>>2]=0;K=C+28|0;c[K>>2]=0;c[C+32>>2]=0;H=C+40|0;c[H>>2]=0;J=C+44|0;c[J>>2]=0;c[C+48>>2]=0;G=C+56|0;c[G>>2]=0;I=C+60|0;c[I>>2]=0;c[C+64>>2]=0;B=C+4|0;c[B>>2]=0;c[B+4>>2]=0;c[B+8>>2]=0;c[B+12>>2]=0;c[C>>2]=3556;A=C+72|0;j=C+112|0;h=A;i=h+36|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));c[j>>2]=j;x=C+116|0;c[x>>2]=j;w=C+120|0;c[w>>2]=0;a[C+128>>0]=0;D=C+20|0;a[D>>0]=0;a[C+140>>0]=0;a[C+142>>0]=0;a[C+36>>0]=0;E=C+37|0;a[E>>0]=0;r=d+4|0;h=c[d>>2]|0;if((c[r>>2]|0)!=(h|0)){s=y+4|0;t=y+8|0;u=z+4|0;v=z+8|0;q=0;do{c[y>>2]=0;c[s>>2]=0;c[t>>2]=0;Td(b,h+(q*12|0)|0,y,1,f);h=c[y>>2]|0;if((c[s>>2]|0)!=(h|0)){i=0;do{Qb[c[(c[C>>2]|0)+8>>2]&15](C,h+(i*12|0)|0,0,1)|0;i=i+1|0;h=c[y>>2]|0;}while(i>>>0<(((c[s>>2]|0)-h|0)/12|0)>>>0)}if(f){c[z>>2]=0;c[u>>2]=0;c[v>>2]=0;p=c[d>>2]|0;k=p+(q*12|0)|0;o=c[b>>2]|0;m=o;l=c[m>>2]|0;m=c[m+4>>2]|0;o=o+8|0;n=c[o>>2]|0;o=c[o+4>>2]|0;p=p+(q*12|0)+4|0;i=c[p>>2]|0;h=c[k>>2]|0;j=i-h|0;if(j){af(z,j>>4);h=c[k>>2]|0;i=c[p>>2]|0;}if((i|0)!=(h|0)){i=0;do{N=h;Q=N+(i<<4)|0;Q=Vw(c[Q>>2]|0,c[Q+4>>2]|0,l|0,m|0)|0;P=F()|0;N=N+(i<<4)+8|0;N=Vw(c[N>>2]|0,c[N+4>>2]|0,n|0,o|0)|0;M=F()|0;j=c[z>>2]|0;O=j+(i<<4)|0;c[O>>2]=Q;c[O+4>>2]=P;j=j+(i<<4)+8|0;c[j>>2]=N;c[j+4>>2]=M;i=i+1|0;h=c[k>>2]|0;}while(i>>>0<(c[p>>2]|0)-h>>4>>>0)}Ec(C,z,1,1)|0;h=c[z>>2]|0;if(h|0){c[u>>2]=h;$j(h);}h=c[y>>2]|0;}if(h|0){i=c[s>>2]|0;if((i|0)==(h|0))i=h;else{do{j=i;i=i+-12|0;k=c[i>>2]|0;if(k|0){c[j+-8>>2]=k;$j(k);}}while((i|0)!=(h|0));i=c[y>>2]|0;}c[s>>2]=h;$j(i);}q=q+1|0;h=c[d>>2]|0;}while(q>>>0<(((c[r>>2]|0)-h|0)/12|0)>>>0)}Oc(C,1,e,1,1)|0;c[C>>2]=3556;h=C+112|0;if(c[w>>2]|0?(g=c[x>>2]|0,Q=(c[h>>2]|0)+4|0,P=c[g>>2]|0,c[P+4>>2]=c[Q>>2],c[c[Q>>2]>>2]=P,c[w>>2]=0,(g|0)!=(h|0)):0)do{Q=g;g=c[g+4>>2]|0;$j(Q);}while((g|0)!=(h|0));g=c[C+96>>2]|0;if(g|0){c[C+100>>2]=g;$j(g);}g=c[C+84>>2]|0;if(g|0){c[C+88>>2]=g;$j(g);}g=c[A>>2]|0;if(g|0){c[C+76>>2]=g;$j(g);}c[C>>2]=3528;l=C+8|0;k=c[l>>2]|0;m=C+12|0;c[m>>2]=k;c[B>>2]=k;k=C+24|0;g=c[K>>2]|0;h=c[k>>2]|0;if((g|0)!=(h|0)){j=0;do{i=c[h+(j<<2)>>2]|0;if(i){ak(i);h=c[k>>2]|0;g=c[K>>2]|0;}j=j+1|0;}while(j>>>0<g-h>>2>>>0);g=h;}c[K>>2]=g;a[D>>0]=0;a[E>>0]=0;g=c[G>>2]|0;if(g|0){c[I>>2]=g;$j(g);}g=c[H>>2]|0;if(g|0){c[J>>2]=g;$j(g);}g=c[k>>2]|0;if(g|0){c[K>>2]=g;$j(g);}g=c[l>>2]|0;if(!g){Eb=L;return}c[m>>2]=g;$j(g);Eb=L;return}function Wd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;u=Eb;Eb=Eb+144|0;m=u;Td(b,d,e,0,1);c[m+24>>2]=0;t=m+28|0;c[t>>2]=0;c[m+32>>2]=0;r=m+40|0;c[r>>2]=0;s=m+44|0;c[s>>2]=0;c[m+48>>2]=0;p=m+56|0;c[p>>2]=0;q=m+60|0;c[q>>2]=0;c[m+64>>2]=0;l=m+4|0;c[l>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;c[m>>2]=3556;k=m+72|0;f=m+112|0;b=k;d=b+36|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(d|0));c[f>>2]=f;i=m+116|0;c[i>>2]=f;h=m+120|0;c[h>>2]=0;a[m+128>>0]=0;n=m+20|0;a[n>>0]=0;a[m+140>>0]=0;a[m+142>>0]=0;a[m+36>>0]=0;o=m+37|0;a[o>>0]=0;g=e+4|0;b=c[e>>2]|0;a:do if((c[g>>2]|0)!=(b|0)){d=0;f=3556;while(1){Qb[c[f+8>>2]&15](m,b+(d*12|0)|0,0,1)|0;d=d+1|0;b=c[e>>2]|0;if(d>>>0>=(((c[g>>2]|0)-b|0)/12|0)>>>0)break a;f=c[m>>2]|0;}}while(0);Oc(m,1,e,1,1)|0;c[m>>2]=3556;d=m+112|0;if(c[h>>2]|0?(j=c[i>>2]|0,e=(c[d>>2]|0)+4|0,i=c[j>>2]|0,c[i+4>>2]=c[e>>2],c[c[e>>2]>>2]=i,c[h>>2]=0,(j|0)!=(d|0)):0){b=j;do{j=b;b=c[b+4>>2]|0;$j(j);}while((b|0)!=(d|0))}b=c[m+96>>2]|0;if(b|0){c[m+100>>2]=b;$j(b);}b=c[m+84>>2]|0;if(b|0){c[m+88>>2]=b;$j(b);}b=c[k>>2]|0;if(b|0){c[m+76>>2]=b;$j(b);}c[m>>2]=3528;i=m+8|0;h=c[i>>2]|0;e=m+12|0;c[e>>2]=h;c[l>>2]=h;h=m+24|0;b=c[t>>2]|0;d=c[h>>2]|0;if((b|0)!=(d|0)){g=0;do{f=c[d+(g<<2)>>2]|0;if(f){ak(f);d=c[h>>2]|0;b=c[t>>2]|0;}g=g+1|0;}while(g>>>0<b-d>>2>>>0);b=d;}c[t>>2]=b;a[n>>0]=0;a[o>>0]=0;b=c[p>>2]|0;if(b|0){c[q>>2]=b;$j(b);}b=c[r>>2]|0;if(b|0){c[s>>2]=b;$j(b);}b=c[h>>2]|0;if(b|0){c[t>>2]=b;$j(b);}b=c[i>>2]|0;if(!b){Eb=u;return}c[e>>2]=b;$j(b);Eb=u;return}function Xd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;switch(d|0){case 2:{f=(a[b+36>>0]|0)!=0;break}case 1:return;default:f=0;}k=b+4|0;n=b+8|0;do if(!(f|(c[k>>2]|0)==(c[n>>2]|0))){l=e+4|0;g=c[l>>2]|0;if((g|0)==(c[e+8>>2]|0)){He(e,k);break}c[g>>2]=0;m=g+4|0;c[m>>2]=0;h=g+8|0;c[h>>2]=0;f=(c[n>>2]|0)-(c[k>>2]|0)|0;i=f>>4;if(f|0){if(i>>>0>268435455)gk();j=Zj(f)|0;c[m>>2]=j;c[g>>2]=j;c[h>>2]=j+(i<<4);g=c[k>>2]|0;f=(c[n>>2]|0)-g|0;if((f|0)>0){ax(j|0,g|0,f|0)|0;c[m>>2]=j+(f>>>4<<4);}}c[l>>2]=(c[l>>2]|0)+12;}while(0);i=b+16|0;h=b+20|0;f=c[i>>2]|0;if(((c[h>>2]|0)-f|0)<=0)return;g=0;do{Xd(c[f+(g<<2)>>2]|0,d,e);g=g+1|0;f=c[i>>2]|0;}while((g|0)<((c[h>>2]|0)-f>>2|0));return}function Yd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=b+4|0;e=c[g>>2]|0;f=c[b>>2]|0;h=f;d=e;if((e|0)!=(f|0)){if((h|0)!=(d|0))do{e=d;d=d+-12|0;f=c[d>>2]|0;if(f|0){c[e+-8>>2]=f;$j(f);}}while((d|0)!=(h|0));c[g>>2]=h;}e=c[a+48>>2]|0;h=(c[a+52>>2]|0)-e|0;d=h>>2;if((h|0)>0)d=d+(((c[c[a+16>>2]>>2]|0)!=(c[e>>2]|0))<<31>>31)|0;md(b,d);Xd(a,0,b);return}function Zd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=b+4|0;e=c[g>>2]|0;f=c[b>>2]|0;h=f;d=e;if((e|0)!=(f|0)){if((h|0)!=(d|0))do{e=d;d=d+-12|0;f=c[d>>2]|0;if(f|0){c[e+-8>>2]=f;$j(f);}}while((d|0)!=(h|0));c[g>>2]=h;}e=c[a+48>>2]|0;h=(c[a+52>>2]|0)-e|0;d=h>>2;if((h|0)>0)d=d+(((c[c[a+16>>2]>>2]|0)!=(c[e>>2]|0))<<31>>31)|0;md(b,d);Xd(a,2,b);return}function _d(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;p=d+4|0;n=c[p>>2]|0;o=c[d>>2]|0;h=o;e=n;if((n|0)!=(o|0)){if((h|0)!=(e|0))do{f=e;e=e+-12|0;g=c[e>>2]|0;if(g|0){c[f+-8>>2]=g;$j(g);}}while((e|0)!=(h|0));c[p>>2]=h;}f=c[b+48>>2]|0;o=(c[b+52>>2]|0)-f|0;e=o>>2;if((o|0)>0)e=e+(((c[c[b+16>>2]>>2]|0)!=(c[f>>2]|0))<<31>>31)|0;md(d,e);o=b+16|0;m=b+20|0;e=c[o>>2]|0;if(((c[m>>2]|0)-e|0)<=0)return;n=d+8|0;l=0;a:while(1){e=c[e+(l<<2)>>2]|0;do if(a[e+36>>0]|0){g=e+4|0;j=c[p>>2]|0;if((j|0)==(c[n>>2]|0)){He(d,g);break}c[j>>2]=0;k=j+4|0;c[k>>2]=0;h=j+8|0;c[h>>2]=0;b=e+8|0;e=(c[b>>2]|0)-(c[g>>2]|0)|0;f=e>>4;if(e|0){if(f>>>0>268435455){e=17;break a}i=Zj(e)|0;c[k>>2]=i;c[j>>2]=i;c[h>>2]=i+(f<<4);f=c[g>>2]|0;e=(c[b>>2]|0)-f|0;if((e|0)>0){ax(i|0,f|0,e|0)|0;c[k>>2]=i+(e>>>4<<4);}}c[p>>2]=(c[p>>2]|0)+12;}while(0);l=l+1|0;e=c[o>>2]|0;if((l|0)>=((c[m>>2]|0)-e>>2|0)){e=12;break}}if((e|0)==12)return;else if((e|0)==17)gk();}function $d(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0.0,k=0,l=0,m=0.0;h=~~+g[b>>3]>>>0;c[a+4>>2]=c[a>>2];if(!h)return;af(a,h);e=b+8|0;f=0;while(1){m=+g[e>>3];l=+s(m)>=1.0?(m>0.0?~~+B(+r(m/4294967296.0),4294967295.0)>>>0:~~+z((m-+(~~m>>>0))/4294967296.0)>>>0):0;d=b+16|0;j=+g[d>>3];i=+s(j)>=1.0?(j>0.0?~~+B(+r(j/4294967296.0),4294967295.0)>>>0:~~+z((j-+(~~j>>>0))/4294967296.0)>>>0):0;e=c[a>>2]|0;k=e+(f<<4)|0;c[k>>2]=~~m>>>0;c[k+4>>2]=l;e=e+(f<<4)+8|0;c[e>>2]=~~j>>>0;c[e+4>>2]=i;f=f+1|0;if((f|0)==(h|0))break;else{e=b+24|0;b=d;}}return}function ae(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,t=0,u=0,v=0.0,w=0,x=0,y=0.0;u=Eb;Eb=Eb+16|0;q=u;t=~~+g[b>>3]>>>0;h=b+8|0;f=c[a>>2]|0;p=a+4|0;b=c[p>>2]|0;if((b|0)!=(f|0))do{d=b;b=b+-12|0;e=c[b>>2]|0;if(e|0){c[d+-8>>2]=e;$j(e);}}while((b|0)!=(f|0));c[p>>2]=f;md(a,t);if(!t){Eb=u;return}m=q+4|0;n=q+8|0;o=a+8|0;l=0;while(1){c[q>>2]=0;c[n>>2]=0;f=~~+g[h>>3]>>>0;c[m>>2]=0;if(!f)b=1;else{af(q,f);i=f<<1;b=h+8|0;d=0;e=h;while(1){y=+g[b>>3];x=+s(y)>=1.0?(y>0.0?~~+B(+r(y/4294967296.0),4294967295.0)>>>0:~~+z((y-+(~~y>>>0))/4294967296.0)>>>0):0;j=e+16|0;v=+g[j>>3];b=+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0;k=c[q>>2]|0;w=k+(d<<4)|0;c[w>>2]=~~y>>>0;c[w+4>>2]=x;k=k+(d<<4)+8|0;c[k>>2]=~~v>>>0;c[k+4>>2]=b;d=d+1|0;if((d|0)==(f|0))break;else{b=e+24|0;e=j;}}b=i|1;}h=h+(b<<3)|0;j=c[p>>2]|0;if((j|0)==(c[o>>2]|0)){He(a,q);b=c[q>>2]|0;}else{c[j>>2]=0;k=j+4|0;c[k>>2]=0;e=j+8|0;c[e>>2]=0;b=c[q>>2]|0;d=(c[m>>2]|0)-b|0;f=d>>4;if(d){if(f>>>0>268435455){b=16;break}i=Zj(d)|0;c[k>>2]=i;c[j>>2]=i;c[e>>2]=i+(f<<4);b=c[q>>2]|0;d=(c[m>>2]|0)-b|0;if((d|0)>0){ax(i|0,b|0,d|0)|0;c[k>>2]=i+(d>>>4<<4);}}c[p>>2]=(c[p>>2]|0)+12;}if(b|0){c[m>>2]=b;$j(b);}l=l+1|0;if(l>>>0>=t>>>0){b=8;break}}if((b|0)==8){Eb=u;return}else if((b|0)==16)gk();}function be(a,b){a=a|0;b=b|0;ae(a,b);return}function ce(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+16|0;k=l;h=c[b>>2]|0;i=(c[b+4>>2]|0)-h|0;j=i>>4;f=hk((A(2<<3,j)|0)+8|0)|0;g[f>>3]=+(j>>>0);if(!i){j=j<<1;j=j+1|0;i=f;c[k>>2]=j;j=k+4|0;c[j>>2]=i;k=ua(1072,k|0)|0;c[a>>2]=k;Eb=l;return}b=0;d=f+8|0;e=f;while(1){i=h+(b<<4)|0;g[d>>3]=+((c[i>>2]|0)>>>0)+4294967296.0*+(c[i+4>>2]|0);i=e+16|0;d=h+(b<<4)+8|0;g[i>>3]=+((c[d>>2]|0)>>>0)+4294967296.0*+(c[d+4>>2]|0);b=b+1|0;if(b>>>0>=j>>>0)break;else{d=e+24|0;e=i;}}j=j<<1;j=j+1|0;i=f;c[k>>2]=j;j=k+4|0;c[j>>2]=i;k=ua(1072,k|0)|0;c[a>>2]=k;Eb=l;return}function de(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0;k=c[a>>2]|0;d=(c[a+4>>2]|0)-k|0;j=(d|0)/12|0;d=(d|0)==0;if(d){k=hk(8)|0;g[k>>3]=+(j>>>0);return k|0}a=1;b=0;do{a=a+1+((c[k+(b*12|0)+4>>2]|0)-(c[k+(b*12|0)>>2]|0)>>4<<1)|0;b=b+1|0;}while(b>>>0<j>>>0);a=hk(a<<3)|0;g[a>>3]=+(j>>>0);if(d){k=a;return k|0}d=a+8|0;i=0;while(1){h=c[k+(i*12|0)>>2]|0;e=(c[k+(i*12|0)+4>>2]|0)-h|0;f=e>>4;g[d>>3]=+(f>>>0);b=d+8|0;if(e){e=0;do{l=h+(e<<4)|0;g[b>>3]=+((c[l>>2]|0)>>>0)+4294967296.0*+(c[l+4>>2]|0);b=d;d=d+16|0;l=h+(e<<4)+8|0;g[d>>3]=+((c[l>>2]|0)>>>0)+4294967296.0*+(c[l+4>>2]|0);e=e+1|0;b=b+24|0;}while(e>>>0<f>>>0)}i=i+1|0;if(i>>>0>=j>>>0)break;else d=b;}return a|0}function ee(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+16|0;h=i;g=c[b>>2]|0;e=(c[b+4>>2]|0)-g|0;f=(e|0)/12|0;if(!e)d=1;else{d=1;e=0;do{d=d+1+((c[g+(e*12|0)+4>>2]|0)-(c[g+(e*12|0)>>2]|0)>>4<<1)|0;e=e+1|0;}while(e>>>0<f>>>0)}b=de(b)|0;c[h>>2]=d;c[h+4>>2]=b;h=ua(1072,h|0)|0;c[a>>2]=h;Eb=i;return}function fe(a){a=a|0;var b=0;la(7671,3,3600,8958,1,87);la(7678,3,3612,8958,2,88);la(7686,2,3624,9150,26,89);la(7695,2,3632,9150,27,90);ia(1192,7705,4,0);ja(1192,7714,0);ja(1192,7727,1);ja(1192,7733,2);ja(1192,7744,3);ia(1200,7748,4,0);ja(1200,7757,0);ja(1200,7765,1);ia(1208,7770,4,0);ja(1208,7783,0);ja(1208,7791,1);ja(1208,7799,2);ja(1208,7808,3);da(1216,1224,1240,0,9306,5,9309,0,9309,0,7817,9311,94);b=Zj(8)|0;c[b>>2]=1;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=1;c[a+4>>2]=0;ga(1216,7826,3464,9314,1,b|0,3464,9318,1,a|0);a=Zj(8)|0;c[a>>2]=2;c[a+4>>2]=0;b=Zj(8)|0;c[b>>2]=2;c[b+4>>2]=0;ga(1216,7828,3464,9314,1,a|0,3464,9318,1,b|0);la(7830,3,3640,9323,1,1);ke(7842);le(7847);ia(1320,7853,4,0);ja(1320,7865,1);ja(1320,7881,2);ja(1320,7896,4);ia(1328,7914,4,0);ja(1328,7923,0);ja(1328,7930,1);ja(1328,7936,2);ia(1336,7942,4,0);ja(1336,7950,0);ja(1336,7964,1);ja(1336,7975,2);ja(1336,7984,3);ja(1336,7995,4);da(1064,1344,1360,0,9306,6,9309,0,9309,0,8005,9311,95);ea(1064,1,3724,9306,7,1);b=Zj(4)|0;c[b>>2]=4;a=Zj(4)|0;c[a>>2]=4;ga(1064,8014,1112,9150,28,b|0,1112,8958,3,a|0);a=Zj(4)|0;c[a>>2]=16;b=Zj(4)|0;c[b>>2]=16;ga(1064,8022,1400,9150,29,a|0,1400,8958,4,b|0);b=Zj(8)|0;c[b>>2]=8;c[b+4>>2]=0;fa(1064,8029,2,3728,9150,30,b|0,0);b=Zj(8)|0;c[b>>2]=9;c[b+4>>2]=0;fa(1064,8039,2,3728,9150,30,b|0,0);b=Zj(8)|0;c[b>>2]=10;c[b+4>>2]=0;fa(1064,8047,2,3736,9150,31,b|0,0);b=Zj(8)|0;c[b>>2]=11;c[b+4>>2]=0;fa(1064,8054,2,3736,9150,31,b|0,0);b=Zj(8)|0;c[b>>2]=12;c[b+4>>2]=0;fa(1064,8061,2,3744,9150,32,b|0,0);ne(8072);da(1456,1472,1488,1064,9306,13,9306,14,9306,15,8082,9311,96);ea(1456,1,3788,9306,16,2);b=Zj(8)|0;c[b>>2]=17;c[b+4>>2]=0;fa(1456,8091,2,3808,9150,33,b|0,0);b=Zj(8)|0;c[b>>2]=97;c[b+4>>2]=0;fa(1456,8100,2,3816,10111,91,b|0,0);b=Zj(8)|0;c[b>>2]=18;c[b+4>>2]=0;fa(1456,8106,2,3824,9150,34,b|0,0);la(8112,2,3832,9150,35,19);la(8124,2,3840,9314,2,3);la(8129,3,3848,9487,7,36);la(8144,4,112,9481,4,5);la(8160,4,128,9481,5,6);la(8182,3,3860,8958,7,92);la(8208,4,144,10115,1,2);la(8208,3,3872,9318,3,3);la(8221,4,160,10115,2,4);la(8221,3,3884,9318,5,4);la(8235,5,176,10121,4,6);la(8252,5,208,10121,5,7);la(8270,4,240,9481,8,8);la(8284,3,3896,8958,9,93);la(8300,3,3896,8958,9,94);la(8324,3,3908,8958,10,95);la(8346,2,3920,10111,96,98);la(8358,2,3928,10111,97,99);da(1504,1512,1528,0,9306,20,9309,0,9309,0,8371,9311,100);b=Zj(8)|0;c[b>>2]=4;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=5;c[a+4>>2]=0;ga(1504,8379,3464,9314,3,b|0,3464,9318,6,a|0);a=Zj(8)|0;c[a>>2]=5;c[a+4>>2]=0;b=Zj(8)|0;c[b>>2]=6;c[b+4>>2]=0;ga(1504,8384,3464,9314,3,a|0,3464,9318,6,b|0);b=Zj(8)|0;c[b>>2]=6;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=7;c[a+4>>2]=0;ga(1504,8388,3464,9314,3,b|0,3464,9318,6,a|0);a=Zj(8)|0;c[a>>2]=7;c[a+4>>2]=0;b=Zj(8)|0;c[b>>2]=8;c[b+4>>2]=0;ga(1504,8394,3464,9314,3,a|0,3464,9318,6,b|0);da(1040,1544,1560,0,9306,21,9309,0,9309,0,8401,9311,101);b=Zj(8)|0;c[b>>2]=8;c[b+4>>2]=1;fa(1040,8413,5,256,10259,1,b|0,0);b=Zj(8)|0;c[b>>2]=3;c[b+4>>2]=0;fa(1040,8421,5,288,10259,2,b|0,0);b=Zj(8)|0;c[b>>2]=12;c[b+4>>2]=1;fa(1040,8100,2,3936,10111,98,b|0,0);b=Zj(8)|0;c[b>>2]=99;c[b+4>>2]=0;fa(1040,8430,2,3944,9150,37,b|0,0);b=Zj(8)|0;c[b>>2]=22;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=100;c[a+4>>2]=0;ga(1040,8440,3376,9150,38,b|0,3376,8958,11,a|0);da(1048,1576,1592,1040,9306,23,9306,24,9306,25,8458,9311,102);ea(1048,2,3952,9150,39,26);a=Zj(8)|0;c[a>>2]=4;c[a+4>>2]=0;fa(1048,8466,5,320,10259,3,a|0,0);a=Zj(8)|0;c[a>>2]=4;c[a+4>>2]=0;fa(1048,8479,6,352,10315,1,a|0,0);a=Zj(8)|0;c[a>>2]=5;c[a+4>>2]=0;fa(1048,8505,5,384,10259,5,a|0,0);a=Zj(8)|0;c[a>>2]=6;c[a+4>>2]=0;fa(1048,8521,6,416,10315,2,a|0,0);a=Zj(8)|0;c[a>>2]=27;c[a+4>>2]=0;b=Zj(8)|0;c[b>>2]=101;c[b+4>>2]=0;ga(1048,8550,3376,9150,40,a|0,3376,8958,12,b|0);b=Zj(8)|0;c[b>>2]=28;c[b+4>>2]=0;a=Zj(8)|0;c[a>>2]=102;c[a+4>>2]=0;ga(1048,8566,3376,9150,40,b|0,3376,8958,12,a|0);da(1608,1616,1632,0,9306,29,9309,0,9309,0,8581,9311,103);ea(1608,3,3960,9323,2,41);a=Zj(8)|0;c[a>>2]=9;c[a+4>>2]=0;fa(1608,8413,5,448,10121,6,a|0,0);a=Zj(8)|0;c[a>>2]=10;c[a+4>>2]=0;fa(1608,8421,5,480,10121,7,a|0,0);a=Zj(8)|0;c[a>>2]=7;c[a+4>>2]=0;fa(1608,8466,4,512,10115,3,a|0,0);a=Zj(8)|0;c[a>>2]=8;c[a+4>>2]=0;fa(1608,8505,4,528,10115,4,a|0,0);a=Zj(8)|0;c[a>>2]=104;c[a+4>>2]=0;fa(1608,8100,2,3972,10111,103,a|0,0);a=Zj(4)|0;c[a>>2]=0;b=Zj(4)|0;c[b>>2]=0;ga(1608,8595,3464,9314,4,a|0,3464,9318,9,b|0);b=Zj(4)|0;c[b>>2]=8;a=Zj(4)|0;c[a>>2]=8;ga(1608,8606,3464,9314,4,b|0,3464,9318,9,a|0);return}function ge(a){a=a|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function he(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function ie(a){a=a|0;a=a+8|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function je(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;a=a+8|0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function ke(a){a=a|0;da(1112,1256,1272,0,9306,30,9309,0,9309,0,a|0,9311,105);ea(1112,1,3652,9306,31,3);a=Zj(8)|0;c[a>>2]=104;c[a+4>>2]=0;fa(1112,9328,3,3656,8958,13,a|0,0);a=Zj(8)|0;c[a>>2]=14;c[a+4>>2]=0;fa(1112,9338,4,16,9481,11,a|0,0);a=Zj(8)|0;c[a>>2]=32;c[a+4>>2]=0;fa(1112,9345,2,3668,9150,42,a|0,0);a=Zj(4)|0;c[a>>2]=15;fa(1112,9350,3,3676,9487,8,a|0,0);a=Zj(4)|0;c[a>>2]=9;fa(1112,9354,4,32,9492,6,a|0,0);return}function le(a){a=a|0;da(1160,1288,1304,0,9306,33,9309,0,9309,0,a|0,9311,106);ea(1160,1,3688,9306,34,4);a=Zj(8)|0;c[a>>2]=105;c[a+4>>2]=0;fa(1160,9328,3,3692,8958,16,a|0,0);a=Zj(8)|0;c[a>>2]=17;c[a+4>>2]=0;fa(1160,9338,4,48,9481,12,a|0,0);a=Zj(8)|0;c[a>>2]=35;c[a+4>>2]=0;fa(1160,9345,2,3704,9150,43,a|0,0);a=Zj(4)|0;c[a>>2]=18;fa(1160,9350,3,3712,9487,10,a|0,0);a=Zj(4)|0;c[a>>2]=11;fa(1160,9354,4,64,9492,7,a|0,0);return}function me(a){a=a|0;return c[a+28>>2]|0}function ne(a){a=a|0;da(1400,1424,1440,0,9306,36,9309,0,9309,0,a|0,9311,107);ea(1400,1,3752,9306,37,5);a=Zj(8)|0;c[a>>2]=106;c[a+4>>2]=0;fa(1400,9328,3,3756,8958,19,a|0,0);a=Zj(8)|0;c[a>>2]=20;c[a+4>>2]=0;fa(1400,9338,4,80,9481,13,a|0,0);a=Zj(8)|0;c[a>>2]=38;c[a+4>>2]=0;fa(1400,9345,2,3768,9150,44,a|0,0);a=Zj(4)|0;c[a>>2]=21;fa(1400,9350,3,3776,9487,12,a|0,0);a=Zj(4)|0;c[a>>2]=13;fa(1400,9354,4,96,9492,8,a|0,0);return}function oe(a){a=a|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function pe(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function qe(a){a=a|0;a=a+8|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function re(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;a=a+8|0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function se(a){a=a|0;a=a+16|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function te(a,b){a=a|0;b=+b;var d=0;d=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;a=a+16|0;c[a>>2]=~~b>>>0;c[a+4>>2]=d;return}function ue(a){a=a|0;a=a+24|0;return +(+((c[a>>2]|0)>>>0)+4294967296.0*+(c[a+4>>2]|0))}function ve(a,b){return}function we(b){b=b|0;return (a[b+36>>0]|0)!=0|0}function xe(b,c){b=b|0;c=c|0;a[b+36>>0]=c&1;return}function ye(b){b=b|0;return (a[b+140>>0]|0)!=0|0}function ze(b,c){b=b|0;c=c|0;a[b+140>>0]=c&1;return}function Ae(b){b=b|0;return (a[b+142>>0]|0)!=0|0}function Be(b,c){b=b|0;c=c|0;a[b+142>>0]=c&1;return}function Ce(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;c[a>>2]=3556;e=a+112|0;d=a+120|0;if(c[d>>2]|0?(b=c[a+116>>2]|0,f=(c[e>>2]|0)+4|0,g=c[b>>2]|0,c[g+4>>2]=c[f>>2],c[c[f>>2]>>2]=g,c[d>>2]=0,(b|0)!=(e|0)):0)do{g=b;b=c[b+4>>2]|0;$j(g);}while((b|0)!=(e|0));b=c[a+96>>2]|0;if(b|0){c[a+100>>2]=b;$j(b);}b=c[a+84>>2]|0;if(b|0){c[a+88>>2]=b;$j(b);}b=c[a+72>>2]|0;if(!b){yc(a);$j(a);return}c[a+76>>2]=b;$j(b);yc(a);$j(a);return}function De(a){a=a|0;var b=0;c[a>>2]=3512;b=c[a+16>>2]|0;if(b|0){c[a+20>>2]=b;$j(b);}b=c[a+4>>2]|0;if(!b){$j(a);return}c[a+8>>2]=b;$j(b);$j(a);return}function Ee(b){b=b|0;var d=0;c[b>>2]=3588;d=b+4|0;if((a[d+11>>0]|0)>=0){$j(b);return}$j(c[d>>2]|0);$j(b);return}function Fe(b){b=b|0;b=b+4|0;if((a[b+11>>0]|0)<0){b=c[b>>2]|0;return b|0}else return b|0;}function Ge(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>4;d=g+1|0;if(d>>>0>268435455)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>3;h=f>>4>>>0<134217727?(h>>>0<d>>>0?d:h):268435455;do if(h)if(h>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<4)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<4)|0;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+16;c[l>>2]=e+(h<<4);if(!j)return;$j(j);return}function He(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;p=a+4|0;l=c[p>>2]|0;d=c[a>>2]|0;h=(l-d|0)/12|0;e=h+1|0;m=d;if(e>>>0>357913941)gk();o=a+8|0;k=((c[o>>2]|0)-d|0)/12|0;n=k<<1;e=k>>>0<178956970?(n>>>0<e>>>0?e:n):357913941;do if(e)if(e>>>0>357913941){p=S(8)|0;dk(p,8694);c[p>>2]=7328;V(p|0,3264,87);}else{g=Zj(e*12|0)|0;break}else g=0;while(0);f=g+(h*12|0)|0;n=g+(e*12|0)|0;c[f>>2]=0;k=g+(h*12|0)+4|0;c[k>>2]=0;i=g+(h*12|0)+8|0;c[i>>2]=0;j=c[b>>2]|0;e=(c[b+4>>2]|0)-j|0;g=e>>4;if(e|0){if(g>>>0>268435455)gk();h=Zj(e)|0;c[k>>2]=h;c[f>>2]=h;c[i>>2]=h+(g<<4);if((e|0)>0){ax(h|0,j|0,e|0)|0;c[k>>2]=h+(e>>>4<<4);}}g=f+12|0;if((l|0)!=(m|0)){d=l;do{b=f;f=f+-12|0;k=d;d=d+-12|0;c[f>>2]=0;j=b+-8|0;c[j>>2]=0;b=b+-4|0;c[b>>2]=0;c[f>>2]=c[d>>2];l=k+-8|0;c[j>>2]=c[l>>2];k=k+-4|0;c[b>>2]=c[k>>2];c[k>>2]=0;c[l>>2]=0;c[d>>2]=0;}while((d|0)!=(m|0));d=c[a>>2]|0;e=c[p>>2]|0;h=d;c[a>>2]=f;c[p>>2]=g;c[o>>2]=n;if((e|0)!=(h|0))do{f=e;e=e+-12|0;g=c[e>>2]|0;if(g|0){c[f+-8>>2]=g;$j(g);}}while((e|0)!=(h|0))}else{c[a>>2]=f;c[p>>2]=g;c[o>>2]=n;}if(!d)return;$j(d);return}function Ie(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<2)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Je(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>4;d=g+1|0;if(d>>>0>268435455)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>3;h=f>>4>>>0<134217727?(h>>>0<d>>>0?d:h):268435455;do if(h)if(h>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<4)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<4)|0;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+16;c[l>>2]=e+(h<<4);if(!j)return;$j(j);return}function Ke(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<2)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Le(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;r=Eb;Eb=Eb+16|0;q=r;a:while(1){m=b;e=b+-16|0;n=b+-32|0;o=b;p=a;b:while(1){f=m-p|0;a=f>>4;switch(a|0){case 2:{k=4;break a}case 3:{k=6;break a}case 4:{k=14;break a}case 5:{k=15;break a}case 1:case 0:{k=95;break a}}if((f|0)<496){k=21;break a}k=p+(((a|0)/2|0)<<4)|0;do if((f|0)>15984){f=(a|0)/4|0;h=p+(f<<4)|0;f=k+(f<<4)|0;a=Me(p,h,k,f,d)|0;j=f;g=c[j+4>>2]|0;l=e;i=c[l+4>>2]|0;if(!((g|0)<(i|0)|((g|0)==(i|0)?(c[j>>2]|0)>>>0<(c[l>>2]|0)>>>0:0))){f=k;break}c[q>>2]=c[f>>2];c[q+4>>2]=c[f+4>>2];c[q+8>>2]=c[f+8>>2];c[q+12>>2]=c[f+12>>2];c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];g=a+1|0;j=k;s=c[j+4>>2]|0;l=f;i=c[l+4>>2]|0;if((s|0)<(i|0)|((s|0)==(i|0)?(c[j>>2]|0)>>>0<(c[l>>2]|0)>>>0:0)){c[q>>2]=c[k>>2];c[q+4>>2]=c[k+4>>2];c[q+8>>2]=c[k+8>>2];c[q+12>>2]=c[k+12>>2];c[k>>2]=c[f>>2];c[k+4>>2]=c[f+4>>2];c[k+8>>2]=c[f+8>>2];c[k+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];f=a+2|0;l=h;i=c[l+4>>2]|0;s=k;j=c[s+4>>2]|0;if((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0)){c[q>>2]=c[h>>2];c[q+4>>2]=c[h+4>>2];c[q+8>>2]=c[h+8>>2];c[q+12>>2]=c[h+12>>2];c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[k>>2]=c[q>>2];c[k+4>>2]=c[q+4>>2];c[k+8>>2]=c[q+8>>2];c[k+12>>2]=c[q+12>>2];l=p;i=c[l+4>>2]|0;s=h;j=c[s+4>>2]|0;if((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0)){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[h>>2];c[p+4>>2]=c[h+4>>2];c[p+8>>2]=c[h+8>>2];c[p+12>>2]=c[h+12>>2];c[h>>2]=c[q>>2];c[h+4>>2]=c[q+4>>2];c[h+8>>2]=c[q+8>>2];c[h+12>>2]=c[q+12>>2];a=a+4|0;f=k;}else{a=a+3|0;f=k;}}else{a=f;f=k;}}else{a=g;f=k;}}else{l=p;i=c[l+4>>2]|0;j=k;s=c[j>>2]|0;j=c[j+4>>2]|0;a=e;h=c[a+4>>2]|0;a=(j|0)<(h|0)|((j|0)==(h|0)?s>>>0<(c[a>>2]|0)>>>0:0);if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<s>>>0:0))){if(!a){a=0;f=k;break}c[q>>2]=c[k>>2];c[q+4>>2]=c[k+4>>2];c[q+8>>2]=c[k+8>>2];c[q+12>>2]=c[k+12>>2];c[k>>2]=c[e>>2];c[k+4>>2]=c[e+4>>2];c[k+8>>2]=c[e+8>>2];c[k+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];l=p;i=c[l+4>>2]|0;s=k;j=c[s+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){a=1;f=k;break}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[k>>2];c[p+4>>2]=c[k+4>>2];c[p+8>>2]=c[k+8>>2];c[p+12>>2]=c[k+12>>2];c[k>>2]=c[q>>2];c[k+4>>2]=c[q+4>>2];c[k+8>>2]=c[q+8>>2];c[k+12>>2]=c[q+12>>2];a=2;f=k;break}if(a){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];a=1;f=k;break}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[k>>2];c[p+4>>2]=c[k+4>>2];c[p+8>>2]=c[k+8>>2];c[p+12>>2]=c[k+12>>2];c[k>>2]=c[q>>2];c[k+4>>2]=c[q+4>>2];c[k+8>>2]=c[q+8>>2];c[k+12>>2]=c[q+12>>2];l=k;i=c[l+4>>2]|0;s=e;j=c[s+4>>2]|0;if((i|0)<(j|0)|((i|0)==(j|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0)){c[q>>2]=c[k>>2];c[q+4>>2]=c[k+4>>2];c[q+8>>2]=c[k+8>>2];c[q+12>>2]=c[k+12>>2];c[k>>2]=c[e>>2];c[k+4>>2]=c[e+4>>2];c[k+8>>2]=c[e+8>>2];c[k+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];a=2;f=k;}else{a=1;f=k;}}while(0);h=f;g=c[h>>2]|0;h=c[h+4>>2]|0;l=p;j=c[l>>2]|0;l=c[l+4>>2]|0;if((h|0)<(l|0)|(h|0)==(l|0)&g>>>0<j>>>0)f=e;else{if((p|0)==(n|0)){k=58;break}f=n;while(1){s=f;i=c[s+4>>2]|0;if((h|0)<(i|0)|((h|0)==(i|0)?g>>>0<(c[s>>2]|0)>>>0:0))break;f=f+-16|0;if((p|0)==(f|0)){k=57;break b}}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[f>>2];c[p+4>>2]=c[f+4>>2];c[p+8>>2]=c[f+8>>2];c[p+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];a=a+1|0;}g=p+16|0;c:do if(g>>>0<f>>>0)while(1){j=k;i=c[j>>2]|0;j=c[j+4>>2]|0;while(1){s=g;l=c[s+4>>2]|0;h=g+16|0;if((j|0)<(l|0)|((j|0)==(l|0)?i>>>0<(c[s>>2]|0)>>>0:0))g=h;else break}do{f=f+-16|0;s=f;l=c[s+4>>2]|0;}while(!((j|0)<(l|0)|((j|0)==(l|0)?i>>>0<(c[s>>2]|0)>>>0:0)));if(g>>>0>f>>>0){f=k;break c}c[q>>2]=c[g>>2];c[q+4>>2]=c[g+4>>2];c[q+8>>2]=c[g+8>>2];c[q+12>>2]=c[g+12>>2];c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];k=(k|0)==(g|0)?f:k;g=h;a=a+1|0;}else f=k;while(0);if((g|0)!=(f|0)?(l=g,j=c[l+4>>2]|0,s=f,k=c[s+4>>2]|0,(j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[s>>2]|0)>>>0:0)):0){c[q>>2]=c[g>>2];c[q+4>>2]=c[g+4>>2];c[q+8>>2]=c[g+8>>2];c[q+12>>2]=c[g+12>>2];c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];a=a+1|0;}if(!a){f=Ne(p,g,d)|0;a=g+16|0;if(Ne(a,b,d)|0){k=88;break}if(f){e=2;k=93;break}}s=g;if((s-p|0)>=(o-s|0)){k=92;break}Le(p,g,d);p=g+16|0;}if((k|0)==57){i=p;k=59;}else if((k|0)==58){i=p;k=59;}else if((k|0)==88){e=f?1:2;a=p;b=f?b:g;k=93;}else if((k|0)==92){k=0;Le(g+16|0,b,d);a=p;b=g;}d:do if((k|0)==59){a=p+16|0;s=e;p=c[s+4>>2]|0;if(!((p|0)<(l|0)|((p|0)==(l|0)?(c[s>>2]|0)>>>0<j>>>0:0))){if((a|0)==(e|0)){k=95;break a}while(1){s=a;p=c[s+4>>2]|0;if((p|0)<(l|0)|((p|0)==(l|0)?(c[s>>2]|0)>>>0<j>>>0:0))break;a=a+16|0;if((a|0)==(e|0)){k=95;break a}}c[q>>2]=c[a>>2];c[q+4>>2]=c[a+4>>2];c[q+8>>2]=c[a+8>>2];c[q+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];a=a+16|0;}if((a|0)==(e|0)){k=95;break a}while(1){h=i;g=c[h>>2]|0;h=c[h+4>>2]|0;while(1){s=a;p=c[s+4>>2]|0;f=a+16|0;if((p|0)<(h|0)|((p|0)==(h|0)?(c[s>>2]|0)>>>0<g>>>0:0))break;else a=f;}do{e=e+-16|0;s=e;p=c[s+4>>2]|0;}while((p|0)<(h|0)|((p|0)==(h|0)?(c[s>>2]|0)>>>0<g>>>0:0));if(a>>>0>=e>>>0){e=4;k=93;break d}c[q>>2]=c[a>>2];c[q+4>>2]=c[a+4>>2];c[q+8>>2]=c[a+8>>2];c[q+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];a=f;}}while(0);if((k|0)==93)switch(e&7){case 2:case 4:case 0:break;default:{k=95;break a}}}if((k|0)==4){a=b+-16|0;d=p;n=c[d+4>>2]|0;s=a;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[a>>2];c[p+4>>2]=c[a+4>>2];c[p+8>>2]=c[a+8>>2];c[p+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];Eb=r;return}else if((k|0)==6){e=p+16|0;a=b+-16|0;d=p;n=c[d+4>>2]|0;o=e;s=c[o>>2]|0;o=c[o+4>>2]|0;b=a;m=c[b+4>>2]|0;b=(o|0)<(m|0)|((o|0)==(m|0)?s>>>0<(c[b>>2]|0)>>>0:0);if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<s>>>0:0))){if(!b){Eb=r;return}c[q>>2]=c[e>>2];c[q+4>>2]=c[e+4>>2];c[q+8>>2]=c[e+8>>2];c[q+12>>2]=c[e+12>>2];c[e>>2]=c[a>>2];c[e+4>>2]=c[a+4>>2];c[e+8>>2]=c[a+8>>2];c[e+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];d=p;n=c[d+4>>2]|0;s=e;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];Eb=r;return}if(b){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[a>>2];c[p+4>>2]=c[a+4>>2];c[p+8>>2]=c[a+8>>2];c[p+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];Eb=r;return}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];p=e;o=c[p+4>>2]|0;s=a;d=c[s+4>>2]|0;if(!((o|0)<(d|0)|((o|0)==(d|0)?(c[p>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[e>>2];c[q+4>>2]=c[e+4>>2];c[q+8>>2]=c[e+8>>2];c[q+12>>2]=c[e+12>>2];c[e>>2]=c[a>>2];c[e+4>>2]=c[a+4>>2];c[e+8>>2]=c[a+8>>2];c[e+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];Eb=r;return}else if((k|0)==14){Me(p,p+16|0,p+32|0,b+-16|0,d)|0;Eb=r;return}else if((k|0)==15){e=p+16|0;f=p+32|0;g=p+48|0;a=b+-16|0;Me(p,e,f,g,d)|0;d=g;n=c[d+4>>2]|0;s=a;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[g>>2];c[q+4>>2]=c[g+4>>2];c[q+8>>2]=c[g+8>>2];c[q+12>>2]=c[g+12>>2];c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];d=f;n=c[d+4>>2]|0;s=g;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[f>>2];c[q+4>>2]=c[f+4>>2];c[q+8>>2]=c[f+8>>2];c[q+12>>2]=c[f+12>>2];c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[g>>2]=c[q>>2];c[g+4>>2]=c[q+4>>2];c[g+8>>2]=c[q+8>>2];c[g+12>>2]=c[q+12>>2];d=e;n=c[d+4>>2]|0;s=f;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[e>>2];c[q+4>>2]=c[e+4>>2];c[q+8>>2]=c[e+8>>2];c[q+12>>2]=c[e+12>>2];c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];c[e+8>>2]=c[f+8>>2];c[e+12>>2]=c[f+12>>2];c[f>>2]=c[q>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];d=p;n=c[d+4>>2]|0;s=e;o=c[s+4>>2]|0;if(!((n|0)<(o|0)|((n|0)==(o|0)?(c[d>>2]|0)>>>0<(c[s>>2]|0)>>>0:0))){Eb=r;return}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];Eb=r;return}else if((k|0)==21){e=p+32|0;a=p+16|0;g=p;f=c[g>>2]|0;g=c[g+4>>2]|0;d=a;s=c[d>>2]|0;d=c[d+4>>2]|0;i=e;h=c[i>>2]|0;i=c[i+4>>2]|0;j=(d|0)<(i|0)|(d|0)==(i|0)&s>>>0<h>>>0;do if((g|0)<(d|0)|(g|0)==(d|0)&f>>>0<s>>>0){if(j){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[e>>2];c[p+4>>2]=c[e+4>>2];c[p+8>>2]=c[e+8>>2];c[p+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];break}c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[a>>2];c[p+4>>2]=c[a+4>>2];c[p+8>>2]=c[a+8>>2];c[p+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];s=a;d=c[s+4>>2]|0;if((d|0)<(i|0)|((d|0)==(i|0)?(c[s>>2]|0)>>>0<h>>>0:0)){c[q>>2]=c[a>>2];c[q+4>>2]=c[a+4>>2];c[q+8>>2]=c[a+8>>2];c[q+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[q>>2];c[e+4>>2]=c[q+4>>2];c[e+8>>2]=c[q+8>>2];c[e+12>>2]=c[q+12>>2];}}else if(j?(c[q>>2]=c[a>>2],c[q+4>>2]=c[a+4>>2],c[q+8>>2]=c[a+8>>2],c[q+12>>2]=c[a+12>>2],c[a>>2]=c[e>>2],c[a+4>>2]=c[e+4>>2],c[a+8>>2]=c[e+8>>2],c[a+12>>2]=c[e+12>>2],c[e>>2]=c[q>>2],c[e+4>>2]=c[q+4>>2],c[e+8>>2]=c[q+8>>2],c[e+12>>2]=c[q+12>>2],s=a,d=c[s+4>>2]|0,(g|0)<(d|0)|((g|0)==(d|0)?f>>>0<(c[s>>2]|0)>>>0:0)):0){c[q>>2]=c[p>>2];c[q+4>>2]=c[p+4>>2];c[q+8>>2]=c[p+8>>2];c[q+12>>2]=c[p+12>>2];c[p>>2]=c[a>>2];c[p+4>>2]=c[a+4>>2];c[p+8>>2]=c[a+8>>2];c[p+12>>2]=c[a+12>>2];c[a>>2]=c[q>>2];c[a+4>>2]=c[q+4>>2];c[a+8>>2]=c[q+8>>2];c[a+12>>2]=c[q+12>>2];}while(0);a=p+48|0;if((a|0)==(b|0)){Eb=r;return}while(1){s=e;q=c[s+4>>2]|0;h=a;g=c[h>>2]|0;h=c[h+4>>2]|0;if((q|0)<(h|0)|((q|0)==(h|0)?(c[s>>2]|0)>>>0<g>>>0:0)){j=a+8|0;i=c[j>>2]|0;j=c[j+4>>2]|0;f=a;while(1){c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];if((e|0)==(p|0)){f=p;e=p;break}f=e+-16|0;s=f;q=c[s+4>>2]|0;if((q|0)<(h|0)|((q|0)==(h|0)?(c[s>>2]|0)>>>0<g>>>0:0)){s=e;e=f;f=s;}else{k=35;break}}if((k|0)==35){k=0;f=e;}s=e;c[s>>2]=g;c[s+4>>2]=h;s=f+8|0;c[s>>2]=i;c[s+4>>2]=j;}e=a+16|0;if((e|0)==(b|0))break;else{s=a;a=e;e=s;}}Eb=r;return}else if((k|0)==95){Eb=r;return}}function Me(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=Eb;Eb=Eb+16|0;g=h;j=a;l=c[j+4>>2]|0;k=b;i=c[k>>2]|0;k=c[k+4>>2]|0;f=d;m=c[f+4>>2]|0;f=(k|0)<(m|0)|((k|0)==(m|0)?i>>>0<(c[f>>2]|0)>>>0:0);do if((l|0)<(k|0)|((l|0)==(k|0)?(c[j>>2]|0)>>>0<i>>>0:0)){if(f){c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[d>>2];c[a+4>>2]=c[d+4>>2];c[a+8>>2]=c[d+8>>2];c[a+12>>2]=c[d+12>>2];c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];f=1;break}c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[b>>2]=c[g>>2];c[b+4>>2]=c[g+4>>2];c[b+8>>2]=c[g+8>>2];c[b+12>>2]=c[g+12>>2];l=b;j=c[l+4>>2]|0;m=d;k=c[m+4>>2]|0;if((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0)){c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];f=2;}else f=1;}else if(f){c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];l=a;j=c[l+4>>2]|0;m=b;k=c[m+4>>2]|0;if((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0)){c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[b>>2]=c[g>>2];c[b+4>>2]=c[g+4>>2];c[b+8>>2]=c[g+8>>2];c[b+12>>2]=c[g+12>>2];f=2;}else f=1;}else f=0;while(0);l=d;j=c[l+4>>2]|0;m=e;k=c[m+4>>2]|0;if(!((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0))){m=f;Eb=h;return m|0}c[g>>2]=c[d>>2];c[g+4>>2]=c[d+4>>2];c[g+8>>2]=c[d+8>>2];c[g+12>>2]=c[d+12>>2];c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];c[d+8>>2]=c[e+8>>2];c[d+12>>2]=c[e+12>>2];c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];l=b;j=c[l+4>>2]|0;m=d;k=c[m+4>>2]|0;if(!((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0))){m=f+1|0;Eb=h;return m|0}c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];c[g+8>>2]=c[b+8>>2];c[g+12>>2]=c[b+12>>2];c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];c[d+8>>2]=c[g+8>>2];c[d+12>>2]=c[g+12>>2];l=a;j=c[l+4>>2]|0;m=b;k=c[m+4>>2]|0;if(!((j|0)<(k|0)|((j|0)==(k|0)?(c[l>>2]|0)>>>0<(c[m>>2]|0)>>>0:0))){m=f+2|0;Eb=h;return m|0}c[g>>2]=c[a>>2];c[g+4>>2]=c[a+4>>2];c[g+8>>2]=c[a+8>>2];c[g+12>>2]=c[a+12>>2];c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[b>>2]=c[g>>2];c[b+4>>2]=c[g+4>>2];c[b+8>>2]=c[g+8>>2];c[b+12>>2]=c[g+12>>2];m=f+3|0;Eb=h;return m|0}function Ne(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Eb;Eb=Eb+16|0;l=m;switch(b-a>>4|0){case 2:{e=b+-16|0;k=a;i=c[k+4>>2]|0;b=e;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}case 3:{g=a+16|0;e=b+-16|0;k=a;i=c[k+4>>2]|0;j=g;b=c[j>>2]|0;j=c[j+4>>2]|0;f=e;d=c[f+4>>2]|0;f=(j|0)<(d|0)|((j|0)==(d|0)?b>>>0<(c[f>>2]|0)>>>0:0);if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<b>>>0:0))){if(!f){l=1;Eb=m;return l|0}c[l>>2]=c[g>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];k=a;i=c[k+4>>2]|0;b=g;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}if(f){c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];b=g;j=c[b+4>>2]|0;a=e;k=c[a+4>>2]|0;if(!((j|0)<(k|0)|((j|0)==(k|0)?(c[b>>2]|0)>>>0<(c[a>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[g>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}case 4:{Me(a,a+16|0,a+32|0,b+-16|0,d)|0;l=1;Eb=m;return l|0}case 5:{f=a+16|0;g=a+32|0;h=a+48|0;e=b+-16|0;Me(a,f,g,h,d)|0;k=h;i=c[k+4>>2]|0;b=e;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[h>>2];c[l+4>>2]=c[h+4>>2];c[l+8>>2]=c[h+8>>2];c[l+12>>2]=c[h+12>>2];c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];c[h+8>>2]=c[e+8>>2];c[h+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];k=g;i=c[k+4>>2]|0;b=h;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[g>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];c[g+8>>2]=c[h+8>>2];c[g+12>>2]=c[h+12>>2];c[h>>2]=c[l>>2];c[h+4>>2]=c[l+4>>2];c[h+8>>2]=c[l+8>>2];c[h+12>>2]=c[l+12>>2];k=f;i=c[k+4>>2]|0;b=g;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[f>>2];c[l+4>>2]=c[f+4>>2];c[l+8>>2]=c[f+8>>2];c[l+12>>2]=c[f+12>>2];c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];k=a;i=c[k+4>>2]|0;b=f;j=c[b+4>>2]|0;if(!((i|0)<(j|0)|((i|0)==(j|0)?(c[k>>2]|0)>>>0<(c[b>>2]|0)>>>0:0))){l=1;Eb=m;return l|0}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[f>>2];c[a+4>>2]=c[f+4>>2];c[a+8>>2]=c[f+8>>2];c[a+12>>2]=c[f+12>>2];c[f>>2]=c[l>>2];c[f+4>>2]=c[l+4>>2];c[f+8>>2]=c[l+8>>2];c[f+12>>2]=c[l+12>>2];l=1;Eb=m;return l|0}case 1:case 0:{l=1;Eb=m;return l|0}default:{g=a+32|0;e=a+16|0;h=a;f=c[h>>2]|0;h=c[h+4>>2]|0;o=e;n=c[o>>2]|0;o=c[o+4>>2]|0;i=g;d=c[i>>2]|0;i=c[i+4>>2]|0;j=(o|0)<(i|0)|(o|0)==(i|0)&n>>>0<d>>>0;do if((h|0)<(o|0)|(h|0)==(o|0)&f>>>0<n>>>0){if(j){c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[g>>2];c[a+4>>2]=c[g+4>>2];c[a+8>>2]=c[g+8>>2];c[a+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];break}c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];o=e;n=c[o+4>>2]|0;if((n|0)<(i|0)|((n|0)==(i|0)?(c[o>>2]|0)>>>0<d>>>0:0)){c[l>>2]=c[e>>2];c[l+4>>2]=c[e+4>>2];c[l+8>>2]=c[e+8>>2];c[l+12>>2]=c[e+12>>2];c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];c[e+8>>2]=c[g+8>>2];c[e+12>>2]=c[g+12>>2];c[g>>2]=c[l>>2];c[g+4>>2]=c[l+4>>2];c[g+8>>2]=c[l+8>>2];c[g+12>>2]=c[l+12>>2];}}else if(j?(c[l>>2]=c[e>>2],c[l+4>>2]=c[e+4>>2],c[l+8>>2]=c[e+8>>2],c[l+12>>2]=c[e+12>>2],c[e>>2]=c[g>>2],c[e+4>>2]=c[g+4>>2],c[e+8>>2]=c[g+8>>2],c[e+12>>2]=c[g+12>>2],c[g>>2]=c[l>>2],c[g+4>>2]=c[l+4>>2],c[g+8>>2]=c[l+8>>2],c[g+12>>2]=c[l+12>>2],o=e,n=c[o+4>>2]|0,(h|0)<(n|0)|((h|0)==(n|0)?f>>>0<(c[o>>2]|0)>>>0:0)):0){c[l>>2]=c[a>>2];c[l+4>>2]=c[a+4>>2];c[l+8>>2]=c[a+8>>2];c[l+12>>2]=c[a+12>>2];c[a>>2]=c[e>>2];c[a+4>>2]=c[e+4>>2];c[a+8>>2]=c[e+8>>2];c[a+12>>2]=c[e+12>>2];c[e>>2]=c[l>>2];c[e+4>>2]=c[l+4>>2];c[e+8>>2]=c[l+8>>2];c[e+12>>2]=c[l+12>>2];}while(0);e=a+48|0;if((e|0)==(b|0)){o=1;Eb=m;return o|0}f=0;while(1){o=g;n=c[o+4>>2]|0;i=e;d=c[i>>2]|0;i=c[i+4>>2]|0;if((n|0)<(i|0)|((n|0)==(i|0)?(c[o>>2]|0)>>>0<d>>>0:0)){n=e+8|0;o=c[n+4>>2]|0;h=l;c[h>>2]=c[n>>2];c[h+4>>2]=o;h=e;while(1){c[h>>2]=c[g>>2];c[h+4>>2]=c[g+4>>2];c[h+8>>2]=c[g+8>>2];c[h+12>>2]=c[g+12>>2];if((g|0)==(a|0)){h=a;g=a;break}h=g+-16|0;o=h;n=c[o+4>>2]|0;if((n|0)<(i|0)|((n|0)==(i|0)?(c[o>>2]|0)>>>0<d>>>0:0)){o=g;g=h;h=o;}else{k=32;break}}if((k|0)==32){k=0;h=g;}j=g;c[j>>2]=d;c[j+4>>2]=i;j=l;n=c[j+4>>2]|0;o=h+8|0;c[o>>2]=c[j>>2];c[o+4>>2]=n;f=f+1|0;if((f|0)==8)break}g=e+16|0;if((g|0)==(b|0)){e=1;k=36;break}else{o=e;e=g;g=o;}}if((k|0)==36){Eb=m;return e|0}o=(e+16|0)==(b|0);Eb=m;return o|0}}return 0}function Oe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>3;d=g+1|0;if(d>>>0>536870911)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>2;h=f>>3>>>0<268435455?(h>>>0<d>>>0?d:h):536870911;do if(h)if(h>>>0>536870911){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<3)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<3)|0;m=b;g=c[m+4>>2]|0;b=d;c[b>>2]=c[m>>2];c[b+4>>2]=g;if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+8;c[l>>2]=e+(h<<3);if(!j)return;$j(j);return}function Pe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<2)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Qe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;l=a+8|0;f=c[l>>2]|0;m=a+4|0;e=c[m>>2]|0;d=e;if(((f-e|0)/12|0)>>>0>=b>>>0){cx(e|0,0,b*12|0)|0;c[m>>2]=d+(b*12|0);return}k=c[a>>2]|0;h=(e-k|0)/12|0;e=h+b|0;j=k;if(e>>>0>357913941)gk();i=(f-k|0)/12|0;g=i<<1;g=i>>>0<178956970?(g>>>0<e>>>0?e:g):357913941;do if(g)if(g>>>0>357913941){m=S(8)|0;dk(m,8694);c[m>>2]=7328;V(m|0,3264,87);}else{f=Zj(g*12|0)|0;break}else f=0;while(0);e=f+(h*12|0)|0;i=f+(g*12|0)|0;cx(e|0,0,b*12|0)|0;f=e+(b*12|0)|0;if((d|0)==(j|0)){h=j;g=k;}else{do{h=e;e=e+-12|0;b=d;d=d+-12|0;c[e>>2]=0;g=h+-8|0;c[g>>2]=0;h=h+-4|0;c[h>>2]=0;c[e>>2]=c[d>>2];k=b+-8|0;c[g>>2]=c[k>>2];b=b+-4|0;c[h>>2]=c[b>>2];c[b>>2]=0;c[k>>2]=0;c[d>>2]=0;}while((d|0)!=(j|0));g=c[a>>2]|0;h=g;d=c[m>>2]|0;}c[a>>2]=e;c[m>>2]=f;c[l>>2]=i;if((d|0)!=(h|0))do{e=d;d=d+-12|0;f=c[d>>2]|0;if(f|0){c[e+-8>>2]=f;$j(f);}}while((d|0)!=(h|0));if(!g)return;$j(g);return}function Re(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<2)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Se(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<2)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Te(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;a:while(1){k=b;f=b+-4|0;l=b+-8|0;m=b;b:while(1){e=k-a|0;g=e>>2;switch(g|0){case 2:{e=4;break a}case 3:{e=6;break a}case 4:{e=14;break a}case 5:{e=15;break a}case 1:case 0:{e=76;break a}}if((e|0)<124){e=21;break a}j=a+(((g|0)/2|0)<<2)|0;do if((e|0)>3996){g=(g|0)/4|0;i=a+(g<<2)|0;g=j+(g<<2)|0;e=Ue(a,i,j,g,d)|0;if(Ob[c[d>>2]&63](c[f>>2]|0,c[g>>2]|0)|0){h=c[g>>2]|0;c[g>>2]=c[f>>2];c[f>>2]=h;h=e+1|0;if(Ob[c[d>>2]&63](c[g>>2]|0,c[j>>2]|0)|0){h=c[j>>2]|0;c[j>>2]=c[g>>2];c[g>>2]=h;g=e+2|0;if(Ob[c[d>>2]&63](c[j>>2]|0,c[i>>2]|0)|0){h=c[i>>2]|0;c[i>>2]=c[j>>2];c[j>>2]=h;if(Ob[c[d>>2]&63](c[i>>2]|0,c[a>>2]|0)|0){h=c[a>>2]|0;c[a>>2]=c[i>>2];c[i>>2]=h;e=e+4|0;}else e=e+3|0;}else e=g;}else e=h;}}else{i=Ob[c[d>>2]&63](c[j>>2]|0,c[a>>2]|0)|0;e=Ob[c[d>>2]&63](c[f>>2]|0,c[j>>2]|0)|0;if(!i){if(!e){e=0;break}i=c[j>>2]|0;c[j>>2]=c[f>>2];c[f>>2]=i;if(!(Ob[c[d>>2]&63](c[j>>2]|0,c[a>>2]|0)|0)){e=1;break}e=c[a>>2]|0;c[a>>2]=c[j>>2];c[j>>2]=e;e=2;break}g=c[a>>2]|0;if(e){c[a>>2]=c[f>>2];c[f>>2]=g;e=1;break}c[a>>2]=c[j>>2];c[j>>2]=g;if(Ob[c[d>>2]&63](c[f>>2]|0,g)|0){e=c[j>>2]|0;c[j>>2]=c[f>>2];c[f>>2]=e;e=2;}else e=1;}while(0);if(Ob[c[d>>2]&63](c[a>>2]|0,c[j>>2]|0)|0)g=f;else{if((a|0)==(l|0)){e=40;break}g=l;while(1){if(Ob[c[d>>2]&63](c[g>>2]|0,c[j>>2]|0)|0)break;g=g+-4|0;if((a|0)==(g|0)){e=40;break b}}i=c[a>>2]|0;c[a>>2]=c[g>>2];c[g>>2]=i;e=e+1|0;}h=a+4|0;c:do if(h>>>0<g>>>0)while(1){while(1){i=h+4|0;if(Ob[c[d>>2]&63](c[h>>2]|0,c[j>>2]|0)|0)h=i;else break}do g=g+-4|0;while(!(Ob[c[d>>2]&63](c[g>>2]|0,c[j>>2]|0)|0));if(h>>>0>g>>>0){g=j;break c}n=c[h>>2]|0;c[h>>2]=c[g>>2];c[g>>2]=n;j=(j|0)==(h|0)?g:j;h=i;e=e+1|0;}else g=j;while(0);if((h|0)!=(g|0)?Ob[c[d>>2]&63](c[g>>2]|0,c[h>>2]|0)|0:0){n=c[h>>2]|0;c[h>>2]=c[g>>2];c[g>>2]=n;e=e+1|0;}if(!e){g=We(a,h,d)|0;e=h+4|0;if(We(e,b,d)|0){e=69;break}if(g){f=2;a=e;e=74;break}}n=h;if((n-a|0)>=(m-n|0)){e=73;break}Te(a,h,d);a=h+4|0;}d:do if((e|0)==40){e=a+4|0;if(!(Ob[c[d>>2]&63](c[a>>2]|0,c[f>>2]|0)|0)){if((e|0)==(f|0)){e=76;break a}while(1){if(Ob[c[d>>2]&63](c[a>>2]|0,c[e>>2]|0)|0)break;e=e+4|0;if((e|0)==(f|0)){e=76;break a}}n=c[e>>2]|0;c[e>>2]=c[f>>2];c[f>>2]=n;e=e+4|0;}if((e|0)==(f|0)){e=76;break a}while(1){while(1){g=e+4|0;if(Ob[c[d>>2]&63](c[a>>2]|0,c[e>>2]|0)|0)break;else e=g;}do f=f+-4|0;while(Ob[c[d>>2]&63](c[a>>2]|0,c[f>>2]|0)|0);if(e>>>0>=f>>>0){f=4;a=e;e=74;break d}n=c[e>>2]|0;c[e>>2]=c[f>>2];c[f>>2]=n;e=g;}}else if((e|0)==69){f=g?1:2;b=g?b:h;e=74;}else if((e|0)==73){e=0;Te(h+4|0,b,d);b=h;}while(0);if((e|0)==74)switch(f&7){case 2:case 4:case 0:break;default:{e=76;break a}}}if((e|0)==4){b=b+-4|0;if(!(Ob[c[d>>2]&63](c[b>>2]|0,c[a>>2]|0)|0))return;n=c[a>>2]|0;c[a>>2]=c[b>>2];c[b>>2]=n;return}else if((e|0)==6){g=a+4|0;b=b+-4|0;n=Ob[c[d>>2]&63](c[g>>2]|0,c[a>>2]|0)|0;e=Ob[c[d>>2]&63](c[b>>2]|0,c[g>>2]|0)|0;if(!n){if(!e)return;n=c[g>>2]|0;c[g>>2]=c[b>>2];c[b>>2]=n;if(!(Ob[c[d>>2]&63](c[g>>2]|0,c[a>>2]|0)|0))return;n=c[a>>2]|0;c[a>>2]=c[g>>2];c[g>>2]=n;return}f=c[a>>2]|0;if(e){c[a>>2]=c[b>>2];c[b>>2]=f;return}c[a>>2]=c[g>>2];c[g>>2]=f;if(!(Ob[c[d>>2]&63](c[b>>2]|0,f)|0))return;n=c[g>>2]|0;c[g>>2]=c[b>>2];c[b>>2]=n;return}else if((e|0)==14){Ue(a,a+4|0,a+8|0,b+-4|0,d)|0;return}else if((e|0)==15){e=a+4|0;f=a+8|0;g=a+12|0;b=b+-4|0;Ue(a,e,f,g,d)|0;if(!(Ob[c[d>>2]&63](c[b>>2]|0,c[g>>2]|0)|0))return;n=c[g>>2]|0;c[g>>2]=c[b>>2];c[b>>2]=n;if(!(Ob[c[d>>2]&63](c[g>>2]|0,c[f>>2]|0)|0))return;m=c[f>>2]|0;n=c[g>>2]|0;c[f>>2]=n;c[g>>2]=m;if(!(Ob[c[d>>2]&63](n,c[e>>2]|0)|0))return;m=c[e>>2]|0;n=c[f>>2]|0;c[e>>2]=n;c[f>>2]=m;if(!(Ob[c[d>>2]&63](n,c[a>>2]|0)|0))return;n=c[a>>2]|0;c[a>>2]=c[e>>2];c[e>>2]=n;return}else if((e|0)==21){Ve(a,b,d);return}else if((e|0)==76)return}function Ue(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;h=Ob[c[f>>2]&63](c[b>>2]|0,c[a>>2]|0)|0;g=Ob[c[f>>2]&63](c[d>>2]|0,c[b>>2]|0)|0;do if(h){h=c[a>>2]|0;if(g){c[a>>2]=c[d>>2];c[d>>2]=h;g=1;break}c[a>>2]=c[b>>2];c[b>>2]=h;if(Ob[c[f>>2]&63](c[d>>2]|0,h)|0){g=c[b>>2]|0;c[b>>2]=c[d>>2];c[d>>2]=g;g=2;}else g=1;}else if(g){h=c[b>>2]|0;c[b>>2]=c[d>>2];c[d>>2]=h;if(Ob[c[f>>2]&63](c[b>>2]|0,c[a>>2]|0)|0){g=c[a>>2]|0;c[a>>2]=c[b>>2];c[b>>2]=g;g=2;}else g=1;}else g=0;while(0);if(!(Ob[c[f>>2]&63](c[e>>2]|0,c[d>>2]|0)|0)){f=g;return f|0}h=c[d>>2]|0;c[d>>2]=c[e>>2];c[e>>2]=h;if(!(Ob[c[f>>2]&63](c[d>>2]|0,c[b>>2]|0)|0)){f=g+1|0;return f|0}e=c[b>>2]|0;c[b>>2]=c[d>>2];c[d>>2]=e;if(!(Ob[c[f>>2]&63](c[b>>2]|0,c[a>>2]|0)|0)){f=g+2|0;return f|0}f=c[a>>2]|0;c[a>>2]=c[b>>2];c[b>>2]=f;f=g+3|0;return f|0}
  function Ve(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;f=a+8|0;h=a+4|0;i=Ob[c[d>>2]&63](c[h>>2]|0,c[a>>2]|0)|0;e=Ob[c[d>>2]&63](c[f>>2]|0,c[h>>2]|0)|0;do if(i){g=c[a>>2]|0;if(e){c[a>>2]=c[f>>2];c[f>>2]=g;break}c[a>>2]=c[h>>2];c[h>>2]=g;if(Ob[c[d>>2]&63](c[f>>2]|0,g)|0){i=c[h>>2]|0;c[h>>2]=c[f>>2];c[f>>2]=i;}}else if(e?(g=c[h>>2]|0,i=c[f>>2]|0,c[h>>2]=i,c[f>>2]=g,Ob[c[d>>2]&63](i,c[a>>2]|0)|0):0){i=c[a>>2]|0;c[a>>2]=c[h>>2];c[h>>2]=i;}while(0);e=a+12|0;if((e|0)==(b|0))return;while(1){if(Ob[c[d>>2]&63](c[e>>2]|0,c[f>>2]|0)|0){i=c[e>>2]|0;h=i;g=e;while(1){c[g>>2]=c[f>>2];if((f|0)==(a|0)){f=a;break}g=f+-4|0;if(Ob[c[d>>2]&63](h,c[g>>2]|0)|0){j=f;f=g;g=j;}else break}c[f>>2]=i;}f=e+4|0;if((f|0)==(b|0))break;else{j=e;e=f;f=j;}}return}function We(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;switch(b-a>>2|0){case 2:{e=b+-4|0;if(!(Ob[c[d>>2]&63](c[e>>2]|0,c[a>>2]|0)|0)){d=1;return d|0}d=c[a>>2]|0;c[a>>2]=c[e>>2];c[e>>2]=d;d=1;return d|0}case 3:{h=a+4|0;e=b+-4|0;b=Ob[c[d>>2]&63](c[h>>2]|0,c[a>>2]|0)|0;f=Ob[c[d>>2]&63](c[e>>2]|0,c[h>>2]|0)|0;if(!b){if(!f){d=1;return d|0}b=c[h>>2]|0;c[h>>2]=c[e>>2];c[e>>2]=b;if(!(Ob[c[d>>2]&63](c[h>>2]|0,c[a>>2]|0)|0)){d=1;return d|0}d=c[a>>2]|0;c[a>>2]=c[h>>2];c[h>>2]=d;d=1;return d|0}g=c[a>>2]|0;if(f){c[a>>2]=c[e>>2];c[e>>2]=g;d=1;return d|0}c[a>>2]=c[h>>2];c[h>>2]=g;if(!(Ob[c[d>>2]&63](c[e>>2]|0,g)|0)){d=1;return d|0}d=c[h>>2]|0;c[h>>2]=c[e>>2];c[e>>2]=d;d=1;return d|0}case 4:{Ue(a,a+4|0,a+8|0,b+-4|0,d)|0;d=1;return d|0}case 5:{f=a+4|0;g=a+8|0;h=a+12|0;e=b+-4|0;Ue(a,f,g,h,d)|0;if(!(Ob[c[d>>2]&63](c[e>>2]|0,c[h>>2]|0)|0)){d=1;return d|0}b=c[h>>2]|0;c[h>>2]=c[e>>2];c[e>>2]=b;if(!(Ob[c[d>>2]&63](c[h>>2]|0,c[g>>2]|0)|0)){d=1;return d|0}k=c[g>>2]|0;b=c[h>>2]|0;c[g>>2]=b;c[h>>2]=k;if(!(Ob[c[d>>2]&63](b,c[f>>2]|0)|0)){d=1;return d|0}k=c[f>>2]|0;b=c[g>>2]|0;c[f>>2]=b;c[g>>2]=k;if(!(Ob[c[d>>2]&63](b,c[a>>2]|0)|0)){d=1;return d|0}d=c[a>>2]|0;c[a>>2]=c[f>>2];c[f>>2]=d;d=1;return d|0}case 1:case 0:{d=1;return d|0}default:{f=a+8|0;e=a+4|0;j=Ob[c[d>>2]&63](c[e>>2]|0,c[a>>2]|0)|0;g=Ob[c[d>>2]&63](c[f>>2]|0,c[e>>2]|0)|0;do if(j){h=c[a>>2]|0;if(g){c[a>>2]=c[f>>2];c[f>>2]=h;break}c[a>>2]=c[e>>2];c[e>>2]=h;if(Ob[c[d>>2]&63](c[f>>2]|0,h)|0){j=c[e>>2]|0;c[e>>2]=c[f>>2];c[f>>2]=j;}}else if(g?(i=c[e>>2]|0,j=c[f>>2]|0,c[e>>2]=j,c[f>>2]=i,Ob[c[d>>2]&63](j,c[a>>2]|0)|0):0){j=c[a>>2]|0;c[a>>2]=c[e>>2];c[e>>2]=j;}while(0);e=a+12|0;if((e|0)==(b|0)){d=1;return d|0}j=e;e=0;while(1){if(Ob[c[d>>2]&63](c[j>>2]|0,c[f>>2]|0)|0){i=c[j>>2]|0;h=i;g=j;while(1){c[g>>2]=c[f>>2];if((f|0)==(a|0)){f=a;break}g=f+-4|0;if(Ob[c[d>>2]&63](h,c[g>>2]|0)|0){l=f;f=g;g=l;}else break}c[f>>2]=i;e=e+1|0;if((e|0)==8)break}f=j+4|0;if((f|0)==(b|0)){e=1;k=35;break}else{l=j;j=f;f=l;}}if((k|0)==35)return e|0;l=(j+4|0)==(b|0);return l|0}}return 0}function Xe(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;q=Eb;Eb=Eb+32|0;l=q+20|0;k=q+16|0;h=q+12|0;j=q+8|0;n=q+4|0;o=q;switch(d|0){case 1:case 0:{a=c[a>>2]|0;Eb=q;return a|0}case 2:{h=c[c[b>>2]>>2]|0;c[b>>2]=h;f=c[a>>2]|0;p=h+8|0;o=c[p+4>>2]|0;a=f+8|0;b=c[a+4>>2]|0;g=h;if(!((o|0)<(b|0)|((o|0)==(b|0)?(c[p>>2]|0)>>>0<(c[a>>2]|0)>>>0:0))){a=f;Eb=q;return a|0}a=g+4|0;p=c[g>>2]|0;c[p+4>>2]=c[a>>2];c[c[a>>2]>>2]=p;p=c[f>>2]|0;c[p+4>>2]=g;c[h>>2]=p;c[f>>2]=g;c[a>>2]=f;a=g;Eb=q;return a|0}default:{m=d>>>1;i=c[a>>2]|0;f=i;if(m){g=m;while(1){f=c[f+4>>2]|0;if((g|0)>1)g=g+-1|0;else break}}g=f;c[h>>2]=i;c[j>>2]=g;c[k>>2]=c[h>>2];c[l>>2]=c[j>>2];p=Xe(k,l,m,e)|0;c[a>>2]=p;c[n>>2]=g;g=c[b>>2]|0;c[o>>2]=g;c[k>>2]=c[n>>2];c[l>>2]=c[o>>2];j=Xe(k,l,d-m|0,e)|0;b=j+8|0;o=c[b+4>>2]|0;i=p+8|0;h=c[i>>2]|0;i=c[i+4>>2]|0;n=g;if((o|0)<(i|0)|((o|0)==(i|0)?(c[b>>2]|0)>>>0<h>>>0:0)){g=c[j+4>>2]|0;f=g;a:do if((n|0)==(f|0))f=n;else while(1){b=g+8|0;o=c[b+4>>2]|0;if(!((o|0)<(i|0)|((o|0)==(i|0)?(c[b>>2]|0)>>>0<h>>>0:0)))break a;g=c[f+4>>2]|0;f=g;if((n|0)==(f|0)){f=n;break}}while(0);b=c[f>>2]|0;f=b+4|0;h=c[j>>2]|0;c[h+4>>2]=c[f>>2];c[c[f>>2]>>2]=h;h=c[p+4>>2]|0;o=c[p>>2]|0;c[o+4>>2]=j;c[j>>2]=o;c[p>>2]=b;c[f>>2]=p;f=j;}else{f=p;g=j;h=c[p+4>>2]|0;}c[a>>2]=h;j=h;i=g;if((j|0)==(i|0)){a=f;Eb=q;return a|0}k=g;while(1){m=k;if((n|0)==(m|0)){g=26;break}p=k+8|0;b=c[p+4>>2]|0;e=h+8|0;d=c[e>>2]|0;e=c[e+4>>2]|0;if((b|0)<(e|0)|((b|0)==(e|0)?(c[p>>2]|0)>>>0<d>>>0:0)){h=c[m+4>>2]|0;l=h;b:do if((n|0)==(l|0))l=n;else while(1){p=h+8|0;b=c[p+4>>2]|0;if(!((b|0)<(e|0)|((b|0)==(e|0)?(c[p>>2]|0)>>>0<d>>>0:0)))break b;h=c[l+4>>2]|0;l=h;if((n|0)==(l|0)){l=n;break}}while(0);o=c[l>>2]|0;b=o+4|0;p=c[m>>2]|0;c[p+4>>2]=c[b>>2];c[c[b>>2]>>2]=p;p=c[j+4>>2]|0;e=c[j>>2]|0;c[e+4>>2]=m;c[k>>2]=e;c[j>>2]=o;c[b>>2]=j;k=h;g=(i|0)==(m|0)?h:g;h=p;}else h=c[j+4>>2]|0;c[a>>2]=h;j=h;i=g;if((j|0)==(i|0)){g=26;break}}if((g|0)==26){Eb=q;return f|0}}}return 0}function Ye(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>2;d=g+1|0;if(d>>>0>1073741823)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>1;h=f>>2>>>0<536870911?(h>>>0<d>>>0?d:h):1073741823;do if(h)if(h>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<2)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<2)|0;c[d>>2]=c[b>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+4;c[l>>2]=e+(h<<2);if(!j)return;$j(j);return}function Ze(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=d;h=b;g=k-h|0;f=g>>4;i=a+8|0;e=c[i>>2]|0;l=c[a>>2]|0;j=l;if(f>>>0<=e-l>>4>>>0){g=a+4|0;a=(c[g>>2]|0)-l>>4;f=f>>>0>a>>>0;a=f?b+(a<<4)|0:d;d=a;e=d-h|0;if(e|0)bx(l|0,b|0,e|0)|0;if(!f){c[g>>2]=j+(e>>4<<4);return}e=k-d|0;if((e|0)<=0)return;ax(c[g>>2]|0,a|0,e|0)|0;c[g>>2]=(c[g>>2]|0)+(e>>>4<<4);return}if(l){e=a+4|0;c[e>>2]=l;$j(l);c[i>>2]=0;c[e>>2]=0;c[a>>2]=0;e=0;}if(f>>>0>268435455)gk();l=e>>3;f=e>>4>>>0<134217727?(l>>>0<f>>>0?f:l):268435455;if(f>>>0>268435455)gk();e=Zj(f<<4)|0;d=a+4|0;c[d>>2]=e;c[a>>2]=e;c[i>>2]=e+(f<<4);if((g|0)<=0)return;ax(e|0,b|0,g|0)|0;c[d>>2]=e+(g>>>4<<4);return}function _e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>4;d=g+1|0;if(d>>>0>268435455)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>3;h=f>>4>>>0<134217727?(h>>>0<d>>>0?d:h):268435455;do if(h)if(h>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<4)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<4)|0;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+16;c[l>>2]=e+(h<<4);if(!j)return;$j(j);return}function $e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;i=a+4|0;j=c[a>>2]|0;k=(c[i>>2]|0)-j|0;g=k>>4;d=g+1|0;if(d>>>0>268435455)gk();l=a+8|0;f=(c[l>>2]|0)-j|0;h=f>>3;h=f>>4>>>0<134217727?(h>>>0<d>>>0?d:h):268435455;do if(h)if(h>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{f=Zj(h<<4)|0;e=f;break}else{e=0;f=0;}while(0);d=e+(g<<4)|0;c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];c[d+8>>2]=c[b+8>>2];c[d+12>>2]=c[b+12>>2];if((k|0)>0)ax(f|0,j|0,k|0)|0;c[a>>2]=e;c[i>>2]=d+16;c[l>>2]=e+(h<<4);if(!j)return;$j(j);return}function af(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=a+8|0;e=c[k>>2]|0;l=a+4|0;d=c[l>>2]|0;if(e-d>>4>>>0>=b>>>0){do{c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;d=(c[l>>2]|0)+16|0;c[l>>2]=d;b=b+-1|0;}while((b|0)!=0);return}j=c[a>>2]|0;g=d-j|0;h=g>>4;i=h+b|0;if(i>>>0>268435455)gk();e=e-j|0;f=e>>3;f=e>>4>>>0<134217727?(f>>>0<i>>>0?i:f):268435455;do if(f)if(f>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{e=Zj(f<<4)|0;d=e;break}else{d=0;e=0;}while(0);cx(d+(h<<4)|0,0,b<<4|0)|0;if((g|0)>0)ax(e|0,j|0,g|0)|0;c[a>>2]=d;c[l>>2]=d+(i<<4);c[k>>2]=d+(f<<4);if(!j)return;$j(j);return}function bf(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function cf(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function df(a,b){a=a|0;b=b|0;var d=0,e=0;d=Eb;Eb=Eb+16|0;e=d;Xb[a&127](e,b);sa(c[e>>2]|0);b=c[e>>2]|0;ra(b|0);Eb=d;return b|0}function ef(a,b){a=a|0;b=b|0;var d=0,e=0;d=Eb;Eb=Eb+16|0;e=d;Xb[a&127](e,b);sa(c[e>>2]|0);b=c[e>>2]|0;ra(b|0);Eb=d;return b|0}function ff(a){return 1216}function gf(a){a=a|0;if(!a)return;$j(a);return}function hf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0.0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;f=+Ib[e&7](a);return +f}else{e=c[(c[a>>2]|0)+d>>2]|0;f=+Ib[e&7](a);return +f}}function jf(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Vb[f&15](a,d);return}else{f=c[(c[a>>2]|0)+e>>2]|0;Vb[f&15](a,d);return}}function kf(a,b,d){a=a|0;b=+b;d=+d;var e=0,f=0;e=Eb;Eb=Eb+16|0;f=e;Wb[a&1](f,b,d);a=Zj(16)|0;c[a>>2]=c[f>>2];c[a+4>>2]=c[f+4>>2];c[a+8>>2]=c[f+8>>2];c[a+12>>2]=c[f+12>>2];Eb=e;return a|0}function lf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=a+4|0;f=c[a>>2]|0;g=(c[e>>2]|0)-f>>4;if(g>>>0<b>>>0){of(a,b-g|0,d);return}if(g>>>0<=b>>>0)return;c[e>>2]=f+(b<<4);return}function mf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=c[b>>2]|0;if((c[b+4>>2]|0)-f>>4>>>0<=d>>>0){f=1;c[a>>2]=f;Eb=g;return}d=f+(d<<4)|0;f=Zj(16)|0;c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];c[f+8>>2]=c[d+8>>2];c[f+12>>2]=c[d+12>>2];c[e>>2]=f;f=ua(1216,e|0)|0;c[a>>2]=f;Eb=g;return}function nf(a,b,d){a=a|0;b=b|0;d=d|0;b=(c[a>>2]|0)+(b<<4)|0;c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];return 1}function of(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=a+8|0;g=c[k>>2]|0;l=a+4|0;e=c[l>>2]|0;if(g-e>>4>>>0>=b>>>0){do{c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];c[e+8>>2]=c[d+8>>2];c[e+12>>2]=c[d+12>>2];e=(c[l>>2]|0)+16|0;c[l>>2]=e;b=b+-1|0;}while((b|0)!=0);return}f=c[a>>2]|0;h=e-f>>4;j=h+b|0;if(j>>>0>268435455)gk();i=g-f|0;e=i>>3;e=i>>4>>>0<134217727?(e>>>0<j>>>0?j:e):268435455;do if(e)if(e>>>0>268435455){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{i=Zj(e<<4)|0;break}else i=0;while(0);g=i+(h<<4)|0;h=i+(e<<4)|0;e=g;while(1){c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];c[e+8>>2]=c[d+8>>2];c[e+12>>2]=c[d+12>>2];b=b+-1|0;if(!b)break;else e=e+16|0;}b=c[a>>2]|0;f=(c[l>>2]|0)-b|0;e=g+(0-(f>>4)<<4)|0;if((f|0)>0)ax(e|0,b|0,f|0)|0;c[a>>2]=e;c[l>>2]=i+(j<<4);c[k>>2]=h;if(!b)return;$j(b);return}function pf(a){return 1112}function qf(a){a=a|0;var b=0;if(!a)return;b=c[a>>2]|0;if(b|0){c[a+4>>2]=b;$j(b);}$j(a);return}function rf(){var a=0;a=Zj(12)|0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;return a|0}function sf(a){a=a|0;return Kb[a&7]()|0}function tf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Xb[f&127](a,d);return}else{f=c[(c[a>>2]|0)+e>>2]|0;Xb[f&127](a,d);return}}function uf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(!(g&1)){g=f;Zb[g&31](a,d,e);return}else{g=c[(c[a>>2]|0)+f>>2]|0;Zb[g&31](a,d,e);return}}function vf(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function wf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=Eb;Eb=Eb+16|0;f=e;Zb[c[a>>2]&31](f,b,d);sa(c[f>>2]|0);d=c[f>>2]|0;ra(d|0);Eb=e;return d|0}function xf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;return Pb[c[a>>2]&15](b,d,e)|0}function yf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;h=a+4|0;e=c[h>>2]|0;f=c[a>>2]|0;g=(e-f|0)/12|0;if(g>>>0<b>>>0){Bf(a,b-g|0,d);return}if(g>>>0<=b>>>0)return;d=f+(b*12|0)|0;if((d|0)!=(e|0))do{a=e;e=e+-12|0;b=c[e>>2]|0;if(b|0){c[a+-8>>2]=b;$j(b);}}while((e|0)!=(d|0));c[h>>2]=d;return}function zf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=c[b>>2]|0;if((((c[b+4>>2]|0)-f|0)/12|0)>>>0<=d>>>0){f=1;c[a>>2]=f;Eb=g;return}Kf(e,f+(d*12|0)|0);f=ua(1112,e|0)|0;c[a>>2]=f;Eb=g;return}function Af(a,b,d){a=a|0;b=b|0;d=d|0;a=(c[a>>2]|0)+(b*12|0)|0;if((a|0)==(d|0))return 1;Ze(a,c[d>>2]|0,c[d+4>>2]|0);return 1}function Bf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;s=a+8|0;n=c[s>>2]|0;t=a+4|0;m=c[t>>2]|0;if(((n-m|0)/12|0)>>>0>=b>>>0){l=d+4|0;k=b;e=m;while(1){c[e>>2]=0;j=e+4|0;c[j>>2]=0;g=e+8|0;c[g>>2]=0;f=(c[l>>2]|0)-(c[d>>2]|0)|0;h=f>>4;if(f|0){if(h>>>0>268435455){q=5;break}i=Zj(f)|0;c[j>>2]=i;c[e>>2]=i;c[g>>2]=i+(h<<4);e=c[d>>2]|0;f=(c[l>>2]|0)-e|0;if((f|0)>0){ax(i|0,e|0,f|0)|0;c[j>>2]=i+(f>>>4<<4);}}e=(c[t>>2]|0)+12|0;c[t>>2]=e;k=k+-1|0;if(!k){q=34;break}}if((q|0)==5)gk();else if((q|0)==34)return}f=c[a>>2]|0;h=(m-f|0)/12|0;e=h+b|0;if(e>>>0>357913941)gk();p=(n-f|0)/12|0;g=p<<1;g=p>>>0<178956970?(g>>>0<e>>>0?e:g):357913941;do if(g)if(g>>>0>357913941){t=S(8)|0;dk(t,8694);c[t>>2]=7328;V(t|0,3264,87);}else{f=Zj(g*12|0)|0;break}else f=0;while(0);e=f+(h*12|0)|0;o=e;p=f+(g*12|0)|0;n=d+4|0;k=b;l=o;g=e;while(1){c[g>>2]=0;m=g+4|0;c[m>>2]=0;h=g+8|0;c[h>>2]=0;f=(c[n>>2]|0)-(c[d>>2]|0)|0;i=f>>4;if(f|0){if(i>>>0>268435455){q=18;break}j=Zj(f)|0;c[m>>2]=j;c[g>>2]=j;c[h>>2]=j+(i<<4);f=c[d>>2]|0;g=(c[n>>2]|0)-f|0;if((g|0)>0){ax(j|0,f|0,g|0)|0;c[m>>2]=j+(g>>>4<<4);}}r=l+12|0;k=k+-1|0;if(!k)break;else{l=r;g=r;}}if((q|0)==18)gk();h=r;g=c[a>>2]|0;f=c[t>>2]|0;if((f|0)==(g|0)){f=o;i=g;e=g;}else{do{q=e;e=e+-12|0;r=f;f=f+-12|0;c[e>>2]=0;b=q+-8|0;c[b>>2]=0;q=q+-4|0;c[q>>2]=0;c[e>>2]=c[f>>2];d=r+-8|0;c[b>>2]=c[d>>2];r=r+-4|0;c[q>>2]=c[r>>2];c[r>>2]=0;c[d>>2]=0;c[f>>2]=0;}while((f|0)!=(g|0));f=e;i=c[a>>2]|0;e=c[t>>2]|0;}c[a>>2]=f;c[t>>2]=h;c[s>>2]=p;h=i;if((e|0)!=(h|0))do{f=e;e=e+-12|0;g=c[e>>2]|0;if(g|0){c[f+-8>>2]=g;$j(g);}}while((e|0)!=(h|0));if(!i)return;$j(i);return}function Cf(a){return 1160}function Df(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;if(!a)return;f=c[a>>2]|0;if(f|0){g=a+4|0;b=c[g>>2]|0;if((b|0)==(f|0))b=f;else{do{d=b;b=b+-12|0;e=c[b>>2]|0;if(e|0){c[d+-8>>2]=e;$j(e);}}while((b|0)!=(f|0));b=c[a>>2]|0;}c[g>>2]=f;$j(b);}$j(a);return}function Ef(){var a=0;a=Zj(12)|0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;return a|0}function Ff(a){a=a|0;return Kb[a&7]()|0}function Gf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Xb[f&127](a,d);return}else{f=c[(c[a>>2]|0)+e>>2]|0;Xb[f&127](a,d);return}}function Hf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(!(g&1)){g=f;Zb[g&31](a,d,e);return}else{g=c[(c[a>>2]|0)+f>>2]|0;Zb[g&31](a,d,e);return}}function If(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Jf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=Eb;Eb=Eb+16|0;f=e;Zb[c[a>>2]&31](f,b,d);sa(c[f>>2]|0);d=c[f>>2]|0;ra(d|0);Eb=e;return d|0}function Kf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;f=Zj(12)|0;c[f>>2]=0;g=f+4|0;c[g>>2]=0;h=f+8|0;c[h>>2]=0;i=c[b>>2]|0;d=(c[b+4>>2]|0)-i|0;e=d>>4;if(!d){c[a>>2]=f;return}if(e>>>0>268435455)gk();b=Zj(d)|0;c[g>>2]=b;c[f>>2]=b;c[h>>2]=b+(e<<4);if((d|0)<=0){c[a>>2]=f;return}ax(b|0,i|0,d|0)|0;c[g>>2]=b+(d>>>4<<4);c[a>>2]=f;return}function Lf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;return Pb[c[a>>2]&15](b,d,e)|0}function Mf(a){a=a|0;return c[(c[a>>2]|0)+-4>>2]|0}function Nf(a){a=a|0;if(!a)return;Ub[c[(c[a>>2]|0)+4>>2]&127](a);return}function Of(){var b=0,d=0;b=Zj(48)|0;c[b>>2]=3512;d=b+4|0;c[d>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;c[d+24>>2]=0;c[d+28>>2]=0;a[d+32>>0]=0;return b|0}function Pf(a){a=a|0;return Kb[a&7]()|0}function Qf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;a=b+(c[a>>2]|0)|0;e=Zj(12)|0;c[e>>2]=0;f=e+4|0;c[f>>2]=0;g=e+8|0;c[g>>2]=0;h=c[a>>2]|0;a=(c[a+4>>2]|0)-h|0;b=a>>4;if(!a)return e|0;if(b>>>0>268435455)gk();d=Zj(a)|0;c[f>>2]=d;c[e>>2]=d;c[g>>2]=d+(b<<4);if((a|0)<=0)return e|0;ax(d|0,h|0,a|0)|0;c[f>>2]=d+(a>>>4<<4);return e|0}function Rf(a,b,d){a=a|0;b=b|0;d=d|0;a=b+(c[a>>2]|0)|0;if((a|0)==(d|0))return;Ze(a,c[d>>2]|0,c[d+4>>2]|0);return}function Sf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;a=b+(c[a>>2]|0)|0;e=Zj(12)|0;c[e>>2]=0;f=e+4|0;c[f>>2]=0;g=e+8|0;c[g>>2]=0;h=c[a>>2]|0;a=(c[a+4>>2]|0)-h|0;b=a>>2;if(!a)return e|0;if(b>>>0>1073741823)gk();d=Zj(a)|0;c[f>>2]=d;c[e>>2]=d;c[g>>2]=d+(b<<2);if((a|0)<=0)return e|0;ax(d|0,h|0,a|0)|0;c[f>>2]=d+(a>>>2<<2);return e|0}function Tf(a,b,d){a=a|0;b=b|0;d=d|0;a=b+(c[a>>2]|0)|0;if((a|0)==(d|0))return;Uf(a,c[d>>2]|0,c[d+4>>2]|0);return}function Uf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=d;h=b;g=k-h|0;f=g>>2;i=a+8|0;e=c[i>>2]|0;l=c[a>>2]|0;j=l;if(f>>>0<=e-l>>2>>>0){g=a+4|0;a=(c[g>>2]|0)-l>>2;f=f>>>0>a>>>0;a=f?b+(a<<2)|0:d;d=a;e=d-h|0;if(e|0)bx(l|0,b|0,e|0)|0;if(!f){c[g>>2]=j+(e>>2<<2);return}e=k-d|0;if((e|0)<=0)return;ax(c[g>>2]|0,a|0,e|0)|0;c[g>>2]=(c[g>>2]|0)+(e>>>2<<2);return}if(l){e=a+4|0;c[e>>2]=l;$j(l);c[i>>2]=0;c[e>>2]=0;c[a>>2]=0;e=0;}if(f>>>0>1073741823)gk();l=e>>1;f=e>>2>>>0<536870911?(l>>>0<f>>>0?f:l):1073741823;if(f>>>0>1073741823)gk();e=Zj(f<<2)|0;d=a+4|0;c[d>>2]=e;c[a>>2]=e;c[i>>2]=e+(f<<2);if((g|0)<=0)return;ax(e|0,b|0,g|0)|0;c[d>>2]=e+(g>>>2<<2);return}function Vf(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Wf(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Xf(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Yf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=a+4|0;f=c[a>>2]|0;g=(c[e>>2]|0)-f>>2;if(g>>>0<b>>>0){$f(a,b-g|0,d);return}if(g>>>0<=b>>>0)return;c[e>>2]=f+(b<<2);return}function Zf(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=c[b>>2]|0;if((c[b+4>>2]|0)-f>>2>>>0<=d>>>0){f=1;c[a>>2]=f;Eb=g;return}c[e>>2]=c[f+(d<<2)>>2];f=ua(1344,e|0)|0;c[a>>2]=f;Eb=g;return}function _f(a,b,d){a=a|0;b=b|0;d=d|0;c[(c[a>>2]|0)+(b<<2)>>2]=c[d>>2];return 1}function $f(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;k=a+8|0;g=c[k>>2]|0;l=a+4|0;e=c[l>>2]|0;if(g-e>>2>>>0>=b>>>0){do{c[e>>2]=c[d>>2];e=(c[l>>2]|0)+4|0;c[l>>2]=e;b=b+-1|0;}while((b|0)!=0);return}f=c[a>>2]|0;h=e-f>>2;j=h+b|0;if(j>>>0>1073741823)gk();i=g-f|0;e=i>>1;e=i>>2>>>0<536870911?(e>>>0<j>>>0?j:e):1073741823;do if(e)if(e>>>0>1073741823){l=S(8)|0;dk(l,8694);c[l>>2]=7328;V(l|0,3264,87);}else{i=Zj(e<<2)|0;break}else i=0;while(0);g=i+(h<<2)|0;h=i+(e<<2)|0;e=g;while(1){c[e>>2]=c[d>>2];b=b+-1|0;if(!b)break;else e=e+4|0;}b=c[a>>2]|0;f=(c[l>>2]|0)-b|0;e=g+(0-(f>>2)<<2)|0;if((f|0)>0)ax(e|0,b|0,f|0)|0;c[a>>2]=e;c[l>>2]=i+(j<<2);c[k>>2]=h;if(!b)return;$j(b);return}function ag(a){return 1400}function bg(a){a=a|0;var b=0;if(!a)return;b=c[a>>2]|0;if(b|0){c[a+4>>2]=b;$j(b);}$j(a);return}function cg(){var a=0;a=Zj(12)|0;c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;return a|0}function dg(a){a=a|0;return Kb[a&7]()|0}function eg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+16|0;f=g;e=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)e=c[(c[a>>2]|0)+e>>2]|0;c[f>>2]=d;Xb[e&127](a,f);Eb=g;return}function fg(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=Eb;Eb=Eb+16|0;g=h;f=c[a>>2]|0;i=c[a+4>>2]|0;a=b+(i>>1)|0;if(i&1)f=c[(c[a>>2]|0)+f>>2]|0;c[g>>2]=e;Zb[f&31](a,d,g);Eb=h;return}function gg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function hg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=Eb;Eb=Eb+16|0;f=e;Zb[c[a>>2]&31](f,b,d);sa(c[f>>2]|0);d=c[f>>2]|0;ra(d|0);Eb=e;return d|0}function ig(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=Eb;Eb=Eb+16|0;g=f;a=c[a>>2]|0;c[g>>2]=e;e=Pb[a&15](b,d,g)|0;Eb=f;return e|0}function jg(a){a=a|0;return c[(c[a>>2]|0)+-4>>2]|0}function kg(a){a=a|0;if(!a)return;Ub[c[(c[a>>2]|0)+4>>2]&127](a);return}function lg(a){a=a|0;return a|0}function mg(a){a=a|0;return a|0}function ng(){var a=0,b=0,d=0;a=Zj(60)|0;b=a;d=b+48|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(d|0));c[a>>2]=3800;c[a+48>>2]=0;c[a+52>>2]=0;c[a+56>>2]=0;return a|0}function og(a){a=a|0;return Kb[a&7]()|0}function pg(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;c[a>>2]=3800;h=a+48|0;i=a+52|0;f=c[i>>2]|0;b=c[h>>2]|0;d=b;if((f|0)!=(b|0)){g=0;do{e=c[b+(g<<2)>>2]|0;if(e){Ub[c[(c[e>>2]|0)+4>>2]&127](e);b=c[h>>2]|0;f=c[i>>2]|0;d=b;}g=g+1|0;e=f-b|0;}while(g>>>0<e>>2>>>0);if(e)c[i>>2]=b;}e=a+20|0;h=c[a+16>>2]|0;b=h;if((c[e>>2]|0)!=(h|0))c[e>>2]=b;if(d){c[i>>2]=d;$j(d);b=c[a+16>>2]|0;}c[a>>2]=3512;if(b|0){c[e>>2]=b;$j(b);}b=c[a+4>>2]|0;if(!b)return;c[a+8>>2]=b;$j(b);return}function qg(a){a=a|0;pg(a);$j(a);return}function rg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function sg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;Ub[e&127](a);return}else{e=c[(c[a>>2]|0)+d>>2]|0;Ub[e&127](a);return}}function tg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function ug(a,b){a=a|0;b=b|0;return Lb[a&63](b)|0}function vg(a,b){a=a|0;b=b|0;return +(+Ib[a&7](b))}function wg(a,b,c){a=a|0;b=b|0;c=c|0;return Ob[a&63](b,c)|0}function xg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Zb[a&31](b,c,d);return}function yg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Zb[a&31](b,c,d);return}function zg(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function Ag(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;Yb[a&15](b,c,d);return}function Bg(a,b,c){a=a|0;b=b|0;c=+c;Vb[a&15](b,c);return}function Cg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;Yb[a&15](b,c,d);return}function Dg(a,b,c){a=a|0;b=b|0;c=+c;Vb[a&15](b,c);return}function Eg(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;$b[a&15](b,c,d,e);return}function Fg(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;$b[a&15](b,c,d,e);return}function Gg(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Zb[a&31](b,c,d);return}function Hg(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function Ig(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b,c);return}function Jg(a,b){a=a|0;b=b|0;Ub[a&127](b);return}function Kg(a,b){a=a|0;b=b|0;Ub[a&127](b);return}function Lg(a){return 1504}function Mg(a){a=a|0;if(!a)return;$j(a);return}function Ng(a,b){a=a|0;b=b|0;var d=0,e=0,f=0.0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;f=+Ib[e&7](a);return +f}else{e=c[(c[a>>2]|0)+d>>2]|0;f=+Ib[e&7](a);return +f}}function Og(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Vb[f&15](a,d);return}else{f=c[(c[a>>2]|0)+e>>2]|0;Vb[f&15](a,d);return}}function Pg(a){a=a|0;return c[(c[a>>2]|0)+-4>>2]|0}function Qg(a){a=a|0;if(!a)return;Ub[c[(c[a>>2]|0)+4>>2]&127](a);return}function Rg(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)g=c[(c[a>>2]|0)+g>>2]|0;return Qb[g&15](a,d,e,f)|0}function Sg(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)g=c[(c[a>>2]|0)+g>>2]|0;return Qb[g&15](a,d,e,f)|0}function Tg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;Ub[e&127](a);return}else{e=c[(c[a>>2]|0)+d>>2]|0;Ub[e&127](a);return}}function Ug(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+32|0;e=f;d=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(g&1)d=c[(c[a>>2]|0)+d>>2]|0;Xb[d&127](e,a);g=Zj(32)|0;c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[g+16>>2]=c[e+16>>2];c[g+20>>2]=c[e+20>>2];c[g+24>>2]=c[e+24>>2];c[g+28>>2]=c[e+28>>2];Eb=f;return g|0}function Vg(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function Wg(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Xb[f&127](a,d);return}else{f=c[(c[a>>2]|0)+e>>2]|0;Xb[f&127](a,d);return}}function Xg(a){a=a|0;return c[(c[a>>2]|0)+-4>>2]|0}function Yg(a){a=a|0;if(!a)return;Ub[c[(c[a>>2]|0)+4>>2]&127](a);return}function Zg(a){a=a|0;return a|0}function _g(a){a=a|0;return a|0}function $g(b){b=b|0;var d=0,e=0,f=0,g=0;g=Zj(144)|0;d=c[b>>2]|0;c[g+24>>2]=0;c[g+28>>2]=0;c[g+32>>2]=0;c[g+40>>2]=0;c[g+44>>2]=0;c[g+48>>2]=0;c[g+56>>2]=0;c[g+60>>2]=0;c[g+64>>2]=0;b=g+4|0;c[b>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;c[g>>2]=3556;b=g+112|0;e=g+72|0;f=e+36|0;do{c[e>>2]=0;e=e+4|0;}while((e|0)<(f|0));c[b>>2]=b;c[g+116>>2]=b;c[g+120>>2]=0;a[g+128>>0]=0;a[g+20>>0]=0;a[g+140>>0]=d&1;a[g+142>>0]=d>>>1&1;a[g+36>>0]=d>>>2&1;a[g+37>>0]=0;return g|0}function ah(a,b){a=a|0;b=b|0;var d=0,e=0;d=Eb;Eb=Eb+16|0;e=d;c[e>>2]=b;b=Lb[a&63](e)|0;Eb=d;return b|0}function bh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)g=c[(c[a>>2]|0)+g>>2]|0;return Qb[g&15](a,d,e,f)|0}function ch(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0;h=c[a>>2]|0;i=c[a+4>>2]|0;a=b+(i>>1)|0;if(i&1)h=c[(c[a>>2]|0)+h>>2]|0;return Rb[h&7](a,d,e,f,g)|0}function dh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(h&1)g=c[(c[a>>2]|0)+g>>2]|0;return Qb[g&15](a,d,e,f)|0}function eh(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0;h=c[a>>2]|0;i=c[a+4>>2]|0;a=b+(i>>1)|0;if(i&1)h=c[(c[a>>2]|0)+h>>2]|0;return Rb[h&7](a,d,e,f,g)|0}function fh(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(e&1)d=c[(c[a>>2]|0)+d>>2]|0;return Lb[d&63](a)|0}function gh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=c[a>>2]|0;f=c[a+4>>2]|0;a=b+(f>>1)|0;if(!(f&1)){f=e;Xb[f&127](a,d);return}else{f=c[(c[a>>2]|0)+e>>2]|0;Xb[f&127](a,d);return}}function hh(a){return 1608}function ih(a){a=a|0;if(!a)return;vd(a);$j(a);return}function jh(b,d){b=b|0;d=d|0;var e=0.0,f=0,h=0,i=0.0,j=0;j=Zj(176)|0;i=+g[b>>3];e=+g[d>>3];b=j+112|0;d=j+128|0;f=j+16|0;h=f+48|0;do{c[f>>2]=0;f=f+4|0;}while((f|0)<(h|0));h=j+120|0;c[h>>2]=0;c[h+4>>2]=0;c[d>>2]=3512;h=j+132|0;c[h>>2]=0;c[h+4>>2]=0;c[h+8>>2]=0;c[h+12>>2]=0;c[h+16>>2]=0;c[h+20>>2]=0;c[h+24>>2]=0;c[h+28>>2]=0;a[h+32>>0]=0;g[j>>3]=i;g[j+8>>3]=e;h=b;c[h>>2]=-1;c[h+4>>2]=-1;return j|0}function kh(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;f=d+8|0;e=d;g[f>>3]=b;g[e>>3]=c;a=Ob[a&63](f,e)|0;Eb=d;return a|0}function lh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(!(h&1)){h=g;$b[h&15](a,d,e,f);return}else{h=c[(c[a>>2]|0)+g>>2]|0;$b[h&15](a,d,e,f);return}}function mh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=c[a>>2]|0;h=c[a+4>>2]|0;a=b+(h>>1)|0;if(!(h&1)){h=g;$b[h&15](a,d,e,f);return}else{h=c[(c[a>>2]|0)+g>>2]|0;$b[h&15](a,d,e,f);return}}function nh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,g=0;f=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(!(g&1)){g=f;Yb[g&15](a,d,e);return}else{g=c[(c[a>>2]|0)+f>>2]|0;Yb[g&15](a,d,e);return}}function oh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,g=0;f=c[a>>2]|0;g=c[a+4>>2]|0;a=b+(g>>1)|0;if(!(g&1)){g=f;Yb[g&15](a,d,e);return}else{g=c[(c[a>>2]|0)+f>>2]|0;Yb[g&15](a,d,e);return}}function ph(a,b){a=a|0;b=b|0;var d=0,e=0;d=c[a>>2]|0;e=c[a+4>>2]|0;a=b+(e>>1)|0;if(!(e&1)){e=d;Ub[e&127](a);return}else{e=c[(c[a>>2]|0)+d>>2]|0;Ub[e&127](a);return}}function qh(a,b){a=a|0;b=b|0;return +(+g[b+(c[a>>2]|0)>>3])}function rh(a,b,d){a=a|0;b=b|0;d=+d;g[b+(c[a>>2]|0)>>3]=d;return}function sh(){fe(0);return}function th(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;a=yh(c[a+60>>2]|0)|0;c[d>>2]=a;a=wh(ba(6,d|0)|0)|0;Eb=b;return a|0}function uh(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Eb;Eb=Eb+48|0;k=m+32|0;g=m+16|0;f=m;i=a+28|0;e=c[i>>2]|0;c[f>>2]=e;j=a+20|0;e=(c[j>>2]|0)-e|0;c[f+4>>2]=e;c[f+8>>2]=b;c[f+12>>2]=d;e=e+d|0;h=a+60|0;c[g>>2]=c[h>>2];c[g+4>>2]=f;c[g+8>>2]=2;g=wh(aa(146,g|0)|0)|0;a:do if((e|0)!=(g|0)){b=2;while(1){if((g|0)<0)break;e=e-g|0;o=c[f+4>>2]|0;n=g>>>0>o>>>0;f=n?f+8|0:f;b=b+(n<<31>>31)|0;o=g-(n?o:0)|0;c[f>>2]=(c[f>>2]|0)+o;n=f+4|0;c[n>>2]=(c[n>>2]|0)-o;c[k>>2]=c[h>>2];c[k+4>>2]=f;c[k+8>>2]=b;g=wh(aa(146,k|0)|0)|0;if((e|0)==(g|0)){l=3;break a}}c[a+16>>2]=0;c[i>>2]=0;c[j>>2]=0;c[a>>2]=c[a>>2]|32;if((b|0)==2)d=0;else d=d-(c[f+4>>2]|0)|0;}else l=3;while(0);if((l|0)==3){o=c[a+44>>2]|0;c[a+16>>2]=o+(c[a+48>>2]|0);c[i>>2]=o;c[j>>2]=o;}Eb=m;return d|0}function vh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;g=Eb;Eb=Eb+32|0;h=g+8|0;f=g;c[h>>2]=c[a+60>>2];c[h+4>>2]=d;c[h+8>>2]=b;c[h+12>>2]=f;c[h+16>>2]=e;if((wh($(140,h|0)|0)|0)<0){a=f;c[a>>2]=-1;c[a+4>>2]=-1;a=-1;b=-1;}else{b=f;a=c[b+4>>2]|0;b=c[b>>2]|0;}E(a|0);Eb=g;return b|0}function wh(a){a=a|0;var b=0;if(a>>>0>4294963200){b=xh()|0;c[b>>2]=0-a;a=-1;}return a|0}function xh(){return 18240}function yh(a){a=a|0;return a|0}function zh(a){a=a|0;return (a+-97|0)>>>0<26|0}function Ah(b,c){b=b|0;c=c|0;var d=0,e=0;d=a[b>>0]|0;e=a[c>>0]|0;if(d<<24>>24==0?1:d<<24>>24!=e<<24>>24)b=e;else{do{b=b+1|0;c=c+1|0;d=a[b>>0]|0;e=a[c>>0]|0;}while(!(d<<24>>24==0?1:d<<24>>24!=e<<24>>24));b=e;}return (d&255)-(b&255)|0}function Bh(a){a=a|0;return (a+-48|0)>>>0<10|0}function Ch(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+160|0;g=j+144|0;i=j;ax(i|0,1792,144)|0;if((d+-1|0)>>>0>2147483646)if(!d){b=g;d=1;h=4;}else{d=xh()|0;c[d>>2]=75;d=-1;}else h=4;if((h|0)==4){h=-2-b|0;h=d>>>0>h>>>0?h:d;c[i+48>>2]=h;g=i+20|0;c[g>>2]=b;c[i+44>>2]=b;d=b+h|0;b=i+16|0;c[b>>2]=d;c[i+28>>2]=d;d=Dh(i,e,f)|0;if(h){i=c[g>>2]|0;a[i+(((i|0)==(c[b>>2]|0))<<31>>31)>>0]=0;}}Eb=j;return d|0}function Dh(a,b,c){a=a|0;b=b|0;c=c|0;return Gh(a,b,c,1,107)|0}function Eh(b,e,f,g,h,i){b=b|0;e=+e;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,B=0,C=0,D=0,E=0,G=0,H=0;H=Eb;Eb=Eb+560|0;l=H+32|0;u=H+536|0;G=H;E=G;m=H+540|0;c[u>>2]=0;D=m+12|0;Yh(e)|0;j=F()|0;if((j|0)<0){e=-e;Yh(e)|0;C=1;B=10433;j=F()|0;}else{C=(h&2049|0)!=0&1;B=(h&2048|0)==0?((h&1|0)==0?10434:10439):10436;}do if(0==0&(j&2146435072|0)==2146435072){G=(i&32|0)!=0;j=C+3|0;Rh(b,32,f,j,h&-65537);Kh(b,B,C);Kh(b,e!=e|0.0!=0.0?(G?10460:10464):G?10452:10456,3);Rh(b,32,f,j,h^8192);}else{q=+Zh(e,u)*2.0;j=q!=0.0;if(j)c[u>>2]=(c[u>>2]|0)+-1;t=i|32;if((t|0)==97){o=i&32;r=(o|0)==0?B:B+9|0;p=C|2;j=12-g|0;do if(!(g>>>0>11|(j|0)==0)){e=8.0;do{j=j+-1|0;e=e*16.0;}while((j|0)!=0);if((a[r>>0]|0)==45){e=-(e+(-q-e));break}else{e=q+e-e;break}}else e=q;while(0);k=c[u>>2]|0;j=(k|0)<0?0-k|0:k;j=Ph(j,((j|0)<0)<<31>>31,D)|0;if((j|0)==(D|0)){j=m+11|0;a[j>>0]=48;}a[j+-1>>0]=(k>>31&2)+43;n=j+-2|0;a[n>>0]=i+15;k=(g|0)<1;l=(h&8|0)==0;m=G;do{C=~~e;j=m+1|0;a[m>>0]=o|d[1008+C>>0];e=(e-+(C|0))*16.0;if((j-E|0)==1?!(l&(k&e==0.0)):0){a[j>>0]=46;m=m+2|0;}else m=j;}while(e!=0.0);if((g|0)!=0?(-2-E+m|0)<(g|0):0){k=D;l=n;j=g+2+k-l|0;}else{k=D;l=n;j=k-E-l+m|0;}D=j+p|0;Rh(b,32,f,D,h);Kh(b,r,p);Rh(b,48,f,D,h^65536);E=m-E|0;Kh(b,G,E);G=k-l|0;Rh(b,48,j-(E+G)|0,0,0);Kh(b,n,G);Rh(b,32,f,D,h^8192);j=D;break}k=(g|0)<0?6:g;if(j){j=(c[u>>2]|0)+-28|0;c[u>>2]=j;e=q*268435456.0;}else{e=q;j=c[u>>2]|0;}z=(j|0)<0?l:l+288|0;l=z;do{x=~~e>>>0;c[l>>2]=x;l=l+4|0;e=(e-+(x>>>0))*1.0e9;}while(e!=0.0);x=z;if((j|0)>0){o=z;while(1){n=(j|0)<29?j:29;j=l+-4|0;if(j>>>0>=o>>>0){m=0;do{s=$w(c[j>>2]|0,0,n|0)|0;s=Vw(s|0,F()|0,m|0,0)|0;v=F()|0;m=Zw(s|0,v|0,1e9,0)|0;w=Uw(m|0,F()|0,1e9,0)|0;w=Ww(s|0,v|0,w|0,F()|0)|0;F()|0;c[j>>2]=w;j=j+-4|0;}while(j>>>0>=o>>>0);if(m){w=o+-4|0;c[w>>2]=m;m=w;}else m=o;}else m=o;a:do if(l>>>0>m>>>0){j=l;while(1){l=j+-4|0;if(c[l>>2]|0){l=j;break a}if(l>>>0>m>>>0)j=l;else break}}while(0);j=(c[u>>2]|0)-n|0;c[u>>2]=j;if((j|0)>0)o=m;else break}}else m=z;if((j|0)<0){g=((k+25|0)/9|0)+1|0;s=(t|0)==102;do{r=0-j|0;r=(r|0)<9?r:9;if(m>>>0<l>>>0){n=(1<<r)+-1|0;o=1e9>>>r;p=0;j=m;do{w=c[j>>2]|0;c[j>>2]=(w>>>r)+p;p=A(w&n,o)|0;j=j+4|0;}while(j>>>0<l>>>0);m=(c[m>>2]|0)==0?m+4|0:m;if(p){c[l>>2]=p;l=l+4|0;}}else m=(c[m>>2]|0)==0?m+4|0:m;j=s?z:m;l=(l-j>>2|0)>(g|0)?j+(g<<2)|0:l;j=(c[u>>2]|0)+r|0;c[u>>2]=j;}while((j|0)<0);s=m;}else s=m;if(s>>>0<l>>>0){j=(x-s>>2)*9|0;n=c[s>>2]|0;if(n>>>0>=10){m=10;do{m=m*10|0;j=j+1|0;}while(n>>>0>=m>>>0)}}else j=0;v=(t|0)==103;w=(k|0)!=0;m=k-((t|0)==102?0:j)+((w&v)<<31>>31)|0;if((m|0)<(((l-x>>2)*9|0)+-9|0)){u=m+9216|0;m=(u|0)/9|0;g=z+4+(m+-1024<<2)|0;m=u-(m*9|0)|0;if((m|0)<8){n=10;while(1){n=n*10|0;if((m|0)<7)m=m+1|0;else break}}else n=10;p=c[g>>2]|0;m=(p>>>0)/(n>>>0)|0;r=p-(A(m,n)|0)|0;o=(g+4|0)==(l|0);if(!(o&(r|0)==0)){q=(m&1|0)==0?9007199254740992.0:9007199254740994.0;u=n>>>1;e=r>>>0<u>>>0?.5:o&(r|0)==(u|0)?1.0:1.5;if(C){u=(a[B>>0]|0)==45;e=u?-e:e;q=u?-q:q;}m=p-r|0;c[g>>2]=m;if(q+e!=q){u=m+n|0;c[g>>2]=u;if(u>>>0>999999999){n=g;j=s;while(1){m=n+-4|0;c[n>>2]=0;if(m>>>0<j>>>0){j=j+-4|0;c[j>>2]=0;}u=(c[m>>2]|0)+1|0;c[m>>2]=u;if(u>>>0>999999999)n=m;else{n=j;break}}}else{m=g;n=s;}j=(x-n>>2)*9|0;p=c[n>>2]|0;if(p>>>0>=10){o=10;do{o=o*10|0;j=j+1|0;}while(p>>>0>=o>>>0)}}else{m=g;n=s;}}else{m=g;n=s;}u=m+4|0;l=l>>>0>u>>>0?u:l;}else n=s;g=0-j|0;b:do if(l>>>0>n>>>0)while(1){m=l+-4|0;if(c[m>>2]|0){u=l;t=1;break b}if(m>>>0>n>>>0)l=m;else{u=m;t=0;break}}else{u=l;t=0;}while(0);do if(v){k=k+((w^1)&1)|0;if((k|0)>(j|0)&(j|0)>-5){o=i+-1|0;k=k+-1-j|0;}else{o=i+-2|0;k=k+-1|0;}if(!(h&8)){if(t?(y=c[u+-4>>2]|0,(y|0)!=0):0)if(!((y>>>0)%10|0)){m=0;l=10;do{l=l*10|0;m=m+1|0;}while(!((y>>>0)%(l>>>0)|0|0))}else m=0;else m=9;l=((u-x>>2)*9|0)+-9|0;if((o|32|0)==102){i=l-m|0;i=(i|0)>0?i:0;k=(k|0)<(i|0)?k:i;break}else{i=l+j-m|0;i=(i|0)>0?i:0;k=(k|0)<(i|0)?k:i;break}}}else o=i;while(0);s=(k|0)!=0;p=s?1:h>>>3&1;r=(o|32|0)==102;if(r){v=0;j=(j|0)>0?j:0;}else{l=(j|0)<0?g:j;l=Ph(l,((l|0)<0)<<31>>31,D)|0;m=D;if((m-l|0)<2)do{l=l+-1|0;a[l>>0]=48;}while((m-l|0)<2);a[l+-1>>0]=(j>>31&2)+43;j=l+-2|0;a[j>>0]=o;v=j;j=m-j|0;}j=C+1+k+p+j|0;Rh(b,32,f,j,h);Kh(b,B,C);Rh(b,48,f,j,h^65536);if(r){p=n>>>0>z>>>0?z:n;r=G+9|0;n=r;o=G+8|0;m=p;do{l=Ph(c[m>>2]|0,0,r)|0;if((m|0)==(p|0)){if((l|0)==(r|0)){a[o>>0]=48;l=o;}}else if(l>>>0>G>>>0){cx(G|0,48,l-E|0)|0;do l=l+-1|0;while(l>>>0>G>>>0)}Kh(b,l,n-l|0);m=m+4|0;}while(m>>>0<=z>>>0);if(!((h&8|0)==0&(s^1)))Kh(b,14405,1);if(m>>>0<u>>>0&(k|0)>0)while(1){l=Ph(c[m>>2]|0,0,r)|0;if(l>>>0>G>>>0){cx(G|0,48,l-E|0)|0;do l=l+-1|0;while(l>>>0>G>>>0)}Kh(b,l,(k|0)<9?k:9);m=m+4|0;l=k+-9|0;if(!(m>>>0<u>>>0&(k|0)>9)){k=l;break}else k=l;}Rh(b,48,k+9|0,9,0);}else{u=t?u:n+4|0;if(n>>>0<u>>>0&(k|0)>-1){g=G+9|0;s=(h&8|0)==0;t=g;p=0-E|0;r=G+8|0;o=n;do{l=Ph(c[o>>2]|0,0,g)|0;if((l|0)==(g|0)){a[r>>0]=48;l=r;}do if((o|0)==(n|0)){m=l+1|0;Kh(b,l,1);if(s&(k|0)<1){l=m;break}Kh(b,14405,1);l=m;}else{if(l>>>0<=G>>>0)break;cx(G|0,48,l+p|0)|0;do l=l+-1|0;while(l>>>0>G>>>0)}while(0);E=t-l|0;Kh(b,l,(k|0)>(E|0)?E:k);k=k-E|0;o=o+4|0;}while(o>>>0<u>>>0&(k|0)>-1)}Rh(b,48,k+18|0,18,0);Kh(b,v,D-v|0);}Rh(b,32,f,j,h^8192);}while(0);Eb=H;return ((j|0)<(f|0)?f:j)|0}function Fh(a,b){a=a|0;b=b|0;var d=0.0,e=0;e=(c[b>>2]|0)+(8-1)&~(8-1);d=+g[e>>3];c[b>>2]=e+8;g[a>>3]=d;return}function Gh(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,p=0,q=0,r=0,s=0,t=0;t=Eb;Eb=Eb+224|0;p=t+208|0;q=t+160|0;r=t+80|0;s=t;h=q;i=h+40|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));c[p>>2]=c[e>>2];if((Hh(0,d,p,r,q,f,g)|0)<0)e=-1;else{if((c[b+76>>2]|0)>-1);e=c[b>>2]|0;n=e&32;if((a[b+74>>0]|0)<1)c[b>>2]=e&-33;h=b+48|0;if(!(c[h>>2]|0)){i=b+44|0;j=c[i>>2]|0;c[i>>2]=s;k=b+28|0;c[k>>2]=s;l=b+20|0;c[l>>2]=s;c[h>>2]=80;m=b+16|0;c[m>>2]=s+80;e=Hh(b,d,p,r,q,f,g)|0;if(j){Pb[c[b+36>>2]&15](b,0,0)|0;e=(c[l>>2]|0)==0?-1:e;c[i>>2]=j;c[h>>2]=0;c[m>>2]=0;c[k>>2]=0;c[l>>2]=0;}}else e=Hh(b,d,p,r,q,f,g)|0;h=c[b>>2]|0;c[b>>2]=h|n;e=(h&32|0)==0?e:-1;}Eb=t;return e|0}function Hh(d,e,f,h,i,j,k){d=d|0;e=e|0;f=f|0;h=h|0;i=i|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0;J=Eb;Eb=Eb+64|0;G=J+56|0;I=J+40|0;A=J;C=J+48|0;D=J+60|0;c[G>>2]=e;x=(d|0)!=0;y=A+40|0;z=y;A=A+39|0;B=C+4|0;l=0;e=0;n=0;a:while(1){do{do if((e|0)>-1)if((l|0)>(2147483647-e|0)){e=xh()|0;c[e>>2]=75;e=-1;break}else{e=l+e|0;break}while(0);r=c[G>>2]|0;l=a[r>>0]|0;if(!(l<<24>>24)){w=92;break a}m=r;b:while(1){switch(l<<24>>24){case 37:{w=10;break b}case 0:{l=m;break b}}v=m+1|0;c[G>>2]=v;l=a[v>>0]|0;m=v;}c:do if((w|0)==10){w=0;l=m;do{if((a[m+1>>0]|0)!=37)break c;l=l+1|0;m=m+2|0;c[G>>2]=m;}while((a[m>>0]|0)==37)}while(0);l=l-r|0;if(x)Kh(d,r,l);}while((l|0)!=0);v=(Bh(a[(c[G>>2]|0)+1>>0]|0)|0)==0;m=c[G>>2]|0;if(!v?(a[m+2>>0]|0)==36:0){t=(a[m+1>>0]|0)+-48|0;p=1;l=3;}else{t=-1;p=n;l=1;}l=m+l|0;c[G>>2]=l;m=a[l>>0]|0;n=(m<<24>>24)+-32|0;if(n>>>0>31|(1<<n&75913|0)==0)o=0;else{o=0;do{o=1<<n|o;l=l+1|0;c[G>>2]=l;m=a[l>>0]|0;n=(m<<24>>24)+-32|0;}while(!(n>>>0>31|(1<<n&75913|0)==0))}if(m<<24>>24==42){if((Bh(a[l+1>>0]|0)|0)!=0?(H=c[G>>2]|0,(a[H+2>>0]|0)==36):0){l=H+1|0;c[i+((a[l>>0]|0)+-48<<2)>>2]=10;l=c[h+((a[l>>0]|0)+-48<<3)>>2]|0;n=1;m=H+3|0;}else{if(p|0){e=-1;break}if(x){v=(c[f>>2]|0)+(4-1)&~(4-1);l=c[v>>2]|0;c[f>>2]=v+4;}else l=0;n=0;m=(c[G>>2]|0)+1|0;}c[G>>2]=m;v=(l|0)<0;u=v?0-l|0:l;o=v?o|8192:o;v=n;}else{l=Lh(G)|0;if((l|0)<0){e=-1;break}u=l;v=p;m=c[G>>2]|0;}do if((a[m>>0]|0)==46){l=m+1|0;if((a[l>>0]|0)!=42){c[G>>2]=l;l=Lh(G)|0;m=c[G>>2]|0;break}if(Bh(a[m+2>>0]|0)|0?(E=c[G>>2]|0,(a[E+3>>0]|0)==36):0){l=E+2|0;c[i+((a[l>>0]|0)+-48<<2)>>2]=10;l=c[h+((a[l>>0]|0)+-48<<3)>>2]|0;m=E+4|0;c[G>>2]=m;break}if(v|0){e=-1;break a}if(x){s=(c[f>>2]|0)+(4-1)&~(4-1);l=c[s>>2]|0;c[f>>2]=s+4;}else l=0;m=(c[G>>2]|0)+2|0;c[G>>2]=m;}else l=-1;while(0);s=0;while(1){if(((a[m>>0]|0)+-65|0)>>>0>57){e=-1;break a}n=m;m=m+1|0;c[G>>2]=m;n=a[(a[n>>0]|0)+-65+(544+(s*58|0))>>0]|0;p=n&255;if((p+-1|0)>>>0>=8)break;else s=p;}if(!(n<<24>>24)){e=-1;break}q=(t|0)>-1;do if(n<<24>>24==19)if(q){e=-1;break a}else w=54;else{if(q){c[i+(t<<2)>>2]=p;q=h+(t<<3)|0;t=c[q+4>>2]|0;w=I;c[w>>2]=c[q>>2];c[w+4>>2]=t;w=54;break}if(!x){e=0;break a}Mh(I,p,f,k);m=c[G>>2]|0;w=55;}while(0);if((w|0)==54){w=0;if(x)w=55;else l=0;}d:do if((w|0)==55){w=0;m=a[m+-1>>0]|0;m=(s|0)!=0&(m&15|0)==3?m&-33:m;n=o&-65537;t=(o&8192|0)==0?o:n;e:do switch(m|0){case 110:switch((s&255)<<24>>24){case 0:{c[c[I>>2]>>2]=e;l=0;break d}case 1:{c[c[I>>2]>>2]=e;l=0;break d}case 2:{l=c[I>>2]|0;c[l>>2]=e;c[l+4>>2]=((e|0)<0)<<31>>31;l=0;break d}case 3:{b[c[I>>2]>>1]=e;l=0;break d}case 4:{a[c[I>>2]>>0]=e;l=0;break d}case 6:{c[c[I>>2]>>2]=e;l=0;break d}case 7:{l=c[I>>2]|0;c[l>>2]=e;c[l+4>>2]=((e|0)<0)<<31>>31;l=0;break d}default:{l=0;break d}}case 112:{m=120;l=l>>>0>8?l:8;n=t|8;w=67;break}case 88:case 120:{n=t;w=67;break}case 111:{q=I;q=Oh(c[q>>2]|0,c[q+4>>2]|0,y)|0;n=z-q|0;o=0;p=10416;l=(t&8|0)==0|(l|0)>(n|0)?l:n+1|0;n=t;w=73;break}case 105:case 100:{n=I;m=c[n>>2]|0;n=c[n+4>>2]|0;if((n|0)<0){m=Ww(0,0,m|0,n|0)|0;n=F()|0;o=I;c[o>>2]=m;c[o+4>>2]=n;o=1;p=10416;w=72;break e}else{o=(t&2049|0)!=0&1;p=(t&2048|0)==0?((t&1|0)==0?10416:10418):10417;w=72;break e}}case 117:{n=I;o=0;p=10416;m=c[n>>2]|0;n=c[n+4>>2]|0;w=72;break}case 99:{a[A>>0]=c[I>>2];r=A;o=0;p=10416;q=1;m=n;l=z;break}case 115:{s=c[I>>2]|0;s=(s|0)==0?10426:s;t=Qh(s,0,l)|0;K=(t|0)==0;r=s;o=0;p=10416;q=K?l:t-s|0;m=n;l=K?s+l|0:t;break}case 67:{c[C>>2]=c[I>>2];c[B>>2]=0;c[I>>2]=C;p=-1;w=79;break}case 83:{if(!l){Rh(d,32,u,0,t);l=0;w=89;}else{p=l;w=79;}break}case 65:case 71:case 70:case 69:case 97:case 103:case 102:case 101:{l=Nb[j&1](d,+g[I>>3],u,l,t,m)|0;break d}default:{o=0;p=10416;q=l;m=t;l=z;}}while(0);f:do if((w|0)==67){q=I;q=Nh(c[q>>2]|0,c[q+4>>2]|0,y,m&32)|0;p=I;p=(n&8|0)==0|(c[p>>2]|0)==0&(c[p+4>>2]|0)==0;o=p?0:2;p=p?10416:10416+(m>>>4)|0;w=73;}else if((w|0)==72){q=Ph(m,n,y)|0;n=t;w=73;}else if((w|0)==79){w=0;o=c[I>>2]|0;l=0;while(1){m=c[o>>2]|0;if(!m)break;m=Sh(D,m)|0;n=(m|0)<0;if(n|m>>>0>(p-l|0)>>>0){w=83;break}l=m+l|0;if(p>>>0>l>>>0)o=o+4|0;else break}if((w|0)==83){w=0;if(n){e=-1;break a}}Rh(d,32,u,l,t);if(!l){l=0;w=89;}else{n=c[I>>2]|0;o=0;while(1){m=c[n>>2]|0;if(!m){w=89;break f}m=Sh(D,m)|0;o=m+o|0;if((o|0)>(l|0)){w=89;break f}Kh(d,D,m);if(o>>>0>=l>>>0){w=89;break}else n=n+4|0;}}}while(0);if((w|0)==73){w=0;m=I;m=(c[m>>2]|0)!=0|(c[m+4>>2]|0)!=0;K=(l|0)!=0|m;m=z-q+((m^1)&1)|0;r=K?q:y;q=K?((l|0)>(m|0)?l:m):0;m=(l|0)>-1?n&-65537:n;l=z;}else if((w|0)==89){w=0;Rh(d,32,u,l,t^8192);l=(u|0)>(l|0)?u:l;break}t=l-r|0;s=(q|0)<(t|0)?t:q;K=s+o|0;l=(u|0)<(K|0)?K:u;Rh(d,32,l,K,m);Kh(d,p,o);Rh(d,48,l,K,m^65536);Rh(d,48,s,t,0);Kh(d,r,t);Rh(d,32,l,K,m^8192);}while(0);n=v;}g:do if((w|0)==92)if(!d)if(!n)e=0;else{e=1;while(1){l=c[i+(e<<2)>>2]|0;if(!l)break;Mh(h+(e<<3)|0,l,f,k);e=e+1|0;if(e>>>0>=10){e=1;break g}}while(1){if(c[i+(e<<2)>>2]|0){e=-1;break g}e=e+1|0;if(e>>>0>=10){e=1;break}}}while(0);Eb=J;return e|0}function Ih(a){return 1}function Kh(a,b,d){a=a|0;b=b|0;d=d|0;if(!(c[a>>2]&32))Wh(b,d,a)|0;return}function Lh(b){b=b|0;var d=0,e=0;if(!(Bh(a[c[b>>2]>>0]|0)|0))d=0;else{d=0;do{e=c[b>>2]|0;d=(d*10|0)+-48+(a[e>>0]|0)|0;e=e+1|0;c[b>>2]=e;}while((Bh(a[e>>0]|0)|0)!=0)}return d|0}function Mh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0.0;a:do if(b>>>0<=20)do switch(b|0){case 9:{b=(c[d>>2]|0)+(4-1)&~(4-1);e=c[b>>2]|0;c[d>>2]=b+4;c[a>>2]=e;break a}case 10:{e=(c[d>>2]|0)+(4-1)&~(4-1);b=c[e>>2]|0;c[d>>2]=e+4;e=a;c[e>>2]=b;c[e+4>>2]=((b|0)<0)<<31>>31;break a}case 11:{e=(c[d>>2]|0)+(4-1)&~(4-1);b=c[e>>2]|0;c[d>>2]=e+4;e=a;c[e>>2]=b;c[e+4>>2]=0;break a}case 12:{e=(c[d>>2]|0)+(8-1)&~(8-1);b=e;f=c[b>>2]|0;b=c[b+4>>2]|0;c[d>>2]=e+8;e=a;c[e>>2]=f;c[e+4>>2]=b;break a}case 13:{f=(c[d>>2]|0)+(4-1)&~(4-1);e=c[f>>2]|0;c[d>>2]=f+4;e=(e&65535)<<16>>16;f=a;c[f>>2]=e;c[f+4>>2]=((e|0)<0)<<31>>31;break a}case 14:{f=(c[d>>2]|0)+(4-1)&~(4-1);e=c[f>>2]|0;c[d>>2]=f+4;f=a;c[f>>2]=e&65535;c[f+4>>2]=0;break a}case 15:{f=(c[d>>2]|0)+(4-1)&~(4-1);e=c[f>>2]|0;c[d>>2]=f+4;e=(e&255)<<24>>24;f=a;c[f>>2]=e;c[f+4>>2]=((e|0)<0)<<31>>31;break a}case 16:{f=(c[d>>2]|0)+(4-1)&~(4-1);e=c[f>>2]|0;c[d>>2]=f+4;f=a;c[f>>2]=e&255;c[f+4>>2]=0;break a}case 17:{f=(c[d>>2]|0)+(8-1)&~(8-1);h=+g[f>>3];c[d>>2]=f+8;g[a>>3]=h;break a}case 18:{Xb[e&127](a,d);break a}default:break a}while(0);while(0);return}function Nh(b,c,e,f){b=b|0;c=c|0;e=e|0;f=f|0;if(!((b|0)==0&(c|0)==0))do{e=e+-1|0;a[e>>0]=d[1008+(b&15)>>0]|0|f;b=_w(b|0,c|0,4)|0;c=F()|0;}while(!((b|0)==0&(c|0)==0));return e|0}function Oh(b,c,d){b=b|0;c=c|0;d=d|0;if(!((b|0)==0&(c|0)==0))do{d=d+-1|0;a[d>>0]=b&7|48;b=_w(b|0,c|0,3)|0;c=F()|0;}while(!((b|0)==0&(c|0)==0));return d|0}function Ph(b,c,d){b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;if(c>>>0>0|(c|0)==0&b>>>0>4294967295){do{e=b;b=Zw(b|0,c|0,10,0)|0;f=c;c=F()|0;g=Uw(b|0,c|0,10,0)|0;g=Ww(e|0,f|0,g|0,F()|0)|0;F()|0;d=d+-1|0;a[d>>0]=g&255|48;}while(f>>>0>9|(f|0)==9&e>>>0>4294967295);c=b;}else c=b;if(c)do{g=c;c=(c>>>0)/10|0;d=d+-1|0;a[d>>0]=g-(c*10|0)|48;}while(g>>>0>=10);return d|0}function Qh(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=d&255;f=(e|0)!=0;a:do if(f&(b&3|0)!=0){g=d&255;while(1){if((a[b>>0]|0)==g<<24>>24){i=6;break a}b=b+1|0;e=e+-1|0;f=(e|0)!=0;if(!(f&(b&3|0)!=0)){i=5;break}}}else i=5;while(0);if((i|0)==5)if(f)i=6;else i=16;b:do if((i|0)==6){g=d&255;if((a[b>>0]|0)==g<<24>>24)if(!e){i=16;break}else break;f=A(h,16843009)|0;c:do if(e>>>0>3)while(1){h=c[b>>2]^f;if((h&-2139062144^-2139062144)&h+-16843009|0)break c;b=b+4|0;e=e+-4|0;if(e>>>0<=3){i=11;break}}else i=11;while(0);if((i|0)==11)if(!e){i=16;break}while(1){if((a[b>>0]|0)==g<<24>>24)break b;e=e+-1|0;if(!e){i=16;break}else b=b+1|0;}}while(0);if((i|0)==16)b=0;return b|0}function Rh(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,g=0;g=Eb;Eb=Eb+256|0;f=g;if((c|0)>(d|0)&(e&73728|0)==0){e=c-d|0;cx(f|0,b<<24>>24|0,(e>>>0<256?e:256)|0)|0;if(e>>>0>255){b=c-d|0;do{Kh(a,f,256);e=e+-256|0;}while(e>>>0>255);e=b&255;}Kh(a,f,e);}Eb=g;return}function Sh(a,b){a=a|0;b=b|0;if(!a)a=0;else a=Th(a,b,0)|0;return a|0}function Th(b,d,e){b=b|0;d=d|0;e=e|0;do if(b){if(d>>>0<128){a[b>>0]=d;b=1;break}e=(Uh()|0)+188|0;if(!(c[c[e>>2]>>2]|0))if((d&-128|0)==57216){a[b>>0]=d;b=1;break}else{b=xh()|0;c[b>>2]=84;b=-1;break}if(d>>>0<2048){a[b>>0]=d>>>6|192;a[b+1>>0]=d&63|128;b=2;break}if(d>>>0<55296|(d&-8192|0)==57344){a[b>>0]=d>>>12|224;a[b+1>>0]=d>>>6&63|128;a[b+2>>0]=d&63|128;b=3;break}if((d+-65536|0)>>>0<1048576){a[b>>0]=d>>>18|240;a[b+1>>0]=d>>>12&63|128;a[b+2>>0]=d>>>6&63|128;a[b+3>>0]=d&63|128;b=4;break}else{b=xh()|0;c[b>>2]=84;b=-1;break}}else b=1;while(0);return b|0}function Uh(){return Vh()|0}function Vh(){return 3984}function Wh(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=e+16|0;g=c[f>>2]|0;if(!g)if(!(Xh(e)|0)){g=c[f>>2]|0;h=5;}else f=0;else h=5;a:do if((h|0)==5){j=e+20|0;i=c[j>>2]|0;f=i;if((g-i|0)>>>0<d>>>0){f=Pb[c[e+36>>2]&15](e,b,d)|0;break}b:do if((a[e+75>>0]|0)<0|(d|0)==0){h=0;g=b;}else{i=d;while(1){g=i+-1|0;if((a[b+g>>0]|0)==10)break;if(!g){h=0;g=b;break b}else i=g;}f=Pb[c[e+36>>2]&15](e,b,i)|0;if(f>>>0<i>>>0)break a;h=i;g=b+i|0;d=d-i|0;f=c[j>>2]|0;}while(0);ax(f|0,g|0,d|0)|0;c[j>>2]=(c[j>>2]|0)+d;f=h+d|0;}while(0);return f|0}function Xh(b){b=b|0;var d=0,e=0;d=b+74|0;e=a[d>>0]|0;a[d>>0]=e+255|e;d=c[b>>2]|0;if(!(d&8)){c[b+8>>2]=0;c[b+4>>2]=0;e=c[b+44>>2]|0;c[b+28>>2]=e;c[b+20>>2]=e;c[b+16>>2]=e+(c[b+48>>2]|0);b=0;}else{c[b>>2]=d|32;b=-1;}return b|0}function Yh(a){a=+a;var b=0;g[h>>3]=a;b=c[h>>2]|0;E(c[h+4>>2]|0);return b|0}function Zh(a,b){a=+a;b=b|0;var d=0,e=0,f=0;g[h>>3]=a;d=c[h>>2]|0;e=c[h+4>>2]|0;f=_w(d|0,e|0,52)|0;F()|0;switch(f&2047){case 0:{if(a!=0.0){a=+Zh(a*18446744073709551616.0,b);d=(c[b>>2]|0)+-64|0;}else d=0;c[b>>2]=d;break}case 2047:break;default:{c[b>>2]=(f&2047)+-1022;c[h>>2]=d;c[h+4>>2]=e&-2146435073|1071644672;a=+g[h>>3];}}return +a}function _h(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=a+20|0;f=c[e>>2]|0;a=(c[a+16>>2]|0)-f|0;a=a>>>0>d>>>0?d:a;ax(f|0,b|0,a|0)|0;c[e>>2]=(c[e>>2]|0)+a;return d|0}function $h(a){a=a|0;return (((a|32)+-97|0)>>>0<6|(Bh(a)|0)!=0)&1|0}function ai(b){b=b|0;var d=0,e=0,f=0;f=b;a:do if(!(f&3))e=5;else{d=f;while(1){if(!(a[b>>0]|0)){b=d;break a}b=b+1|0;d=b;if(!(d&3)){e=5;break}}}while(0);if((e|0)==5){while(1){d=c[b>>2]|0;if(!((d&-2139062144^-2139062144)&d+-16843009))b=b+4|0;else break}if((d&255)<<24>>24)do b=b+1|0;while((a[b>>0]|0)!=0)}return b-f|0}function bi(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=Eb;Eb=Eb+16|0;g=f;c[g>>2]=e;e=Ch(a,b,d,g)|0;Eb=f;return e|0}function ci(a){a=a|0;var b=0,c=0;b=(ai(a)|0)+1|0;c=hk(b)|0;if(!c)a=0;else a=ax(c|0,a|0,b|0)|0;return a|0}function di(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+16|0;j=l;k=e&255;a[j>>0]=k;g=b+16|0;h=c[g>>2]|0;if(!h)if(!(Xh(b)|0)){h=c[g>>2]|0;i=4;}else f=-1;else i=4;do if((i|0)==4){i=b+20|0;g=c[i>>2]|0;if(g>>>0<h>>>0?(f=e&255,(f|0)!=(a[b+75>>0]|0)):0){c[i>>2]=g+1;a[g>>0]=k;break}if((Pb[c[b+36>>2]&15](b,j,1)|0)==1)f=d[j>>0]|0;else f=-1;}while(0);Eb=l;return f|0}function ei(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;if((c[d+76>>2]|0)>=0?(Ih()|0)!=0:0){f=b&255;e=b&255;if((e|0)!=(a[d+75>>0]|0)?(i=d+20|0,j=c[i>>2]|0,j>>>0<(c[d+16>>2]|0)>>>0):0){c[i>>2]=j+1;a[j>>0]=f;}else e=di(d,b)|0;}else k=3;do if((k|0)==3){f=b&255;e=b&255;if((e|0)!=(a[d+75>>0]|0)?(g=d+20|0,h=c[g>>2]|0,h>>>0<(c[d+16>>2]|0)>>>0):0){c[g>>2]=h+1;a[h>>0]=f;break}e=di(d,b)|0;}while(0);return e|0}function fi(){gi();return}function gi(){hi(18756);return}function hi(a){a=a|0;var b=0;b=Eb;Eb=Eb+16|0;c[b>>2]=a;ii();Eb=b;return}function ii(){qa(ji()|0,12081);ca(ki()|0,12086,1,1,0);li(12091);mi(12096);ni(12108);oi(12122);pi(12128);qi(12143);ri(12147);si(12160);ti(12165);ui(12216);vi(16870);oa(wi()|0,12526);oa(xi()|0,10468);pa(yi()|0,4,10501);ha(zi()|0,10514);Ai(10530);Bi(10560);Ci(10597);Di(10636);Ei(10667);Fi(10707);Gi(10736);Hi(10774);Ii(10804);Bi(10843);Ci(10875);Di(10908);Ei(10941);Fi(10975);Gi(11008);Ji(11042);Ki(11073);Li(11105);return}function ji(){return Vj()|0}function ki(){return Uj()|0}function li(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Sj()|0;ma(a|0,c[d>>2]|0,1,-128<<24>>24|0,127<<24>>24|0);Eb=b;return}function mi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Qj()|0;ma(a|0,c[d>>2]|0,1,-128<<24>>24|0,127<<24>>24|0);Eb=b;return}function ni(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Oj()|0;ma(a|0,c[d>>2]|0,1,0,255);Eb=b;return}function oi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Mj()|0;ma(a|0,c[d>>2]|0,2,-32768<<16>>16|0,32767<<16>>16|0);Eb=b;return}function pi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Kj()|0;ma(a|0,c[d>>2]|0,2,0,65535);Eb=b;return}function qi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Ij()|0;ma(a|0,c[d>>2]|0,4,-2147483648,2147483647);Eb=b;return}function ri(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Gj()|0;ma(a|0,c[d>>2]|0,4,0,-1);Eb=b;return}function si(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Ej()|0;ma(a|0,c[d>>2]|0,4,-2147483648,2147483647);Eb=b;return}function ti(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Cj()|0;ma(a|0,c[d>>2]|0,4,0,-1);Eb=b;return}function ui(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=Aj()|0;ka(a|0,c[d>>2]|0,4);Eb=b;return}function vi(a){a=a|0;var b=0,d=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;a=yj()|0;ka(a|0,c[d>>2]|0,8);Eb=b;return}function wi(){return xj()|0}function xi(){return wj()|0}function yi(){return vj()|0}function zi(){return uj()|0}function Ai(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=rj()|0;a=sj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Bi(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=oj()|0;a=pj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ci(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=lj()|0;a=mj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Di(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=ij()|0;a=jj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ei(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=fj()|0;a=gj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Fi(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=cj()|0;a=dj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Gi(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=$i()|0;a=aj()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Hi(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Yi()|0;a=Zi()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ii(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Vi()|0;a=Wi()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ji(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Si()|0;a=Ti()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Ki(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Pi()|0;a=Qi()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Li(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;c[d>>2]=a;e=Mi()|0;a=Ni()|0;na(e|0,a|0,c[d>>2]|0);Eb=b;return}function Mi(){return Oi()|0}function Ni(){return 7}function Oi(){return 1936}function Pi(){return Ri()|0}function Qi(){return 7}function Ri(){return 1072}function Si(){return Ui()|0}function Ti(){return 6}function Ui(){return 1944}function Vi(){return Xi()|0}function Wi(){return 5}function Xi(){return 1952}function Yi(){return _i()|0}function Zi(){return 4}function _i(){return 1960}function $i(){return bj()|0}function aj(){return 5}function bj(){return 1968}function cj(){return ej()|0}function dj(){return 4}function ej(){return 1976}function fj(){return hj()|0}function gj(){return 3}function hj(){return 1984}function ij(){return kj()|0}function jj(){return 2}function kj(){return 1992}function lj(){return nj()|0}function mj(){return 1}function nj(){return 2e3}function oj(){return qj()|0}function pj(){return 0}function qj(){return 2008}function rj(){return tj()|0}function sj(){return 0}function tj(){return 2016}function uj(){return 1184}function vj(){return 2024}function wj(){return 2056}function xj(){return 2080}function yj(){return zj()|0}function zj(){return 3464}function Aj(){return Bj()|0}function Bj(){return 3456}function Cj(){return Dj()|0}function Dj(){return 3448}function Ej(){return Fj()|0}function Fj(){return 3440}function Gj(){return Hj()|0}function Hj(){return 3432}function Ij(){return Jj()|0}function Jj(){return 3424}function Kj(){return Lj()|0}function Lj(){return 3416}function Mj(){return Nj()|0}function Nj(){return 3408}function Oj(){return Pj()|0}function Pj(){return 3392}function Qj(){return Rj()|0}function Rj(){return 3400}function Sj(){return Tj()|0}function Tj(){return 3384}function Uj(){return 3376}function Vj(){return 3360}function Wj(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b+4|0;e=b;c[e>>2]=a;c[d>>2]=c[e>>2];a=ci(c[(c[d>>2]|0)+4>>2]|0)|0;Eb=b;return a|0}function Xj(){return (Yj()|0)>0|0}function Yj(){return W()|0}function Zj(a){a=a|0;var b=0;b=(a|0)==0?1:a;while(1){a=hk(b)|0;if(a|0)break;a=Qw()|0;if(!a){a=0;break}Tb[a&3]();}return a|0}function _j(a){a=a|0;return Zj(a)|0}function $j(a){a=a|0;ik(a);return}function ak(a){a=a|0;$j(a);return}function bk(a,b){a=a|0;b=b|0;var d=0,e=0;e=ai(b)|0;d=Zj(e+13|0)|0;c[d>>2]=e;c[d+4>>2]=e;c[d+8>>2]=0;d=ck(d)|0;ax(d|0,b|0,e+1|0)|0;c[a>>2]=d;return}function ck(a){a=a|0;return a+12|0}function dk(a,b){a=a|0;b=b|0;c[a>>2]=7308;bk(a+4|0,b);return}function fk(a){va();}function gk(a){va();}function hk(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;w=Eb;Eb=Eb+16|0;n=w;do if(a>>>0<245){k=a>>>0<11?16:a+11&-8;a=k>>>3;m=c[4561]|0;d=m>>>a;if(d&3|0){b=(d&1^1)+a|0;a=18284+(b<<1<<2)|0;d=a+8|0;e=c[d>>2]|0;f=e+8|0;g=c[f>>2]|0;if((g|0)==(a|0))c[4561]=m&~(1<<b);else{c[g+12>>2]=a;c[d>>2]=g;}v=b<<3;c[e+4>>2]=v|3;v=e+v+4|0;c[v>>2]=c[v>>2]|1;v=f;Eb=w;return v|0}l=c[4563]|0;if(k>>>0>l>>>0){if(d|0){b=2<<a;b=d<<a&(b|0-b);b=(b&0-b)+-1|0;i=b>>>12&16;b=b>>>i;d=b>>>5&8;b=b>>>d;g=b>>>2&4;b=b>>>g;a=b>>>1&2;b=b>>>a;e=b>>>1&1;e=(d|i|g|a|e)+(b>>>e)|0;b=18284+(e<<1<<2)|0;a=b+8|0;g=c[a>>2]|0;i=g+8|0;d=c[i>>2]|0;if((d|0)==(b|0)){a=m&~(1<<e);c[4561]=a;}else{c[d+12>>2]=b;c[a>>2]=d;a=m;}v=e<<3;h=v-k|0;c[g+4>>2]=k|3;f=g+k|0;c[f+4>>2]=h|1;c[g+v>>2]=h;if(l|0){e=c[4566]|0;b=l>>>3;d=18284+(b<<1<<2)|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else{a=d+8|0;b=c[a>>2]|0;}c[a>>2]=e;c[b+12>>2]=e;c[e+8>>2]=b;c[e+12>>2]=d;}c[4563]=h;c[4566]=f;v=i;Eb=w;return v|0}g=c[4562]|0;if(g){d=(g&0-g)+-1|0;f=d>>>12&16;d=d>>>f;e=d>>>5&8;d=d>>>e;h=d>>>2&4;d=d>>>h;i=d>>>1&2;d=d>>>i;j=d>>>1&1;j=c[18548+((e|f|h|i|j)+(d>>>j)<<2)>>2]|0;d=j;i=j;j=(c[j+4>>2]&-8)-k|0;while(1){a=c[d+16>>2]|0;if(!a){a=c[d+20>>2]|0;if(!a)break}h=(c[a+4>>2]&-8)-k|0;f=h>>>0<j>>>0;d=a;i=f?a:i;j=f?h:j;}h=i+k|0;if(h>>>0>i>>>0){f=c[i+24>>2]|0;b=c[i+12>>2]|0;do if((b|0)==(i|0)){a=i+20|0;b=c[a>>2]|0;if(!b){a=i+16|0;b=c[a>>2]|0;if(!b){d=0;break}}while(1){e=b+20|0;d=c[e>>2]|0;if(!d){e=b+16|0;d=c[e>>2]|0;if(!d)break;else{b=d;a=e;}}else{b=d;a=e;}}c[a>>2]=0;d=b;}else{d=c[i+8>>2]|0;c[d+12>>2]=b;c[b+8>>2]=d;d=b;}while(0);do if(f|0){b=c[i+28>>2]|0;a=18548+(b<<2)|0;if((i|0)==(c[a>>2]|0)){c[a>>2]=d;if(!d){c[4562]=g&~(1<<b);break}}else{v=f+16|0;c[((c[v>>2]|0)==(i|0)?v:f+20|0)>>2]=d;if(!d)break}c[d+24>>2]=f;b=c[i+16>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d;}b=c[i+20>>2]|0;if(b|0){c[d+20>>2]=b;c[b+24>>2]=d;}}while(0);if(j>>>0<16){v=j+k|0;c[i+4>>2]=v|3;v=i+v+4|0;c[v>>2]=c[v>>2]|1;}else{c[i+4>>2]=k|3;c[h+4>>2]=j|1;c[h+j>>2]=j;if(l|0){e=c[4566]|0;b=l>>>3;d=18284+(b<<1<<2)|0;b=1<<b;if(!(b&m)){c[4561]=b|m;b=d;a=d+8|0;}else{a=d+8|0;b=c[a>>2]|0;}c[a>>2]=e;c[b+12>>2]=e;c[e+8>>2]=b;c[e+12>>2]=d;}c[4563]=j;c[4566]=h;}v=i+8|0;Eb=w;return v|0}else m=k;}else m=k;}else m=k;}else if(a>>>0<=4294967231){a=a+11|0;k=a&-8;e=c[4562]|0;if(e){f=0-k|0;a=a>>>8;if(a)if(k>>>0>16777215)j=31;else{m=(a+1048320|0)>>>16&8;q=a<<m;i=(q+520192|0)>>>16&4;q=q<<i;j=(q+245760|0)>>>16&2;j=14-(i|m|j)+(q<<j>>>15)|0;j=k>>>(j+7|0)&1|j<<1;}else j=0;d=c[18548+(j<<2)>>2]|0;a:do if(!d){d=0;a=0;q=61;}else{a=0;i=k<<((j|0)==31?0:25-(j>>>1)|0);g=0;while(1){h=(c[d+4>>2]&-8)-k|0;if(h>>>0<f>>>0)if(!h){a=d;f=0;q=65;break a}else{a=d;f=h;}q=c[d+20>>2]|0;d=c[d+16+(i>>>31<<2)>>2]|0;g=(q|0)==0|(q|0)==(d|0)?g:q;if(!d){d=g;q=61;break}else i=i<<1;}}while(0);if((q|0)==61){if((d|0)==0&(a|0)==0){a=2<<j;a=(a|0-a)&e;if(!a){m=k;break}m=(a&0-a)+-1|0;h=m>>>12&16;m=m>>>h;g=m>>>5&8;m=m>>>g;i=m>>>2&4;m=m>>>i;j=m>>>1&2;m=m>>>j;d=m>>>1&1;a=0;d=c[18548+((g|h|i|j|d)+(m>>>d)<<2)>>2]|0;}if(!d){i=a;h=f;}else q=65;}if((q|0)==65){g=d;while(1){m=(c[g+4>>2]&-8)-k|0;d=m>>>0<f>>>0;f=d?m:f;a=d?g:a;d=c[g+16>>2]|0;if(!d)d=c[g+20>>2]|0;if(!d){i=a;h=f;break}else g=d;}}if(((i|0)!=0?h>>>0<((c[4563]|0)-k|0)>>>0:0)?(l=i+k|0,l>>>0>i>>>0):0){g=c[i+24>>2]|0;b=c[i+12>>2]|0;do if((b|0)==(i|0)){a=i+20|0;b=c[a>>2]|0;if(!b){a=i+16|0;b=c[a>>2]|0;if(!b){b=0;break}}while(1){f=b+20|0;d=c[f>>2]|0;if(!d){f=b+16|0;d=c[f>>2]|0;if(!d)break;else{b=d;a=f;}}else{b=d;a=f;}}c[a>>2]=0;}else{v=c[i+8>>2]|0;c[v+12>>2]=b;c[b+8>>2]=v;}while(0);do if(g){a=c[i+28>>2]|0;d=18548+(a<<2)|0;if((i|0)==(c[d>>2]|0)){c[d>>2]=b;if(!b){e=e&~(1<<a);c[4562]=e;break}}else{v=g+16|0;c[((c[v>>2]|0)==(i|0)?v:g+20|0)>>2]=b;if(!b)break}c[b+24>>2]=g;a=c[i+16>>2]|0;if(a|0){c[b+16>>2]=a;c[a+24>>2]=b;}a=c[i+20>>2]|0;if(a){c[b+20>>2]=a;c[a+24>>2]=b;}}while(0);b:do if(h>>>0<16){v=h+k|0;c[i+4>>2]=v|3;v=i+v+4|0;c[v>>2]=c[v>>2]|1;}else{c[i+4>>2]=k|3;c[l+4>>2]=h|1;c[l+h>>2]=h;b=h>>>3;if(h>>>0<256){d=18284+(b<<1<<2)|0;a=c[4561]|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else{a=d+8|0;b=c[a>>2]|0;}c[a>>2]=l;c[b+12>>2]=l;c[l+8>>2]=b;c[l+12>>2]=d;break}b=h>>>8;if(b)if(h>>>0>16777215)d=31;else{u=(b+1048320|0)>>>16&8;v=b<<u;t=(v+520192|0)>>>16&4;v=v<<t;d=(v+245760|0)>>>16&2;d=14-(t|u|d)+(v<<d>>>15)|0;d=h>>>(d+7|0)&1|d<<1;}else d=0;b=18548+(d<<2)|0;c[l+28>>2]=d;a=l+16|0;c[a+4>>2]=0;c[a>>2]=0;a=1<<d;if(!(e&a)){c[4562]=e|a;c[b>>2]=l;c[l+24>>2]=b;c[l+12>>2]=l;c[l+8>>2]=l;break}b=c[b>>2]|0;c:do if((c[b+4>>2]&-8|0)!=(h|0)){e=h<<((d|0)==31?0:25-(d>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(h|0)){b=a;break c}else{e=e<<1;b=a;}}c[d>>2]=l;c[l+24>>2]=b;c[l+12>>2]=l;c[l+8>>2]=l;break b}while(0);u=b+8|0;v=c[u>>2]|0;c[v+12>>2]=l;c[u>>2]=l;c[l+8>>2]=v;c[l+12>>2]=b;c[l+24>>2]=0;}while(0);v=i+8|0;Eb=w;return v|0}else m=k;}else m=k;}else m=-1;while(0);d=c[4563]|0;if(d>>>0>=m>>>0){b=d-m|0;a=c[4566]|0;if(b>>>0>15){v=a+m|0;c[4566]=v;c[4563]=b;c[v+4>>2]=b|1;c[a+d>>2]=b;c[a+4>>2]=m|3;}else{c[4563]=0;c[4566]=0;c[a+4>>2]=d|3;v=a+d+4|0;c[v>>2]=c[v>>2]|1;}v=a+8|0;Eb=w;return v|0}h=c[4564]|0;if(h>>>0>m>>>0){t=h-m|0;c[4564]=t;v=c[4567]|0;u=v+m|0;c[4567]=u;c[u+4>>2]=t|1;c[v+4>>2]=m|3;v=v+8|0;Eb=w;return v|0}if(!(c[4679]|0)){c[4681]=4096;c[4680]=4096;c[4682]=-1;c[4683]=-1;c[4684]=0;c[4672]=0;c[4679]=n&-16^1431655768;a=4096;}else a=c[4681]|0;i=m+48|0;j=m+47|0;g=a+j|0;f=0-a|0;k=g&f;if(k>>>0<=m>>>0){v=0;Eb=w;return v|0}a=c[4671]|0;if(a|0?(l=c[4669]|0,n=l+k|0,n>>>0<=l>>>0|n>>>0>a>>>0):0){v=0;Eb=w;return v|0}d:do if(!(c[4672]&4)){d=c[4567]|0;e:do if(d){e=18692;while(1){n=c[e>>2]|0;if(n>>>0<=d>>>0?(n+(c[e+4>>2]|0)|0)>>>0>d>>>0:0)break;a=c[e+8>>2]|0;if(!a){q=128;break e}else e=a;}b=g-h&f;if(b>>>0<2147483647){a=dx(b|0)|0;if((a|0)==((c[e>>2]|0)+(c[e+4>>2]|0)|0)){if((a|0)!=(-1|0)){h=b;g=a;q=145;break d}}else{e=a;q=136;}}else b=0;}else q=128;while(0);do if((q|0)==128){d=dx(0)|0;if((d|0)!=(-1|0)?(b=d,o=c[4680]|0,p=o+-1|0,b=((p&b|0)==0?0:(p+b&0-o)-b|0)+k|0,o=c[4669]|0,p=b+o|0,b>>>0>m>>>0&b>>>0<2147483647):0){n=c[4671]|0;if(n|0?p>>>0<=o>>>0|p>>>0>n>>>0:0){b=0;break}a=dx(b|0)|0;if((a|0)==(d|0)){h=b;g=d;q=145;break d}else{e=a;q=136;}}else b=0;}while(0);do if((q|0)==136){d=0-b|0;if(!(i>>>0>b>>>0&(b>>>0<2147483647&(e|0)!=(-1|0))))if((e|0)==(-1|0)){b=0;break}else{h=b;g=e;q=145;break d}a=c[4681]|0;a=j-b+a&0-a;if(a>>>0>=2147483647){h=b;g=e;q=145;break d}if((dx(a|0)|0)==(-1|0)){dx(d|0)|0;b=0;break}else{h=a+b|0;g=e;q=145;break d}}while(0);c[4672]=c[4672]|4;q=143;}else{b=0;q=143;}while(0);if(((q|0)==143?k>>>0<2147483647:0)?(t=dx(k|0)|0,p=dx(0)|0,r=p-t|0,s=r>>>0>(m+40|0)>>>0,!((t|0)==(-1|0)|s^1|t>>>0<p>>>0&((t|0)!=(-1|0)&(p|0)!=(-1|0))^1)):0){h=s?r:b;g=t;q=145;}if((q|0)==145){b=(c[4669]|0)+h|0;c[4669]=b;if(b>>>0>(c[4670]|0)>>>0)c[4670]=b;j=c[4567]|0;f:do if(j){b=18692;while(1){a=c[b>>2]|0;d=c[b+4>>2]|0;if((g|0)==(a+d|0)){q=154;break}e=c[b+8>>2]|0;if(!e)break;else b=e;}if(((q|0)==154?(u=b+4|0,(c[b+12>>2]&8|0)==0):0)?g>>>0>j>>>0&a>>>0<=j>>>0:0){c[u>>2]=d+h;v=(c[4564]|0)+h|0;t=j+8|0;t=(t&7|0)==0?0:0-t&7;u=j+t|0;t=v-t|0;c[4567]=u;c[4564]=t;c[u+4>>2]=t|1;c[j+v+4>>2]=40;c[4568]=c[4683];break}if(g>>>0<(c[4565]|0)>>>0)c[4565]=g;d=g+h|0;b=18692;while(1){if((c[b>>2]|0)==(d|0)){q=162;break}a=c[b+8>>2]|0;if(!a)break;else b=a;}if((q|0)==162?(c[b+12>>2]&8|0)==0:0){c[b>>2]=g;l=b+4|0;c[l>>2]=(c[l>>2]|0)+h;l=g+8|0;l=g+((l&7|0)==0?0:0-l&7)|0;b=d+8|0;b=d+((b&7|0)==0?0:0-b&7)|0;k=l+m|0;i=b-l-m|0;c[l+4>>2]=m|3;g:do if((j|0)==(b|0)){v=(c[4564]|0)+i|0;c[4564]=v;c[4567]=k;c[k+4>>2]=v|1;}else{if((c[4566]|0)==(b|0)){v=(c[4563]|0)+i|0;c[4563]=v;c[4566]=k;c[k+4>>2]=v|1;c[k+v>>2]=v;break}a=c[b+4>>2]|0;if((a&3|0)==1){h=a&-8;e=a>>>3;h:do if(a>>>0<256){a=c[b+8>>2]|0;d=c[b+12>>2]|0;if((d|0)==(a|0)){c[4561]=c[4561]&~(1<<e);break}else{c[a+12>>2]=d;c[d+8>>2]=a;break}}else{g=c[b+24>>2]|0;a=c[b+12>>2]|0;do if((a|0)==(b|0)){d=b+16|0;e=d+4|0;a=c[e>>2]|0;if(!a){a=c[d>>2]|0;if(!a){a=0;break}}else d=e;while(1){f=a+20|0;e=c[f>>2]|0;if(!e){f=a+16|0;e=c[f>>2]|0;if(!e)break;else{a=e;d=f;}}else{a=e;d=f;}}c[d>>2]=0;}else{v=c[b+8>>2]|0;c[v+12>>2]=a;c[a+8>>2]=v;}while(0);if(!g)break;d=c[b+28>>2]|0;e=18548+(d<<2)|0;do if((c[e>>2]|0)!=(b|0)){v=g+16|0;c[((c[v>>2]|0)==(b|0)?v:g+20|0)>>2]=a;if(!a)break h}else{c[e>>2]=a;if(a|0)break;c[4562]=c[4562]&~(1<<d);break h}while(0);c[a+24>>2]=g;d=b+16|0;e=c[d>>2]|0;if(e|0){c[a+16>>2]=e;c[e+24>>2]=a;}d=c[d+4>>2]|0;if(!d)break;c[a+20>>2]=d;c[d+24>>2]=a;}while(0);b=b+h|0;f=h+i|0;}else f=i;b=b+4|0;c[b>>2]=c[b>>2]&-2;c[k+4>>2]=f|1;c[k+f>>2]=f;b=f>>>3;if(f>>>0<256){d=18284+(b<<1<<2)|0;a=c[4561]|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else{a=d+8|0;b=c[a>>2]|0;}c[a>>2]=k;c[b+12>>2]=k;c[k+8>>2]=b;c[k+12>>2]=d;break}b=f>>>8;do if(!b)e=0;else{if(f>>>0>16777215){e=31;break}u=(b+1048320|0)>>>16&8;v=b<<u;t=(v+520192|0)>>>16&4;v=v<<t;e=(v+245760|0)>>>16&2;e=14-(t|u|e)+(v<<e>>>15)|0;e=f>>>(e+7|0)&1|e<<1;}while(0);b=18548+(e<<2)|0;c[k+28>>2]=e;a=k+16|0;c[a+4>>2]=0;c[a>>2]=0;a=c[4562]|0;d=1<<e;if(!(a&d)){c[4562]=a|d;c[b>>2]=k;c[k+24>>2]=b;c[k+12>>2]=k;c[k+8>>2]=k;break}b=c[b>>2]|0;i:do if((c[b+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(f|0)){b=a;break i}else{e=e<<1;b=a;}}c[d>>2]=k;c[k+24>>2]=b;c[k+12>>2]=k;c[k+8>>2]=k;break g}while(0);u=b+8|0;v=c[u>>2]|0;c[v+12>>2]=k;c[u>>2]=k;c[k+8>>2]=v;c[k+12>>2]=b;c[k+24>>2]=0;}while(0);v=l+8|0;Eb=w;return v|0}b=18692;while(1){a=c[b>>2]|0;if(a>>>0<=j>>>0?(v=a+(c[b+4>>2]|0)|0,v>>>0>j>>>0):0)break;b=c[b+8>>2]|0;}f=v+-47|0;a=f+8|0;a=f+((a&7|0)==0?0:0-a&7)|0;f=j+16|0;a=a>>>0<f>>>0?j:a;b=a+8|0;d=h+-40|0;t=g+8|0;t=(t&7|0)==0?0:0-t&7;u=g+t|0;t=d-t|0;c[4567]=u;c[4564]=t;c[u+4>>2]=t|1;c[g+d+4>>2]=40;c[4568]=c[4683];d=a+4|0;c[d>>2]=27;c[b>>2]=c[4673];c[b+4>>2]=c[4674];c[b+8>>2]=c[4675];c[b+12>>2]=c[4676];c[4673]=g;c[4674]=h;c[4676]=0;c[4675]=b;b=a+24|0;do{u=b;b=b+4|0;c[b>>2]=7;}while((u+8|0)>>>0<v>>>0);if((a|0)!=(j|0)){g=a-j|0;c[d>>2]=c[d>>2]&-2;c[j+4>>2]=g|1;c[a>>2]=g;b=g>>>3;if(g>>>0<256){d=18284+(b<<1<<2)|0;a=c[4561]|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else{a=d+8|0;b=c[a>>2]|0;}c[a>>2]=j;c[b+12>>2]=j;c[j+8>>2]=b;c[j+12>>2]=d;break}b=g>>>8;if(b)if(g>>>0>16777215)e=31;else{u=(b+1048320|0)>>>16&8;v=b<<u;t=(v+520192|0)>>>16&4;v=v<<t;e=(v+245760|0)>>>16&2;e=14-(t|u|e)+(v<<e>>>15)|0;e=g>>>(e+7|0)&1|e<<1;}else e=0;d=18548+(e<<2)|0;c[j+28>>2]=e;c[j+20>>2]=0;c[f>>2]=0;b=c[4562]|0;a=1<<e;if(!(b&a)){c[4562]=b|a;c[d>>2]=j;c[j+24>>2]=d;c[j+12>>2]=j;c[j+8>>2]=j;break}b=c[d>>2]|0;j:do if((c[b+4>>2]&-8|0)!=(g|0)){e=g<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(g|0)){b=a;break j}else{e=e<<1;b=a;}}c[d>>2]=j;c[j+24>>2]=b;c[j+12>>2]=j;c[j+8>>2]=j;break f}while(0);u=b+8|0;v=c[u>>2]|0;c[v+12>>2]=j;c[u>>2]=j;c[j+8>>2]=v;c[j+12>>2]=b;c[j+24>>2]=0;}}else{v=c[4565]|0;if((v|0)==0|g>>>0<v>>>0)c[4565]=g;c[4673]=g;c[4674]=h;c[4676]=0;c[4570]=c[4679];c[4569]=-1;c[4574]=18284;c[4573]=18284;c[4576]=18292;c[4575]=18292;c[4578]=18300;c[4577]=18300;c[4580]=18308;c[4579]=18308;c[4582]=18316;c[4581]=18316;c[4584]=18324;c[4583]=18324;c[4586]=18332;c[4585]=18332;c[4588]=18340;c[4587]=18340;c[4590]=18348;c[4589]=18348;c[4592]=18356;c[4591]=18356;c[4594]=18364;c[4593]=18364;c[4596]=18372;c[4595]=18372;c[4598]=18380;c[4597]=18380;c[4600]=18388;c[4599]=18388;c[4602]=18396;c[4601]=18396;c[4604]=18404;c[4603]=18404;c[4606]=18412;c[4605]=18412;c[4608]=18420;c[4607]=18420;c[4610]=18428;c[4609]=18428;c[4612]=18436;c[4611]=18436;c[4614]=18444;c[4613]=18444;c[4616]=18452;c[4615]=18452;c[4618]=18460;c[4617]=18460;c[4620]=18468;c[4619]=18468;c[4622]=18476;c[4621]=18476;c[4624]=18484;c[4623]=18484;c[4626]=18492;c[4625]=18492;c[4628]=18500;c[4627]=18500;c[4630]=18508;c[4629]=18508;c[4632]=18516;c[4631]=18516;c[4634]=18524;c[4633]=18524;c[4636]=18532;c[4635]=18532;v=h+-40|0;t=g+8|0;t=(t&7|0)==0?0:0-t&7;u=g+t|0;t=v-t|0;c[4567]=u;c[4564]=t;c[u+4>>2]=t|1;c[g+v+4>>2]=40;c[4568]=c[4683];}while(0);b=c[4564]|0;if(b>>>0>m>>>0){t=b-m|0;c[4564]=t;v=c[4567]|0;u=v+m|0;c[4567]=u;c[u+4>>2]=t|1;c[v+4>>2]=m|3;v=v+8|0;Eb=w;return v|0}}v=xh()|0;c[v>>2]=12;v=0;Eb=w;return v|0}function ik(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;if(!a)return;d=a+-8|0;f=c[4565]|0;a=c[a+-4>>2]|0;b=a&-8;j=d+b|0;do if(!(a&1)){e=c[d>>2]|0;if(!(a&3))return;h=d+(0-e)|0;g=e+b|0;if(h>>>0<f>>>0)return;if((c[4566]|0)==(h|0)){a=j+4|0;b=c[a>>2]|0;if((b&3|0)!=3){i=h;b=g;break}c[4563]=g;c[a>>2]=b&-2;c[h+4>>2]=g|1;c[h+g>>2]=g;return}d=e>>>3;if(e>>>0<256){a=c[h+8>>2]|0;b=c[h+12>>2]|0;if((b|0)==(a|0)){c[4561]=c[4561]&~(1<<d);i=h;b=g;break}else{c[a+12>>2]=b;c[b+8>>2]=a;i=h;b=g;break}}f=c[h+24>>2]|0;a=c[h+12>>2]|0;do if((a|0)==(h|0)){b=h+16|0;d=b+4|0;a=c[d>>2]|0;if(!a){a=c[b>>2]|0;if(!a){a=0;break}}else b=d;while(1){e=a+20|0;d=c[e>>2]|0;if(!d){e=a+16|0;d=c[e>>2]|0;if(!d)break;else{a=d;b=e;}}else{a=d;b=e;}}c[b>>2]=0;}else{i=c[h+8>>2]|0;c[i+12>>2]=a;c[a+8>>2]=i;}while(0);if(f){b=c[h+28>>2]|0;d=18548+(b<<2)|0;if((c[d>>2]|0)==(h|0)){c[d>>2]=a;if(!a){c[4562]=c[4562]&~(1<<b);i=h;b=g;break}}else{i=f+16|0;c[((c[i>>2]|0)==(h|0)?i:f+20|0)>>2]=a;if(!a){i=h;b=g;break}}c[a+24>>2]=f;b=h+16|0;d=c[b>>2]|0;if(d|0){c[a+16>>2]=d;c[d+24>>2]=a;}b=c[b+4>>2]|0;if(b){c[a+20>>2]=b;c[b+24>>2]=a;i=h;b=g;}else{i=h;b=g;}}else{i=h;b=g;}}else{i=d;h=d;}while(0);if(h>>>0>=j>>>0)return;a=j+4|0;e=c[a>>2]|0;if(!(e&1))return;if(!(e&2)){if((c[4567]|0)==(j|0)){j=(c[4564]|0)+b|0;c[4564]=j;c[4567]=i;c[i+4>>2]=j|1;if((i|0)!=(c[4566]|0))return;c[4566]=0;c[4563]=0;return}if((c[4566]|0)==(j|0)){j=(c[4563]|0)+b|0;c[4563]=j;c[4566]=h;c[i+4>>2]=j|1;c[h+j>>2]=j;return}f=(e&-8)+b|0;d=e>>>3;do if(e>>>0<256){b=c[j+8>>2]|0;a=c[j+12>>2]|0;if((a|0)==(b|0)){c[4561]=c[4561]&~(1<<d);break}else{c[b+12>>2]=a;c[a+8>>2]=b;break}}else{g=c[j+24>>2]|0;a=c[j+12>>2]|0;do if((a|0)==(j|0)){b=j+16|0;d=b+4|0;a=c[d>>2]|0;if(!a){a=c[b>>2]|0;if(!a){d=0;break}}else b=d;while(1){e=a+20|0;d=c[e>>2]|0;if(!d){e=a+16|0;d=c[e>>2]|0;if(!d)break;else{a=d;b=e;}}else{a=d;b=e;}}c[b>>2]=0;d=a;}else{d=c[j+8>>2]|0;c[d+12>>2]=a;c[a+8>>2]=d;d=a;}while(0);if(g|0){a=c[j+28>>2]|0;b=18548+(a<<2)|0;if((c[b>>2]|0)==(j|0)){c[b>>2]=d;if(!d){c[4562]=c[4562]&~(1<<a);break}}else{e=g+16|0;c[((c[e>>2]|0)==(j|0)?e:g+20|0)>>2]=d;if(!d)break}c[d+24>>2]=g;a=j+16|0;b=c[a>>2]|0;if(b|0){c[d+16>>2]=b;c[b+24>>2]=d;}a=c[a+4>>2]|0;if(a|0){c[d+20>>2]=a;c[a+24>>2]=d;}}}while(0);c[i+4>>2]=f|1;c[h+f>>2]=f;if((i|0)==(c[4566]|0)){c[4563]=f;return}}else{c[a>>2]=e&-2;c[i+4>>2]=b|1;c[h+b>>2]=b;f=b;}a=f>>>3;if(f>>>0<256){d=18284+(a<<1<<2)|0;b=c[4561]|0;a=1<<a;if(!(b&a)){c[4561]=b|a;a=d;b=d+8|0;}else{b=d+8|0;a=c[b>>2]|0;}c[b>>2]=i;c[a+12>>2]=i;c[i+8>>2]=a;c[i+12>>2]=d;return}a=f>>>8;if(a)if(f>>>0>16777215)e=31;else{h=(a+1048320|0)>>>16&8;j=a<<h;g=(j+520192|0)>>>16&4;j=j<<g;e=(j+245760|0)>>>16&2;e=14-(g|h|e)+(j<<e>>>15)|0;e=f>>>(e+7|0)&1|e<<1;}else e=0;a=18548+(e<<2)|0;c[i+28>>2]=e;c[i+20>>2]=0;c[i+16>>2]=0;b=c[4562]|0;d=1<<e;a:do if(!(b&d)){c[4562]=b|d;c[a>>2]=i;c[i+24>>2]=a;c[i+12>>2]=i;c[i+8>>2]=i;}else{a=c[a>>2]|0;b:do if((c[a+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=a+16+(e>>>31<<2)|0;b=c[d>>2]|0;if(!b)break;if((c[b+4>>2]&-8|0)==(f|0)){a=b;break b}else{e=e<<1;a=b;}}c[d>>2]=i;c[i+24>>2]=a;c[i+12>>2]=i;c[i+8>>2]=i;break a}while(0);h=a+8|0;j=c[h>>2]|0;c[j+12>>2]=i;c[h>>2]=i;c[i+8>>2]=j;c[i+12>>2]=a;c[i+24>>2]=0;}while(0);j=(c[4569]|0)+-1|0;c[4569]=j;if(j|0)return;a=18700;while(1){a=c[a>>2]|0;if(!a)break;else a=a+8|0;}c[4569]=-1;return}function jk(a,b){a=a|0;b=b|0;var d=0,e=0;if(!a){b=hk(b)|0;return b|0}if(b>>>0>4294967231){b=xh()|0;c[b>>2]=12;b=0;return b|0}d=kk(a+-8|0,b>>>0<11?16:b+11&-8)|0;if(d|0){b=d+8|0;return b|0}d=hk(b)|0;if(!d){b=0;return b|0}e=c[a+-4>>2]|0;e=(e&-8)-((e&3|0)==0?8:4)|0;ax(d|0,a|0,(e>>>0<b>>>0?e:b)|0)|0;ik(a);b=d;return b|0}function kk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;l=a+4|0;m=c[l>>2]|0;d=m&-8;i=a+d|0;if(!(m&3)){if(b>>>0<256){a=0;return a|0}if(d>>>0>=(b+4|0)>>>0?(d-b|0)>>>0<=c[4681]<<1>>>0:0)return a|0;a=0;return a|0}if(d>>>0>=b>>>0){d=d-b|0;if(d>>>0<=15)return a|0;k=a+b|0;c[l>>2]=m&1|b|2;c[k+4>>2]=d|3;m=i+4|0;c[m>>2]=c[m>>2]|1;lk(k,d);return a|0}if((c[4567]|0)==(i|0)){k=(c[4564]|0)+d|0;d=k-b|0;e=a+b|0;if(k>>>0<=b>>>0){a=0;return a|0}c[l>>2]=m&1|b|2;c[e+4>>2]=d|1;c[4567]=e;c[4564]=d;return a|0}if((c[4566]|0)==(i|0)){e=(c[4563]|0)+d|0;if(e>>>0<b>>>0){a=0;return a|0}d=e-b|0;if(d>>>0>15){k=a+b|0;e=a+e|0;c[l>>2]=m&1|b|2;c[k+4>>2]=d|1;c[e>>2]=d;e=e+4|0;c[e>>2]=c[e>>2]&-2;e=k;}else{c[l>>2]=m&1|e|2;e=a+e+4|0;c[e>>2]=c[e>>2]|1;e=0;d=0;}c[4563]=d;c[4566]=e;return a|0}e=c[i+4>>2]|0;if(e&2|0){a=0;return a|0}j=(e&-8)+d|0;if(j>>>0<b>>>0){a=0;return a|0}k=j-b|0;f=e>>>3;do if(e>>>0<256){e=c[i+8>>2]|0;d=c[i+12>>2]|0;if((d|0)==(e|0)){c[4561]=c[4561]&~(1<<f);break}else{c[e+12>>2]=d;c[d+8>>2]=e;break}}else{h=c[i+24>>2]|0;d=c[i+12>>2]|0;do if((d|0)==(i|0)){e=i+16|0;f=e+4|0;d=c[f>>2]|0;if(!d){d=c[e>>2]|0;if(!d){f=0;break}}else e=f;while(1){g=d+20|0;f=c[g>>2]|0;if(!f){g=d+16|0;f=c[g>>2]|0;if(!f)break;else{d=f;e=g;}}else{d=f;e=g;}}c[e>>2]=0;f=d;}else{f=c[i+8>>2]|0;c[f+12>>2]=d;c[d+8>>2]=f;f=d;}while(0);if(h|0){d=c[i+28>>2]|0;e=18548+(d<<2)|0;if((c[e>>2]|0)==(i|0)){c[e>>2]=f;if(!f){c[4562]=c[4562]&~(1<<d);break}}else{g=h+16|0;c[((c[g>>2]|0)==(i|0)?g:h+20|0)>>2]=f;if(!f)break}c[f+24>>2]=h;d=i+16|0;e=c[d>>2]|0;if(e|0){c[f+16>>2]=e;c[e+24>>2]=f;}d=c[d+4>>2]|0;if(d|0){c[f+20>>2]=d;c[d+24>>2]=f;}}}while(0);if(k>>>0<16){c[l>>2]=m&1|j|2;m=a+j+4|0;c[m>>2]=c[m>>2]|1;return a|0}else{i=a+b|0;c[l>>2]=m&1|b|2;c[i+4>>2]=k|3;m=a+j+4|0;c[m>>2]=c[m>>2]|1;lk(i,k);return a|0}}function lk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=a+b|0;d=c[a+4>>2]|0;do if(!(d&1)){f=c[a>>2]|0;if(!(d&3))return;h=a+(0-f)|0;b=f+b|0;if((c[4566]|0)==(h|0)){a=i+4|0;d=c[a>>2]|0;if((d&3|0)!=3)break;c[4563]=b;c[a>>2]=d&-2;c[h+4>>2]=b|1;c[i>>2]=b;return}e=f>>>3;if(f>>>0<256){a=c[h+8>>2]|0;d=c[h+12>>2]|0;if((d|0)==(a|0)){c[4561]=c[4561]&~(1<<e);break}else{c[a+12>>2]=d;c[d+8>>2]=a;break}}g=c[h+24>>2]|0;a=c[h+12>>2]|0;do if((a|0)==(h|0)){d=h+16|0;e=d+4|0;a=c[e>>2]|0;if(!a){a=c[d>>2]|0;if(!a){a=0;break}}else d=e;while(1){f=a+20|0;e=c[f>>2]|0;if(!e){f=a+16|0;e=c[f>>2]|0;if(!e)break;else{a=e;d=f;}}else{a=e;d=f;}}c[d>>2]=0;}else{f=c[h+8>>2]|0;c[f+12>>2]=a;c[a+8>>2]=f;}while(0);if(g){d=c[h+28>>2]|0;e=18548+(d<<2)|0;if((c[e>>2]|0)==(h|0)){c[e>>2]=a;if(!a){c[4562]=c[4562]&~(1<<d);break}}else{f=g+16|0;c[((c[f>>2]|0)==(h|0)?f:g+20|0)>>2]=a;if(!a)break}c[a+24>>2]=g;d=h+16|0;e=c[d>>2]|0;if(e|0){c[a+16>>2]=e;c[e+24>>2]=a;}d=c[d+4>>2]|0;if(d){c[a+20>>2]=d;c[d+24>>2]=a;}}}else h=a;while(0);a=i+4|0;e=c[a>>2]|0;if(!(e&2)){if((c[4567]|0)==(i|0)){i=(c[4564]|0)+b|0;c[4564]=i;c[4567]=h;c[h+4>>2]=i|1;if((h|0)!=(c[4566]|0))return;c[4566]=0;c[4563]=0;return}if((c[4566]|0)==(i|0)){i=(c[4563]|0)+b|0;c[4563]=i;c[4566]=h;c[h+4>>2]=i|1;c[h+i>>2]=i;return}f=(e&-8)+b|0;d=e>>>3;do if(e>>>0<256){a=c[i+8>>2]|0;b=c[i+12>>2]|0;if((b|0)==(a|0)){c[4561]=c[4561]&~(1<<d);break}else{c[a+12>>2]=b;c[b+8>>2]=a;break}}else{g=c[i+24>>2]|0;b=c[i+12>>2]|0;do if((b|0)==(i|0)){a=i+16|0;d=a+4|0;b=c[d>>2]|0;if(!b){b=c[a>>2]|0;if(!b){d=0;break}}else a=d;while(1){e=b+20|0;d=c[e>>2]|0;if(!d){e=b+16|0;d=c[e>>2]|0;if(!d)break;else{b=d;a=e;}}else{b=d;a=e;}}c[a>>2]=0;d=b;}else{d=c[i+8>>2]|0;c[d+12>>2]=b;c[b+8>>2]=d;d=b;}while(0);if(g|0){b=c[i+28>>2]|0;a=18548+(b<<2)|0;if((c[a>>2]|0)==(i|0)){c[a>>2]=d;if(!d){c[4562]=c[4562]&~(1<<b);break}}else{e=g+16|0;c[((c[e>>2]|0)==(i|0)?e:g+20|0)>>2]=d;if(!d)break}c[d+24>>2]=g;b=i+16|0;a=c[b>>2]|0;if(a|0){c[d+16>>2]=a;c[a+24>>2]=d;}b=c[b+4>>2]|0;if(b|0){c[d+20>>2]=b;c[b+24>>2]=d;}}}while(0);c[h+4>>2]=f|1;c[h+f>>2]=f;if((h|0)==(c[4566]|0)){c[4563]=f;return}}else{c[a>>2]=e&-2;c[h+4>>2]=b|1;c[h+b>>2]=b;f=b;}b=f>>>3;if(f>>>0<256){d=18284+(b<<1<<2)|0;a=c[4561]|0;b=1<<b;if(!(a&b)){c[4561]=a|b;b=d;a=d+8|0;}else{a=d+8|0;b=c[a>>2]|0;}c[a>>2]=h;c[b+12>>2]=h;c[h+8>>2]=b;c[h+12>>2]=d;return}b=f>>>8;if(b)if(f>>>0>16777215)e=31;else{g=(b+1048320|0)>>>16&8;i=b<<g;d=(i+520192|0)>>>16&4;i=i<<d;e=(i+245760|0)>>>16&2;e=14-(d|g|e)+(i<<e>>>15)|0;e=f>>>(e+7|0)&1|e<<1;}else e=0;b=18548+(e<<2)|0;c[h+28>>2]=e;c[h+20>>2]=0;c[h+16>>2]=0;a=c[4562]|0;d=1<<e;if(!(a&d)){c[4562]=a|d;c[b>>2]=h;c[h+24>>2]=b;c[h+12>>2]=h;c[h+8>>2]=h;return}b=c[b>>2]|0;a:do if((c[b+4>>2]&-8|0)!=(f|0)){e=f<<((e|0)==31?0:25-(e>>>1)|0);while(1){d=b+16+(e>>>31<<2)|0;a=c[d>>2]|0;if(!a)break;if((c[a+4>>2]&-8|0)==(f|0)){b=a;break a}else{e=e<<1;b=a;}}c[d>>2]=h;c[h+24>>2]=b;c[h+12>>2]=h;c[h+8>>2]=h;return}while(0);g=b+8|0;i=c[g>>2]|0;c[i+12>>2]=h;c[g>>2]=h;c[h+8>>2]=i;c[h+12>>2]=b;c[h+24>>2]=0;return}function mk(){var a=0,b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;f=Eb;Eb=Eb+1072|0;j=f+1056|0;b=f+1048|0;k=f+1040|0;i=f+1024|0;h=f+1068|0;g=f+1064|0;e=f;f=f+1060|0;a=nk()|0;if(a|0?(d=c[a>>2]|0,d|0):0){a=d+48|0;if(!(ok(a)|0)){c[b>>2]=11846;rk(11796,b);}b=pk(a)|0;if((b|0)==1126902529&(F()|0)==1129074247)a=c[d+44>>2]|0;else a=d+80|0;c[h>>2]=a;d=c[d>>2]|0;c[f>>2]=1024;b=d+4|0;a=qk(c[b>>2]|0,e,f,g)|0;if(c[g>>2]|0)a=c[b>>2]|0;if(Pb[c[(c[526]|0)+16>>2]&15](2104,d,h)|0){k=c[h>>2]|0;k=Lb[c[(c[k>>2]|0)+8>>2]&63](k)|0;c[i>>2]=11846;c[i+4>>2]=a;c[i+8>>2]=k;rk(11710,i);}else{c[k>>2]=11846;c[k+4>>2]=a;rk(11755,k);}}rk(11834,j);}function nk(){return 18740}function ok(a){a=a|0;a=pk(a)|0;return (a&-256|0)==1126902528&(F()|0)==1129074247|0}function pk(a){a=a|0;var b=0;b=a;a=c[b>>2]|0;E(c[b+4>>2]|0);return a|0}function qk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+4496|0;h=i;f=i+4472|0;if((a|0)!=0?(g=(d|0)==0,!((b|0)!=0&g)):0){Kk(h,a,a+(ai(a)|0)|0);Lk(f);a=Mk(h)|0;if(a)if(Ok(b,d,f)|0){Pk(a,f);Qk(f,0);if(!g){g=Rk(f)|0;c[d>>2]=g;}b=Sk(f)|0;a=0;}else a=-1;else a=-2;if(e|0)c[e>>2]=a;Nk(h);b=(a|0)==0?b:0;}else if(!e)b=0;else{c[e>>2]=-3;b=0;}Eb=i;return b|0}function rk(a,b){a=a|0;b=b|0;var d=0;d=Eb;Eb=Eb+16|0;c[d>>2]=b;b=c[995]|0;Dh(b,a,d)|0;ei(10,b)|0;va();}function sk(a){return}function tk(a){a=a|0;$j(a);return}function uk(a){return}function vk(a){return}function wk(d,e,f){d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+64|0;j=l;if(!(Ak(d,e,0)|0))if((e|0)!=0?(k=Ek(e,2128,2112,0)|0,(k|0)!=0):0){c[j>>2]=k;c[j+4>>2]=0;c[j+8>>2]=d;c[j+12>>2]=-1;d=j+16|0;e=j+24|0;g=j+48|0;h=d;i=h+36|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));b[d+36>>1]=0;a[d+38>>0]=0;c[g>>2]=1;$b[c[(c[k>>2]|0)+28>>2]&15](k,j,c[f>>2]|0,1);if((c[e>>2]|0)==1){c[f>>2]=c[d>>2];d=1;}else d=0;}else d=0;else d=1;Eb=l;return d|0}function xk(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;if(Ak(a,c[b+8>>2]|0,g)|0)Dk(0,b,d,e,f);return}function yk(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;do if(!(Ak(b,c[d+8>>2]|0,g)|0)){if(Ak(b,c[d>>2]|0,g)|0){if((c[d+16>>2]|0)!=(e|0)?(h=d+20|0,(c[h>>2]|0)!=(e|0)):0){c[d+32>>2]=f;c[h>>2]=e;g=d+40|0;c[g>>2]=(c[g>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0)a[d+54>>0]=1;c[d+44>>2]=4;break}if((f|0)==1)c[d+32>>2]=1;}}else Ck(0,d,e,f);while(0);return}function zk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;if(Ak(a,c[b+8>>2]|0,0)|0)Bk(0,b,d,e);return}function Ak(a,b,d){a=a|0;b=b|0;d=d|0;if(d)a=(Ah(c[a+4>>2]|0,c[b+4>>2]|0)|0)==0;else a=(a|0)==(b|0);return a|0}function Bk(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0;b=d+16|0;g=c[b>>2]|0;do if(g){if((g|0)!=(e|0)){f=d+36|0;c[f>>2]=(c[f>>2]|0)+1;c[d+24>>2]=2;a[d+54>>0]=1;break}b=d+24|0;if((c[b>>2]|0)==2)c[b>>2]=f;}else{c[b>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;}while(0);return}function Ck(a,b,d,e){b=b|0;d=d|0;e=e|0;var f=0;if((c[b+4>>2]|0)==(d|0)?(f=b+28|0,(c[f>>2]|0)!=1):0)c[f>>2]=e;return}function Dk(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;a[d+53>>0]=1;do if((c[d+4>>2]|0)==(f|0)){a[d+52>>0]=1;b=d+16|0;f=c[b>>2]|0;if(!f){c[b>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((g|0)==1?(c[d+48>>2]|0)==1:0))break;a[d+54>>0]=1;break}if((f|0)!=(e|0)){g=d+36|0;c[g>>2]=(c[g>>2]|0)+1;a[d+54>>0]=1;break}f=d+24|0;b=c[f>>2]|0;if((b|0)==2){c[f>>2]=g;b=g;}if((b|0)==1?(c[d+48>>2]|0)==1:0)a[d+54>>0]=1;}while(0);return}function Ek(d,e,f,g){d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;p=Eb;Eb=Eb+64|0;n=p;m=c[d>>2]|0;o=d+(c[m+-8>>2]|0)|0;m=c[m+-4>>2]|0;c[n>>2]=f;c[n+4>>2]=d;c[n+8>>2]=e;c[n+12>>2]=g;d=n+16|0;e=n+20|0;g=n+24|0;h=n+28|0;i=n+32|0;j=n+40|0;k=d;l=k+36|0;do{c[k>>2]=0;k=k+4|0;}while((k|0)<(l|0));b[d+36>>1]=0;a[d+38>>0]=0;a:do if(Ak(m,f,0)|0){c[n+48>>2]=1;bc[c[(c[m>>2]|0)+20>>2]&3](m,n,o,o,1,0);d=(c[g>>2]|0)==1?o:0;}else{ac[c[(c[m>>2]|0)+24>>2]&7](m,n,o,1,0);switch(c[n+36>>2]|0){case 0:{d=(c[j>>2]|0)==1&(c[h>>2]|0)==1&(c[i>>2]|0)==1?c[e>>2]|0:0;break a}case 1:break;default:{d=0;break a}}if((c[g>>2]|0)!=1?!((c[j>>2]|0)==0&(c[h>>2]|0)==1&(c[i>>2]|0)==1):0){d=0;break}d=c[d>>2]|0;}while(0);Eb=p;return d|0}function Fk(a){a=a|0;$j(a);return}function Gk(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;if(Ak(a,c[b+8>>2]|0,g)|0)Dk(0,b,d,e,f);else{a=c[a+8>>2]|0;bc[c[(c[a>>2]|0)+20>>2]&3](a,b,d,e,f,g);}return}function Hk(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0;a:do if(!(Ak(b,c[d+8>>2]|0,g)|0)){if(!(Ak(b,c[d>>2]|0,g)|0)){i=c[b+8>>2]|0;ac[c[(c[i>>2]|0)+24>>2]&7](i,d,e,f,g);break}if((c[d+16>>2]|0)!=(e|0)?(i=d+20|0,(c[i>>2]|0)!=(e|0)):0){c[d+32>>2]=f;f=d+44|0;do if((c[f>>2]|0)!=4){h=d+52|0;a[h>>0]=0;j=d+53|0;a[j>>0]=0;b=c[b+8>>2]|0;bc[c[(c[b>>2]|0)+20>>2]&3](b,d,e,e,1,g);if(a[j>>0]|0){j=(a[h>>0]|0)==0;c[f>>2]=3;if(j)break;else break a}else{c[f>>2]=4;break}}while(0);c[i>>2]=e;j=d+40|0;c[j>>2]=(c[j>>2]|0)+1;if((c[d+36>>2]|0)!=1)break;if((c[d+24>>2]|0)!=2)break;a[d+54>>0]=1;break}if((f|0)==1)c[d+32>>2]=1;}else Ck(0,d,e,f);while(0);return}function Ik(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;if(Ak(a,c[b+8>>2]|0,0)|0)Bk(0,b,d,e);else{a=c[a+8>>2]|0;$b[c[(c[a>>2]|0)+28>>2]&15](a,b,d,e);}return}function Kk(a,b,c){a=a|0;b=b|0;c=c|0;nw(a,b,c);return}function Lk(a){a=a|0;c[a+12>>2]=-1;c[a+16>>2]=-1;return}function Mk(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+48|0;e=g+32|0;h=g+24|0;f=g;b=g+16|0;d=g+8|0;fl(h,12025);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];do if(gl(a,e)|0){b=il(hl(a)|0)|0;c[e>>2]=b;if(!b)b=0;else{if((jl(a,0)|0)<<24>>24==46){h=a+4|0;kl(f,c[a>>2]|0,c[h>>2]|0);b=ll(a,e,f)|0;c[e>>2]=b;c[a>>2]=c[h>>2];}h=(ml(a)|0)==0;b=h?b:0;}}else{fl(b,12028);c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];if(!(gl(a,e)|0)){b=rl(hl(a)|0)|0;h=(ml(a)|0)==0;b=h?b:0;break}h=il(hl(a)|0)|0;c[f>>2]=h;if(((h|0)!=0?(fl(d,12033),c[e>>2]=c[d>>2],c[e+4>>2]=c[d+4>>2],gl(a,e)|0):0)?(h=nl(a,95)|0,ol(e,a,0),!(h&(pl(e)|0))):0){if((jl(a,0)|0)<<24>>24==46)c[a>>2]=c[a+4>>2];if(!(ml(a)|0))b=ql(a,12047,f)|0;else b=0;}else b=0;}while(0);Eb=g;return b|0}function Nk(a){a=a|0;Yk(a+368|0);Zk(a+332|0);_k(a+288|0);$k(a+148|0);$k(a+8|0);return}function Ok(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;if(!a){a=hk(1024)|0;if(!a)a=0;else{b=1024;e=4;}}else{b=c[b>>2]|0;e=4;}if((e|0)==4){Xk(d,a,b);a=1;}return a|0}function Pk(b,d){b=b|0;d=d|0;Xb[c[(c[b>>2]|0)+16>>2]&127](b,d);if((a[b+5>>0]|0)!=1)Xb[c[(c[b>>2]|0)+20>>2]&127](b,d);return}function Qk(b,d){b=b|0;d=d|0;var e=0,f=0;Tk(b,1);e=c[b>>2]|0;f=b+4|0;b=c[f>>2]|0;c[f>>2]=b+1;a[e+b>>0]=d;return}function Rk(a){a=a|0;return c[a+4>>2]|0}function Sk(a){a=a|0;return c[a>>2]|0}function Tk(a,b){a=a|0;b=b|0;var d=0,e=0;b=(c[a+4>>2]|0)+b|0;d=a+8|0;e=c[d>>2]|0;if(b>>>0>=e>>>0?(e=e<<1,e=e>>>0<b>>>0?b:e,c[d>>2]=e,e=jk(c[a>>2]|0,e)|0,c[a>>2]=e,(e|0)==0):0)Uk();return}function Uk(){var a=0,b=0;a=nk()|0;if((a|0?(b=c[a>>2]|0,b|0):0)?ok(b+48|0)|0:0)Vk(c[b+12>>2]|0);Vk(Wk()|0);}function Vk(a){a=a|0;var b=0;b=Eb;Eb=Eb+16|0;Tb[a&3]();rk(11985,b);}function Wk(){return 2}function Xk(a,b,d){a=a|0;b=b|0;d=d|0;c[a+4>>2]=0;c[a>>2]=b;c[a+8>>2]=d;return}function Yk(a){a=a|0;dl(a);return}function Zk(a){a=a|0;if(!(cl(a)|0))ik(c[a>>2]|0);return}function _k(a){a=a|0;if(!(bl(a)|0))ik(c[a>>2]|0);return}function $k(a){a=a|0;if(!(al(a)|0))ik(c[a>>2]|0);return}function al(a){a=a|0;return (c[a>>2]|0)==(a+12|0)|0}function bl(a){a=a|0;return (c[a>>2]|0)==(a+12|0)|0}function cl(a){a=a|0;return (c[a>>2]|0)==(a+12|0)|0}function dl(a){a=a|0;el(a);return}function el(a){a=a|0;var b=0,d=0;b=a+4096|0;while(1){d=c[b>>2]|0;if(!d)break;c[b>>2]=c[d>>2];if((a|0)!=(d|0))ik(d);}c[a>>2]=0;c[a+4>>2]=0;c[b>>2]=a;return}function fl(a,b){a=a|0;b=b|0;c[a>>2]=b;b=b+(ai(b)|0)|0;c[a+4>>2]=b;return}function gl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=Eb;Eb=Eb+32|0;e=d+16|0;f=d+8|0;g=d;kl(f,c[a>>2]|0,c[a+4>>2]|0);j=b;i=c[j+4>>2]|0;h=g;c[h>>2]=c[j>>2];c[h+4>>2]=i;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];if(Aq(f,e)|0){j=vm(b)|0;c[a>>2]=(c[a>>2]|0)+j;a=1;}else a=0;Eb=d;return a|0}function hl(a){a=a|0;return a|0}function il(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;n=Eb;Eb=Eb+64|0;g=n+48|0;h=n+40|0;j=n+24|0;k=n+20|0;l=n+16|0;e=n+8|0;m=n;switch((jl(b,0)|0)<<24>>24){case 84:case 71:{d=vv(hl(b)|0)|0;break}default:{c[h>>2]=b;wv(j,b);i=hl(b)|0;d=zs(i,j)|0;c[k>>2]=d;if((d|0)!=0?!(xv(b,j)|0):0){if(!(yv(h)|0)){c[l>>2]=0;fl(e,17380);c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];do if(gl(b,g)|0){d=b+8|0;e=Zl(d)|0;while(1){if(nl(b,69)|0){f=11;break}f=nn(i)|0;c[g>>2]=f;if(!f){f=12;break}Yl(d,g);}if((f|0)==11){sn(g,b,e);e=zv(b,g)|0;c[l>>2]=e;f=13;break}else if((f|0)==12){d=0;break}}else f=13;while(0);if((f|0)==13){c[g>>2]=0;if(((a[j>>0]|0)==0?(a[j+1>>0]|0)!=0:0)?(e=rl(i)|0,c[g>>2]=e,(e|0)==0):0)d=0;else f=16;do if((f|0)==16){if(nl(b,118)|0){bq(m);d=Av(b,g,k,m,l,j+4|0,j+8|0)|0;break}d=b+8|0;e=Zl(d)|0;while(1){f=rl(i)|0;c[m>>2]=f;if(!f){f=21;break}Yl(d,m);if(yv(h)|0){f=22;break}}if((f|0)==21){d=0;break}else if((f|0)==22){sn(m,b,e);d=Av(b,g,k,m,l,j+4|0,j+8|0)|0;break}}while(0)}}}else d=0;}}Eb=n;return d|0}function jl(b,d){b=b|0;d=d|0;var e=0;e=c[b>>2]|0;if(((c[b+4>>2]|0)-e|0)>>>0>d>>>0)b=a[e+d>>0]|0;else b=0;return b|0}function kl(a,b,d){a=a|0;b=b|0;d=d|0;c[a>>2]=b;c[a+4>>2]=d;return}function ll(a,b,c){a=a|0;b=b|0;c=c|0;return rv(a+368|0,b,c)|0}function ml(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)|0}function nl(b,d){b=b|0;d=d|0;var e=0;e=c[b>>2]|0;if((e|0)!=(c[b+4>>2]|0)?(a[e>>0]|0)==d<<24>>24:0){c[b>>2]=e+1;b=1;}else b=0;return b|0}function ol(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0;g=c[d>>2]|0;if(e)nl(d,110)|0;if((ml(d)|0)!=0?(f=c[d>>2]|0,((a[f>>0]|0)+-48|0)>>>0<10):0){while(1){if(!(ml(d)|0))break;if(((a[f>>0]|0)+-48|0)>>>0>=10)break;e=f+1|0;c[d>>2]=e;f=e;}kl(b,g,f);}else tm(b);return}function pl(a){a=a|0;return (c[a>>2]|0)==(c[a+4>>2]|0)|0}function ql(a,b,c){a=a|0;b=b|0;c=c|0;return nv(a+368|0,b,c)|0}function rl(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+32|0;h=j+16|0;g=j+8|0;f=j;c[h>>2]=0;d=jl(b,0)|0;a:do switch(d<<24>>24|0){case 75:case 86:case 114:{i=d<<24>>24==114;d=i&1;g=(jl(b,d)|0)<<24>>24==86;d=g?(i?2:1):d;d=d+((jl(b,d)|0)<<24>>24==75&1)|0;switch((jl(b,d)|0)<<24>>24){case 70:break;case 68:{switch((jl(b,d+1|0)|0)<<24>>24){case 120:case 119:case 79:case 111:break;default:{i=5;break a}}break}default:{i=5;break a}}d=sl(hl(b)|0)|0;c[h>>2]=d;i=81;break}case 85:{i=5;break}case 118:{c[b>>2]=(c[b>>2]|0)+1;d=ul(b,12081)|0;break}case 119:{c[b>>2]=(c[b>>2]|0)+1;d=vl(b)|0;break}case 98:{c[b>>2]=(c[b>>2]|0)+1;d=ul(b,12086)|0;break}case 99:{c[b>>2]=(c[b>>2]|0)+1;d=ul(b,12091)|0;break}case 97:{c[b>>2]=(c[b>>2]|0)+1;d=wl(b,12096)|0;break}case 104:{c[b>>2]=(c[b>>2]|0)+1;d=xl(b,12108)|0;break}case 115:{c[b>>2]=(c[b>>2]|0)+1;d=yl(b,12122)|0;break}case 116:{c[b>>2]=(c[b>>2]|0)+1;d=zl(b,12128)|0;break}case 105:{c[b>>2]=(c[b>>2]|0)+1;d=Al(b,12143)|0;break}case 106:{c[b>>2]=(c[b>>2]|0)+1;d=Bl(b,12147)|0;break}case 108:{c[b>>2]=(c[b>>2]|0)+1;d=ul(b,12160)|0;break}case 109:{c[b>>2]=(c[b>>2]|0)+1;d=xl(b,12165)|0;break}case 120:{c[b>>2]=(c[b>>2]|0)+1;d=Cl(b,12179)|0;break}case 121:{c[b>>2]=(c[b>>2]|0)+1;d=Dl(b)|0;break}case 110:{c[b>>2]=(c[b>>2]|0)+1;d=El(b,12189)|0;break}case 111:{c[b>>2]=(c[b>>2]|0)+1;d=Fl(b,12198)|0;break}case 102:{c[b>>2]=(c[b>>2]|0)+1;d=yl(b,12216)|0;break}case 100:{c[b>>2]=(c[b>>2]|0)+1;d=Gl(b)|0;break}case 101:{c[b>>2]=(c[b>>2]|0)+1;d=wl(b,12222)|0;break}case 103:{c[b>>2]=(c[b>>2]|0)+1;d=Hl(b,12234)|0;break}case 122:{c[b>>2]=(c[b>>2]|0)+1;d=Al(b,12245)|0;break}case 117:{c[b>>2]=(c[b>>2]|0)+1;Il(g,b);if(pl(g)|0)d=0;else d=Jl(b,g)|0;break}case 68:do switch((jl(b,1)|0)<<24>>24|0){case 100:{c[b>>2]=(c[b>>2]|0)+2;d=Cl(b,12249)|0;break a}case 101:{c[b>>2]=(c[b>>2]|0)+2;d=Hl(b,12259)|0;break a}case 102:{c[b>>2]=(c[b>>2]|0)+2;d=Cl(b,12270)|0;break a}case 104:{c[b>>2]=(c[b>>2]|0)+2;d=Cl(b,12280)|0;break a}case 105:{c[b>>2]=(c[b>>2]|0)+2;d=El(b,12290)|0;break a}case 115:{c[b>>2]=(c[b>>2]|0)+2;d=El(b,12299)|0;break a}case 97:{c[b>>2]=(c[b>>2]|0)+2;d=ul(b,12308)|0;break a}case 99:{c[b>>2]=(c[b>>2]|0)+2;d=zl(b,12313)|0;break a}case 110:{c[b>>2]=(c[b>>2]|0)+2;d=zl(b,12328)|0;break a}case 84:case 116:{d=Kl(hl(b)|0)|0;c[h>>2]=d;i=81;break a}case 118:{d=Ll(hl(b)|0)|0;c[h>>2]=d;i=81;break a}case 112:{c[b>>2]=(c[b>>2]|0)+2;f=rl(hl(b)|0)|0;c[g>>2]=f;if(!f){d=0;break a}else{i=Ml(b,g)|0;c[h>>2]=i;i=82;break a}}case 120:case 119:case 79:case 111:{d=sl(hl(b)|0)|0;c[h>>2]=d;i=81;break a}default:{d=0;break a}}while(0);case 70:{d=sl(hl(b)|0)|0;c[h>>2]=d;i=81;break}case 65:{d=Nl(hl(b)|0)|0;c[h>>2]=d;i=81;break}case 77:{d=Ol(hl(b)|0)|0;c[h>>2]=d;i=81;break}case 84:{switch((jl(b,1)|0)<<24>>24){case 101:case 117:case 115:{d=Pl(hl(b)|0)|0;c[h>>2]=d;i=81;break a}}d=hl(b)|0;f=Ql(d)|0;c[h>>2]=f;if(f)if((a[b+360>>0]|0)!=0?(jl(b,0)|0)<<24>>24==73:0){f=Rl(d,0)|0;c[g>>2]=f;if(!f){d=0;break a}else{i=Sl(b,h,g)|0;c[h>>2]=i;i=82;break a}}else i=82;else d=0;break}case 80:{c[b>>2]=(c[b>>2]|0)+1;f=rl(hl(b)|0)|0;c[g>>2]=f;if(!f){d=0;break a}else{i=Tl(b,g)|0;c[h>>2]=i;i=82;break a}}case 82:{c[b>>2]=(c[b>>2]|0)+1;e=rl(hl(b)|0)|0;c[g>>2]=e;if(!e){d=0;break a}else{c[f>>2]=0;i=Ul(b,g,f)|0;c[h>>2]=i;i=82;break a}}case 79:{c[b>>2]=(c[b>>2]|0)+1;e=rl(hl(b)|0)|0;c[g>>2]=e;if(!e){d=0;break a}else{c[f>>2]=1;i=Ul(b,g,f)|0;c[h>>2]=i;i=82;break a}}case 67:{c[b>>2]=(c[b>>2]|0)+1;f=rl(hl(b)|0)|0;c[g>>2]=f;if(!f){d=0;break a}else{i=Vl(b,g)|0;c[h>>2]=i;i=82;break a}}case 71:{c[b>>2]=(c[b>>2]|0)+1;f=rl(hl(b)|0)|0;c[g>>2]=f;if(!f){d=0;break a}else{i=Wl(b,g)|0;c[h>>2]=i;i=82;break a}}case 83:{switch((jl(b,1)|0)<<24>>24){case 116:case 0:{i=80;break a}}e=hl(b)|0;d=Xl(e)|0;c[g>>2]=d;if(d){if((a[b+360>>0]|0)!=0?(jl(b,0)|0)<<24>>24==73:0){e=Rl(e,0)|0;c[f>>2]=e;if(!e){d=0;break a}else{i=Sl(b,g,f)|0;c[h>>2]=i;i=82;break a}}}else d=0;break}default:i=80;}while(0);if((i|0)==5){d=tl(hl(b)|0)|0;c[h>>2]=d;i=81;}else if((i|0)==80){d=Pl(hl(b)|0)|0;c[h>>2]=d;i=81;}if((i|0)==81)if(!d)d=0;else i=82;if((i|0)==82){Yl(b+148|0,h);d=c[h>>2]|0;}Eb=j;return d|0}function sl(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;o=Eb;Eb=Eb+80|0;h=o+64|0;i=o+28|0;k=o+24|0;p=o+56|0;d=o+48|0;e=o+40|0;f=o+32|0;l=o;m=o+72|0;n=o+16|0;j=o+8|0;q=ds(b)|0;c[i>>2]=q;c[k>>2]=0;fl(p,17081);c[h>>2]=c[p>>2];c[h+4>>2]=c[p+4>>2];do if(!(gl(b,h)|0)){fl(d,17093);c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];if(gl(b,h)|0){q=ao(hl(b)|0)|0;c[h>>2]=q;if(!q){d=0;break}if(nl(b,69)|0){g=Xu(b,h)|0;c[k>>2]=g;g=14;break}else{d=0;break}}fl(e,17096);c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];if(gl(b,h)|0){d=b+8|0;e=Zl(d)|0;while(1){if(nl(b,69)|0){g=12;break}q=rl(hl(b)|0)|0;c[h>>2]=q;if(!q){g=13;break}Yl(d,h);}if((g|0)==12){sn(h,b,e);q=Yu(b,h)|0;c[k>>2]=q;g=14;break}else if((g|0)==13){d=0;break}}else g=14;}else{g=El(b,17084)|0;c[k>>2]=g;g=14;}while(0);if((g|0)==14){fl(f,17099);c[h>>2]=c[f>>2];c[h+4>>2]=c[f+4>>2];gl(b,h)|0;if(nl(b,70)|0){nl(b,89)|0;d=hl(b)|0;q=rl(d)|0;c[l>>2]=q;if(!q)d=0;else{a[m>>0]=0;e=b+8|0;f=Zl(e)|0;while(1){if(nl(b,69)|0){g=27;break}if(!(nl(b,118)|0)){fl(n,17102);c[h>>2]=c[n>>2];c[h+4>>2]=c[n+4>>2];if(gl(b,h)|0){g=21;break}fl(j,17105);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];if(gl(b,h)|0){g=23;break}q=rl(d)|0;c[h>>2]=q;if(!q){g=26;break}Yl(e,h);}}if((g|0)==21){a[m>>0]=1;g=27;}else if((g|0)==23){a[m>>0]=2;g=27;}else if((g|0)==26)d=0;if((g|0)==27){sn(h,b,f);d=Zu(b,l,h,i,m,k)|0;}}}else d=0;}Eb=o;return d|0}function tl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+64|0;g=i+48|0;h=i+40|0;b=i+32|0;d=i;e=i+20|0;f=i+8|0;if(nl(a,85)|0){Il(h,a);do if(pl(h)|0)b=0;else{fl(b,16896);c[g>>2]=c[b>>2];c[g+4>>2]=c[b+4>>2];if(!(Aq(h,g)|0)){f=tl(hl(a)|0)|0;c[g>>2]=f;if(!f)b=0;else b=Eu(a,g,h)|0;break}No(g,h,9);tm(d);Bu(e,a,wm(g)|0);Bu(f,a+4|0,en(g)|0);Il(d,a);Cu(f);Cu(e);if(pl(d)|0)b=0;else{h=tl(hl(a)|0)|0;c[e>>2]=h;if(!h)b=0;else b=Du(a,e,d)|0;}}while(0)}else{d=ds(a)|0;c[g>>2]=d;b=rl(hl(a)|0)|0;c[h>>2]=b;if(b){if(d){b=Fu(a,h,g)|0;c[h>>2]=b;}}else b=0;}Eb=i;return b|0}function ul(a,b){a=a|0;b=b|0;return Au(a+368|0,b)|0}function vl(a){a=a|0;return zu(a+368|0,13001)|0}function wl(a,b){a=a|0;b=b|0;return yu(a+368|0,b)|0}function xl(a,b){a=a|0;b=b|0;return xu(a+368|0,b)|0}function yl(a,b){a=a|0;b=b|0;return wu(a+368|0,b)|0}function zl(a,b){a=a|0;b=b|0;return vu(a+368|0,b)|0}function Al(a,b){a=a|0;b=b|0;return uu(a+368|0,b)|0}function Bl(a,b){a=a|0;b=b|0;return tu(a+368|0,b)|0}function Cl(a,b){a=a|0;b=b|0;return su(a+368|0,b)|0}function Dl(a){a=a|0;return ru(a+368|0,16877)|0}function El(a,b){a=a|0;b=b|0;return qu(a+368|0,b)|0}function Fl(a,b){a=a|0;b=b|0;return pu(a+368|0,b)|0}function Gl(a){a=a|0;return ou(a+368|0,16870)|0}function Hl(a,b){a=a|0;b=b|0;return nu(a+368|0,b)|0}function Il(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+16|0;d=g+8|0;e=g;c[d>>2]=0;if(!(zq(b,d)|0)?(h=ml(b)|0,f=c[d>>2]|0,h>>>0>=f>>>0):0){h=c[b>>2]|0;kl(e,h,h+f|0);c[b>>2]=(c[b>>2]|0)+f;f=c[e+4>>2]|0;h=a;c[h>>2]=c[e>>2];c[h+4>>2]=f;}else tm(a);Eb=g;return}function Jl(a,b){a=a|0;b=b|0;return mu(a+368|0,b)|0}function Kl(a){a=a|0;var b=0,d=0,e=0;d=Eb;Eb=Eb+16|0;b=d;do if(nl(a,68)|0){if(!(nl(a,116)|0)?!(nl(a,84)|0):0){a=0;break}e=ao(hl(a)|0)|0;c[b>>2]=e;if((e|0)!=0?nl(a,69)|0:0)a=Wo(a,16860,b)|0;else a=0;}else a=0;while(0);Eb=d;return a|0}function Ll(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+32|0;b=f+16|0;d=f+8|0;e=f;fl(d,16735);c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];do if(gl(a,b)|0){if(((jl(a,0)|0)+-49&255)<9){ol(b,a,0);do if(nl(a,95)|0){if(nl(a,112)|0){b=_t(a,b)|0;break}d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=$t(a,e,b)|0;}else b=0;while(0);break}if(nl(a,95)|0){d=rl(hl(a)|0)|0;c[b>>2]=d;if(!d)b=0;else{tm(e);b=bu(a,b,e)|0;}break}d=hl(a)|0;g=ao(d)|0;c[b>>2]=g;if((g|0)!=0?nl(a,95)|0:0){g=rl(d)|0;c[e>>2]=g;if(!g)b=0;else b=au(a,e,b)|0;}else b=0;}else b=0;while(0);Eb=f;return b|0}function Ml(a,b){a=a|0;b=b|0;return Zt(a+368|0,b)|0}function Nl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+32|0;d=g+16|0;e=g;b=g+8|0;if(nl(a,65)|0){Kt(e);if((((jl(a,0)|0)<<24>>24)+-48|0)>>>0<10){ol(b,a,0);c[d>>2]=c[b>>2];c[d+4>>2]=c[b+4>>2];Lt(e,d);if(nl(a,95)|0)f=8;else b=0;}else if(!(nl(a,95)|0)){b=ao(hl(a)|0)|0;if((b|0)!=0?nl(a,95)|0:0){Mt(e,b);f=8;}else b=0;}else f=8;if((f|0)==8){f=rl(hl(a)|0)|0;c[d>>2]=f;if(!f)b=0;else b=Nt(a,d,e)|0;}}else b=0;Eb=g;return b|0}function Ol(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+16|0;b=f+4|0;d=f;if(nl(a,77)|0){e=hl(a)|0;g=rl(e)|0;c[b>>2]=g;if(!g)a=0;else{g=rl(e)|0;c[d>>2]=g;if(!g)a=0;else a=Dt(a,b,d)|0;}}else a=0;Eb=f;return a|0}function Pl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+48|0;e=g+32|0;f=g;h=g+24|0;b=g+16|0;d=g+8|0;tm(f);fl(h,15791);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];do if(!(gl(a,e)|0)){fl(b,15801);c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];if(gl(a,e)|0){fl(f,15804);break}fl(d,15810);c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];if(gl(a,e)|0)fl(f,15813);}else fl(f,15794);while(0);b=zs(hl(a)|0,0)|0;c[e>>2]=b;if(b){if(!(pl(f)|0))b=As(a,f,e)|0;}else b=0;Eb=g;return b|0}function Ql(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+16|0;e=i+4|0;f=i;if(nl(b,84)|0){c[e>>2]=0;if(!(nl(b,95)|0))if(!(zq(b,e)|0)?(d=(c[e>>2]|0)+1|0,c[e>>2]=d,nl(b,95)|0):0){g=d;h=5;}else d=0;else{g=0;h=5;}do if((h|0)==5){if(a[b+362>>0]|0){d=ul(b,12308)|0;break}if(a[b+361>>0]|0){d=ls(b,e)|0;c[f>>2]=d;ms(b+332|0,f);break}d=b+288|0;if(g>>>0<(Gn(d)|0)>>>0){d=ns(d,g)|0;d=c[d>>2]|0;}else d=0;}while(0)}else d=0;Eb=i;return d|0}function Rl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+64|0;j=l+16|0;e=l+12|0;f=l+8|0;g=l;do if(nl(a,73)|0){h=a+288|0;if(b)ln(h);i=a+8|0;k=Zl(i)|0;while(1){if(nl(a,69)|0){d=16;break}if(b){mn(j,h);d=nn(hl(a)|0)|0;c[e>>2]=d;on(h,j);if(!d){d=12;break}Yl(i,e);c[f>>2]=d;if((Vm(d)|0)<<24>>24==28){pn(g,d);d=qn(a,g)|0;c[f>>2]=d;}rn(h,f);_k(j);}else{d=nn(hl(a)|0)|0;c[j>>2]=d;if(!d){d=15;break}Yl(i,j);}}if((d|0)==12){_k(j);b=0;break}else if((d|0)==15){b=0;break}else if((d|0)==16){sn(j,a,k);b=tn(a,j)|0;break}}else b=0;while(0);Eb=l;return b|0}function Sl(a,b,c){a=a|0;b=b|0;c=c|0;return fn(a+368|0,b,c)|0}function Tl(a,b){a=a|0;b=b|0;return Xm(a+368|0,b)|0}function Ul(a,b,c){a=a|0;b=b|0;c=c|0;return Km(a+368|0,b,c)|0}function Vl(a,b){a=a|0;b=b|0;return Jm(a+368|0,b,12702)|0}function Wl(a,b){a=a|0;b=b|0;return Fm(a+368|0,b,12634)|0}function Xl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;f=g;a:do if(nl(a,83)|0){e=(jl(a,0)|0)<<24>>24;if(!(zh(e)|0)){if(nl(a,95)|0){b=a+148|0;if(bm(b)|0){b=0;break}b=cm(b,0)|0;b=c[b>>2]|0;break}c[f>>2]=0;if((!(dm(a,f)|0)?(b=(c[f>>2]|0)+1|0,c[f>>2]=b,nl(a,95)|0):0)?(d=a+148|0,b>>>0<(Zl(d)|0)>>>0):0){b=cm(d,b)|0;b=c[b>>2]|0;}else b=0;break}switch(e|0){case 97:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=0;b=$l(a,f)|0;break}case 98:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=1;b=$l(a,f)|0;break}case 115:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=2;b=$l(a,f)|0;break}case 105:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=3;b=$l(a,f)|0;break}case 111:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=4;b=$l(a,f)|0;break}case 100:{c[a>>2]=(c[a>>2]|0)+1;c[f>>2]=5;b=$l(a,f)|0;break}default:{b=0;break a}}d=am(hl(a)|0,b)|0;c[f>>2]=d;if((d|0)!=(b|0)){Yl(a+148|0,f);b=d;}}else b=0;while(0);Eb=g;return b|0}function Yl(a,b){a=a|0;b=b|0;var d=0,e=0;e=a+4|0;d=c[e>>2]|0;if((d|0)==(c[a+8>>2]|0)){_l(a,(Zl(a)|0)<<1);d=c[e>>2]|0;}b=c[b>>2]|0;c[e>>2]=d+4;c[d>>2]=b;return}function Zl(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>2|0}function _l(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Zl(a)|0;do if(!(al(a)|0)){e=jk(c[a>>2]|0,b<<2)|0;c[a>>2]=e;if(!e)Uk();else{f=e;d=a+4|0;break}}else{f=hk(b<<2)|0;if(!f)Uk();g=c[a>>2]|0;d=a+4|0;e=(c[d>>2]|0)-g|0;if(e|0)bx(f|0,g|0,e|0)|0;c[a>>2]=f;}while(0);c[d>>2]=f+(h<<2);c[a+8>>2]=f+(b<<2);return}function $l(a,b){a=a|0;b=b|0;return Am(a+368|0,b)|0}function am(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;d=g;e=g+8|0;c[d>>2]=b;while(1){if(!(nl(a,66)|0))break;Il(e,a);if(pl(e)|0){f=5;break}b=fm(a,d,e)|0;c[d>>2]=b;}if((f|0)==5)b=0;Eb=g;return b|0}function bm(a){a=a|0;return (c[a>>2]|0)==(c[a+4>>2]|0)|0}function cm(a,b){a=a|0;b=b|0;return (em(a)|0)+(b<<2)|0}function dm(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;f=jl(a,0)|0;if(f<<24>>24>47?f<<24>>24<58|(f+-65&255)<26:0){d=0;while(1){f=jl(a,0)|0;if(f<<24>>24<=47)break;if(f<<24>>24>=58)if((f+-65&255)<26)e=-55;else break;else e=-48;c[a>>2]=(c[a>>2]|0)+1;d=(d*36|0)+e+(f<<24>>24)|0;}c[b>>2]=d;d=0;}else d=1;return d|0}function em(a){a=a|0;return c[a>>2]|0}function fm(a,b,c){a=a|0;b=b|0;c=c|0;return gm(a+368|0,b,c)|0}function gm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];im(a,b,f);Eb=e;return a|0}function hm(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;g=b+15&-16;h=a+4096|0;d=c[h>>2]|0;e=d+4|0;b=c[e>>2]|0;f=b+g|0;do if(f>>>0>4087)if(g>>>0>4088){b=ym(a,g)|0;break}else{zm(a);d=c[h>>2]|0;e=d+4|0;b=c[e>>2]|0;f=b+g|0;i=5;break}else i=5;while(0);if((i|0)==5){c[e>>2]=f;b=d+8+b|0;}return b|0}function im(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;jm(b,8,a[d+5>>0]|0,a[d+6>>0]|0,a[d+7>>0]|0);c[b>>2]=4316;c[b+8>>2]=d;f=e;d=c[f+4>>2]|0;e=b+12|0;c[e>>2]=c[f>>2];c[e+4>>2]=d;return}function jm(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;c[b>>2]=4360;a[b+4>>0]=d;a[b+5>>0]=e;a[b+6>>0]=f;a[b+7>>0]=g;return}function km(a,b){return 0}function lm(a,b){return 0}function mm(a,b){return 0}function nm(a,b){a=a|0;return a|0}function om(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+24|0;i=d+16|0;g=d;f=d+8|0;h=c[a+8>>2]|0;Xb[c[(c[h>>2]|0)+16>>2]&127](h,b);fl(i,12343);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);i=a+12|0;h=c[i+4>>2]|0;a=g;c[a>>2]=c[i>>2];c[a+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,12349);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function pm(a,b){return}function qm(a,b){a=a|0;tm(a);return}function rm(a){return}function sm(a){a=a|0;$j(a);return}function tm(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;return}function um(a,b){a=a|0;b=b|0;var d=0,e=0;d=vm(b)|0;if(d|0){Tk(a,d);e=a+4|0;a=(c[a>>2]|0)+(c[e>>2]|0)|0;bx(a|0,wm(b)|0,d|0)|0;c[e>>2]=(c[e>>2]|0)+d;}return}function vm(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)|0}function wm(a){a=a|0;return c[a>>2]|0}function xm(a){Aa();}function ym(a,b){a=a|0;b=b|0;b=hk(b+8|0)|0;if(!b)Uk();else{a=c[a+4096>>2]|0;c[b>>2]=c[a>>2];c[b+4>>2]=0;c[a>>2]=b;return b+8|0}return 0}function zm(a){a=a|0;var b=0;b=hk(4096)|0;if(!b)Uk();else{a=a+4096|0;c[b>>2]=c[a>>2];c[b+4>>2]=0;c[a>>2]=b;return}}function Am(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Bm(a,c[b>>2]|0);return a|0}function Bm(a,b){a=a|0;b=b|0;jm(a,36,1,1,1);c[a>>2]=4404;c[a+8>>2]=b;return}function Cm(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=Eb;Eb=Eb+64|0;d=k+48|0;e=k+40|0;f=k+32|0;g=k+24|0;h=k+16|0;i=k+8|0;j=k;switch(c[a+8>>2]|0){case 0:{fl(e,12493);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);break}case 1:{fl(f,12508);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);break}case 2:{fl(g,12526);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];um(b,d);break}case 3:{fl(h,12538);c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);break}case 4:{fl(i,12551);c[d>>2]=c[i>>2];c[d+4>>2]=c[i+4>>2];um(b,d);break}case 5:{fl(j,12564);c[d>>2]=c[j>>2];c[d+4>>2]=c[j+4>>2];um(b,d);break}}Eb=k;return}function Dm(a,b){a=a|0;b=b|0;switch(c[b+8>>2]|0){case 0:{fl(a,12438);break}case 1:{fl(a,12448);break}case 2:{fl(a,12461);break}case 3:{fl(a,12468);break}case 4:{fl(a,12476);break}case 5:{fl(a,12484);break}}return}function Em(a){a=a|0;$j(a);return}function Fm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;fl(g,d);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Gm(a,b,f);Eb=e;return a|0}function Gm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,5,1,1,1);c[a>>2]=4448;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Hm(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;h=c[a+8>>2]|0;Xb[c[(c[h>>2]|0)+16>>2]&127](h,b);h=a+12|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Im(a){a=a|0;$j(a);return}function Jm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;fl(g,d);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Gm(a,b,f);Eb=e;return a|0}function Km(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,20)|0;Lm(a,c[b>>2]|0,c[d>>2]|0);return a|0}function Lm(b,d,e){b=b|0;d=d|0;e=e|0;jm(b,12,a[d+5>>0]|0,1,1);c[b>>2]=4492;c[b+8>>2]=d;c[b+12>>2]=e;a[b+16>>0]=0;return}function Mm(a,b){a=a|0;b=b|0;return Wm(c[a+8>>2]|0,b)|0}function Nm(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+48|0;f=l+40|0;g=l+24|0;h=l+8|0;i=l+32|0;j=l+16|0;k=l;e=b+16|0;if(!(a[e>>0]|0)){Qm(g,e,1);Rm(h,b,d);b=c[h+4>>2]|0;Xb[c[(c[b>>2]|0)+16>>2]&127](b,d);if(Sm(b,d)|0){fl(i,12713);c[f>>2]=c[i>>2];c[f+4>>2]=c[i+4>>2];um(d,f);}if(!(!(Sm(b,d)|0)?!(Tm(b,d)|0):0)){fl(j,12715);c[f>>2]=c[j>>2];c[f+4>>2]=c[j+4>>2];um(d,f);}fl(k,(c[h>>2]|0)==0?12717:12719);c[f>>2]=c[k>>2];c[f+4>>2]=c[k+4>>2];um(d,f);Um(g);}Eb=l;return}function Om(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+32|0;g=j+24|0;h=j+16|0;e=j+8|0;i=j;f=b+16|0;if(!(a[f>>0]|0)){Qm(h,f,1);Rm(e,b,d);b=c[e+4>>2]|0;if(!(!(Sm(b,d)|0)?!(Tm(b,d)|0):0)){fl(i,12711);c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];um(d,g);}Xb[c[(c[b>>2]|0)+20>>2]&127](b,d);Um(h);}Eb=j;return}function Pm(a){a=a|0;$j(a);return}function Qm(b,d,e){b=b|0;d=d|0;e=e|0;c[b>>2]=d;a[b+4>>0]=a[d>>0]|0;a[b+5>>0]=1;a[d>>0]=e&1;return}function Rm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=c[b+12>>2]|0;c[a>>2]=e;f=a+4|0;b=c[b+8>>2]|0;c[f>>2]=b;while(1){b=Ob[c[(c[b>>2]|0)+12>>2]&63](b,d)|0;if((Vm(b)|0)<<24>>24!=12)break;h=c[b+8>>2]|0;c[f>>2]=h;g=c[b+12>>2]|0;g=(g|0)<(e|0)?g:e;c[a>>2]=g;b=h;e=g;}return}function Sm(b,d){b=b|0;d=d|0;var e=0;e=a[b+6>>0]|0;if(e<<24>>24==2)b=Ob[c[(c[b>>2]|0)+4>>2]&63](b,d)|0;else b=e<<24>>24==0;return b|0}function Tm(b,d){b=b|0;d=d|0;var e=0;e=a[b+7>>0]|0;if(e<<24>>24==2)b=Ob[c[(c[b>>2]|0)+8>>2]&63](b,d)|0;else b=e<<24>>24==0;return b|0}function Um(b){b=b|0;if(a[b+5>>0]|0)a[c[b>>2]>>0]=a[b+4>>0]|0;return}function Vm(b){b=b|0;return a[b+4>>0]|0}function Wm(b,d){b=b|0;d=d|0;var e=0;e=a[b+5>>0]|0;if(e<<24>>24==2)b=Ob[c[c[b>>2]>>2]&63](b,d)|0;else b=e<<24>>24==0;return b|0}function Xm(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Ym(a,c[b>>2]|0);return a|0}function Ym(b,d){b=b|0;d=d|0;jm(b,11,a[d+5>>0]|0,1,1);c[b>>2]=4536;c[b+8>>2]=d;return}function Zm(a,b){a=a|0;b=b|0;return Wm(c[a+8>>2]|0,b)|0}function _m(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;h=m+48|0;i=m+40|0;j=m+32|0;k=m+24|0;d=m+16|0;e=m;f=m+8|0;g=a+8|0;a=c[g>>2]|0;do if((Vm(a)|0)<<24>>24==10)if(bn(a)|0){i=c[g>>2]|0;fl(d,12786);c[h>>2]=c[d>>2];c[h+4>>2]=c[d+4>>2];um(b,h);i=i+12|0;j=c[i+4>>2]|0;k=e;c[k>>2]=c[i>>2];c[k+4>>2]=j;c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];um(b,h);fl(f,12790);c[h>>2]=c[f>>2];c[h+4>>2]=c[f+4>>2];um(b,h);break}else{a=c[g>>2]|0;l=4;break}else l=4;while(0);if((l|0)==4){Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);if(Sm(c[g>>2]|0,b)|0){fl(i,12713);c[h>>2]=c[i>>2];c[h+4>>2]=c[i+4>>2];um(b,h);}if(!(!(Sm(c[g>>2]|0,b)|0)?!(Tm(c[g>>2]|0,b)|0):0)){fl(j,12715);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];um(b,h);}fl(k,12784);c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];um(b,h);}Eb=m;return}function $m(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;e=h+8|0;f=h;d=a+8|0;a=c[d>>2]|0;if((Vm(a)|0)<<24>>24==10){if(!(bn(a)|0)){a=c[d>>2]|0;g=4;}}else g=4;if((g|0)==4){if(!(!(Sm(a,b)|0)?!(Tm(c[d>>2]|0,b)|0):0)){fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);}g=c[d>>2]|0;Xb[c[(c[g>>2]|0)+20>>2]&127](g,b);}Eb=h;return}function an(a){a=a|0;$j(a);return}function bn(a){a=a|0;var b=0,d=0,e=0;e=Eb;Eb=Eb+16|0;b=e+8|0;d=e;a=c[a+8>>2]|0;if((Vm(a)|0)<<24>>24==7){cn(b,a);fl(d,12772);a=dn(b,d)|0;}else a=0;Eb=e;return a|0}function cn(a,b){a=a|0;b=b|0;var d=0,e=0;e=b+8|0;d=c[e+4>>2]|0;b=a;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function dn(b,c){b=b|0;c=c|0;var d=0,e=0;d=vm(b)|0;a:do if((d|0)==(vm(c)|0)){e=wm(b)|0;d=en(b)|0;b=wm(c)|0;c=e;while(1){if((c|0)==(d|0)){b=1;break a}if((a[c>>0]|0)!=(a[b>>0]|0)){b=0;break a}b=b+1|0;c=c+1|0;}}else b=0;while(0);return b|0}function en(a){a=a|0;return c[a+4>>2]|0}function fn(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;gn(a,c[b>>2]|0,c[d>>2]|0);return a|0}function gn(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,32,1,1,1);c[a>>2]=4580;c[a+8>>2]=b;c[a+12>>2]=d;return}function hn(a,b){a=a|0;b=b|0;Pk(c[a+8>>2]|0,b);Pk(c[a+12>>2]|0,b);return}function jn(a,b){a=a|0;b=b|0;b=c[b+8>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function kn(a){a=a|0;$j(a);return}function ln(a){a=a|0;c[a+4>>2]=c[a>>2];return}function mn(a,b){a=a|0;b=b|0;var d=0,e=0;ks(a);if(bl(b)|0){d=_n(b)|0;e=($n(b)|0)-d|0;if(e|0)bx(c[a>>2]|0,d|0,e|0)|0;e=c[a>>2]|0;e=e+((Gn(b)|0)<<2)|0;c[a+4>>2]=e;ln(b);}else{c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];Zn(b);}return}function nn(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;d=g;a:do switch((jl(a,0)|0)<<24>>24|0){case 88:{c[a>>2]=(c[a>>2]|0)+1;b=ao(hl(a)|0)|0;if(!b)b=0;else{a=nl(a,69)|0;Eb=g;return (a?b:0)|0}break}case 74:{c[a>>2]=(c[a>>2]|0)+1;b=a+8|0;e=Zl(b)|0;while(1){if(nl(a,69)|0){f=9;break}f=nn(hl(a)|0)|0;c[d>>2]=f;if(!f){f=8;break}Yl(b,d);}if((f|0)==8){b=0;break a}else if((f|0)==9){sn(d,a,e);b=bo(a,d)|0;break a}break}case 76:{if((jl(a,1)|0)<<24>>24!=90){b=co(hl(a)|0)|0;break a}c[a>>2]=(c[a>>2]|0)+2;b=il(hl(a)|0)|0;if(!b)b=0;else{a=nl(a,69)|0;b=a?b:0;}break}default:b=rl(hl(a)|0)|0;}while(0);Eb=g;return b|0}function on(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;e=bl(b)|0;d=bl(a)|0;do if(!e)if(d){c[a>>2]=c[b>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];Zn(b);break}else{f=c[a>>2]|0;c[a>>2]=c[b>>2];c[b>>2]=f;f=a+4|0;d=b+4|0;e=c[f>>2]|0;c[f>>2]=c[d>>2];c[d>>2]=e;d=a+8|0;a=b+8|0;e=c[d>>2]|0;c[d>>2]=c[a>>2];c[a>>2]=e;ln(b);break}else{if(!d){ik(c[a>>2]|0);Zn(a);}d=_n(b)|0;e=($n(b)|0)-d|0;if(e|0)bx(c[a>>2]|0,d|0,e|0)|0;f=c[a>>2]|0;f=f+((Gn(b)|0)<<2)|0;c[a+4>>2]=f;ln(b);}while(0);return}function pn(a,b){a=a|0;b=b|0;var d=0,e=0;e=b+8|0;d=c[e+4>>2]|0;b=a;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function qn(a,b){a=a|0;b=b|0;return In(a+368|0,b)|0}function rn(a,b){a=a|0;b=b|0;var d=0,e=0;e=a+4|0;d=c[e>>2]|0;if((d|0)==(c[a+8>>2]|0)){Hn(a,(Gn(a)|0)<<1);d=c[e>>2]|0;}b=c[b>>2]|0;c[e>>2]=d+4;c[d>>2]=b;return}function sn(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=b+8|0;e=(em(d)|0)+(c<<2)|0;Cn(a,b,e,Bn(d)|0);Dn(d,c);return}function tn(a,b){a=a|0;b=b|0;return un(a+368|0,b)|0}function un(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];vn(a,e);Eb=d;return a|0}function vn(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,30,1,1,1);c[a>>2]=4624;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function wn(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+32|0;d=g+24|0;h=g+16|0;e=g+8|0;f=g;fl(h,12897);c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);yn(a+8|0,b);if((zn(b)|0)<<24>>24==62){fl(e,12713);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}fl(f,12790);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);Eb=g;return}function xn(a){a=a|0;$j(a);return}function yn(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;j=Eb;Eb=Eb+16|0;g=j+8|0;h=j;i=a+4|0;d=1;f=0;while(1){if((f|0)==(c[i>>2]|0))break;e=Rk(b)|0;if(!d){fl(h,12899);c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];um(b,g);}k=Rk(b)|0;Pk(c[(c[a>>2]|0)+(f<<2)>>2]|0,b);if((k|0)==(Rk(b)|0))An(b,e);else d=0;f=f+1|0;}Eb=j;return}function zn(b){b=b|0;var d=0;d=c[b+4>>2]|0;if(!d)b=0;else b=a[(c[b>>2]|0)+(d+-1)>>0]|0;return b|0}function An(a,b){a=a|0;b=b|0;c[a+4>>2]=b;return}function Bn(a){a=a|0;return c[a+4>>2]|0}function Cn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=d-c|0;f=e>>2;d=En(b+368|0,f)|0;if(e|0)bx(d|0,c|0,e|0)|0;Fn(a,d,f);return}function Dn(a,b){a=a|0;b=b|0;c[a+4>>2]=(c[a>>2]|0)+(b<<2);return}function En(a,b){a=a|0;b=b|0;return hm(a,b<<2)|0}function Fn(a,b,d){a=a|0;b=b|0;d=d|0;c[a>>2]=b;c[a+4>>2]=d;return}function Gn(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>2|0}
  function cc(){sh();fi();}function dc(a){a=a|0;var b=0;b=Eb;Eb=Eb+a|0;Eb=Eb+15&-16;return b|0}function ec(){return Eb|0}function fc(a){a=a|0;Eb=a;}function gc(a,b){a=a|0;Eb=a;}function hc(a,b,d){a=a|0;b=+b;d=+d;var e=0,f=0,g=0;g=+s(b)>=1.0?(b>0.0?~~+B(+r(b/4294967296.0),4294967295.0)>>>0:~~+z((b-+(~~b>>>0))/4294967296.0)>>>0):0;e=+s(d)>=1.0?(d>0.0?~~+B(+r(d/4294967296.0),4294967295.0)>>>0:~~+z((d-+(~~d>>>0))/4294967296.0)>>>0):0;f=a;c[f>>2]=~~b>>>0;c[f+4>>2]=g;a=a+8|0;c[a>>2]=~~d>>>0;c[a+4>>2]=e;return}function ic(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;g=a+48|0;h=a+52|0;e=c[h>>2]|0;b=c[g>>2]|0;if((e|0)!=(b|0)){f=0;do{d=c[b+(f<<2)>>2]|0;if(d){Ub[c[(c[d>>2]|0)+4>>2]&127](d);e=c[h>>2]|0;b=c[g>>2]|0;}f=f+1|0;d=e-b|0;}while(f>>>0<d>>2>>>0);if(d|0)c[h>>2]=b;}d=a+20|0;b=c[a+16>>2]|0;if((c[d>>2]|0)==(b|0))return;c[d>>2]=b;return}function jc(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>2|0}function kc(a){a=a|0;var b=0;b=c[a+16>>2]|0;if((b|0)==(c[a+20>>2]|0)){b=0;return b|0}b=c[b>>2]|0;return b|0}function lc(a){a=a|0;var b=0,d=0,e=0;b=c[a+48>>2]|0;e=(c[a+52>>2]|0)-b|0;d=e>>2;if((e|0)>0)return d+(((c[c[a+16>>2]>>2]|0)!=(c[b>>2]|0))<<31>>31)|0;else return d|0;}function mc(a){a=a|0;return (c[a+20>>2]|0)-(c[a+16>>2]|0)>>2|0}function nc(a){a=a|0;var b=0,d=0,e=0;b=c[a+16>>2]|0;if((b|0)!=(c[a+20>>2]|0)){e=c[b>>2]|0;return e|0}d=c[a+28>>2]|0;if(!d){e=0;return e|0}b=a;while(1){b=c[b+32>>2]|0;a=c[d+16>>2]|0;if((b|0)!=(((c[d+20>>2]|0)-a>>2)+-1|0))break;b=c[d+28>>2]|0;if(!b){b=0;e=8;break}else{a=d;d=b;b=a;}}if((e|0)==8)return b|0;e=c[a+(b+1<<2)>>2]|0;return e|0}function oc(a){a=a|0;var b=0;b=1;while(1){a=c[a+28>>2]|0;if(!a)break;else b=b^1;}return b|0}function pc(b){b=b|0;return (a[b+36>>0]|0)!=0|0}function qc(a){a=a|0;var b=0.0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;i=c[a>>2]|0;g=(c[a+4>>2]|0)-i|0;h=g>>4;if((g|0)<48){i=1;return i|0}g=h+-1|0;e=i+(g<<4)|0;g=i+(g<<4)+8|0;a=0;b=0.0;d=c[e+4>>2]|0;e=c[e>>2]|0;f=c[g+4>>2]|0;g=c[g>>2]|0;do{n=i+(a<<4)|0;m=e;e=c[n>>2]|0;l=d;d=c[n+4>>2]|0;n=i+(a<<4)+8|0;k=g;g=c[n>>2]|0;j=f;f=c[n+4>>2]|0;b=b+(+(m>>>0)+4294967296.0*+(l|0)+(+(e>>>0)+4294967296.0*+(d|0)))*(+(k>>>0)+4294967296.0*+(j|0)-(+(g>>>0)+4294967296.0*+(f|0)));a=a+1|0;}while((a|0)<(h|0));n=b*-.5>=0.0;return n|0}function rc(a){a=a|0;var b=0.0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;i=c[a>>2]|0;g=(c[a+4>>2]|0)-i|0;h=g>>4;if((g|0)<48){b=0.0;return +b}g=h+-1|0;e=i+(g<<4)|0;g=i+(g<<4)+8|0;a=0;b=0.0;d=c[e+4>>2]|0;e=c[e>>2]|0;f=c[g+4>>2]|0;g=c[g>>2]|0;do{n=i+(a<<4)|0;m=e;e=c[n>>2]|0;l=d;d=c[n+4>>2]|0;n=i+(a<<4)+8|0;k=g;g=c[n>>2]|0;j=f;f=c[n+4>>2]|0;b=b+(+(m>>>0)+4294967296.0*+(l|0)+(+(e>>>0)+4294967296.0*+(d|0)))*(+(k>>>0)+4294967296.0*+(j|0)-(+(g>>>0)+4294967296.0*+(f|0)));a=a+1|0;}while((a|0)<(h|0));b=b*-.5;return +b}function sc(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>4|0}function tc(a,b){a=a|0;b=b|0;var d=0.0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0.0;s=c[b>>2]|0;r=(c[b+4>>2]|0)-s>>4;if(r>>>0<3){s=0;return s|0}m=s+8|0;o=s;q=a+8|0;p=c[q>>2]|0;q=c[q+4>>2]|0;k=a;j=c[k>>2]|0;k=c[k+4>>2]|0;b=0;i=1;l=c[m>>2]|0;m=c[m+4>>2]|0;n=c[o+4>>2]|0;o=c[o>>2]|0;a:while(1){f=(i|0)==(r|0)?s:s+(i<<4)|0;g=f;e=o;o=c[g>>2]|0;a=n;n=c[g+4>>2]|0;f=f+8|0;g=l;l=c[f>>2]|0;h=m;m=c[f+4>>2]|0;if((l|0)==(p|0)&(m|0)==(q|0)){if((o|0)==(j|0)&(n|0)==(k|0)){b=-1;a=15;break}if((g|0)==(p|0)&(h|0)==(q|0)?!(((n|0)>(k|0)|(n|0)==(k|0)&o>>>0>j>>>0)^((a|0)<(k|0)|(a|0)==(k|0)&e>>>0<j>>>0)):0){b=-1;a=15;break}}do if(((h|0)<(q|0)|(h|0)==(q|0)&g>>>0<p>>>0)^((m|0)<(q|0)|(m|0)==(q|0)&l>>>0<p>>>0)){f=(n|0)>(k|0)|(n|0)==(k|0)&o>>>0>j>>>0;if((a|0)<(k|0)|(a|0)==(k|0)&e>>>0<j>>>0){if(!f)break;f=Ww(e|0,a|0,j|0,k|0)|0;t=+(f>>>0)+4294967296.0*+(F()|0);f=Ww(l|0,m|0,p|0,q|0)|0;t=(+(f>>>0)+4294967296.0*+(F()|0))*t;f=Ww(o|0,n|0,j|0,k|0)|0;d=+(f>>>0)+4294967296.0*+(F()|0);f=Ww(g|0,h|0,p|0,q|0)|0;d=t-(+(f>>>0)+4294967296.0*+(F()|0))*d;if(d!=0.0){b=((m|0)>(h|0)|(m|0)==(h|0)&l>>>0>g>>>0)^d>0.0?b:1-b|0;break}else{b=-1;a=15;break a}}if(!f){f=Ww(e|0,a|0,j|0,k|0)|0;t=+(f>>>0)+4294967296.0*+(F()|0);f=Ww(l|0,m|0,p|0,q|0)|0;t=(+(f>>>0)+4294967296.0*+(F()|0))*t;f=Ww(o|0,n|0,j|0,k|0)|0;d=+(f>>>0)+4294967296.0*+(F()|0);f=Ww(g|0,h|0,p|0,q|0)|0;d=t-(+(f>>>0)+4294967296.0*+(F()|0))*d;if(d!=0.0){b=((m|0)>(h|0)|(m|0)==(h|0)&l>>>0>g>>>0)^d>0.0?b:1-b|0;break}else{b=-1;a=15;break a}}else{b=1-b|0;break}}while(0);i=i+1|0;if(i>>>0>r>>>0){a=15;break}}if((a|0)==15)return b|0;return 0}function uc(a,b){a=a|0;b=b|0;var d=0.0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0.0;r=a+8|0;q=c[r>>2]|0;r=c[r+4>>2]|0;p=a;o=c[p>>2]|0;p=c[p+4>>2]|0;n=b;a=0;a:while(1){i=n;n=c[n+24>>2]|0;m=n+16|0;l=c[m>>2]|0;m=c[m+4>>2]|0;if((l|0)==(q|0)&(m|0)==(r|0)){g=n+8|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if((f|0)==(o|0)&(g|0)==(p|0)){a=-1;s=16;break}h=i+16|0;e=c[h>>2]|0;h=c[h+4>>2]|0;if((e|0)==(q|0)&(h|0)==(r|0)){k=i+8|0;j=c[k+4>>2]|0;if(!(((g|0)>(p|0)|(g|0)==(p|0)&f>>>0>o>>>0)^((j|0)<(p|0)|((j|0)==(p|0)?(c[k>>2]|0)>>>0<o>>>0:0)))){a=-1;s=16;break}if((m|0)<(r|0)|(m|0)==(r|0)&l>>>0<q>>>0){e=q;h=r;s=9;}}else s=8;}else{e=i+16|0;h=c[e+4>>2]|0;e=c[e>>2]|0;s=8;}if((s|0)==8){s=0;if(((m|0)<(r|0)|(m|0)==(r|0)&l>>>0<q>>>0)^((h|0)<(r|0)|(h|0)==(r|0)&e>>>0<q>>>0))s=9;}do if((s|0)==9){s=0;k=i+8|0;j=c[k>>2]|0;k=c[k+4>>2]|0;g=n+8|0;f=c[g>>2]|0;g=c[g+4>>2]|0;i=(g|0)>(p|0)|(g|0)==(p|0)&f>>>0>o>>>0;if((k|0)<(p|0)|(k|0)==(p|0)&j>>>0<o>>>0){if(!i)break;k=Ww(j|0,k|0,o|0,p|0)|0;t=+(k>>>0)+4294967296.0*+(F()|0);k=Ww(l|0,m|0,q|0,r|0)|0;t=(+(k>>>0)+4294967296.0*+(F()|0))*t;k=Ww(f|0,g|0,o|0,p|0)|0;d=+(k>>>0)+4294967296.0*+(F()|0);k=Ww(e|0,h|0,q|0,r|0)|0;d=t-(+(k>>>0)+4294967296.0*+(F()|0))*d;if(d!=0.0){a=((m|0)>(h|0)|(m|0)==(h|0)&l>>>0>e>>>0)^d>0.0?a:1-a|0;break}else{a=-1;s=16;break a}}if(!i){k=Ww(j|0,k|0,o|0,p|0)|0;t=+(k>>>0)+4294967296.0*+(F()|0);k=Ww(l|0,m|0,q|0,r|0)|0;t=(+(k>>>0)+4294967296.0*+(F()|0))*t;k=Ww(f|0,g|0,o|0,p|0)|0;d=+(k>>>0)+4294967296.0*+(F()|0);k=Ww(e|0,h|0,q|0,r|0)|0;d=t-(+(k>>>0)+4294967296.0*+(F()|0))*d;if(d!=0.0){a=((m|0)>(h|0)|(m|0)==(h|0)&l>>>0>e>>>0)^d>0.0?a:1-a|0;break}else{a=-1;s=16;break a}}else{a=1-a|0;break}}while(0);if((n|0)==(b|0)){s=16;break}}if((s|0)==16)return a|0;return 0}function vc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;g=a+32|0;f=a+40|0;e=a+8|0;e=Ww(c[f>>2]|0,c[f+4>>2]|0,c[e>>2]|0,c[e+4>>2]|0)|0;f=F()|0;i=b+32|0;h=b;h=Ww(c[i>>2]|0,c[i+4>>2]|0,c[h>>2]|0,c[h+4>>2]|0)|0;i=F()|0;if(d){q=(f|0)<0;u=_w(e|0,f|0,63)|0;F()|0;j=(i|0)<0;k=_w(h|0,i|0,63)|0;F()|0;k=(u|0)==(k|0);u=Ww(0,0,e|0,f|0)|0;p=F()|0;u=q?u:e;p=q?p:f;q=Ww(0,0,h|0,i|0)|0;m=F()|0;q=j?q:h;m=j?m:i;j=Uw(m|0,0,p|0,0)|0;t=F()|0;l=Uw(q|0,0,u|0,0)|0;f=F()|0;p=Uw(q|0,0,p|0,0)|0;q=F()|0;u=Uw(m|0,0,u|0,0)|0;u=Vw(p|0,q|0,u|0,F()|0)|0;t=Vw(F()|0,0,j|0,t|0)|0;j=F()|0;u=Vw(0,u|0,l|0,f|0)|0;q=F()|0;l=Vw(t|0,j|0,(q>>>0<f>>>0|(q|0)==(f|0)&u>>>0<l>>>0)&1|0,0)|0;f=F()|0;j=(u|0)==0&(q|0)==0;t=Ww(0,0,u|0,q|0)|0;p=F()|0;m=Ww(0,0,l|0,f|0)|0;e=F()|0;n=g;s=a;s=Ww(c[n>>2]|0,c[n+4>>2]|0,c[s>>2]|0,c[s+4>>2]|0)|0;n=F()|0;a=b+40|0;o=b+8|0;o=Ww(c[a>>2]|0,c[a+4>>2]|0,c[o>>2]|0,c[o+4>>2]|0)|0;a=F()|0;g=(n|0)<0;i=_w(s|0,n|0,63)|0;F()|0;r=(a|0)<0;d=_w(o|0,a|0,63)|0;F()|0;d=(i|0)==(d|0);i=Ww(0,0,s|0,n|0)|0;b=F()|0;s=g?i:s;n=g?b:n;b=Ww(0,0,o|0,a|0)|0;g=F()|0;o=r?b:o;a=r?g:a;g=Uw(a|0,0,n|0,0)|0;r=F()|0;b=Uw(o|0,0,s|0,0)|0;i=F()|0;n=Uw(o|0,0,n|0,0)|0;o=F()|0;s=Uw(a|0,0,s|0,0)|0;s=Vw(n|0,o|0,s|0,F()|0)|0;r=Vw(F()|0,0,g|0,r|0)|0;g=F()|0;s=Vw(0,s|0,b|0,i|0)|0;o=F()|0;b=Vw(r|0,g|0,(o>>>0<i>>>0|(o|0)==(i|0)&s>>>0<b>>>0)&1|0,0)|0;i=F()|0;g=(s|0)==0&(o|0)==0;r=Ww(0,0,s|0,o|0)|0;n=F()|0;a=Ww(0,0,b|0,i|0)|0;h=F()|0;return (((k?u:t)|0)==((d?s:r)|0)?((k?q:p)|0)==((d?o:n)|0):0)&(((k?l:j?m:~l)|0)==((d?b:g?a:~b)|0)?((k?f:j?e:~f)|0)==((d?i:g?h:~i)|0):0)|0}else{s=Uw(h|0,i|0,e|0,f|0)|0;u=F()|0;t=g;r=a;r=Ww(c[t>>2]|0,c[t+4>>2]|0,c[r>>2]|0,c[r+4>>2]|0)|0;t=F()|0;p=b+40|0;q=b+8|0;q=Ww(c[p>>2]|0,c[p+4>>2]|0,c[q>>2]|0,c[q+4>>2]|0)|0;t=Uw(q|0,F()|0,r|0,t|0)|0;return (s|0)==(t|0)&(u|0)==(F()|0)|0}}function wc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0.0,k=0.0,l=0.0,m=0,n=0,o=0,p=0,q=0,t=0.0,u=0.0,v=0.0;u=+g[a+48>>3];t=+g[b+48>>3];do if(u==t){f=a+24|0;e=c[f>>2]|0;f=c[f+4>>2]|0;b=d+8|0;c[b>>2]=e;c[b+4>>2]=f;b=a+40|0;if((c[b>>2]|0)==(e|0)?(c[b+4>>2]|0)==(f|0):0){f=a+32|0;e=c[f>>2]|0;f=c[f+4>>2]|0;break}else{b=a;q=c[b>>2]|0;b=c[b+4>>2]|0;a=a+8|0;e=Ww(e|0,f|0,c[a>>2]|0,c[a+4>>2]|0)|0;u=u*(+(e>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);e=Vw(q|0,b|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;f=F()|0;break}}else{do if(u==0.0){f=a;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d;c[h>>2]=e;c[h+4>>2]=f;h=b+8|0;i=c[h>>2]|0;h=c[h+4>>2]|0;if(t==-1.e+40){e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;break}else{q=b;l=(+(e>>>0)+4294967296.0*+(f|0))/t+(+(i>>>0)+4294967296.0*+(h|0)-(+((c[q>>2]|0)>>>0)+4294967296.0*+(c[q+4>>2]|0))/t);l=l+(l<0.0?-.5:.5);i=~~l>>>0;h=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;break}}else if(t==0.0){f=b;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d;c[h>>2]=e;c[h+4>>2]=f;h=a+8|0;i=c[h>>2]|0;h=c[h+4>>2]|0;if(u==-1.e+40){e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;break}else{q=a;l=(+(e>>>0)+4294967296.0*+(f|0))/u+(+(i>>>0)+4294967296.0*+(h|0)-(+((c[q>>2]|0)>>>0)+4294967296.0*+(c[q+4>>2]|0))/u);l=l+(l<0.0?-.5:.5);i=~~l>>>0;h=+s(l)>=1.0?(l>0.0?~~+B(+r(l/4294967296.0),4294967295.0)>>>0:~~+z((l-+(~~l>>>0))/4294967296.0)>>>0):0;e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;break}}else{i=a;h=a+8|0;j=+((c[i>>2]|0)>>>0)+4294967296.0*+(c[i+4>>2]|0)-u*(+((c[h>>2]|0)>>>0)+4294967296.0*+(c[h+4>>2]|0));h=b;i=b+8|0;k=+((c[h>>2]|0)>>>0)+4294967296.0*+(c[h+4>>2]|0)-t*(+((c[i>>2]|0)>>>0)+4294967296.0*+(c[i+4>>2]|0));l=(k-j)/(u-t);v=l+(l<0.0?-.5:.5);i=~~v>>>0;h=+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0;e=d+8|0;q=e;c[q>>2]=i;c[q+4>>2]=h;if(+s(+u)<+s(+t)){v=j+u*l;v=v+(v<0.0?-.5:.5);p=+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0;q=d;c[q>>2]=~~v>>>0;c[q+4>>2]=p;break}else{v=k+t*l;v=v+(v<0.0?-.5:.5);p=+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0;q=d;c[q>>2]=~~v>>>0;c[q+4>>2]=p;break}}while(0);q=a+40|0;n=q;f=c[n>>2]|0;n=c[n+4>>2]|0;p=b+40|0;o=p;m=c[o>>2]|0;o=c[o+4>>2]|0;if((h|0)<(n|0)|(h|0)==(n|0)&i>>>0<f>>>0|((h|0)<(o|0)|(h|0)==(o|0)&i>>>0<m>>>0)){h=(n|0)>(o|0)|(n|0)==(o|0)&f>>>0>m>>>0;i=h?f:m;h=h?n:o;o=e;c[o>>2]=i;c[o+4>>2]=h;do if(+s(+u)<+s(+t)){p=q;if((c[p>>2]|0)==(i|0)?(c[p+4>>2]|0)==(h|0):0){m=a+32|0;f=c[m>>2]|0;m=c[m+4>>2]|0;break}else{f=a;m=c[f>>2]|0;f=c[f+4>>2]|0;p=a+8|0;p=Ww(i|0,h|0,c[p>>2]|0,c[p+4>>2]|0)|0;v=u*(+(p>>>0)+4294967296.0*+(F()|0));v=v+(v<0.0?-.5:.5);f=Vw(m|0,f|0,~~v>>>0|0,(+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0)|0)|0;m=F()|0;break}}else if((c[p>>2]|0)==(i|0)?(c[p+4>>2]|0)==(h|0):0){m=b+32|0;f=c[m>>2]|0;m=c[m+4>>2]|0;break}else{f=b;m=c[f>>2]|0;f=c[f+4>>2]|0;p=b+8|0;p=Ww(i|0,h|0,c[p>>2]|0,c[p+4>>2]|0)|0;v=t*(+(p>>>0)+4294967296.0*+(F()|0));v=v+(v<0.0?-.5:.5);f=Vw(m|0,f|0,~~v>>>0|0,(+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0)|0)|0;m=F()|0;break}while(0);p=d;c[p>>2]=f;c[p+4>>2]=m;}m=a+24|0;f=c[m>>2]|0;m=c[m+4>>2]|0;if(!((h|0)>(m|0)|(h|0)==(m|0)&i>>>0>f>>>0))return;p=e;c[p>>2]=f;c[p+4>>2]=m;if(+s(+u)>+s(+t)){a=b+40|0;if((c[a>>2]|0)==(f|0)?(c[a+4>>2]|0)==(m|0):0){f=b+32|0;e=c[f>>2]|0;f=c[f+4>>2]|0;break}else{e=b;a=c[e>>2]|0;e=c[e+4>>2]|0;b=b+8|0;f=Ww(f|0,m|0,c[b>>2]|0,c[b+4>>2]|0)|0;v=t*(+(f>>>0)+4294967296.0*+(F()|0));v=v+(v<0.0?-.5:.5);e=Vw(a|0,e|0,~~v>>>0|0,(+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0)|0)|0;f=F()|0;break}}else{b=q;if((c[b>>2]|0)==(f|0)?(c[b+4>>2]|0)==(m|0):0){f=a+32|0;e=c[f>>2]|0;f=c[f+4>>2]|0;break}else{e=a;b=c[e>>2]|0;e=c[e+4>>2]|0;a=a+8|0;f=Ww(f|0,m|0,c[a>>2]|0,c[a+4>>2]|0)|0;v=u*(+(f>>>0)+4294967296.0*+(F()|0));v=v+(v<0.0?-.5:.5);e=Vw(b|0,e|0,~~v>>>0|0,(+s(v)>=1.0?(v>0.0?~~+B(+r(v/4294967296.0),4294967295.0)>>>0:~~+z((v-+(~~v>>>0))/4294967296.0)>>>0):0)|0)|0;f=F()|0;break}}}while(0);c[d>>2]=e;c[d+4>>2]=f;return}function xc(a,b){a=a|0;b=b|0;var d=0.0,e=0,f=0,g=0,h=0,i=0,j=0.0,k=0,l=0,m=0,n=0,o=0,p=0.0,q=0.0,r=0,t=0,u=0,v=0,w=0,x=0,y=0;r=c[a+28>>2]|0;y=r+8|0;x=c[y>>2]|0;y=c[y+4>>2]|0;u=a+8|0;t=c[u>>2]|0;u=c[u+4>>2]|0;w=a+16|0;v=c[w>>2]|0;w=c[w+4>>2]|0;a:do if((x|0)==(t|0)&(y|0)==(u|0)){e=r;while(1){o=e+16|0;if((e|0)==(a|0)|((c[o>>2]|0)!=(v|0)?1:(c[o+4>>2]|0)!=(w|0))){h=x;i=y;break a}e=c[e+28>>2]|0;o=e+8|0;if(!((c[o>>2]|0)==(x|0)?(c[o+4>>2]|0)==(y|0):0)){h=x;i=y;break}}}else{e=r;h=t;i=u;}while(0);g=e+16|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if((f|0)==(v|0)&(g|0)==(w|0))d=-1.e+40;else{o=e+8|0;o=Ww(c[o>>2]|0,c[o+4>>2]|0,t|0,u|0)|0;d=+(o>>>0)+4294967296.0*+(F()|0);o=Ww(f|0,g|0,v|0,w|0)|0;d=d/(+(o>>>0)+4294967296.0*+(F()|0));}q=+s(+d);e=c[a+24>>2]|0;o=e+8|0;b:do if((c[o>>2]|0)==(h|0)?(c[o+4>>2]|0)==(i|0):0){f=e;do{o=f+16|0;if((f|0)==(a|0)|((c[o>>2]|0)!=(v|0)?1:(c[o+4>>2]|0)!=(w|0)))break b;f=c[f+24>>2]|0;o=f+8|0;}while((c[o>>2]|0)==(h|0)?(c[o+4>>2]|0)==(i|0):0)}else f=e;while(0);h=f+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((g|0)==(v|0)&(h|0)==(w|0))d=-1.e+40;else{o=f+8|0;o=Ww(c[o>>2]|0,c[o+4>>2]|0,t|0,u|0)|0;d=+(o>>>0)+4294967296.0*+(F()|0);o=Ww(g|0,h|0,v|0,w|0)|0;d=d/(+(o>>>0)+4294967296.0*+(F()|0));}p=+s(+d);f=c[b+28>>2]|0;h=f+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;m=b+8|0;l=c[m>>2]|0;m=c[m+4>>2]|0;o=b+16|0;n=c[o>>2]|0;o=c[o+4>>2]|0;c:do if((g|0)==(l|0)&(h|0)==(m|0))while(1){k=f+16|0;if((f|0)==(b|0)|((c[k>>2]|0)!=(n|0)?1:(c[k+4>>2]|0)!=(o|0))){k=g;i=h;break c}f=c[f+28>>2]|0;k=f+8|0;if(!((c[k>>2]|0)==(g|0)?(c[k+4>>2]|0)==(h|0):0)){k=g;i=h;break}}else{k=l;i=m;}while(0);h=f+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((g|0)==(n|0)&(h|0)==(o|0))d=-1.e+40;else{f=f+8|0;f=Ww(c[f>>2]|0,c[f+4>>2]|0,l|0,m|0)|0;d=+(f>>>0)+4294967296.0*+(F()|0);h=Ww(g|0,h|0,n|0,o|0)|0;d=d/(+(h>>>0)+4294967296.0*+(F()|0));}j=+s(+d);f=c[b+24>>2]|0;h=f+8|0;d:do if((c[h>>2]|0)==(k|0)?(c[h+4>>2]|0)==(i|0):0)do{h=f+16|0;if((f|0)==(b|0)|((c[h>>2]|0)!=(n|0)?1:(c[h+4>>2]|0)!=(o|0)))break d;f=c[f+24>>2]|0;h=f+8|0;}while((c[h>>2]|0)==(k|0)?(c[h+4>>2]|0)==(i|0):0);while(0);h=f+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((g|0)==(n|0)&(h|0)==(o|0))d=-1.e+40;else{b=f+8|0;b=Ww(c[b>>2]|0,c[b+4>>2]|0,l|0,m|0)|0;d=+(b>>>0)+4294967296.0*+(F()|0);b=Ww(g|0,h|0,n|0,o|0)|0;d=d/(+(b>>>0)+4294967296.0*+(F()|0));}d=+s(+d);if((q<p?p:q)==(j<d?d:j)?(p<q?p:q)==(d<j?d:j):0){if(!a){a=0;return a|0}y=Vw(t|0,u|0,x|0,y|0)|0;d=+(y>>>0)+4294967296.0*+(F()|0);y=r+16|0;y=Ww(c[y>>2]|0,c[y+4>>2]|0,v|0,w|0)|0;d=d*(+(y>>>0)+4294967296.0*+(F()|0))+0.0;if((e|0)!=(a|0))do{w=c[e+28>>2]|0;v=w+8|0;u=e+8|0;y=e+16|0;x=c[y>>2]|0;y=c[y+4>>2]|0;e=c[e+24>>2]|0;v=Vw(c[u>>2]|0,c[u+4>>2]|0,c[v>>2]|0,c[v+4>>2]|0)|0;q=+(v>>>0)+4294967296.0*+(F()|0);w=w+16|0;y=Ww(c[w>>2]|0,c[w+4>>2]|0,x|0,y|0)|0;d=d+q*(+(y>>>0)+4294967296.0*+(F()|0));}while((e|0)!=(a|0));a=d*.5>0.0;return a|0}if(!(!(q>=j)|!(q>=d))){a=1;return a|0}if(!(p>=j)){a=0;return a|0}a=p>=d;return a|0}function yc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;c[b>>2]=3528;i=b+8|0;h=c[i>>2]|0;k=b+12|0;c[k>>2]=h;c[b+4>>2]=h;h=b+24|0;j=b+28|0;e=c[j>>2]|0;d=c[h>>2]|0;if((e|0)==(d|0))d=e;else{g=0;do{f=c[d+(g<<2)>>2]|0;if(f){ak(f);d=c[h>>2]|0;e=c[j>>2]|0;}g=g+1|0;}while(g>>>0<e-d>>2>>>0)}c[j>>2]=d;a[b+20>>0]=0;a[b+37>>0]=0;d=c[b+56>>2]|0;if(d|0){c[b+60>>2]=d;$j(d);}d=c[b+40>>2]|0;if(d|0){c[b+44>>2]=d;$j(d);}d=c[h>>2]|0;if(d|0){c[j>>2]=d;$j(d);}d=c[i>>2]|0;if(!d)return;c[k>>2]=d;$j(d);return}function Ac(a){a=a|0;yc(a);$j(a);return}function Bc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0;c[b>>2]=3588;e=b+4|0;c[e>>2]=0;c[e+4>>2]=0;c[e+8>>2]=0;f=ai(d)|0;if(f>>>0>4294967279)fk();if(f>>>0<11){a[e+11>>0]=f;if(!f){d=e;f=d+f|0;a[f>>0]=0;return}}else{h=f+16&-16;g=Zj(h)|0;c[e>>2]=g;c[b+12>>2]=h|-2147483648;c[b+8>>2]=f;e=g;}ax(e|0,d|0,f|0)|0;h=e;h=h+f|0;a[h>>0]=0;return}function Cc(b){b=b|0;c[b>>2]=3588;b=b+4|0;if((a[b+11>>0]|0)>=0)return;$j(c[b>>2]|0);return}function Dc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,i=0.0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0.0,u=0;u=Eb;Eb=Eb+16|0;k=u;if((c[b+76>>2]|0)==-2){a:do if(d){e=b;while(1){r=e+40|0;f=c[e+80>>2]|0;s=f+8|0;if((c[r>>2]|0)==(c[s>>2]|0)?(c[r+4>>2]|0)==(c[s+4>>2]|0):0)e=f;else break}if((e|0)!=(b|0))do{if(!(+g[e+48>>3]==-1.e+40)){h=e;j=15;break a}e=c[e+84>>2]|0;}while((e|0)!=(b|0))}else{e=b;while(1){r=e+40|0;f=c[e+84>>2]|0;s=f+8|0;if((c[r>>2]|0)==(c[s>>2]|0)?(c[r+4>>2]|0)==(c[s+4>>2]|0):0)e=f;else break}if((e|0)!=(b|0))do{if(!(+g[e+48>>3]==-1.e+40)){h=e;j=15;break a}e=c[e+80>>2]|0;}while((e|0)!=(b|0))}while(0);if((j|0)==15?(h|0)!=(b|0):0){e=c[(d?b+80|0:b+84|0)>>2]|0;b=e+8|0;h=c[b+4>>2]|0;f=k;c[f>>2]=c[b>>2];c[f+4>>2]=h;c[k+8>>2]=0;c[k+12>>2]=e;c[e+64>>2]=0;e=Dc(a,e,d)|0;f=a+12|0;h=c[f>>2]|0;if((h|0)==(c[a+16>>2]|0))Je(a+8|0,k);else{c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];c[h+8>>2]=c[k+8>>2];c[h+12>>2]=c[k+12>>2];c[f>>2]=(c[f>>2]|0)+16;}b=e;Eb=u;return b|0}if(d){b=c[b+80>>2]|0;Eb=u;return b|0}else{b=c[b+84>>2]|0;Eb=u;return b|0}}t=+g[b+48>>3];do if(t==-1.e+40){e=c[(d?b+84|0:b+80|0)>>2]|0;j=e;h=b;f=c[h>>2]|0;h=c[h+4>>2]|0;j=(c[j>>2]|0)!=(f|0)?1:(c[j+4>>2]|0)!=(h|0);if(!(+g[e+48>>3]==-1.e+40)){if(!j)break;k=b+32|0;a=k;j=c[a>>2]|0;a=c[a+4>>2]|0;c[k>>2]=f;c[k+4>>2]=h;k=b;c[k>>2]=j;c[k+4>>2]=a;break}if(j?(k=e+32|0,!((c[k>>2]|0)==(f|0)?(c[k+4>>2]|0)==(h|0):0)):0){k=b+32|0;a=k;j=c[a>>2]|0;a=c[a+4>>2]|0;c[k>>2]=f;c[k+4>>2]=h;k=b;c[k>>2]=j;c[k+4>>2]=a;}}while(0);h=b+40|0;e=c[h>>2]|0;h=c[h+4>>2]|0;if(d){f=c[b+80>>2]|0;s=f+8|0;if((e|0)==(c[s>>2]|0)?(h|0)==(c[s+4>>2]|0):0){e=b;while(1){if((c[f+76>>2]|0)==-2)break;r=f+40|0;h=c[f+80>>2]|0;s=h+8|0;if((c[r>>2]|0)==(c[s>>2]|0)?(c[r+4>>2]|0)==(c[s+4>>2]|0):0){e=f;f=h;}else{e=f;f=h;break}}h=e;i=+g[e+48>>3];}else{h=b;i=t;}if(i==-1.e+40?(c[f+76>>2]|0)!=-2:0){e=h;do e=c[e+84>>2]|0;while(+g[e+48>>3]==-1.e+40);s=e+32|0;q=c[s+4>>2]|0;f=f+32|0;r=c[f+4>>2]|0;f=(q|0)>(r|0)|((q|0)==(r|0)?(c[s>>2]|0)>>>0>(c[f>>2]|0)>>>0:0)?e:h;}else f=h;if((f|0)!=(b|0)){h=b;i=t;while(1){e=c[h+80>>2]|0;c[h+88>>2]=e;if(!((h|0)==(b|0)|i!=-1.e+40)?(m=h,l=c[m>>2]|0,m=c[m+4>>2]|0,s=(c[h+84>>2]|0)+32|0,!((l|0)==(c[s>>2]|0)?(m|0)==(c[s+4>>2]|0):0)):0){s=h+32|0;r=s;q=c[r>>2]|0;r=c[r+4>>2]|0;c[s>>2]=l;c[s+4>>2]=m;s=h;c[s>>2]=q;c[s+4>>2]=r;}if((f|0)==(e|0))break;h=e;i=+g[e+48>>3];}if(!((f|0)==(b|0)?1:+g[f+48>>3]!=-1.e+40)?(o=f,n=c[o>>2]|0,o=c[o+4>>2]|0,b=(c[f+84>>2]|0)+32|0,!((n|0)==(c[b>>2]|0)?(o|0)==(c[b+4>>2]|0):0)):0){b=f+32|0;s=b;r=c[s>>2]|0;s=c[s+4>>2]|0;c[b>>2]=n;c[b+4>>2]=o;b=f;c[b>>2]=r;c[b+4>>2]=s;}}e=f+80|0;}else{f=c[b+84>>2]|0;o=f+8|0;if((e|0)==(c[o>>2]|0)?(h|0)==(c[o+4>>2]|0):0){e=b;while(1){if((c[f+76>>2]|0)==-2)break;n=f+40|0;h=c[f+84>>2]|0;o=h+8|0;if((c[n>>2]|0)==(c[o>>2]|0)?(c[n+4>>2]|0)==(c[o+4>>2]|0):0){e=f;f=h;}else{e=f;f=h;break}}h=e;i=+g[e+48>>3];}else{h=b;i=t;}if(i==-1.e+40?(c[f+76>>2]|0)!=-2:0){e=h;do e=c[e+80>>2]|0;while(+g[e+48>>3]==-1.e+40);o=e+32|0;m=c[o+4>>2]|0;f=f+32|0;n=c[f+4>>2]|0;f=(m|0)<(n|0)|((m|0)==(n|0)?(c[o>>2]|0)>>>0<(c[f>>2]|0)>>>0:0)?h:e;}else f=h;if((f|0)!=(b|0)){h=b;i=t;while(1){e=c[h+84>>2]|0;c[h+88>>2]=e;if(!((h|0)==(b|0)|i!=-1.e+40)?(q=h,p=c[q>>2]|0,q=c[q+4>>2]|0,o=(c[h+80>>2]|0)+32|0,!((p|0)==(c[o>>2]|0)?(q|0)==(c[o+4>>2]|0):0)):0){o=h+32|0;n=o;m=c[n>>2]|0;n=c[n+4>>2]|0;c[o>>2]=p;c[o+4>>2]=q;o=h;c[o>>2]=m;c[o+4>>2]=n;}if((f|0)==(e|0))break;h=e;i=+g[e+48>>3];}if(!((f|0)==(b|0)?1:+g[f+48>>3]!=-1.e+40)?(s=f,r=c[s>>2]|0,s=c[s+4>>2]|0,b=(c[f+80>>2]|0)+32|0,!((r|0)==(c[b>>2]|0)?(s|0)==(c[b+4>>2]|0):0)):0){b=f+32|0;q=b;p=c[q>>2]|0;q=c[q+4>>2]|0;c[b>>2]=r;c[b+4>>2]=s;b=f;c[b>>2]=p;c[b+4>>2]=q;}}e=f+84|0;}b=c[e>>2]|0;Eb=u;return b|0}function Ec(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,i=0,j=0,k=0,l=0.0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,T=0,U=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0;K=Eb;Eb=Eb+32|0;I=K+16|0;J=K;G=f^1;if((e|0)==1&G){K=S(16)|0;Bc(K,7530);V(K|0,1024,9);}n=c[d>>2]|0;H=(c[d+4>>2]|0)-n|0;h=(H>>4)+-1|0;a:do if((H|0)>16&f){k=n;j=c[k>>2]|0;k=c[k+4>>2]|0;m=n+8|0;while(1){H=n+(h<<4)|0;if(!((c[H>>2]|0)==(j|0)?(c[H+4>>2]|0)==(k|0):0))break a;E=n+(h<<4)+8|0;H=m;if(!((c[E>>2]|0)==(c[H>>2]|0)?(c[E+4>>2]|0)==(c[H+4>>2]|0):0))break a;i=h+-1|0;if((h|0)>1)h=i;else{h=i;break}}}while(0);b:do if((h|0)>0){k=n+(h<<4)|0;j=c[k>>2]|0;k=c[k+4>>2]|0;while(1){i=h+-1|0;H=n+(i<<4)|0;if(!((j|0)==(c[H>>2]|0)?(k|0)==(c[H+4>>2]|0):0))break b;E=n+(h<<4)+8|0;H=n+(i<<4)+8|0;if(!((c[E>>2]|0)==(c[H>>2]|0)?(c[E+4>>2]|0)==(c[H+4>>2]|0):0))break b;if((h|0)>1)h=i;else{h=i;break}}}while(0);if(f?(h|0)<2:(h|0)<1){b=0;Eb=K;return b|0}i=h+1|0;H=_j(i>>>0>38347922?-1:i*112|0)|0;if(!i){o=d;k=n;}else{i=H+(i*112|0)|0;j=H;do{p=j;q=p+48|0;do{c[p>>2]=0;p=p+4|0;}while((p|0)<(q|0));j=j+112|0;}while((j|0)!=(i|0));o=d;k=c[d>>2]|0;}c[I>>2]=H;j=k+16|0;D=H+128|0;c[D>>2]=c[j>>2];c[D+4>>2]=c[j+4>>2];c[D+8>>2]=c[j+8>>2];c[D+12>>2]=c[j+12>>2];D=b+20|0;j=k;i=c[j>>2]|0;j=c[j+4>>2]|0;E=H;do if(!(a[D>>0]|0)){A=k+8|0;A=Vw(c[A>>2]|0,c[A+4>>2]|0,1073741823,0)|0;z=F()|0;C=Vw(i|0,j|0,1073741823,0)|0;B=F()|0;if(z>>>0>0|(z|0)==0&A>>>0>2147483646|(B>>>0>0|(B|0)==0&C>>>0>2147483646)){a[D>>0]=1;s=22;break}i=k+(h<<4)|0;j=c[i>>2]|0;i=c[i+4>>2]|0;C=k+(h<<4)+8|0;C=Vw(c[C>>2]|0,c[C+4>>2]|0,1073741823,0)|0;B=F()|0;if(B>>>0>0|(B|0)==0&C>>>0>2147483646){a[D>>0]=1;s=29;break}C=Vw(j|0,i|0,1073741823,0)|0;B=F()|0;if(B>>>0>0|(B|0)==0&C>>>0>2147483646){a[D>>0]=1;s=29;}else n=0;}else s=22;while(0);do if((s|0)==22){if((j|0)>2097151|(j|0)==2097151&i>>>0>4294967295){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;p=h+12|0;c[p>>2]=-2147483600;p=h+8|0;c[p>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));K=i+32|0;a[K>>0]=0;V(h|0,1024,9);}C=k+8|0;C=Vw(c[C>>2]|0,c[C+4>>2]|0,-1,2097151)|0;B=F()|0;if((j|0)<-2097152|(j|0)==-2097152&i>>>0<1|(B>>>0>4194303|(B|0)==4194303&C>>>0>4294967294)){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;p=h+12|0;c[p>>2]=-2147483600;p=h+8|0;c[p>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));K=i+32|0;a[K>>0]=0;V(h|0,1024,9);}else{j=k+(h<<4)|0;i=c[j+4>>2]|0;j=c[j>>2]|0;s=29;break}}while(0);if((s|0)==29){if((i|0)>2097151|(i|0)==2097151&j>>>0>4294967295){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;p=h+12|0;c[p>>2]=-2147483600;p=h+8|0;c[p>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));K=i+32|0;a[K>>0]=0;V(h|0,1024,9);}C=k+(h<<4)+8|0;C=Vw(c[C>>2]|0,c[C+4>>2]|0,-1,2097151)|0;B=F()|0;if((i|0)<-2097152|(i|0)==-2097152&j>>>0<1|(B>>>0>4194303|(B|0)==4194303&C>>>0>4294967294)){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;p=h+12|0;c[p>>2]=-2147483600;p=h+8|0;c[p>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));K=i+32|0;a[K>>0]=0;V(h|0,1024,9);}else n=1;}i=H+112|0;m=H+(h*112|0)|0;p=H;q=p+112|0;do{c[p>>2]=0;p=p+4|0;}while((p|0)<(q|0));c[H+80>>2]=i;c[H+84>>2]=m;j=H+16|0;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];c[j+8>>2]=c[k+8>>2];c[j+12>>2]=c[k+12>>2];c[H+76>>2]=-1;j=h+-1|0;k=H+(j*112|0)|0;d=c[o>>2]|0;i=d+(h<<4)|0;p=m;q=p+112|0;do{c[p>>2]=0;p=p+4|0;}while((p|0)<(q|0));c[H+(h*112|0)+80>>2]=H;c[H+(h*112|0)+84>>2]=k;C=H+(h*112|0)+16|0;c[C>>2]=c[i>>2];c[C+4>>2]=c[i+4>>2];c[C+8>>2]=c[i+8>>2];c[C+12>>2]=c[i+12>>2];c[H+(h*112|0)+76>>2]=-1;c:do if((h|0)>1){o=j;h=n;while(1){m=d+(o<<4)|0;j=m;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!(h<<24>>24)){A=d+(o<<4)+8|0;A=Vw(c[A>>2]|0,c[A+4>>2]|0,1073741823,0)|0;z=F()|0;C=Vw(i|0,j|0,1073741823,0)|0;B=F()|0;if(z>>>0>0|(z|0)==0&A>>>0>2147483646|(B>>>0>0|(B|0)==0&C>>>0>2147483646)){a[D>>0]=1;h=1;s=39;}else h=0;}else s=39;if((s|0)==39){s=0;if((j|0)>2097151|(j|0)==2097151&i>>>0>4294967295){s=41;break}C=d+(o<<4)+8|0;C=Vw(c[C>>2]|0,c[C+4>>2]|0,-1,2097151)|0;B=F()|0;if((j|0)<-2097152|(j|0)==-2097152&i>>>0<1|(B>>>0>4194303|(B|0)==4194303&C>>>0>4294967294)){s=41;break}}j=H+((o+1|0)*112|0)|0;i=o;o=o+-1|0;k=H+(o*112|0)|0;p=H+(i*112|0)|0;q=p+112|0;do{c[p>>2]=0;p=p+4|0;}while((p|0)<(q|0));c[H+(i*112|0)+80>>2]=j;c[H+(i*112|0)+84>>2]=k;C=H+(i*112|0)+16|0;c[C>>2]=c[m>>2];c[C+4>>2]=c[m+4>>2];c[C+8>>2]=c[m+8>>2];c[C+12>>2]=c[m+12>>2];c[H+(i*112|0)+76>>2]=-1;if((i|0)<=1)break c}if((s|0)==41){h=S(16)|0;c[h>>2]=3588;p=h+4|0;c[p>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;i=Zj(48)|0;c[p>>2]=i;c[h+12>>2]=-2147483600;c[h+8>>2]=32;p=i;j=7464;q=p+32|0;do{a[p>>0]=a[j>>0]|0;p=p+1|0;j=j+1|0;}while((p|0)<(q|0));a[i+32>>0]=0;V(h|0,1024,9);}}while(0);C=b+36|0;j=H;k=H;d:while(1){n=j+16|0;h=j;m=c[n>>2]|0;n=c[n+4>>2]|0;e:while(1){i=c[h+80>>2]|0;o=h+16|0;B=i+16|0;A=c[B>>2]|0;B=c[B+4>>2]|0;if((m|0)==(A|0)&(n|0)==(B|0)?(y=h+24|0,z=i+24|0,!(((c[y>>2]|0)!=(c[z>>2]|0)?1:(c[y+4>>2]|0)!=(c[z+4>>2]|0))|(i|0)==(k|0)&G)):0){s=45;break}z=c[h+84>>2]|0;if((z|0)==(i|0)){s=66;break d}do if(f){w=z+16|0;v=c[w>>2]|0;w=c[w+4>>2]|0;y=z+24|0;x=c[y>>2]|0;y=c[y+4>>2]|0;q=o;p=c[q>>2]|0;q=c[q+4>>2]|0;s=h+24|0;r=c[s>>2]|0;s=c[s+4>>2]|0;u=i+24|0;t=c[u>>2]|0;u=c[u+4>>2]|0;L=(a[D>>0]|0)==0;m=Ww(x|0,y|0,r|0,s|0)|0;n=F()|0;o=Ww(p|0,q|0,A|0,B|0)|0;d=F()|0;if(L){o=Uw(o|0,d|0,m|0,n|0)|0;L=F()|0;n=Ww(v|0,w|0,p|0,q|0)|0;d=F()|0;m=Ww(r|0,s|0,t|0,u|0)|0;d=Uw(m|0,F()|0,n|0,d|0)|0;if(!((o|0)==(d|0)&(L|0)==(F()|0)))break}else{Y=(n|0)<0;aa=_w(m|0,n|0,63)|0;F()|0;N=(d|0)<0;O=_w(o|0,d|0,63)|0;F()|0;O=(aa|0)==(O|0);aa=Ww(0,0,m|0,n|0)|0;X=F()|0;aa=Y?aa:m;X=Y?X:n;Y=Ww(0,0,o|0,d|0)|0;T=F()|0;Y=N?Y:o;T=N?T:d;N=Uw(T|0,0,X|0,0)|0;$=F()|0;R=Uw(Y|0,0,aa|0,0)|0;m=F()|0;X=Uw(Y|0,0,X|0,0)|0;Y=F()|0;aa=Uw(T|0,0,aa|0,0)|0;aa=Vw(X|0,Y|0,aa|0,F()|0)|0;$=Vw(F()|0,0,N|0,$|0)|0;N=F()|0;aa=Vw(0,aa|0,R|0,m|0)|0;Y=F()|0;R=Vw($|0,N|0,(Y>>>0<m>>>0|(Y|0)==(m|0)&aa>>>0<R>>>0)&1|0,0)|0;m=F()|0;N=(aa|0)==0&(Y|0)==0;$=Ww(0,0,aa|0,Y|0)|0;X=F()|0;T=Ww(0,0,R|0,m|0)|0;M=F()|0;_=Ww(v|0,w|0,p|0,q|0)|0;U=F()|0;W=Ww(r|0,s|0,t|0,u|0)|0;Q=F()|0;o=(U|0)<0;L=_w(_|0,U|0,63)|0;F()|0;Z=(Q|0)<0;n=_w(W|0,Q|0,63)|0;F()|0;n=(L|0)==(n|0);L=Ww(0,0,_|0,U|0)|0;P=F()|0;_=o?L:_;U=o?P:U;P=Ww(0,0,W|0,Q|0)|0;o=F()|0;W=Z?P:W;Q=Z?o:Q;o=Uw(Q|0,0,U|0,0)|0;Z=F()|0;P=Uw(W|0,0,_|0,0)|0;L=F()|0;U=Uw(W|0,0,U|0,0)|0;W=F()|0;_=Uw(Q|0,0,_|0,0)|0;_=Vw(U|0,W|0,_|0,F()|0)|0;Z=Vw(F()|0,0,o|0,Z|0)|0;o=F()|0;_=Vw(0,_|0,P|0,L|0)|0;W=F()|0;P=Vw(Z|0,o|0,(W>>>0<L>>>0|(W|0)==(L|0)&_>>>0<P>>>0)&1|0,0)|0;L=F()|0;o=(_|0)==0&(W|0)==0;Z=Ww(0,0,_|0,W|0)|0;U=F()|0;Q=Ww(0,0,P|0,L|0)|0;d=F()|0;if(!((((O?aa:$)|0)==((n?_:Z)|0)?((O?Y:X)|0)==((n?W:U)|0):0)&(((O?R:N?T:~R)|0)==((n?P:o?Q:~P)|0)?((O?m:N?M:~m)|0)==((n?L:o?d:~L)|0):0)))break}if(!(a[C>>0]|0)){s=61;break e}m=(v|0)==(A|0)&(w|0)==(B|0);if(m&((x|0)==(t|0)&(y|0)==(u|0))){s=61;break e}if((v|0)==(p|0)&(w|0)==(q|0)&((x|0)==(r|0)&(y|0)==(s|0))){s=61;break e}if((p|0)==(A|0)&(q|0)==(B|0)&((r|0)==(t|0)&(s|0)==(u|0))){s=61;break e}if(m)if(((y|0)<(s|0)|(y|0)==(s|0)&x>>>0<r>>>0)^((s|0)<(u|0)|(s|0)==(u|0)&r>>>0<t>>>0)){s=61;break e}else break;else if(((w|0)<(q|0)|(w|0)==(q|0)&v>>>0<p>>>0)^((q|0)<(B|0)|(q|0)==(B|0)&p>>>0<A>>>0)){s=61;break e}else break}while(0);if((i|0)==(j|0)){h=j;s=66;break d}if(!f?(c[i+80>>2]|0)==(k|0):0){h=k;s=68;break d}h=i;m=A;n=B;}if((s|0)==45){if((h|0)==(i|0)){s=66;break}aa=h+84|0;$=c[aa>>2]|0;c[$+80>>2]=i;j=c[h+80>>2]|0;c[j+84>>2]=$;c[aa>>2]=0;k=(h|0)==(k|0)?i:k;}else if((s|0)==61){c[z+80>>2]=i;j=(c[h+80>>2]|0)+84|0;c[j>>2]=z;c[h+84>>2]=0;j=c[j>>2]|0;k=(h|0)==(k|0)?i:k;}}do if((s|0)==66)if(f)if((c[h+84>>2]|0)==(c[h+80>>2]|0)){s=70;break}else{s=72;break}else{i=h;h=c[h+80>>2]|0;s=68;break}while(0);if((s|0)==68)if((i|0)==(h|0))s=70;else{a[b+37>>0]=1;c[(c[k+84>>2]|0)+76>>2]=-2;s=72;}f:do if((s|0)==70){ak(H);h=0;}else if((s|0)==72){d=k+24|0;h=1;o=k;do{i=o+16|0;$=o+24|0;Z=c[$+4>>2]|0;m=o;o=c[o+80>>2]|0;n=o+24|0;aa=n;_=c[aa+4>>2]|0;if((Z|0)<(_|0)|((Z|0)==(_|0)?(c[$>>2]|0)>>>0<(c[aa>>2]|0)>>>0:0)){aa=m+32|0;c[aa>>2]=c[i>>2];c[aa+4>>2]=c[i+4>>2];c[aa+8>>2]=c[i+8>>2];c[aa+12>>2]=c[i+12>>2];aa=o+16|0;c[m>>2]=c[aa>>2];c[m+4>>2]=c[aa+4>>2];c[m+8>>2]=c[aa+8>>2];c[m+12>>2]=c[aa+12>>2];}else{c[m>>2]=c[i>>2];c[m+4>>2]=c[i+4>>2];c[m+8>>2]=c[i+8>>2];c[m+12>>2]=c[i+12>>2];$=o+16|0;aa=m+32|0;c[aa>>2]=c[$>>2];c[aa+4>>2]=c[$+4>>2];c[aa+8>>2]=c[$+8>>2];c[aa+12>>2]=c[$+12>>2];}j=m+40|0;i=m+8|0;i=Ww(c[j>>2]|0,c[j+4>>2]|0,c[i>>2]|0,c[i+4>>2]|0)|0;j=F()|0;if((i|0)==0&(j|0)==0)l=-1.e+40;else{$=m+32|0;aa=m;aa=Ww(c[$>>2]|0,c[$+4>>2]|0,c[aa>>2]|0,c[aa+4>>2]|0)|0;l=(+(aa>>>0)+4294967296.0*+(F()|0))/(+(i>>>0)+4294967296.0*+(j|0));}g[m+48>>3]=l;c[m+56>>2]=e;if(h){aa=n;h=d;h=(c[aa>>2]|0)==(c[h>>2]|0)?(c[aa+4>>2]|0)==(c[h+4>>2]|0):0;}else h=0;}while((o|0)!=(k|0));if(h){if(f){ak(H);h=0;break}j=c[k+84>>2]|0;c[j+76>>2]=-2;_=k+8|0;$=c[_+4>>2]|0;aa=J;c[aa>>2]=c[_>>2];c[aa+4>>2]=$;c[J+8>>2]=0;c[J+12>>2]=k;c[k+60>>2]=2;c[k+64>>2]=0;while(1){i=k;h=c[i>>2]|0;i=c[i+4>>2]|0;aa=j+32|0;if(!((h|0)==(c[aa>>2]|0)?(i|0)==(c[aa+4>>2]|0):0)){aa=k+32|0;$=aa;_=c[$>>2]|0;$=c[$+4>>2]|0;c[aa>>2]=h;c[aa+4>>2]=i;aa=k;c[aa>>2]=_;c[aa+4>>2]=$;}h=c[k+80>>2]|0;if((c[h+76>>2]|0)==-2)break;c[k+88>>2]=h;k=h;j=c[h+84>>2]|0;}h=b+12|0;i=c[h>>2]|0;if((i|0)==(c[b+16>>2]|0))Je(b+8|0,J);else{c[i>>2]=c[J>>2];c[i+4>>2]=c[J+4>>2];c[i+8>>2]=c[J+8>>2];c[i+12>>2]=c[J+12>>2];c[h>>2]=(c[h>>2]|0)+16;}h=b+28|0;i=c[h>>2]|0;if((i|0)==(c[b+32>>2]|0))Ke(b+24|0,I);else{c[i>>2]=c[I>>2];c[h>>2]=(c[h>>2]|0)+4;}h=1;break}h=b+28|0;i=c[h>>2]|0;if((i|0)==(c[b+32>>2]|0))Ke(b+24|0,I);else{c[i>>2]=E;c[h>>2]=(c[h>>2]|0)+4;}h=c[k+84>>2]|0;$=h;aa=h+32|0;if(((c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0)?($=h+8|0,aa=h+40|0,(c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0):0)k=c[k+80>>2]|0;o=J+8|0;d=J+12|0;p=b+12|0;q=b+16|0;r=b+8|0;m=0;while(1){g:while(1){h=c[k+84>>2]|0;$=k;aa=h;do if(((c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0)?($=k+8|0,aa=h+8|0,(c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0):0){$=k+16|0;aa=k+32|0;if(((c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0)?($=k+24|0,aa=k+40|0,(c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0):0){s=108;break}l=+g[k+48>>3];i=+g[h+48>>3]==-1.e+40;if(l==-1.e+40)if(i)s=113;else j=k;else if(i)s=113;else break g;if((s|0)==113){s=0;i=h;while(1){h=c[i+84>>2]|0;if(+g[h+48>>3]==-1.e+40)i=h;else break}j=i;l=+g[i+48>>3];}if(l==-1.e+40){i=j;do i=c[i+80>>2]|0;while(+g[i+48>>3]==-1.e+40);k=i;i=c[i+84>>2]|0;}else{k=j;i=h;}$=k+40|0;aa=i+8|0;if(!((c[$>>2]|0)==(c[aa>>2]|0)?(c[$+4>>2]|0)==(c[aa+4>>2]|0):0)){s=121;break g}}else s=108;while(0);if((s|0)==108){s=0;k=c[k+80>>2]|0;}}if((s|0)==121){s=0;$=h;Z=c[$+4>>2]|0;aa=k;_=c[aa+4>>2]|0;k=(Z|0)<(_|0)|((Z|0)==(_|0)?(c[$>>2]|0)>>>0<(c[aa>>2]|0)>>>0:0)?j:k;}if((k|0)==(m|0)){h=1;break f}m=(m|0)==0?k:m;$=k+8|0;aa=c[$+4>>2]|0;h=J;c[h>>2]=c[$>>2];c[h+4>>2]=aa;h=c[k+84>>2]|0;if(+g[k+48>>3]<+g[h+48>>3]){c[o>>2]=h;c[d>>2]=k;n=0;i=h;}else{c[o>>2]=k;c[d>>2]=h;n=1;i=k;k=h;}do if(f){h=i+64|0;if((c[i+80>>2]|0)==(k|0)){c[h>>2]=-1;h=1;break}else{c[h>>2]=1;h=-1;break}}else{c[i+64>>2]=0;h=0;}while(0);c[k+64>>2]=h;h=Dc(b,i,n)|0;if((c[h+76>>2]|0)==-2)h=Dc(b,h,n)|0;i=n^1;j=Dc(b,c[d>>2]|0,i)|0;if((c[j+76>>2]|0)==-2)j=Dc(b,j,i)|0;if((c[(c[o>>2]|0)+76>>2]|0)!=-2){if((c[(c[d>>2]|0)+76>>2]|0)==-2)c[d>>2]=0;}else c[o>>2]=0;i=c[p>>2]|0;if((i|0)==(c[q>>2]|0))Je(r,J);else{c[i>>2]=c[J>>2];c[i+4>>2]=c[J+4>>2];c[i+8>>2]=c[J+8>>2];c[i+12>>2]=c[J+12>>2];c[p>>2]=(c[p>>2]|0)+16;}k=n?h:j;}}while(0);aa=h;Eb=K;return aa|0}function Fc(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;i=b+4|0;g=c[b>>2]|0;if((c[i>>2]|0)==(g|0)){i=0;return i|0}h=0;f=0;do{f=f|(Qb[c[(c[a>>2]|0)+8>>2]&15](a,g+(h*12|0)|0,d,e)|0);h=h+1|0;g=c[b>>2]|0;}while(h>>>0<(((c[i>>2]|0)-g|0)/12|0)>>>0);return f|0}function Gc(a){a=a|0;return ((c[a+4>>2]|0)-(c[a>>2]|0)|0)/12|0|0}function Hc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;h=c[b+8>>2]|0;c[b+12>>2]=h;c[b+4>>2]=h;h=b+24|0;i=b+28|0;e=c[i>>2]|0;d=c[h>>2]|0;if((e|0)==(d|0)){h=e;c[i>>2]=h;i=b+20|0;a[i>>0]=0;i=b+37|0;a[i>>0]=0;return}g=0;f=e;while(1){e=c[d+(g<<2)>>2]|0;if(!e)e=f;else{ak(e);d=c[h>>2]|0;e=c[i>>2]|0;}g=g+1|0;if(g>>>0>=e-d>>2>>>0)break;else f=e;}c[i>>2]=d;i=b+20|0;a[i>>0]=0;i=b+37|0;a[i>>0]=0;return}function Ic(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;x=Eb;Eb=Eb+16|0;m=x;n=a+8|0;b=c[n>>2]|0;w=a+4|0;c[w>>2]=b;o=a+12|0;d=c[o>>2]|0;if((b|0)==(d|0)){Eb=x;return}Le(b,d,m);l=a+56|0;b=c[l>>2]|0;if(!b){b=a+64|0;d=a+60|0;}else{d=a+60|0;c[d>>2]=b;$j(b);b=a+64|0;c[b>>2]=0;c[d>>2]=0;c[l>>2]=0;}c[l>>2]=0;c[d>>2]=0;c[b>>2]=0;b=c[n>>2]|0;if((b|0)!=(c[o>>2]|0)){j=a+60|0;k=a+64|0;f=0;g=0;while(1){e=b;d=c[e>>2]|0;e=c[e+4>>2]|0;i=m;c[i>>2]=d;c[i+4>>2]=e;if((f|0)==(g|0)){Oe(l,m);d=c[j>>2]|0;}else{i=f;c[i>>2]=d;c[i+4>>2]=e;d=f+8|0;c[j>>2]=d;}i=c[l>>2]|0;e=d-i|0;if((e|0)>8?(p=((e>>>3)+-2|0)/2|0,q=i+(p<<3)|0,r=d+-8|0,t=q,s=c[t>>2]|0,t=c[t+4>>2]|0,v=r,u=c[v>>2]|0,v=c[v+4>>2]|0,(t|0)<(v|0)|(t|0)==(v|0)&s>>>0<u>>>0):0){e=p;f=q;d=r;g=s;h=t;while(1){c[d>>2]=g;c[d+4>>2]=h;if(!e)break;e=(e+-1|0)/2|0;d=i+(e<<3)|0;h=d;g=c[h>>2]|0;h=c[h+4>>2]|0;if(!((h|0)<(v|0)|(h|0)==(v|0)&g>>>0<u>>>0))break;else{y=f;f=d;d=y;}}y=f;c[y>>2]=u;c[y+4>>2]=v;}d=c[b+8>>2]|0;if(d|0){y=d+16|0;c[y>>2]=c[d>>2];c[y+4>>2]=c[d+4>>2];c[y+8>>2]=c[d+8>>2];c[y+12>>2]=c[d+12>>2];c[d+60>>2]=1;c[d+76>>2]=-1;}d=c[b+12>>2]|0;if(d|0){y=d+16|0;c[y>>2]=c[d>>2];c[y+4>>2]=c[d+4>>2];c[y+8>>2]=c[d+8>>2];c[y+12>>2]=c[d+12>>2];c[d+60>>2]=2;c[d+76>>2]=-1;}b=b+16|0;if((b|0)==(c[o>>2]|0))break;f=c[j>>2]|0;g=c[k>>2]|0;}b=c[n>>2]|0;}c[a+52>>2]=0;c[w>>2]=b;Eb=x;return}function Jc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;d=c[b+8>>2]|0;w=c[b+12>>2]|0;if((d|0)==(w|0)){c[a>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;c[a+16>>2]=0;c[a+20>>2]=0;c[a+24>>2]=0;c[a+28>>2]=0;return}s=c[d+8>>2]|0;l=s;i=c[l>>2]|0;l=c[l+4>>2]|0;g=a;c[g>>2]=i;c[g+4>>2]=l;g=s+8|0;e=c[g>>2]|0;g=c[g+4>>2]|0;t=a+8|0;u=t;c[u>>2]=e;c[u+4>>2]=g;u=a+16|0;v=u;c[v>>2]=i;c[v+4>>2]=l;v=a+24|0;m=v;c[m>>2]=e;c[m+4>>2]=g;m=e;k=g;j=i;h=l;f=g;b=e;while(1){q=(f|0)<(g|0)|(f|0)==(g|0)&b>>>0<e>>>0;r=q?e:b;f=q?g:f;q=v;c[q>>2]=r;c[q+4>>2]=f;q=d+12|0;p=s;g=k;e=m;b=j;while(1){n=c[p+88>>2]|0;m=p;k=c[m>>2]|0;m=c[m+4>>2]|0;j=(m|0)<(l|0)|(m|0)==(l|0)&k>>>0<i>>>0;if(!n){k=p;i=p;}else{o=n;while(1){if(j){l=a;c[l>>2]=k;c[l+4>>2]=m;l=m;i=k;}if((m|0)>(h|0)|(m|0)==(h|0)&k>>>0>b>>>0){b=u;c[b>>2]=k;c[b+4>>2]=m;b=k;h=m;}n=c[o+88>>2]|0;m=o;k=c[m>>2]|0;m=c[m+4>>2]|0;j=(m|0)<(l|0)|(m|0)==(l|0)&k>>>0<i>>>0;if(!n)break;else o=n;}k=o;i=o;}l=j?i:a;x=c[l>>2]|0;l=c[l+4>>2]|0;o=a;c[o>>2]=x;c[o+4>>2]=l;o=i;j=c[o>>2]|0;o=c[o+4>>2]|0;n=(h|0)<(o|0)|(h|0)==(o|0)&b>>>0<j>>>0;j=n?j:b;h=n?o:h;o=u;c[o>>2]=j;c[o+4>>2]=h;o=k+32|0;n=o;i=c[n>>2]|0;n=c[n+4>>2]|0;m=(n|0)<(l|0)|(n|0)==(l|0)&i>>>0<x>>>0;i=m?i:x;l=m?n:l;n=a;c[n>>2]=i;c[n+4>>2]=l;n=c[o>>2]|0;o=c[o+4>>2]|0;m=(h|0)<(o|0)|(h|0)==(o|0)&j>>>0<n>>>0;j=m?n:j;h=m?o:h;o=u;c[o>>2]=j;c[o+4>>2]=h;o=k+40|0;m=c[o>>2]|0;o=c[o+4>>2]|0;n=(o|0)<(g|0)|(o|0)==(g|0)&m>>>0<e>>>0;e=n?m:e;g=n?o:g;o=t;c[o>>2]=e;c[o+4>>2]=g;if((p|0)!=(s|0))break;p=c[q>>2]|0;b=j;}b=d+16|0;if((b|0)==(w|0))break;s=c[d+24>>2]|0;x=s+8|0;d=b;m=e;k=g;g=c[x+4>>2]|0;b=r;e=c[x>>2]|0;}return}function Kc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;u=c[a+56>>2]|0;s=a+60|0;a=c[s>>2]|0;if((u|0)==(a|0)){u=0;return u|0}d=u;e=c[d+4>>2]|0;r=b;c[r>>2]=c[d>>2];c[r+4>>2]=e;r=u;e=a-r|0;d=e>>3;q=a+-8|0;if((e|0)>8?(p=u,o=c[p>>2]|0,p=c[p+4>>2]|0,m=q,n=c[m+4>>2]|0,l=u,c[l>>2]=c[m>>2],c[l+4>>2]=n,l=q,c[l>>2]=o,c[l+4>>2]=p,l=d+-1|0,(e|0)!=16):0){k=(d+-3|0)/2|0;a=u+8|0;d=a;if((e|0)>24){p=u+16|0;m=c[a+4>>2]|0;o=p;n=c[o+4>>2]|0;o=(m|0)<(n|0)|((m|0)==(n|0)?(c[a>>2]|0)>>>0<(c[o>>2]|0)>>>0:0);a=o?2:1;d=o?p:d;}else a=1;f=d;e=c[f>>2]|0;f=c[f+4>>2]|0;j=u;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((f|0)<(j|0)|(f|0)==(j|0)&e>>>0<i>>>0)){h=u;g=e;while(1){p=h;h=d;c[p>>2]=g;c[p+4>>2]=f;if((k|0)<(a|0))break;a=a<<1|1;f=u+(a<<3)|0;g=f;e=a+1|0;if((e|0)<(l|0)){p=f+8|0;n=f;f=c[n+4>>2]|0;o=p;m=c[o+4>>2]|0;o=(f|0)<(m|0)|((f|0)==(m|0)?(c[n>>2]|0)>>>0<(c[o>>2]|0)>>>0:0);a=o?e:a;e=o?p:g;}else e=g;f=e;g=c[f>>2]|0;f=c[f+4>>2]|0;if((f|0)<(j|0)|(f|0)==(j|0)&g>>>0<i>>>0)break;else d=e;}p=d;c[p>>2]=i;c[p+4>>2]=j;}}c[s>>2]=q;if((u|0)==(q|0)){u=1;return u|0}m=u+8|0;n=m;o=u+16|0;p=o;l=q;while(1){d=b;a=c[d>>2]|0;d=c[d+4>>2]|0;q=u;if(!((a|0)==(c[q>>2]|0)?(d|0)==(c[q+4>>2]|0):0)){a=1;d=28;break}f=l-r|0;e=f>>3;l=l+-8|0;if((f|0)>8?(k=l,q=c[k+4>>2]|0,t=u,c[t>>2]=c[k>>2],c[t+4>>2]=q,t=l,c[t>>2]=a,c[t+4>>2]=d,t=e+-1|0,(f|0)!=16):0){k=(e+-3|0)/2|0;if((f|0)>24){a=m;j=c[a+4>>2]|0;d=o;q=c[d+4>>2]|0;d=(j|0)<(q|0)|((j|0)==(q|0)?(c[a>>2]|0)>>>0<(c[d>>2]|0)>>>0:0);a=d?2:1;d=d?p:n;}else{a=1;d=n;}f=d;e=c[f>>2]|0;f=c[f+4>>2]|0;j=u;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((f|0)<(j|0)|(f|0)==(j|0)&e>>>0<i>>>0)){h=u;g=e;while(1){q=h;h=d;c[q>>2]=g;c[q+4>>2]=f;if((k|0)<(a|0))break;a=a<<1|1;e=u+(a<<3)|0;g=e;f=a+1|0;if((f|0)<(t|0)){q=e+8|0;v=e;x=c[v+4>>2]|0;e=q;w=c[e+4>>2]|0;e=(x|0)<(w|0)|((x|0)==(w|0)?(c[v>>2]|0)>>>0<(c[e>>2]|0)>>>0:0);a=e?f:a;e=e?q:g;}else e=g;f=e;g=c[f>>2]|0;f=c[f+4>>2]|0;if((f|0)<(j|0)|(f|0)==(j|0)&g>>>0<i>>>0)break;else d=e;}x=d;c[x>>2]=i;c[x+4>>2]=j;}}c[s>>2]=l;if((u|0)==(l|0)){a=1;d=28;break}}if((d|0)==28)return a|0;return 0}function Lc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;h=b+92|0;i=c[h>>2]|0;l=b+96|0;e=c[l>>2]|0;if((i|0)==(e|0))return;k=d+92|0;g=c[k>>2]|0;j=d+96|0;f=c[j>>2]|0;if((g|0)==(f|0))return;if((i|0)!=(d|0)){if((g|0)!=(b|0)){c[h>>2]=g;if(g){c[g+96>>2]=b;f=c[j>>2]|0;}c[l>>2]=f;if(f|0)c[f+92>>2]=b;c[k>>2]=i;if(i|0)c[i+96>>2]=d;c[j>>2]=e;if(!e)e=0;else c[e+92>>2]=d;}else{if(!i)e=f;else{c[i+96>>2]=d;e=c[j>>2]|0;}if(e|0)c[e+92>>2]=b;c[l>>2]=e;c[h>>2]=d;c[j>>2]=b;c[k>>2]=i;e=b;}if(!(c[l>>2]|0)){c[a+52>>2]=b;return}}else{if(g){c[g+96>>2]=b;e=c[l>>2]|0;}if(e|0)c[e+92>>2]=d;c[j>>2]=e;c[k>>2]=b;c[l>>2]=d;c[h>>2]=g;e=c[j>>2]|0;}if(e|0)return;c[a+52>>2]=d;return}function Mc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;q=Eb;Eb=Eb+16|0;l=q;f=c[b>>2]|0;j=c[f+88>>2]|0;if(!j){q=S(16)|0;Bc(q,7567);V(q|0,1024,9);}c[j+76>>2]=c[f+76>>2];i=c[f+96>>2]|0;f=c[f+92>>2]|0;c[((i|0)==0?a+52|0:i+92|0)>>2]=j;if(f|0)c[f+96>>2]=c[(c[b>>2]|0)+88>>2];k=c[b>>2]|0;j=c[k+88>>2]|0;c[j+60>>2]=c[k+60>>2];c[j+64>>2]=c[k+64>>2];c[j+68>>2]=c[k+68>>2];c[j+72>>2]=c[k+72>>2];c[b>>2]=j;k=j+16|0;c[k>>2]=c[j>>2];c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];c[(c[b>>2]|0)+96>>2]=i;c[(c[b>>2]|0)+92>>2]=f;f=c[b>>2]|0;if(+g[f+48>>3]==-1.e+40){Eb=q;return}b=f+40|0;f=c[b>>2]|0;b=c[b+4>>2]|0;k=l;c[k>>2]=f;c[k+4>>2]=b;k=a+56|0;i=a+60|0;j=c[i>>2]|0;if((j|0)==(c[a+64>>2]|0)){Oe(k,l);b=c[i>>2]|0;}else{l=j;c[l>>2]=f;c[l+4>>2]=b;b=j+8|0;c[i>>2]=b;}i=c[k>>2]|0;f=b-i|0;if((f|0)>8?(h=((f>>>3)+-2|0)/2|0,m=i+(h<<3)|0,d=b+-8|0,e=m,n=c[e>>2]|0,e=c[e+4>>2]|0,p=d,o=c[p>>2]|0,p=c[p+4>>2]|0,(e|0)<(p|0)|(e|0)==(p|0)&n>>>0<o>>>0):0){b=m;f=n;while(1){n=d;c[n>>2]=f;c[n+4>>2]=e;if(!h)break;h=(h+-1|0)/2|0;d=i+(h<<3)|0;e=d;f=c[e>>2]|0;e=c[e+4>>2]|0;if(!((e|0)<(p|0)|(e|0)==(p|0)&f>>>0<o>>>0))break;else{n=b;b=d;d=n;}}n=b;c[n>>2]=o;c[n+4>>2]=p;}Eb=q;return}function Nc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Oc(a,b,c,d,d)|0}function Oc(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;o=b+128|0;if(a[o>>0]|0){o=0;return o|0}if(a[b+37>>0]|0){o=S(16)|0;Bc(o,7599);V(o|0,1024,9);}a[o>>0]=1;k=e+4|0;j=c[k>>2]|0;m=c[e>>2]|0;l=m;h=j;if((j|0)!=(m|0)){if((l|0)!=(h|0))do{i=h;h=h+-12|0;j=c[h>>2]|0;if(j|0){c[i+-8>>2]=j;$j(j);}}while((h|0)!=(l|0));c[k>>2]=l;}c[b+136>>2]=f;c[b+132>>2]=g;c[b+108>>2]=d;a[b+141>>0]=0;m=Lb[c[(c[b>>2]|0)+20>>2]&63](b)|0;if(m)Rc(b,e);f=b+40|0;g=b+44|0;h=c[g>>2]|0;i=c[f>>2]|0;if((h|0)!=(i|0)){l=b+40|0;k=0;h=i;do{h=h+(k<<2)|0;j=c[h>>2]|0;d=j+16|0;i=c[d>>2]|0;if(!i){if(j)n=20;}else{c[(c[i+28>>2]|0)+24>>2]=0;h=c[d>>2]|0;if(!h)n=20;else{do{c[d>>2]=c[h+24>>2];$j(h);h=c[d>>2]|0;}while((h|0)!=0);n=20;}}if((n|0)==20){n=0;$j(j);h=(c[l>>2]|0)+(k<<2)|0;}c[h>>2]=0;k=k+1|0;h=c[f>>2]|0;}while(k>>>0<(c[g>>2]|0)-h>>2>>>0)}c[g>>2]=h;a[o>>0]=0;o=m;return o|0}function Pc(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Qc(a,b,c,d,d)|0}function Qc(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0;m=b+128|0;if(a[m>>0]|0){m=0;return m|0}a[m>>0]=1;c[b+136>>2]=f;c[b+132>>2]=g;c[b+108>>2]=d;a[b+141>>0]=1;k=Lb[c[(c[b>>2]|0)+20>>2]&63](b)|0;if(k)Sc(b,e);i=b+40|0;j=b+44|0;d=c[j>>2]|0;f=c[i>>2]|0;if((d|0)!=(f|0)){h=b+40|0;b=0;d=f;do{d=d+(b<<2)|0;g=c[d>>2]|0;e=g+16|0;f=c[e>>2]|0;if(!f){if(g)l=11;}else{c[(c[f+28>>2]|0)+24>>2]=0;d=c[e>>2]|0;if(!d)l=11;else{do{c[e>>2]=c[d+24>>2];$j(d);d=c[e>>2]|0;}while((d|0)!=0);l=11;}}if((l|0)==11){l=0;$j(g);d=(c[h>>2]|0)+(b<<2)|0;}c[d>>2]=0;b=b+1|0;d=c[i>>2]|0;}while(b>>>0<(c[j>>2]|0)-d>>2>>>0)}c[j>>2]=d;a[m>>0]=0;m=k;return m|0}function Rc(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;r=Eb;Eb=Eb+16|0;p=r;q=a+40|0;o=a+44|0;md(b,(c[o>>2]|0)-(c[q>>2]|0)>>2);d=c[o>>2]|0;a=c[q>>2]|0;if((d|0)==(a|0)){Eb=r;return}k=p+4|0;l=p+8|0;m=b+4|0;n=b+8|0;j=0;e=d;while(1){d=a+(j<<2)|0;if(!(c[(c[d>>2]|0)+16>>2]|0))d=e;else{c[p>>2]=0;c[k>>2]=0;c[l>>2]=0;d=c[(c[(c[d>>2]|0)+16>>2]|0)+28>>2]|0;if(d|0){a=d;g=0;while(1){e=g+1|0;a=c[a+24>>2]|0;if((a|0)==(d|0))break;else g=e;}if(e>>>0>=2){nd(p,e);a=0;while(1){e=d+8|0;f=c[k>>2]|0;if((f|0)==(c[l>>2]|0))Ge(p,e);else{c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];c[f+8>>2]=c[e+8>>2];c[f+12>>2]=c[e+12>>2];c[k>>2]=f+16;}if(a>>>0<g>>>0){d=c[d+28>>2]|0;a=a+1|0;}else break}h=c[m>>2]|0;if((h|0)==(c[n>>2]|0)){He(b,p);a=c[p>>2]|0;}else{c[h>>2]=0;i=h+4|0;c[i>>2]=0;e=h+8|0;c[e>>2]=0;a=c[p>>2]|0;d=(c[k>>2]|0)-a|0;f=d>>4;if(d){if(f>>>0>268435455){a=13;break}g=Zj(d)|0;c[i>>2]=g;c[h>>2]=g;c[e>>2]=g+(f<<4);a=c[p>>2]|0;d=(c[k>>2]|0)-a|0;if((d|0)>0){ax(g|0,a|0,d|0)|0;c[i>>2]=g+(d>>>4<<4);}}c[m>>2]=(c[m>>2]|0)+12;}if(a|0){c[k>>2]=a;$j(a);}}}a=c[q>>2]|0;d=c[o>>2]|0;}j=j+1|0;if(j>>>0>=d-a>>2>>>0){a=3;break}else e=d;}if((a|0)==3){Eb=r;return}else if((a|0)==13)gk();}function Sc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=Eb;Eb=Eb+16|0;u=v;n=d+48|0;o=d+52|0;e=c[o>>2]|0;f=c[n>>2]|0;if((e|0)!=(f|0)){h=0;g=f;do{f=c[g+(h<<2)>>2]|0;if(f){Ub[c[(c[f>>2]|0)+4>>2]&127](f);e=c[o>>2]|0;g=c[n>>2]|0;}h=h+1|0;f=e-g|0;}while(h>>>0<f>>2>>>0);if(f|0)c[o>>2]=g;}r=d+16|0;s=d+20|0;e=c[r>>2]|0;if((c[s>>2]|0)!=(e|0))c[s>>2]=e;q=b+40|0;p=b+44|0;qd(n,(c[p>>2]|0)-(c[q>>2]|0)>>2);e=c[p>>2]|0;f=c[q>>2]|0;if((e|0)==(f|0))e=0;else{m=d+56|0;l=0;while(1){i=c[f+(l<<2)>>2]|0;k=i+16|0;b=c[k>>2]|0;if(!b)g=0;else{h=b;g=0;do{g=g+1|0;h=c[h+24>>2]|0;}while((h|0)!=(b|0))}j=(a[i+5>>0]|0)!=0;if(!((g|0)<2&j)?!((g|0)<3&(j^1)):0){b=i+8|0;e=c[b>>2]|0;do if(e|0){h=a[i+4>>0]|0;f=a[e+4>>0]|0;if(h<<24>>24!=f<<24>>24?c[e+16>>2]|0:0)break;while(1){if(f<<24>>24!=h<<24>>24?c[e+16>>2]|0:0)break;f=c[e+8>>2]|0;if(!f){e=0;break}e=f;f=a[f+4>>0]|0;}c[b>>2]=e;}while(0);e=Zj(48)|0;c[e>>2]=3512;f=e+4|0;c[f>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;c[f+20>>2]=0;c[f+24>>2]=0;c[f+28>>2]=0;a[f+32>>0]=0;c[u>>2]=e;f=c[o>>2]|0;if((f|0)==(c[m>>2]|0))Ye(n,u);else{c[f>>2]=e;c[o>>2]=(c[o>>2]|0)+4;}j=c[u>>2]|0;c[i+12>>2]=j;c[j+28>>2]=0;c[j+32>>2]=0;nd(j+4|0,g);if((g|0)>0){j=0;e=c[k>>2]|0;do{e=c[e+28>>2]|0;f=c[u>>2]|0;h=e+8|0;b=f+8|0;i=c[b>>2]|0;if((i|0)==(c[f+12>>2]|0))Ge(f+4|0,h);else{c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];c[i+8>>2]=c[h+8>>2];c[i+12>>2]=c[h+12>>2];c[b>>2]=(c[b>>2]|0)+16;}j=j+1|0;}while((j|0)!=(g|0))}g=c[q>>2]|0;f=c[p>>2]|0;}else{g=f;f=e;}l=l+1|0;e=f-g>>2;if(l>>>0>=e>>>0)break;else{e=f;f=g;}}}qd(r,e);e=c[q>>2]|0;if((c[p>>2]|0)==(e|0)){Eb=v;return}j=d+24|0;i=0;do{e=c[e+(i<<2)>>2]|0;b=c[e+12>>2]|0;if(b|0){do if(!(a[e+5>>0]|0)){e=c[e+8>>2]|0;if(e|0?(t=c[e+12>>2]|0,t|0):0){f=t+16|0;g=t+20|0;h=c[g>>2]|0;e=h-(c[f>>2]|0)|0;c[u>>2]=b;if((c[t+24>>2]|0)>>>0>h>>>0){c[h>>2]=b;c[g>>2]=(c[g>>2]|0)+4;}else Ie(f,u);f=t;break}f=c[s>>2]|0;e=f-(c[r>>2]|0)|0;c[u>>2]=b;if((c[j>>2]|0)>>>0>f>>>0){c[f>>2]=b;c[s>>2]=(c[s>>2]|0)+4;}else Ie(r,u);f=d;}else{a[b+36>>0]=1;f=c[s>>2]|0;e=f-(c[r>>2]|0)|0;c[u>>2]=b;if((c[j>>2]|0)>>>0>f>>>0){c[f>>2]=b;c[s>>2]=(c[s>>2]|0)+4;}else Ie(r,u);f=d;}while(0);c[b+28>>2]=f;c[b+32>>2]=e>>2;}i=i+1|0;e=c[q>>2]|0;}while(i>>>0<(c[p>>2]|0)-e>>2>>>0);Eb=v;return}function Tc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0.0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0.0,s=0,t=0;p=Eb;Eb=Eb+32|0;i=p+8|0;o=p;Ub[c[(c[b>>2]|0)+16>>2]&127](b);c[i>>2]=i;e=i+4|0;c[e>>2]=i;f=i+8|0;c[f>>2]=0;g=b+112|0;h=b+120|0;if(c[h>>2]|0?(d=c[b+116>>2]|0,n=(c[g>>2]|0)+4|0,m=c[d>>2]|0,c[m+4>>2]=c[n>>2],c[c[n>>2]>>2]=m,c[h>>2]=0,(d|0)!=(g|0)):0){do{n=d;d=c[d+4>>2]|0;$j(n);}while((d|0)!=(g|0));d=c[f>>2]|0;if(d|0){l=c[e>>2]|0;m=c[i>>2]|0;n=m+4|0;k=c[l>>2]|0;c[k+4>>2]=c[n>>2];c[c[n>>2]>>2]=k;k=c[g>>2]|0;c[k+4>>2]=l;c[l>>2]=k;c[g>>2]=m;c[n>>2]=g;c[h>>2]=(c[h>>2]|0)+d;c[f>>2]=0;}}n=b+124|0;c[n>>2]=0;if(!(Kc(b,i)|0)){b=0;Eb=p;return b|0}Uc(b,c[i>>2]|0,c[i+4>>2]|0);i=b+12|0;k=b+4|0;l=b+84|0;m=b+88|0;while(1){if(!(Kc(b,o)|0)?(c[k>>2]|0)==(c[i>>2]|0):0){d=9;break}d=c[n>>2]|0;if(d|0)do{e=d+104|0;f=c[e>>2]|0;g=d+100|0;h=c[g>>2]|0;c[((f|0)==0?n:f+100|0)>>2]=h;if(h|0)c[h+104>>2]=f;c[g>>2]=0;c[e>>2]=0;gd(b,d);d=c[n>>2]|0;}while((d|0)!=0);d=c[m>>2]|0;e=c[l>>2]|0;if((d|0)!=(e|0)){g=0;do{f=c[e+(g<<2)>>2]|0;if(f){$j(f);e=c[l>>2]|0;d=c[m>>2]|0;}g=g+1|0;f=d-e|0;}while(g>>>0<f>>2>>>0);if(f|0)c[m>>2]=e;}d=o;e=c[d>>2]|0;d=c[d+4>>2]|0;if(!(Vc(b,e,d)|0)){d=8;break}Wc(b,e,d);Uc(b,e,d);}if((d|0)==8)k=0;else if((d|0)==9){n=b+40|0;o=b+44|0;f=c[o>>2]|0;e=c[n>>2]|0;d=e;if((f|0)!=(e|0)){l=b+140|0;m=f-e>>2;i=0;do{g=c[d+(i<<2)>>2]|0;k=c[g+16>>2]|0;if(k|0?(a[g+5>>0]|0)==0:0){h=a[l>>0]^a[g+4>>0];j=0.0;g=k;do{s=c[g+28>>2]|0;q=s+8|0;t=g+8|0;q=Vw(c[t>>2]|0,c[t+4>>2]|0,c[q>>2]|0,c[q+4>>2]|0)|0;r=+(q>>>0)+4294967296.0*+(F()|0);s=s+16|0;q=g+16|0;q=Ww(c[s>>2]|0,c[s+4>>2]|0,c[q>>2]|0,c[q+4>>2]|0)|0;j=j+r*(+(q>>>0)+4294967296.0*+(F()|0));g=c[g+24>>2]|0;}while((g|0)!=(k|0));if((h&255|0)==(j*.5>0.0|0)){g=k;do{s=g+24|0;t=g;g=c[s>>2]|0;t=t+28|0;c[s>>2]=c[t>>2];c[t>>2]=g;}while((g|0)!=(k|0))}}i=i+1|0;}while(i>>>0<m>>>0)}if((c[b+72>>2]|0)!=(c[b+76>>2]|0)){Xc(b);d=c[n>>2]|0;f=c[o>>2]|0;e=d;}if((f|0)!=(e|0)){i=0;do{d=c[d+(i<<2)>>2]|0;h=d+16|0;e=c[h>>2]|0;do if(e|0){if(!(a[d+5>>0]|0)){Yc(b,d);break}d=c[e+28>>2]|0;if((e|0)!=(d|0)){do{f=c[e+24>>2]|0;e=f;g=c[f+28>>2]|0;s=f+8|0;t=g+8|0;if(((c[s>>2]|0)==(c[t>>2]|0)?(c[s+4>>2]|0)==(c[t+4>>2]|0):0)?(s=f+16|0,t=g+16|0,(c[s>>2]|0)==(c[t>>2]|0)?(c[s+4>>2]|0)==(c[t+4>>2]|0):0):0){e=f+24|0;c[g+24>>2]=c[e>>2];c[(c[e>>2]|0)+28>>2]=g;$j(f);d=(f|0)==(d|0)?g:d;e=g;}}while((d|0)!=(e|0));if((d|0)!=(c[d+28>>2]|0))break}else d=e;$j(d);c[h>>2]=0;}while(0);i=i+1|0;d=c[n>>2]|0;}while(i>>>0<(c[o>>2]|0)-d>>2>>>0)}if(!(a[b+142>>0]|0))k=1;else{Zc(b);k=1;}}h=b+72|0;i=b+76|0;e=c[i>>2]|0;d=c[h>>2]|0;if((e|0)!=(d|0)){g=0;do{f=c[d+(g<<2)>>2]|0;if(f){$j(f);d=c[h>>2]|0;e=c[i>>2]|0;}g=g+1|0;f=e-d|0;}while(g>>>0<f>>2>>>0);if(f|0)c[i>>2]=d;}i=b+84|0;h=b+88|0;e=c[h>>2]|0;d=c[i>>2]|0;if((e|0)==(d|0)){t=k;Eb=p;return t|0}g=0;do{f=c[d+(g<<2)>>2]|0;if(f){$j(f);d=c[i>>2]|0;e=c[h>>2]|0;}g=g+1|0;f=e-d|0;}while(g>>>0<f>>2>>>0);if(!f){t=k;Eb=p;return t|0}c[h>>2]=d;t=k;Eb=p;return t|0}function Uc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0;ra=Eb;Eb=Eb+32|0;X=ra+16|0;fa=ra;ha=b+12|0;la=b+4|0;f=c[la>>2]|0;if((f|0)==(c[ha>>2]|0)){Eb=ra;return}y=b+56|0;z=b+60|0;A=b+64|0;B=b+124|0;C=b+84|0;E=b+88|0;K=b+20|0;N=b+76|0;O=b+80|0;P=b+72|0;while(1){x=f;if(!((c[x>>2]|0)==(d|0)?(c[x+4>>2]|0)==(e|0):0)){f=99;break}c[la>>2]=f+16;w=c[f+8>>2]|0;x=c[f+12>>2]|0;o=(w|0)!=0;do if(o){dd(b,w,0);if(!x){_c(b,w);if($c(b,w)|0)m=bd(b,w,w)|0;else m=0;h=w+40|0;f=c[h>>2]|0;h=c[h+4>>2]|0;i=X;c[i>>2]=f;c[i+4>>2]=h;i=c[z>>2]|0;if((i|0)==(c[A>>2]|0)){Oe(y,X);f=c[z>>2]|0;}else{v=i;c[v>>2]=f;c[v+4>>2]=h;f=i+8|0;c[z>>2]=f;}l=c[y>>2]|0;h=f-l|0;if((h|0)>8?(ja=((h>>>3)+-2|0)/2|0,ka=l+(ja<<3)|0,ma=f+-8|0,oa=ka,na=c[oa>>2]|0,oa=c[oa+4>>2]|0,qa=ma,pa=c[qa>>2]|0,qa=c[qa+4>>2]|0,(oa|0)<(qa|0)|(oa|0)==(qa|0)&na>>>0<pa>>>0):0){h=ja;i=ka;f=ma;j=na;k=oa;while(1){v=f;c[v>>2]=j;c[v+4>>2]=k;if(!h)break;h=(h+-1|0)/2|0;f=l+(h<<3)|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)<(qa|0)|(k|0)==(qa|0)&j>>>0<pa>>>0))break;else{v=i;i=f;f=v;}}v=i;c[v>>2]=pa;c[v+4>>2]=qa;}break}else{dd(b,x,w);_c(b,w);c[x+68>>2]=c[w+68>>2];c[x+72>>2]=c[w+72>>2];if($c(b,w)|0)m=ad(b,w,x,w)|0;else m=0;h=w+40|0;f=c[h>>2]|0;h=c[h+4>>2]|0;i=X;c[i>>2]=f;c[i+4>>2]=h;i=c[z>>2]|0;if((i|0)==(c[A>>2]|0)){Oe(y,X);f=c[z>>2]|0;}else{v=i;c[v>>2]=f;c[v+4>>2]=h;f=i+8|0;c[z>>2]=f;}l=c[y>>2]|0;h=f-l|0;if((h|0)>8?(D=((h>>>3)+-2|0)/2|0,G=l+(D<<3)|0,H=f+-8|0,J=G,I=c[J>>2]|0,J=c[J+4>>2]|0,M=H,L=c[M>>2]|0,M=c[M+4>>2]|0,(J|0)<(M|0)|(J|0)==(M|0)&I>>>0<L>>>0):0){h=D;i=G;f=H;j=I;k=J;while(1){v=f;c[v>>2]=j;c[v+4>>2]=k;if(!h)break;h=(h+-1|0)/2|0;f=l+(h<<3)|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)<(M|0)|(k|0)==(M|0)&j>>>0<L>>>0))break;else{v=i;i=f;f=v;}}v=i;c[v>>2]=L;c[v+4>>2]=M;}break}}else{dd(b,x,0);_c(b,x);if($c(b,x)|0)m=bd(b,x,x)|0;else m=0;}while(0);if(x|0){n=x+48|0;if(+g[n>>3]==-1.e+40){f=c[B>>2]|0;if(!f){c[B>>2]=x;c[x+104>>2]=0;f=0;}else{c[x+104>>2]=0;c[f+104>>2]=x;c[B>>2]=x;}c[x+100>>2]=f;f=c[x+88>>2]|0;if(f|0){h=f+40|0;f=c[h>>2]|0;h=c[h+4>>2]|0;i=X;c[i>>2]=f;c[i+4>>2]=h;i=c[z>>2]|0;if((i|0)==(c[A>>2]|0)){Oe(y,X);f=c[z>>2]|0;}else{v=i;c[v>>2]=f;c[v+4>>2]=h;f=i+8|0;c[z>>2]=f;}l=c[y>>2]|0;h=f-l|0;if((h|0)>8?(Q=((h>>>3)+-2|0)/2|0,R=l+(Q<<3)|0,S=f+-8|0,U=R,T=c[U>>2]|0,U=c[U+4>>2]|0,W=S,V=c[W>>2]|0,W=c[W+4>>2]|0,(U|0)<(W|0)|(U|0)==(W|0)&T>>>0<V>>>0):0){h=Q;i=R;f=S;j=T;k=U;while(1){v=f;c[v>>2]=j;c[v+4>>2]=k;if(!h)break;h=(h+-1|0)/2|0;f=l+(h<<3)|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)<(W|0)|(k|0)==(W|0)&j>>>0<V>>>0))break;else{v=i;i=f;f=v;}}v=i;c[v>>2]=V;c[v+4>>2]=W;}}}else{h=x+40|0;f=c[h>>2]|0;h=c[h+4>>2]|0;i=X;c[i>>2]=f;c[i+4>>2]=h;i=c[z>>2]|0;if((i|0)==(c[A>>2]|0)){Oe(y,X);f=c[z>>2]|0;}else{v=i;c[v>>2]=f;c[v+4>>2]=h;f=i+8|0;c[z>>2]=f;}l=c[y>>2]|0;h=f-l|0;if((h|0)>8?(Y=((h>>>3)+-2|0)/2|0,Z=l+(Y<<3)|0,_=f+-8|0,aa=Z,$=c[aa>>2]|0,aa=c[aa+4>>2]|0,ca=_,ba=c[ca>>2]|0,ca=c[ca+4>>2]|0,(aa|0)<(ca|0)|(aa|0)==(ca|0)&$>>>0<ba>>>0):0){h=Y;i=Z;f=_;j=$;k=aa;while(1){v=f;c[v>>2]=j;c[v+4>>2]=k;if(!h)break;h=(h+-1|0)/2|0;f=l+(h<<3)|0;k=f;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)<(ca|0)|(k|0)==(ca|0)&j>>>0<ba>>>0))break;else{v=i;i=f;f=v;}}v=i;c[v>>2]=ba;c[v+4>>2]=ca;}}if(o){if(((m|0?+g[n>>3]==-1.e+40:0)?(da=c[E>>2]|0,ea=c[C>>2]|0,(da|0)!=(ea|0)):0)?c[x+64>>2]|0:0){l=x+32|0;k=0;f=ea;h=da;do{i=c[f+(k<<2)>>2]|0;j=c[i>>2]|0;q=j+8|0;u=c[q>>2]|0;q=c[q+4>>2]|0;i=i+8|0;p=i;v=c[p>>2]|0;p=c[p+4>>2]|0;ta=x;s=c[ta>>2]|0;ta=c[ta+4>>2]|0;n=l;r=c[n>>2]|0;n=c[n+4>>2]|0;t=(q|0)>(p|0)|(q|0)==(p|0)&u>>>0>v>>>0;sa=t?p:q;p=t?q:p;q=(ta|0)>(n|0)|(ta|0)==(n|0)&s>>>0>r>>>0;o=q?n:ta;n=q?ta:n;if(((sa|0)<(n|0)|((sa|0)==(n|0)?(t?v:u)>>>0<(q?s:r)>>>0:0))&((o|0)<(p|0)|((o|0)==(p|0)?(q?r:s)>>>0<(t?u:v)>>>0:0))){c[fa>>2]=c[i>>2];c[fa+4>>2]=c[i+4>>2];c[fa+8>>2]=c[i+8>>2];c[fa+12>>2]=c[i+12>>2];h=Zj(24)|0;f=h+8|0;c[X>>2]=h;c[h>>2]=j;c[h+4>>2]=m;c[f>>2]=c[fa>>2];c[f+4>>2]=c[fa+4>>2];c[f+8>>2]=c[fa+8>>2];c[f+12>>2]=c[fa+12>>2];f=c[N>>2]|0;if((f|0)==(c[O>>2]|0))Re(P,X);else{c[f>>2]=h;c[N>>2]=(c[N>>2]|0)+4;}f=c[C>>2]|0;h=c[E>>2]|0;}k=k+1|0;}while(k>>>0<h-f>>2>>>0)}do if((((c[w+76>>2]|0)>-1?(ga=c[w+96>>2]|0,ga|0):0)?(sa=ga+16|0,ta=w,(c[sa>>2]|0)==(c[ta>>2]|0)?(c[sa+4>>2]|0)==(c[ta+4>>2]|0):0):0)?(c[ga+76>>2]|0)>-1:0){h=ga;f=c[h>>2]|0;h=c[h+4>>2]|0;r=ga+8|0;j=ga+32|0;i=c[j>>2]|0;j=c[j+4>>2]|0;q=ga+40|0;sa=w+16|0;v=c[sa>>2]|0;sa=c[sa+4>>2]|0;l=w+24|0;k=c[l>>2]|0;l=c[l+4>>2]|0;n=w+32|0;s=w+32|0;t=c[s>>2]|0;s=c[s+4>>2]|0;p=w+40|0;o=c[p>>2]|0;p=c[p+4>>2]|0;ta=(a[K>>0]|0)==0;q=Ww(c[r>>2]|0,c[r+4>>2]|0,c[q>>2]|0,c[q+4>>2]|0)|0;r=F()|0;s=Ww(v|0,sa|0,t|0,s|0)|0;t=F()|0;if(ta){v=Uw(s|0,t|0,q|0,r|0)|0;ta=F()|0;u=Ww(f|0,h|0,i|0,j|0)|0;sa=F()|0;t=Ww(k|0,l|0,o|0,p|0)|0;sa=Uw(t|0,F()|0,u|0,sa|0)|0;if(!((v|0)==(sa|0)&(ta|0)==(F()|0)))break}else{ya=(r|0)<0;Aa=_w(q|0,r|0,63)|0;F()|0;za=(t|0)<0;ua=_w(s|0,t|0,63)|0;F()|0;ua=(Aa|0)==(ua|0);Aa=Ww(0,0,q|0,r|0)|0;xa=F()|0;Aa=ya?Aa:q;xa=ya?xa:r;ya=Ww(0,0,s|0,t|0)|0;wa=F()|0;ya=za?ya:s;wa=za?wa:t;r=Uw(wa|0,0,xa|0,0)|0;za=F()|0;va=Uw(ya|0,0,Aa|0,0)|0;t=F()|0;xa=Uw(ya|0,0,xa|0,0)|0;ya=F()|0;Aa=Uw(wa|0,0,Aa|0,0)|0;Aa=Vw(xa|0,ya|0,Aa|0,F()|0)|0;za=Vw(F()|0,0,r|0,za|0)|0;r=F()|0;Aa=Vw(0,Aa|0,va|0,t|0)|0;ya=F()|0;va=Vw(za|0,r|0,(ya>>>0<t>>>0|(ya|0)==(t|0)&Aa>>>0<va>>>0)&1|0,0)|0;t=F()|0;r=(Aa|0)==0&(ya|0)==0;za=Ww(0,0,Aa|0,ya|0)|0;xa=F()|0;wa=Ww(0,0,va|0,t|0)|0;s=F()|0;j=Ww(f|0,h|0,i|0,j|0)|0;q=F()|0;l=Ww(k|0,l|0,o|0,p|0)|0;p=F()|0;v=(q|0)<0;ta=_w(j|0,q|0,63)|0;F()|0;k=(p|0)<0;u=_w(l|0,p|0,63)|0;F()|0;u=(ta|0)==(u|0);ta=Ww(0,0,j|0,q|0)|0;o=F()|0;j=v?ta:j;o=v?o:q;q=Ww(0,0,l|0,p|0)|0;v=F()|0;l=k?q:l;p=k?v:p;v=Uw(p|0,0,o|0,0)|0;k=F()|0;q=Uw(l|0,0,j|0,0)|0;ta=F()|0;o=Uw(l|0,0,o|0,0)|0;l=F()|0;j=Uw(p|0,0,j|0,0)|0;j=Vw(o|0,l|0,j|0,F()|0)|0;k=Vw(F()|0,0,v|0,k|0)|0;v=F()|0;j=Vw(0,j|0,q|0,ta|0)|0;l=F()|0;q=Vw(k|0,v|0,(l>>>0<ta>>>0|(l|0)==(ta|0)&j>>>0<q>>>0)&1|0,0)|0;ta=F()|0;v=(j|0)==0&(l|0)==0;k=Ww(0,0,j|0,l|0)|0;o=F()|0;p=Ww(0,0,q|0,ta|0)|0;sa=F()|0;if(!((((ua?Aa:za)|0)==((u?j:k)|0)?((ua?ya:xa)|0)==((u?l:o)|0):0)&(((ua?va:r?wa:~va)|0)==((u?q:v?p:~q)|0)?((ua?t:r?s:~t)|0)==((u?ta:v?sa:~ta)|0):0)))break}if(c[w+64>>2]|0?c[ga+64>>2]|0:0){Aa=bd(b,ga,w)|0;c[fa>>2]=c[n>>2];c[fa+4>>2]=c[n+4>>2];c[fa+8>>2]=c[n+8>>2];c[fa+12>>2]=c[n+12>>2];f=Zj(24)|0;h=f+8|0;c[X>>2]=f;c[f>>2]=m;c[f+4>>2]=Aa;c[h>>2]=c[fa>>2];c[h+4>>2]=c[fa+4>>2];c[h+8>>2]=c[fa+8>>2];c[h+12>>2]=c[fa+12>>2];h=c[N>>2]|0;if((h|0)==(c[O>>2]|0))Re(P,X);else{c[h>>2]=f;c[N>>2]=(c[N>>2]|0)+4;}}}while(0);v=w+92|0;f=c[v>>2]|0;if((f|0)!=(x|0)){do if((c[x+76>>2]|0)>-1?(ia=c[x+96>>2]|0,(c[ia+76>>2]|0)>-1):0){i=ia+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;s=ia+24|0;k=ia+32|0;j=c[k>>2]|0;k=c[k+4>>2]|0;r=ia+40|0;za=x+16|0;ya=c[za>>2]|0;za=c[za+4>>2]|0;n=x+24|0;l=c[n>>2]|0;n=c[n+4>>2]|0;o=x+32|0;t=x+32|0;u=c[t>>2]|0;t=c[t+4>>2]|0;q=x+40|0;p=c[q>>2]|0;q=c[q+4>>2]|0;Aa=(a[K>>0]|0)==0;r=Ww(c[s>>2]|0,c[s+4>>2]|0,c[r>>2]|0,c[r+4>>2]|0)|0;s=F()|0;t=Ww(ya|0,za|0,u|0,t|0)|0;u=F()|0;if(Aa){ya=Uw(t|0,u|0,r|0,s|0)|0;Aa=F()|0;xa=Ww(h|0,i|0,j|0,k|0)|0;za=F()|0;wa=Ww(l|0,n|0,p|0,q|0)|0;za=Uw(wa|0,F()|0,xa|0,za|0)|0;if(!((ya|0)==(za|0)&(Aa|0)==(F()|0)))break}else{Ca=(s|0)<0;Ea=_w(r|0,s|0,63)|0;F()|0;ua=(u|0)<0;ta=_w(t|0,u|0,63)|0;F()|0;ta=(Ea|0)==(ta|0);Ea=Ww(0,0,r|0,s|0)|0;Ba=F()|0;Ea=Ca?Ea:r;Ba=Ca?Ba:s;Ca=Ww(0,0,t|0,u|0)|0;s=F()|0;Ca=ua?Ca:t;s=ua?s:u;ua=Uw(s|0,0,Ba|0,0)|0;Da=F()|0;t=Uw(Ca|0,0,Ea|0,0)|0;wa=F()|0;Ba=Uw(Ca|0,0,Ba|0,0)|0;Ca=F()|0;Ea=Uw(s|0,0,Ea|0,0)|0;Ea=Vw(Ba|0,Ca|0,Ea|0,F()|0)|0;Da=Vw(F()|0,0,ua|0,Da|0)|0;ua=F()|0;Ea=Vw(0,Ea|0,t|0,wa|0)|0;Ca=F()|0;t=Vw(Da|0,ua|0,(Ca>>>0<wa>>>0|(Ca|0)==(wa|0)&Ea>>>0<t>>>0)&1|0,0)|0;wa=F()|0;ua=(Ea|0)==0&(Ca|0)==0;Da=Ww(0,0,Ea|0,Ca|0)|0;Ba=F()|0;s=Ww(0,0,t|0,wa|0)|0;va=F()|0;Aa=Ww(h|0,i|0,j|0,k|0)|0;r=F()|0;q=Ww(l|0,n|0,p|0,q|0)|0;u=F()|0;ya=(r|0)<0;n=_w(Aa|0,r|0,63)|0;F()|0;p=(u|0)<0;xa=_w(q|0,u|0,63)|0;F()|0;xa=(n|0)==(xa|0);n=Ww(0,0,Aa|0,r|0)|0;sa=F()|0;n=ya?n:Aa;r=ya?sa:r;sa=Ww(0,0,q|0,u|0)|0;ya=F()|0;q=p?sa:q;u=p?ya:u;ya=Uw(u|0,0,r|0,0)|0;p=F()|0;sa=Uw(q|0,0,n|0,0)|0;Aa=F()|0;r=Uw(q|0,0,r|0,0)|0;q=F()|0;n=Uw(u|0,0,n|0,0)|0;n=Vw(r|0,q|0,n|0,F()|0)|0;p=Vw(F()|0,0,ya|0,p|0)|0;ya=F()|0;n=Vw(0,n|0,sa|0,Aa|0)|0;q=F()|0;sa=Vw(p|0,ya|0,(q>>>0<Aa>>>0|(q|0)==(Aa|0)&n>>>0<sa>>>0)&1|0,0)|0;Aa=F()|0;ya=(n|0)==0&(q|0)==0;p=Ww(0,0,n|0,q|0)|0;r=F()|0;u=Ww(0,0,sa|0,Aa|0)|0;za=F()|0;if(!((((ta?Ea:Da)|0)==((xa?n:p)|0)?((ta?Ca:Ba)|0)==((xa?q:r)|0):0)&(((ta?t:ua?s:~t)|0)==((xa?sa:ya?u:~sa)|0)?((ta?wa:ua?va:~wa)|0)==((xa?Aa:ya?za:~Aa)|0):0)))break}if((c[x+64>>2]|0)!=0?(c[ia+64>>2]|0)!=0:0){Ea=bd(b,ia,x)|0;c[fa>>2]=c[o>>2];c[fa+4>>2]=c[o+4>>2];c[fa+8>>2]=c[o+8>>2];c[fa+12>>2]=c[o+12>>2];h=Zj(24)|0;f=h+8|0;c[X>>2]=h;c[h>>2]=m;c[h+4>>2]=Ea;c[f>>2]=c[fa>>2];c[f+4>>2]=c[fa+4>>2];c[f+8>>2]=c[fa+8>>2];c[f+12>>2]=c[fa+12>>2];f=c[N>>2]|0;if((f|0)==(c[O>>2]|0))Re(P,X);else{c[f>>2]=h;c[N>>2]=(c[N>>2]|0)+4;}f=c[v>>2]|0;}}while(0);if(!((f|0)==0|(f|0)==(x|0))){h=w+16|0;do{ed(b,x,f,h);f=c[f+92>>2]|0;}while((f|0)!=(x|0))}}}}f=c[la>>2]|0;if((f|0)==(c[ha>>2]|0)){f=99;break}}if((f|0)==99){Eb=ra;return}}function Vc(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;if(!(c[a+52>>2]|0)){a=1;return a|0}id(a,b,d);f=a+96|0;g=a+100|0;d=c[g>>2]|0;b=c[f>>2]|0;switch(d-b>>2|0){case 1:break;case 0:{a=1;return a|0}default:e=3;}do if((e|0)==3)if(jd(a)|0){d=c[g>>2]|0;b=c[f>>2]|0;break}else{a=0;return a|0}while(0);if((d|0)!=(b|0)){d=0;do{b=c[b+(d<<2)>>2]|0;e=b+4|0;ed(a,c[b>>2]|0,c[e>>2]|0,b+8|0);Lc(a,c[b>>2]|0,c[e>>2]|0);if(b|0)$j(b);d=d+1|0;b=c[f>>2]|0;}while(d>>>0<(c[g>>2]|0)-b>>2>>>0)}c[g>>2]=b;c[a+124>>2]=0;a=1;return a|0}function Wc(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0.0,t=0,u=0,v=0,w=0,x=0,y=0,A=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0;W=Eb;Eb=Eb+48|0;I=W+36|0;H=W+8|0;C=W+32|0;D=W+28|0;E=W;V=W+24|0;G=b+52|0;h=c[G>>2]|0;c[V>>2]=h;if(!h){p=b+112|0;o=b+120|0;m=b+124|0;}else{u=b+142|0;p=b+112|0;o=b+120|0;m=b+124|0;v=b+76|0;w=b+80|0;x=b+72|0;do{n=h+40|0;a:do if((c[n>>2]|0)==(d|0)?(c[n+4>>2]|0)==(e|0):0){b:do if(!(c[h+88>>2]|0)){i=c[h+80>>2]|0;n=i+32|0;l=h+32|0;k=l;j=c[k>>2]|0;k=c[k+4>>2]|0;if((((c[n>>2]|0)==(j|0)?(c[n+4>>2]|0)==(k|0):0)?(n=i+40|0,(c[n>>2]|0)==(d|0)?(c[n+4>>2]|0)==(e|0):0):0)?(c[i+88>>2]|0)==0:0){t=i;n=12;}else n=9;if((((n|0)==9?(n=0,A=c[h+84>>2]|0,i=A+32|0,(c[i>>2]|0)==(j|0)?(c[i+4>>2]|0)==(k|0):0):0)?(k=A+40|0,(c[k>>2]|0)==(d|0)?(c[k+4>>2]|0)==(e|0):0):0)?(c[A+88>>2]|0)==0:0){t=A;n=12;}do if((n|0)==12?(n=0,(c[t+76>>2]|0)!=-2):0){q=+g[t+48>>3];if((c[t+92>>2]|0)==(c[t+96>>2]|0))if(q==-1.e+40)break b;else break;else if(q!=-1.e+40)break;else break b}while(0);if(a[u>>0]|0){k=Zj(16)|0;i=l;j=c[i+4>>2]|0;l=k+8|0;c[l>>2]=c[i>>2];c[l+4>>2]=j;c[k+4>>2]=p;l=c[p>>2]|0;c[k>>2]=l;c[l+4>>2]=k;c[p>>2]=k;c[o>>2]=(c[o>>2]|0)+1;}i=c[h+96>>2]|0;ld(b,h);if(!i){h=G;break a}h=i+92|0;break a}while(0);n=c[h+88>>2]|0;if(n|0?+g[n+48>>3]==-1.e+40:0){Mc(b,V);h=c[V>>2]|0;if((c[h+76>>2]|0)>-1)bd(b,h,h)|0;i=c[m>>2]|0;if(!i){c[m>>2]=h;c[h+104>>2]=0;c[h+100>>2]=0;n=30;break}else{c[h+100>>2]=i;c[h+104>>2]=0;c[i+104>>2]=h;c[m>>2]=h;n=30;break}}j=h+32|0;i=c[j>>2]|0;j=c[j+4>>2]|0;n=29;}else{i=h;j=c[i>>2]|0;i=c[i+4>>2]|0;q=+g[h+48>>3];n=h+8|0;n=Ww(d|0,e|0,c[n>>2]|0,c[n+4>>2]|0)|0;q=q*(+(n>>>0)+4294967296.0*+(F()|0));q=q+(q<0.0?-.5:.5);i=Vw(j|0,i|0,~~q>>>0|0,(+s(q)>=1.0?(q>0.0?~~+B(+r(q/4294967296.0),4294967295.0)>>>0:~~+z((q-+(~~q>>>0))/4294967296.0)>>>0):0)|0)|0;j=F()|0;n=29;}while(0);if((n|0)==29){l=h+16|0;c[l>>2]=i;c[l+4>>2]=j;l=h+24|0;c[l>>2]=d;c[l+4>>2]=e;n=30;}if((n|0)==30){if((((((a[u>>0]|0)!=0?(y=c[h+96>>2]|0,(c[h+76>>2]|0)>-1):0)?(y|0)!=0&(c[h+64>>2]|0)!=0:0)?(c[y+76>>2]|0)>-1:0)?(l=y+16|0,n=h+16|0,(c[l>>2]|0)==(c[n>>2]|0)?(c[l+4>>2]|0)==(c[n+4>>2]|0):0):0)?(c[y+64>>2]|0)!=0:0){l=h+16|0;c[H>>2]=c[l>>2];c[H+4>>2]=c[l+4>>2];c[H+8>>2]=c[l+8>>2];c[H+12>>2]=c[l+12>>2];l=bd(b,y,H)|0;n=bd(b,h,H)|0;h=Zj(24)|0;i=h+8|0;c[I>>2]=h;c[h>>2]=l;c[h+4>>2]=n;c[i>>2]=c[H>>2];c[i+4>>2]=c[H+4>>2];c[i+8>>2]=c[H+8>>2];c[i+12>>2]=c[H+12>>2];i=c[v>>2]|0;if((i|0)==(c[w>>2]|0))Re(x,I);else{c[i>>2]=h;c[v>>2]=(c[v>>2]|0)+4;}h=c[V>>2]|0;}h=h+92|0;}h=c[h>>2]|0;c[V>>2]=h;}while((h|0)!=0)}n=b+116|0;c[C>>2]=c[n>>2];c[D>>2]=p;h=c[o>>2]|0;c[H>>2]=c[C>>2];c[I>>2]=c[D>>2];Xe(H,I,h,E)|0;h=c[m>>2]|0;if(h|0)do{i=h+104|0;j=c[i>>2]|0;k=h+100|0;l=c[k>>2]|0;c[((j|0)==0?m:j+100|0)>>2]=l;if(l|0)c[l+104>>2]=j;c[k>>2]=0;c[i>>2]=0;gd(b,h);h=c[m>>2]|0;}while((h|0)!=0);if(c[o>>2]|0?(f=c[n>>2]|0,E=(c[b+112>>2]|0)+4|0,D=c[f>>2]|0,c[D+4>>2]=c[E>>2],c[c[E>>2]>>2]=D,c[o>>2]=0,(f|0)!=(p|0)):0)do{E=f;f=c[f+4>>2]|0;$j(E);}while((f|0)!=(p|0));f=c[G>>2]|0;c[V>>2]=f;if(!f){Eb=W;return}v=b+20|0;w=b+76|0;x=b+80|0;y=b+72|0;do{h=f;G=f+40|0;c:do if(((c[G>>2]|0)==(d|0)?(c[G+4>>2]|0)==(e|0):0)?(c[f+88>>2]|0)!=0:0){if((c[f+76>>2]|0)>-1)u=bd(b,f,f+32|0)|0;else u=0;Mc(b,V);f=c[V>>2]|0;h=c[f+96>>2]|0;t=c[f+92>>2]|0;do if((((h|0?(K=h+16|0,J=c[K>>2]|0,K=c[K+4>>2]|0,G=f,(J|0)==(c[G>>2]|0)?(K|0)==(c[G+4>>2]|0):0):0)?(M=h+24|0,L=c[M>>2]|0,M=c[M+4>>2]|0,G=f+8|0,(u|0)!=0&((L|0)==(c[G>>2]|0)?(M|0)==(c[G+4>>2]|0):0)):0)?(c[h+76>>2]|0)>-1:0)?(O=h+40|0,N=c[O>>2]|0,O=c[O+4>>2]|0,(M|0)>(O|0)|(M|0)==(O|0)&L>>>0>N>>>0):0){j=f+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;n=f+24|0;l=f+32|0;k=c[l>>2]|0;l=c[l+4>>2]|0;m=f+40|0;o=h+32|0;p=c[o>>2]|0;o=c[o+4>>2]|0;G=(a[v>>0]|0)==0;m=Ww(c[n>>2]|0,c[n+4>>2]|0,c[m>>2]|0,c[m+4>>2]|0)|0;n=F()|0;o=Ww(J|0,K|0,p|0,o|0)|0;p=F()|0;if(G){D=Uw(o|0,p|0,m|0,n|0)|0;G=F()|0;A=Ww(i|0,j|0,k|0,l|0)|0;C=F()|0;E=Ww(L|0,M|0,N|0,O|0)|0;E=Uw(A|0,C|0,E|0,F()|0)|0;if(!((D|0)==(E|0)&(G|0)==(F()|0)))break}else{$=(n|0)<0;ba=_w(m|0,n|0,63)|0;F()|0;aa=(p|0)<0;X=_w(o|0,p|0,63)|0;F()|0;X=(ba|0)==(X|0);ba=Ww(0,0,m|0,n|0)|0;_=F()|0;ba=$?ba:m;_=$?_:n;$=Ww(0,0,o|0,p|0)|0;Z=F()|0;$=aa?$:o;Z=aa?Z:p;o=Uw(Z|0,0,_|0,0)|0;aa=F()|0;Y=Uw($|0,0,ba|0,0)|0;A=F()|0;_=Uw($|0,0,_|0,0)|0;$=F()|0;ba=Uw(Z|0,0,ba|0,0)|0;ba=Vw(_|0,$|0,ba|0,F()|0)|0;aa=Vw(F()|0,0,o|0,aa|0)|0;o=F()|0;ba=Vw(0,ba|0,Y|0,A|0)|0;$=F()|0;Y=Vw(aa|0,o|0,($>>>0<A>>>0|($|0)==(A|0)&ba>>>0<Y>>>0)&1|0,0)|0;A=F()|0;o=(ba|0)==0&($|0)==0;aa=Ww(0,0,ba|0,$|0)|0;_=F()|0;Z=Ww(0,0,Y|0,A|0)|0;p=F()|0;m=Ww(i|0,j|0,k|0,l|0)|0;k=F()|0;l=Ww(L|0,M|0,N|0,O|0)|0;i=F()|0;D=(k|0)<0;G=_w(m|0,k|0,63)|0;F()|0;j=(i|0)<0;C=_w(l|0,i|0,63)|0;F()|0;C=(G|0)==(C|0);G=Ww(0,0,m|0,k|0)|0;n=F()|0;m=D?G:m;k=D?n:k;n=Ww(0,0,l|0,i|0)|0;D=F()|0;l=j?n:l;i=j?D:i;D=Uw(k|0,0,i|0,0)|0;j=F()|0;n=Uw(m|0,0,l|0,0)|0;G=F()|0;l=Uw(k|0,0,l|0,0)|0;k=F()|0;i=Uw(m|0,0,i|0,0)|0;i=Vw(l|0,k|0,i|0,F()|0)|0;j=Vw(F()|0,0,D|0,j|0)|0;D=F()|0;i=Vw(0,i|0,n|0,G|0)|0;k=F()|0;n=Vw(j|0,D|0,(k>>>0<G>>>0|(k|0)==(G|0)&i>>>0<n>>>0)&1|0,0)|0;G=F()|0;D=(i|0)==0&(k|0)==0;j=Ww(0,0,i|0,k|0)|0;l=F()|0;m=Ww(0,0,n|0,G|0)|0;E=F()|0;if(!((((X?ba:aa)|0)==((C?i:j)|0)?((X?$:_)|0)==((C?k:l)|0):0)&(((X?Y:o?Z:~Y)|0)==((C?n:D?m:~n)|0)?((X?A:o?p:~A)|0)==((C?G:D?E:~G)|0):0)))break}if(c[f+64>>2]|0?c[h+64>>2]|0:0){ba=bd(b,h,f)|0;i=f+32|0;c[H>>2]=c[i>>2];c[H+4>>2]=c[i+4>>2];c[H+8>>2]=c[i+8>>2];c[H+12>>2]=c[i+12>>2];i=Zj(24)|0;h=i+8|0;c[I>>2]=i;c[i>>2]=u;c[i+4>>2]=ba;c[h>>2]=c[H>>2];c[h+4>>2]=c[H+4>>2];c[h+8>>2]=c[H+8>>2];c[h+12>>2]=c[H+12>>2];h=c[w>>2]|0;if((h|0)==(c[x>>2]|0))Re(y,I);else{c[h>>2]=i;c[w>>2]=(c[w>>2]|0)+4;}break c}}while(0);if(((((t|0)!=0?(Q=t+16|0,P=c[Q>>2]|0,Q=c[Q+4>>2]|0,ba=f,(P|0)==(c[ba>>2]|0)?(Q|0)==(c[ba+4>>2]|0):0):0)?(S=t+24|0,R=c[S>>2]|0,S=c[S+4>>2]|0,ba=f+8|0,(u|0)!=0&((R|0)==(c[ba>>2]|0)?(S|0)==(c[ba+4>>2]|0):0)):0)?(c[t+76>>2]|0)>-1:0)?(U=t+40|0,T=c[U>>2]|0,U=c[U+4>>2]|0,(S|0)>(U|0)|(S|0)==(U|0)&R>>>0>T>>>0):0){i=f+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;m=f+24|0;k=f+32|0;j=c[k>>2]|0;k=c[k+4>>2]|0;l=f+40|0;n=t+32|0;o=c[n>>2]|0;n=c[n+4>>2]|0;ba=(a[v>>0]|0)==0;l=Ww(c[m>>2]|0,c[m+4>>2]|0,c[l>>2]|0,c[l+4>>2]|0)|0;m=F()|0;n=Ww(P|0,Q|0,o|0,n|0)|0;o=F()|0;if(ba){$=Uw(n|0,o|0,l|0,m|0)|0;ba=F()|0;Z=Ww(h|0,i|0,j|0,k|0)|0;_=F()|0;aa=Ww(R|0,S|0,T|0,U|0)|0;aa=Uw(Z|0,_|0,aa|0,F()|0)|0;if(!(($|0)==(aa|0)&(ba|0)==(F()|0)))break}else{A=(m|0)<0;da=_w(l|0,m|0,63)|0;F()|0;X=(o|0)<0;G=_w(n|0,o|0,63)|0;F()|0;G=(da|0)==(G|0);da=Ww(0,0,l|0,m|0)|0;ca=F()|0;da=A?da:l;m=A?ca:m;ca=Ww(0,0,n|0,o|0)|0;A=F()|0;n=X?ca:n;A=X?A:o;X=Uw(A|0,0,m|0,0)|0;ca=F()|0;C=Uw(n|0,0,da|0,0)|0;Z=F()|0;n=Uw(n|0,0,m|0,0)|0;m=F()|0;da=Uw(A|0,0,da|0,0)|0;da=Vw(n|0,m|0,da|0,F()|0)|0;ca=Vw(F()|0,0,X|0,ca|0)|0;X=F()|0;da=Vw(0,da|0,C|0,Z|0)|0;m=F()|0;C=Vw(ca|0,X|0,(m>>>0<Z>>>0|(m|0)==(Z|0)&da>>>0<C>>>0)&1|0,0)|0;Z=F()|0;X=(da|0)==0&(m|0)==0;ca=Ww(0,0,da|0,m|0)|0;n=F()|0;A=Ww(0,0,C|0,Z|0)|0;Y=F()|0;D=Ww(h|0,i|0,j|0,k|0)|0;o=F()|0;p=Ww(R|0,S|0,T|0,U|0)|0;k=F()|0;$=(o|0)<0;ba=_w(D|0,o|0,63)|0;F()|0;l=(k|0)<0;_=_w(p|0,k|0,63)|0;F()|0;_=(ba|0)==(_|0);ba=Ww(0,0,D|0,o|0)|0;E=F()|0;D=$?ba:D;o=$?E:o;E=Ww(0,0,p|0,k|0)|0;$=F()|0;p=l?E:p;k=l?$:k;$=Uw(o|0,0,k|0,0)|0;l=F()|0;E=Uw(D|0,0,p|0,0)|0;ba=F()|0;p=Uw(o|0,0,p|0,0)|0;o=F()|0;k=Uw(D|0,0,k|0,0)|0;k=Vw(p|0,o|0,k|0,F()|0)|0;l=Vw(F()|0,0,$|0,l|0)|0;$=F()|0;k=Vw(0,k|0,E|0,ba|0)|0;o=F()|0;E=Vw(l|0,$|0,(o>>>0<ba>>>0|(o|0)==(ba|0)&k>>>0<E>>>0)&1|0,0)|0;ba=F()|0;$=(k|0)==0&(o|0)==0;l=Ww(0,0,k|0,o|0)|0;p=F()|0;D=Ww(0,0,E|0,ba|0)|0;aa=F()|0;if(!((((G?da:ca)|0)==((_?k:l)|0)?((G?m:n)|0)==((_?o:p)|0):0)&(((G?C:X?A:~C)|0)==((_?E:$?D:~E)|0)?((G?Z:X?Y:~Z)|0)==((_?ba:$?aa:~ba)|0):0)))break}if((c[f+64>>2]|0)!=0?(c[t+64>>2]|0)!=0:0){da=bd(b,t,f)|0;i=f+32|0;c[H>>2]=c[i>>2];c[H+4>>2]=c[i+4>>2];c[H+8>>2]=c[i+8>>2];c[H+12>>2]=c[i+12>>2];i=Zj(24)|0;h=i+8|0;c[I>>2]=i;c[i>>2]=u;c[i+4>>2]=da;c[h>>2]=c[H>>2];c[h+4>>2]=c[H+4>>2];c[h+8>>2]=c[H+8>>2];c[h+12>>2]=c[H+12>>2];h=c[w>>2]|0;if((h|0)==(c[x>>2]|0))Re(y,I);else{c[h>>2]=i;c[w>>2]=(c[w>>2]|0)+4;}}}}else f=h;while(0);f=c[f+92>>2]|0;c[V>>2]=f;}while((f|0)!=0);Eb=W;return}function Xc(b){b=b|0;var d=0,e=0.0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0.0;C=Eb;Eb=Eb+16|0;s=C;w=b+72|0;x=b+76|0;d=c[w>>2]|0;if((c[x>>2]|0)==(d|0)){Eb=C;return}z=b+40|0;A=b+40|0;B=b+44|0;t=b+48|0;u=b+141|0;v=b+140|0;r=0;do{i=c[d+(r<<2)>>2]|0;f=c[z>>2]|0;p=c[f+(c[c[i>>2]>>2]<<2)>>2]|0;while(1){d=c[f+(c[p>>2]<<2)>>2]|0;if((p|0)==(d|0))break;else p=d;}j=i+4|0;h=c[f+(c[c[j>>2]>>2]<<2)>>2]|0;while(1){d=c[f+(c[h>>2]<<2)>>2]|0;if((h|0)==(d|0))break;else h=d;}n=p+16|0;a:do if(((c[n>>2]|0?(y=h+16|0,c[y>>2]|0):0)?(a[p+5>>0]|0)==0:0)?(a[h+5>>0]|0)==0:0){g=(p|0)==(h|0);b:do if(g){f=p;k=p;}else{d=p;do{d=c[d+8>>2]|0;if((d|0)==(h|0)){f=h;k=h;break b}}while((d|0)!=0);d=h;do{d=c[d+8>>2]|0;if((d|0)==(p|0)){f=p;k=h;break b}}while((d|0)!=0);f=fd(p,h)|0;k=h;}while(0);if(td(b,i,p,k)|0){if(!g){c[y>>2]=0;c[k+20>>2]=0;c[h>>2]=c[p>>2];a[p+4>>0]=a[f+4>>0]|0;d=k+8|0;if((f|0)==(k|0))c[p+8>>2]=c[d>>2];c[d>>2]=p;if(!(a[u>>0]|0))break;d=c[B>>2]|0;f=c[A>>2]|0;j=f;if((d|0)==(f|0))break;g=d-f>>2;f=0;while(1){h=c[j+(f<<2)>>2]|0;i=h+8|0;d=c[i>>2]|0;c:do if(!d)d=0;else while(1){if(c[d+16>>2]|0)break c;d=c[d+8>>2]|0;if(!d){d=0;break}}while(0);if((d|0)==(k|0)&(c[h+16>>2]|0)!=0)c[i>>2]=p;f=f+1|0;if(f>>>0>=g>>>0)break a}}c[n>>2]=c[i>>2];c[p+20>>2]=0;d=Zj(24)|0;c[s>>2]=d;a[d+4>>0]=0;a[d+5>>0]=0;f=d+8|0;c[f>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;f=c[B>>2]|0;if((f|0)==(c[t>>2]|0)){Pe(A,s);l=c[B>>2]|0;}else{c[f>>2]=d;l=(c[B>>2]|0)+4|0;c[B>>2]=l;}i=c[A>>2]|0;f=(l-i>>2)+-1|0;o=c[s>>2]|0;c[o>>2]=f;m=c[j>>2]|0;g=o+16|0;c[g>>2]=m;d=m;do{c[d>>2]=f;d=c[d+28>>2]|0;}while((d|0)!=(m|0));h=c[n>>2]|0;d=m;do{f=uc(d+8|0,h)|0;if((f|0)>-1){q=30;break}d=c[d+24>>2]|0;}while((d|0)!=(m|0));if((q|0)==30?(q=0,(f|0)==0):0){d=h;while(1){g=uc(d+8|0,m)|0;if((g|0)>-1){q=43;break}d=c[d+24>>2]|0;if((d|0)==(h|0)){q=42;break}}if((q|0)==42){q=0;f=p+4|0;d=a[f>>0]|0;a[o+4>>0]=d;}else if((q|0)==43){q=0;f=p+4|0;d=a[f>>0]|0;a[o+4>>0]=d;if(!g){c[o+8>>2]=c[p+8>>2];if(!(a[u>>0]|0))break;k=i;if((l|0)==(i|0))break;i=l-i>>2;h=0;while(1){f=c[k+(h<<2)>>2]|0;j=f+8|0;d=c[j>>2]|0;d:do if(!d)d=0;else while(1){if(c[d+16>>2]|0)break d;d=c[d+8>>2]|0;if(!d){d=0;break}}while(0);g=c[f+16>>2]|0;do if((d|0)==(p|0)&(g|0)!=0){d=g;do{f=uc(d+8|0,m)|0;if((f|0)>-1){q=63;break}d=c[d+24>>2]|0;}while((d|0)!=(g|0));if((q|0)==63?(q=0,(f|0)==0):0)break;c[j>>2]=o;}while(0);h=h+1|0;if(h>>>0>=i>>>0)break a}}}d=d^1;a[f>>0]=d;m=p+8|0;c[o+8>>2]=c[m>>2];c[m>>2]=o;if(a[u>>0]|0){ud(b,p,o);d=a[f>>0]|0;h=c[n>>2]|0;}f=(a[v>>0]^d)&255;g=(h|0)==0;if(g)break;e=0.0;d=h;do{o=c[d+28>>2]|0;p=o+8|0;n=d+8|0;p=Vw(c[n>>2]|0,c[n+4>>2]|0,c[p>>2]|0,c[p+4>>2]|0)|0;D=+(p>>>0)+4294967296.0*+(F()|0);o=o+16|0;p=d+16|0;p=Ww(c[o>>2]|0,c[o+4>>2]|0,c[p>>2]|0,c[p+4>>2]|0)|0;e=e+D*(+(p>>>0)+4294967296.0*+(F()|0));d=c[d+24>>2]|0;}while((d|0)!=(h|0));if(g|(f|0)!=(e*.5>0.0|0))break;d=h;while(1){o=d+24|0;p=d;d=c[o>>2]|0;p=p+28|0;c[o>>2]=c[p>>2];c[p>>2]=d;if((d|0)==(h|0))break a}}f=o+4|0;d=a[p+4>>0]^1;a[f>>0]=d;c[o+8>>2]=p;if(!(a[u>>0]|0))h=m;else{ud(b,o,p);d=a[f>>0]|0;h=c[g>>2]|0;}f=(a[v>>0]^d)&255;g=(h|0)==0;if(!g){e=0.0;d=h;do{o=c[d+28>>2]|0;p=o+8|0;n=d+8|0;p=Vw(c[n>>2]|0,c[n+4>>2]|0,c[p>>2]|0,c[p+4>>2]|0)|0;D=+(p>>>0)+4294967296.0*+(F()|0);o=o+16|0;p=d+16|0;p=Ww(c[o>>2]|0,c[o+4>>2]|0,c[p>>2]|0,c[p+4>>2]|0)|0;e=e+D*(+(p>>>0)+4294967296.0*+(F()|0));d=c[d+24>>2]|0;}while((d|0)!=(h|0));if(!(g|(f|0)!=(e*.5>0.0|0))){d=h;do{o=d+24|0;p=d;d=c[o>>2]|0;p=p+28|0;c[o>>2]=c[p>>2];c[p>>2]=d;}while((d|0)!=(h|0))}}}}while(0);r=r+1|0;d=c[w>>2]|0;}while(r>>>0<(c[x>>2]|0)-d>>2>>>0);Eb=C;return}function Yc(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;c[d+20>>2]=0;D=d+16|0;e=c[D>>2]|0;if(!(a[b+36>>0]|0))C=(a[b+142>>0]|0)!=0;else C=1;d=e;g=d+28|0;f=c[g>>2]|0;a:do if((f|0)!=(d|0)){B=b+20|0;b=0;b:while(1){r=d+24|0;l=c[r>>2]|0;A=l;if((f|0)==(l|0)){e=f;break a}t=d+8|0;s=c[t>>2]|0;t=c[t+4>>2]|0;v=l+8|0;u=c[v>>2]|0;v=c[v+4>>2]|0;w=(s|0)==(u|0)&(t|0)==(v|0);if(w?(z=d+16|0,E=l+16|0,(c[z>>2]|0)==(c[E>>2]|0)?(c[z+4>>2]|0)==(c[E+4>>2]|0):0):0)E=23;else E=12;c:do if((E|0)==12){E=0;y=f+8|0;x=c[y>>2]|0;y=c[y+4>>2]|0;z=(x|0)==(s|0)&(y|0)==(t|0);if(z){k=d+16|0;j=c[k>>2]|0;k=c[k+4>>2]|0;i=f+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;if((j|0)==(h|0)&(k|0)==(i|0)){E=23;break}else q=j;}else{i=f+16|0;k=d+16|0;h=c[i>>2]|0;i=c[i+4>>2]|0;q=c[k>>2]|0;k=c[k+4>>2]|0;}p=l+16|0;o=c[p>>2]|0;p=c[p+4>>2]|0;G=(a[B>>0]|0)==0;j=Ww(h|0,i|0,q|0,k|0)|0;l=F()|0;m=Ww(s|0,t|0,u|0,v|0)|0;n=F()|0;if(G){m=Uw(m|0,n|0,j|0,l|0)|0;G=F()|0;l=Ww(x|0,y|0,s|0,t|0)|0;n=F()|0;j=Ww(q|0,k|0,o|0,p|0)|0;n=Uw(j|0,F()|0,l|0,n|0)|0;if((m|0)==(n|0)&(G|0)==(F()|0))E=18;}else{R=(l|0)<0;V=_w(j|0,l|0,63)|0;F()|0;I=(n|0)<0;J=_w(m|0,n|0,63)|0;F()|0;J=(V|0)==(J|0);V=Ww(0,0,j|0,l|0)|0;Q=F()|0;V=R?V:j;Q=R?Q:l;R=Ww(0,0,m|0,n|0)|0;N=F()|0;R=I?R:m;N=I?N:n;I=Uw(N|0,0,Q|0,0)|0;U=F()|0;M=Uw(R|0,0,V|0,0)|0;j=F()|0;Q=Uw(R|0,0,Q|0,0)|0;R=F()|0;V=Uw(N|0,0,V|0,0)|0;V=Vw(Q|0,R|0,V|0,F()|0)|0;U=Vw(F()|0,0,I|0,U|0)|0;I=F()|0;V=Vw(0,V|0,M|0,j|0)|0;R=F()|0;M=Vw(U|0,I|0,(R>>>0<j>>>0|(R|0)==(j|0)&V>>>0<M>>>0)&1|0,0)|0;j=F()|0;I=(V|0)==0&(R|0)==0;U=Ww(0,0,V|0,R|0)|0;Q=F()|0;N=Ww(0,0,M|0,j|0)|0;H=F()|0;T=Ww(x|0,y|0,s|0,t|0)|0;O=F()|0;P=Ww(q|0,k|0,o|0,p|0)|0;L=F()|0;m=(O|0)<0;G=_w(T|0,O|0,63)|0;F()|0;S=(L|0)<0;l=_w(P|0,L|0,63)|0;F()|0;l=(G|0)==(l|0);G=Ww(0,0,T|0,O|0)|0;K=F()|0;T=m?G:T;O=m?K:O;K=Ww(0,0,P|0,L|0)|0;m=F()|0;P=S?K:P;L=S?m:L;m=Uw(L|0,0,O|0,0)|0;S=F()|0;K=Uw(P|0,0,T|0,0)|0;G=F()|0;O=Uw(P|0,0,O|0,0)|0;P=F()|0;T=Uw(L|0,0,T|0,0)|0;T=Vw(O|0,P|0,T|0,F()|0)|0;S=Vw(F()|0,0,m|0,S|0)|0;m=F()|0;T=Vw(0,T|0,K|0,G|0)|0;P=F()|0;K=Vw(S|0,m|0,(P>>>0<G>>>0|(P|0)==(G|0)&T>>>0<K>>>0)&1|0,0)|0;G=F()|0;m=(T|0)==0&(P|0)==0;S=Ww(0,0,T|0,P|0)|0;O=F()|0;L=Ww(0,0,K|0,G|0)|0;n=F()|0;if((((J?V:U)|0)==((l?T:S)|0)?((J?R:Q)|0)==((l?P:O)|0):0)&(((J?M:I?N:~M)|0)==((l?K:m?L:~K)|0)?((J?j:I?H:~j)|0)==((l?G:m?n:~G)|0):0))E=18;}do if((E|0)==18){E=0;if(!C){E=23;break c}j=(x|0)==(u|0)&(y|0)==(v|0);if(j&((h|0)==(o|0)&(i|0)==(p|0))|z&((h|0)==(q|0)&(i|0)==(k|0))|w&((q|0)==(o|0)&(k|0)==(p|0))){E=23;break c}if(j)if(((i|0)<(k|0)|(i|0)==(k|0)&h>>>0<q>>>0)^((k|0)<(p|0)|(k|0)==(p|0)&q>>>0<o>>>0)){E=23;break c}else break;else if(((y|0)<(t|0)|(y|0)==(t|0)&x>>>0<s>>>0)^((t|0)<(v|0)|(t|0)==(v|0)&s>>>0<u>>>0)){E=23;break c}else break}while(0);if((b|0)==(d|0)){E=27;break b}b=(b|0)==0?d:b;e=A;}while(0);if((E|0)==23){E=0;c[f+24>>2]=A;c[(c[r>>2]|0)+28>>2]=c[g>>2];V=c[g>>2]|0;$j(e);b=0;e=V;}d=e;g=d+28|0;f=c[g>>2]|0;if((f|0)==(d|0)){E=6;break}}if((E|0)==6){d=e;E=7;break}else if((E|0)==27){c[D>>2]=d;return}}else E=7;while(0);if((E|0)==7)if(!e){V=0;c[D>>2]=V;return}else e=d;c[e+24>>2]=0;do{V=d;d=c[d+24>>2]|0;$j(V);}while((d|0)!=0);d=0;c[D>>2]=d;return}function Zc(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;E=Eb;Eb=Eb+16|0;x=E;y=b+40|0;z=b+44|0;d=c[y>>2]|0;if((c[z>>2]|0)==(d|0)){Eb=E;return}C=b+48|0;D=b+141|0;w=0;do{r=c[d+(w<<2)>>2]|0;w=w+1|0;s=r+16|0;d=c[s>>2]|0;a:do if(d|0?(a[r+5>>0]|0)==0:0){t=r+4|0;u=r+8|0;q=d;do{p=q+24|0;e=c[p>>2]|0;if((e|0)==(d|0))break a;m=q+8|0;n=q+16|0;o=q+28|0;d=e;do{k=m;l=d+8|0;b:do if(((((c[k>>2]|0)==(c[l>>2]|0)?(c[k+4>>2]|0)==(c[l+4>>2]|0):0)?(k=n,l=d+16|0,(c[k>>2]|0)==(c[l>>2]|0)?(c[k+4>>2]|0)==(c[l+4>>2]|0):0):0)?(c[d+24>>2]|0)!=(q|0):0)?(A=d+28|0,B=c[A>>2]|0,(B|0)!=(q|0)):0){e=c[o>>2]|0;c[o>>2]=B;c[B+24>>2]=q;c[A>>2]=e;c[e+24>>2]=d;c[s>>2]=q;e=Zj(24)|0;c[x>>2]=e;a[e+4>>0]=0;a[e+5>>0]=0;f=e+8|0;c[f>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;f=c[z>>2]|0;if((f|0)==(c[C>>2]|0)){Pe(y,x);i=c[z>>2]|0;}else{c[f>>2]=e;i=(c[z>>2]|0)+4|0;c[z>>2]=i;}h=c[y>>2]|0;f=(i-h>>2)+-1|0;l=c[x>>2]|0;c[l>>2]=f;c[l+16>>2]=d;e=d;do{c[e>>2]=f;e=c[e+28>>2]|0;}while((e|0)!=(d|0));g=c[s>>2]|0;e=d;do{f=uc(e+8|0,g)|0;if((f|0)>-1){v=20;break}e=c[e+24>>2]|0;}while((e|0)!=(d|0));if((v|0)==20?(v=0,(f|0)==0):0){e=g;while(1){f=uc(e+8|0,d)|0;if((f|0)>-1){v=27;break}e=c[e+24>>2]|0;if((e|0)==(g|0)){v=26;break}}if((v|0)==26){v=0;d=a[t>>0]|0;a[l+4>>0]=d;}else if((v|0)==27){v=0;e=a[t>>0]|0;a[l+4>>0]=e;if(!f){c[l+8>>2]=c[u>>2];if(!(a[D>>0]|0)){d=q;break}k=h;if((i|0)==(h|0)){d=q;break}i=i-h>>2;h=0;while(1){f=c[k+(h<<2)>>2]|0;j=f+8|0;e=c[j>>2]|0;c:do if(!e)e=0;else while(1){if(c[e+16>>2]|0)break c;e=c[e+8>>2]|0;if(!e){e=0;break}}while(0);g=c[f+16>>2]|0;do if((e|0)==(r|0)&(g|0)!=0){e=g;do{f=uc(e+8|0,d)|0;if((f|0)>-1){v=41;break}e=c[e+24>>2]|0;}while((e|0)!=(g|0));if((v|0)==41?(v=0,(f|0)==0):0)break;c[j>>2]=l;}while(0);h=h+1|0;if(h>>>0>=i>>>0){d=q;break b}}}else d=e;}a[t>>0]=d^1;c[l+8>>2]=c[u>>2];c[u>>2]=l;if(!(a[D>>0]|0)){d=q;break}ud(b,r,l);d=q;break}a[l+4>>0]=a[t>>0]^1;c[l+8>>2]=r;if(!(a[D>>0]|0))d=q;else{ud(b,l,r);d=q;}}while(0);d=c[d+24>>2]|0;}while((d|0)!=(c[s>>2]|0));q=c[p>>2]|0;}while((q|0)!=(d|0))}while(0);d=c[y>>2]|0;}while(w>>>0<(c[z>>2]|0)-d>>2>>>0);Eb=E;return}function _c(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;d=c[b+96>>2]|0;a:do if(d){g=c[b+56>>2]|0;i=d;while(1){if((c[i+56>>2]|0)==(g|0)?(h=c[i+64>>2]|0,h|0):0)break;d=c[i+96>>2]|0;if(!d){j=6;break a}else i=d;}d=c[b+64>>2]|0;e=(d|0)==0;if(e?(c[a+108>>2]|0)!=1:0){c[b+68>>2]=1;d=c[i+72>>2]|0;c[b+72>>2]=d;f=i+92|0;break}if(!(c[((g|0)==0?a+136|0:a+132|0)>>2]|0)){if(e){e=c[i+96>>2]|0;if(!e)d=1;else{d=1;do{if((c[e+56>>2]|0)==(g|0))d=d^(c[e+64>>2]|0)!=0;e=c[e+96>>2]|0;}while((e|0)!=0)}d=(d^1)&1;}c[b+68>>2]=d;d=c[i+72>>2]|0;c[b+72>>2]=d;f=i+92|0;break}else{f=c[i+68>>2]|0;do if((A(h,f)|0)<0){m=((f|0)<0)<<31>>31;l=(m|0)<0;k=Ww(0,0,f|0,m|0)|0;n=F()|0;m=l?n:m;if((m|0)>0|(m|0)==0&(l?k:f)>>>0>1){n=(A(h,d)|0)<0;d=f+(n?0:d)|0;break}else{d=e?1:d;break}}else if(e){d=(f>>31|1)+f|0;break}else{n=(A(h,d)|0)<0;d=f+(n?0:d)|0;break}while(0);c[b+68>>2]=d;d=c[i+72>>2]|0;c[b+72>>2]=d;f=i+92|0;break}}else j=6;while(0);if((j|0)==6){d=c[b+64>>2]|0;e=c[b+56>>2]|0;if(!d)d=(c[((e|0)==0?a+136|0:a+132|0)>>2]|0)==3?-1:1;c[b+68>>2]=d;c[b+72>>2]=0;f=a+52|0;d=0;g=e;}e=c[f>>2]|0;f=(e|0)==(b|0);if(c[((g|0)==0?a+132|0:a+136|0)>>2]|0){if(f)return;f=b+72|0;do{d=d+(c[e+64>>2]|0)|0;e=c[e+92>>2]|0;}while((e|0)!=(b|0));c[f>>2]=d;return}if(f)return;f=b+72|0;do{if(c[e+64>>2]|0){d=(d|0)==0&1;c[f>>2]=d;}e=c[e+92>>2]|0;}while((e|0)!=(b|0));return}function $c(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;e=(c[b+56>>2]|0)==0;g=a+136|0;f=a+132|0;d=c[(e?f:g)>>2]|0;switch(c[(e?g:f)>>2]|0){case 0:{if((c[b+64>>2]|0)==0?(c[b+68>>2]|0)!=1:0){g=0;return g|0}break}case 1:{i=c[b+68>>2]|0;g=((i|0)<0)<<31>>31;h=(g|0)<0;j=Ww(0,0,i|0,g|0)|0;f=F()|0;if(!(((h?j:i)|0)==1&((h?f:g)|0)==0)){j=0;return j|0}break}case 2:{if((c[b+68>>2]|0)!=1){j=0;return j|0}break}default:if((c[b+68>>2]|0)!=-1){j=0;return j|0}}switch(c[a+108>>2]|0){case 0:switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)!=0;return j|0}case 2:{j=(c[b+72>>2]|0)>0;return j|0}default:{j=(c[b+72>>2]|0)<0;return j|0}}case 1:switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)==0;return j|0}case 2:{j=(c[b+72>>2]|0)<1;return j|0}default:{j=(c[b+72>>2]|0)>-1;return j|0}}case 2:if(e)switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)==0;return j|0}case 2:{j=(c[b+72>>2]|0)<1;return j|0}default:{j=(c[b+72>>2]|0)>-1;return j|0}}else switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)!=0;return j|0}case 2:{j=(c[b+72>>2]|0)>0;return j|0}default:{j=(c[b+72>>2]|0)<0;return j|0}}case 3:{if(c[b+64>>2]|0){j=1;return j|0}switch(d|0){case 1:case 0:{j=(c[b+72>>2]|0)==0;return j|0}case 2:{j=(c[b+72>>2]|0)<1;return j|0}default:{j=(c[b+72>>2]|0)>-1;return j|0}}}default:{j=1;return j|0}}return 0}function ad(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,t=0,u=0,v=0,w=0,x=0,y=0.0,A=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0;x=Eb;Eb=Eb+16|0;w=x;y=+g[e+48>>3];if(!(y==-1.e+40)?!(+g[d+48>>3]>y):0){h=bd(b,e,f)|0;c[d+76>>2]=c[e+76>>2];c[d+60>>2]=2;c[e+60>>2]=1;i=c[e+96>>2]|0;if((i|0)==(d|0)){v=h;j=e;i=c[d+96>>2]|0;}else{v=h;j=e;}}else{h=bd(b,d,f)|0;c[e+76>>2]=c[d+76>>2];c[d+60>>2]=1;c[e+60>>2]=2;i=c[d+96>>2]|0;if((i|0)==(e|0)){v=h;j=d;i=c[e+96>>2]|0;}else{v=h;j=d;}}if(!i){Eb=x;return v|0}if((c[i+76>>2]|0)<=-1){Eb=x;return v|0}d=i+40|0;h=c[d>>2]|0;d=c[d+4>>2]|0;n=f+8|0;m=c[n>>2]|0;n=c[n+4>>2]|0;if(!((n|0)>(d|0)|(n|0)==(d|0)&m>>>0>h>>>0)){Eb=x;return v|0}u=j+32|0;p=j+40|0;o=c[p>>2]|0;p=c[p+4>>2]|0;if(!((n|0)>(p|0)|(n|0)==(p|0)&m>>>0>o>>>0)){Eb=x;return v|0}q=i;t=c[q>>2]|0;q=c[q+4>>2]|0;y=+g[i+48>>3];l=i+8|0;l=Ww(m|0,n|0,c[l>>2]|0,c[l+4>>2]|0)|0;y=y*(+(l>>>0)+4294967296.0*+(F()|0));y=y+(y<0.0?-.5:.5);q=Vw(t|0,q|0,~~y>>>0|0,(+s(y)>=1.0?(y>0.0?~~+B(+r(y/4294967296.0),4294967295.0)>>>0:~~+z((y-+(~~y>>>0))/4294967296.0)>>>0):0)|0)|0;t=F()|0;l=j;k=c[l>>2]|0;l=c[l+4>>2]|0;y=+g[j+48>>3];e=j+8|0;e=Ww(m|0,n|0,c[e>>2]|0,c[e+4>>2]|0)|0;y=y*(+(e>>>0)+4294967296.0*+(F()|0));y=y+(y<0.0?-.5:.5);l=Vw(k|0,l|0,~~y>>>0|0,(+s(y)>=1.0?(y>0.0?~~+B(+r(y/4294967296.0),4294967295.0)>>>0:~~+z((y-+(~~y>>>0))/4294967296.0)>>>0):0)|0)|0;if(!((q|0)==(l|0)&(t|0)==(F()|0))){Eb=x;return v|0}if(!(c[j+64>>2]|0)){Eb=x;return v|0}if(!(c[i+64>>2]|0)){Eb=x;return v|0}l=i+32|0;k=c[l>>2]|0;l=c[l+4>>2]|0;e=j+32|0;j=c[e>>2]|0;e=c[e+4>>2]|0;A=(a[b+20>>0]|0)==0;h=Ww(m|0,n|0,h|0,d|0)|0;d=F()|0;e=Ww(q|0,t|0,j|0,e|0)|0;j=F()|0;if(A){j=Uw(e|0,j|0,h|0,d|0)|0;A=F()|0;l=Ww(q|0,t|0,k|0,l|0)|0;q=F()|0;t=Ww(m|0,n|0,o|0,p|0)|0;t=Uw(l|0,q|0,t|0,F()|0)|0;if(!((j|0)==(t|0)&(A|0)==(F()|0))){Eb=x;return v|0}}else{G=(d|0)<0;J=_w(h|0,d|0,63)|0;F()|0;I=(j|0)<0;C=_w(e|0,j|0,63)|0;F()|0;C=(J|0)==(C|0);J=Ww(0,0,h|0,d|0)|0;E=F()|0;J=G?J:h;E=G?E:d;G=Ww(0,0,e|0,j|0)|0;D=F()|0;G=I?G:e;D=I?D:j;d=Uw(D|0,0,E|0,0)|0;I=F()|0;h=Uw(G|0,0,J|0,0)|0;j=F()|0;E=Uw(G|0,0,E|0,0)|0;G=F()|0;J=Uw(D|0,0,J|0,0)|0;J=Vw(E|0,G|0,J|0,F()|0)|0;I=Vw(F()|0,0,d|0,I|0)|0;d=F()|0;J=Vw(0,J|0,h|0,j|0)|0;G=F()|0;h=Vw(I|0,d|0,(G>>>0<j>>>0|(G|0)==(j|0)&J>>>0<h>>>0)&1|0,0)|0;j=F()|0;d=(J|0)==0&(G|0)==0;I=Ww(0,0,J|0,G|0)|0;E=F()|0;D=Ww(0,0,h|0,j|0)|0;e=F()|0;A=Ww(q|0,t|0,k|0,l|0)|0;l=F()|0;m=Ww(m|0,n|0,o|0,p|0)|0;H=F()|0;q=(l|0)<0;n=_w(A|0,l|0,63)|0;F()|0;k=(H|0)<0;p=_w(m|0,H|0,63)|0;F()|0;p=(n|0)==(p|0);n=Ww(0,0,A|0,l|0)|0;o=F()|0;n=q?n:A;l=q?o:l;o=Ww(0,0,m|0,H|0)|0;q=F()|0;m=k?o:m;H=k?q:H;q=Uw(l|0,0,H|0,0)|0;k=F()|0;o=Uw(n|0,0,m|0,0)|0;A=F()|0;m=Uw(l|0,0,m|0,0)|0;l=F()|0;H=Uw(n|0,0,H|0,0)|0;H=Vw(m|0,l|0,H|0,F()|0)|0;k=Vw(F()|0,0,q|0,k|0)|0;q=F()|0;H=Vw(0,H|0,o|0,A|0)|0;l=F()|0;o=Vw(k|0,q|0,(l>>>0<A>>>0|(l|0)==(A|0)&H>>>0<o>>>0)&1|0,0)|0;A=F()|0;q=(H|0)==0&(l|0)==0;k=Ww(0,0,H|0,l|0)|0;m=F()|0;n=Ww(0,0,o|0,A|0)|0;t=F()|0;if(!((((C?J:I)|0)==((p?H:k)|0)?((C?G:E)|0)==((p?l:m)|0):0)&(((C?h:d?D:~h)|0)==((p?o:q?n:~o)|0)?((C?j:d?e:~j)|0)==((p?A:q?t:~A)|0):0))){Eb=x;return v|0}}i=bd(b,i,f)|0;d=Zj(24)|0;h=d+8|0;c[w>>2]=d;c[d>>2]=v;c[d+4>>2]=i;c[h>>2]=c[u>>2];c[h+4>>2]=c[u+4>>2];c[h+8>>2]=c[u+8>>2];c[h+12>>2]=c[u+12>>2];h=b+76|0;i=c[h>>2]|0;if((i|0)==(c[b+80>>2]|0))Re(b+72|0,w);else{c[i>>2]=d;c[h>>2]=(c[h>>2]|0)+4;}Eb=x;return v|0}function bd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+16|0;j=l;k=d+76|0;f=c[k>>2]|0;if((f|0)>=0){h=c[(c[b+40>>2]|0)+(f<<2)>>2]|0;b=h+16|0;i=c[b>>2]|0;g=(c[d+60>>2]|0)==1;if(g){d=e;k=i+8|0;if(((c[d>>2]|0)==(c[k>>2]|0)?(c[d+4>>2]|0)==(c[k+4>>2]|0):0)?(d=e+8|0,k=i+16|0,(c[d>>2]|0)==(c[k>>2]|0)?(c[d+4>>2]|0)==(c[k+4>>2]|0):0):0){k=i;Eb=l;return k|0}}else{f=c[i+28>>2]|0;d=e;k=f+8|0;if(((c[d>>2]|0)==(c[k>>2]|0)?(c[d+4>>2]|0)==(c[k+4>>2]|0):0)?(d=e+8|0,k=f+16|0,(c[d>>2]|0)==(c[k>>2]|0)?(c[d+4>>2]|0)==(c[k+4>>2]|0):0):0){k=f;Eb=l;return k|0}}f=Zj(32)|0;k=f+8|0;c[k>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;c[f>>2]=c[h>>2];c[k>>2]=c[e>>2];c[k+4>>2]=c[e+4>>2];c[k+8>>2]=c[e+8>>2];c[k+12>>2]=c[e+12>>2];c[f+24>>2]=i;k=i+28|0;e=c[k>>2]|0;c[f+28>>2]=e;c[e+24>>2]=f;c[k>>2]=f;if(!g){k=f;Eb=l;return k|0}c[b>>2]=f;k=f;Eb=l;return k|0}h=Zj(24)|0;c[j>>2]=h;a[h+4>>0]=0;a[h+5>>0]=0;g=h+8|0;i=b+40|0;f=b+44|0;c[g>>2]=0;c[g+4>>2]=0;c[g+8>>2]=0;c[g+12>>2]=0;g=c[f>>2]|0;if((g|0)==(c[b+48>>2]|0)){Pe(i,j);f=c[f>>2]|0;}else{c[g>>2]=h;b=(c[f>>2]|0)+4|0;c[f>>2]=b;f=b;}b=c[i>>2]|0;j=c[j>>2]|0;c[j>>2]=(f-b>>2)+-1;h=j+5|0;a[h>>0]=(c[d+64>>2]|0)==0&1;i=Zj(32)|0;g=i+8|0;c[g>>2]=0;c[g+4>>2]=0;c[g+8>>2]=0;c[g+12>>2]=0;c[j+16>>2]=i;c[i>>2]=c[j>>2];c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];c[g+8>>2]=c[e+8>>2];c[g+12>>2]=c[e+12>>2];c[i+24>>2]=i;c[i+28>>2]=i;if(!(a[h>>0]|0)){f=c[d+96>>2]|0;if(f){g=0;do{h=c[f+76>>2]|0;if((h|0)>-1?(c[f+64>>2]|0)!=0:0)if(!g)g=f;else g=(c[g+76>>2]|0)==(h|0)?0:g;f=c[f+96>>2]|0;}while((f|0)!=0);if(g){g=c[b+(c[g+76>>2]<<2)>>2]|0;f=a[g+4>>0]^1;}else{f=0;g=0;}}else{f=0;g=0;}c[j+8>>2]=g;a[j+4>>0]=f;}c[k>>2]=c[j>>2];k=i;Eb=l;return k|0}function cd(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;p=d+76|0;s=c[b+40>>2]|0;t=c[s+(c[p>>2]<<2)>>2]|0;r=e+76|0;s=c[s+(c[r>>2]<<2)>>2]|0;f=t;while(1){f=c[f+8>>2]|0;if((f|0)==(s|0)){n=s;break}if(!f){u=4;break}}a:do if((u|0)==4){f=s;do{f=c[f+8>>2]|0;if((f|0)==(t|0)){n=t;break a}}while((f|0)!=0);n=fd(t,s)|0;}while(0);h=t+16|0;i=c[h>>2]|0;j=i+28|0;k=c[j>>2]|0;o=s+16|0;l=c[o>>2]|0;g=l+28|0;m=c[g>>2]|0;q=c[d+60>>2]|0;f=c[e+60>>2]|0;do if((q|0)==1){if((f|0)!=1){c[m+24>>2]=i;c[j>>2]=m;c[g>>2]=k;c[k+24>>2]=l;c[h>>2]=l;break}if(l|0){f=l;do{g=f+24|0;e=f;f=c[g>>2]|0;e=e+28|0;c[g>>2]=c[e>>2];c[e>>2]=f;}while((f|0)!=(l|0))}c[l+24>>2]=i;c[j>>2]=l;c[k+24>>2]=m;c[m+28>>2]=k;c[h>>2]=m;}else{if((f|0)!=2){c[k+24>>2]=l;c[g>>2]=k;c[j>>2]=m;c[m+24>>2]=i;break}if(l|0){f=l;do{e=f+24|0;h=f;f=c[e>>2]|0;h=h+28|0;c[e>>2]=c[h>>2];c[h>>2]=f;}while((f|0)!=(l|0))}c[k+24>>2]=m;c[m+28>>2]=k;c[l+24>>2]=i;c[j>>2]=l;}while(0);c[t+20>>2]=0;d=s+8|0;if((n|0)==(s|0)){f=c[d>>2]|0;if((f|0)!=(t|0))c[t+8>>2]=f;a[t+4>>0]=a[s+4>>0]|0;}c[o>>2]=0;c[s+20>>2]=0;c[d>>2]=t;d=c[p>>2]|0;g=c[r>>2]|0;c[p>>2]=-1;c[r>>2]=-1;f=c[b+52>>2]|0;if(!f){u=c[t>>2]|0;c[s>>2]=u;return}while(1){if((c[f+76>>2]|0)==(g|0))break;f=c[f+92>>2]|0;if(!f){u=30;break}}if((u|0)==30){u=c[t>>2]|0;c[s>>2]=u;return}c[f+76>>2]=d;c[f+60>>2]=q;u=c[t>>2]|0;c[s>>2]=u;return}function dd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,t=0,u=0.0,v=0;j=a+52|0;k=c[j>>2]|0;l=k;if(!k){c[b+96>>2]=0;c[b+92>>2]=0;t=j;c[t>>2]=b;return}a:do if(!d){d=b+16|0;a=c[d>>2]|0;d=c[d+4>>2]|0;f=k+16|0;e=c[f>>2]|0;f=c[f+4>>2]|0;do if((a|0)==(e|0)&(d|0)==(f|0)){d=b+40|0;a=c[d>>2]|0;d=c[d+4>>2]|0;f=k+40|0;e=c[f>>2]|0;f=c[f+4>>2]|0;if((d|0)>(f|0)|(d|0)==(f|0)&a>>>0>e>>>0){o=b+32|0;q=c[o>>2]|0;o=c[o+4>>2]|0;t=k;p=c[t>>2]|0;t=c[t+4>>2]|0;u=+g[k+48>>3];n=k+8|0;n=Ww(a|0,d|0,c[n>>2]|0,c[n+4>>2]|0)|0;u=u*(+(n>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);t=Vw(p|0,t|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;p=F()|0;if((o|0)<(p|0)|(o|0)==(p|0)&q>>>0<t>>>0)break;else{e=k;break a}}i=k+32|0;h=c[i>>2]|0;i=c[i+4>>2]|0;if((a|0)==(e|0)&(d|0)==(f|0)){d=b+32|0;a=c[d+4>>2]|0;d=c[d>>2]|0;}else{d=b;a=c[d>>2]|0;d=c[d+4>>2]|0;u=+g[b+48>>3];t=b+8|0;t=Ww(e|0,f|0,c[t>>2]|0,c[t+4>>2]|0)|0;u=u*(+(t>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);d=Vw(a|0,d|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;a=F()|0;}if(!((i|0)>(a|0)|(i|0)==(a|0)&h>>>0>d>>>0)){e=k;break a}}else if(!((d|0)<(f|0)|(d|0)==(f|0)&a>>>0<e>>>0)){e=k;break a}while(0);c[b+96>>2]=0;c[b+92>>2]=l;c[k+96>>2]=b;t=j;c[t>>2]=b;return}else e=d;while(0);d=e+92|0;a=c[d>>2]|0;b:do if(!a)a=0;else{n=b+16|0;m=c[n>>2]|0;n=c[n+4>>2]|0;o=b+40|0;p=b+32|0;q=b+48|0;t=b+8|0;while(1){h=a+16|0;f=c[h>>2]|0;h=c[h+4>>2]|0;do if((m|0)==(f|0)&(n|0)==(h|0)){h=o;f=c[h>>2]|0;h=c[h+4>>2]|0;j=a+40|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if((h|0)>(j|0)|(h|0)==(j|0)&f>>>0>i>>>0){i=p;k=c[i>>2]|0;i=c[i+4>>2]|0;l=a;j=c[l>>2]|0;l=c[l+4>>2]|0;u=+g[a+48>>3];v=a+8|0;h=Ww(f|0,h|0,c[v>>2]|0,c[v+4>>2]|0)|0;u=u*(+(h>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);l=Vw(j|0,l|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;j=F()|0;if((i|0)<(j|0)|(i|0)==(j|0)&k>>>0<l>>>0)break b;else break}l=a+32|0;k=c[l>>2]|0;l=c[l+4>>2]|0;if((f|0)==(i|0)&(h|0)==(j|0)){h=p;f=c[h+4>>2]|0;h=c[h>>2]|0;}else{h=b;f=c[h>>2]|0;h=c[h+4>>2]|0;u=+g[q>>3];v=t;v=Ww(i|0,j|0,c[v>>2]|0,c[v+4>>2]|0)|0;u=u*(+(v>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);h=Vw(f|0,h|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;f=F()|0;}if((l|0)>(f|0)|(l|0)==(f|0)&k>>>0>h>>>0)break b}else if((n|0)<(h|0)|(n|0)==(h|0)&m>>>0<f>>>0)break b;while(0);d=a+92|0;e=c[d>>2]|0;if(!e){e=a;a=0;break}else{v=a;a=e;e=v;}}}while(0);c[b+92>>2]=a;a=c[d>>2]|0;if(a|0)c[a+96>>2]=b;c[b+96>>2]=e;v=d;c[v>>2]=b;return}function ed(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;u=b+76|0;q=c[u>>2]|0;r=(q|0)>-1;v=d+76|0;s=c[v>>2]|0;t=(s|0)>-1;m=c[b+64>>2]|0;f=(m|0)==0;p=d+64|0;k=c[p>>2]|0;g=(k|0)==0;if(f){if(g)return}else if(!g){w=c[b+56>>2]|0;o=c[d+56>>2]|0;x=(w|0)==(o|0);do if(x){g=a+136|0;l=a+132|0;f=(w|0)==0?g:l;h=b+68|0;i=c[h>>2]|0;if(!(c[f>>2]|0)){n=d+68|0;c[h>>2]=c[n>>2];c[n>>2]=i;h=l;break}j=i+k|0;c[h>>2]=(j|0)==0?0-i|0:j;i=d+68|0;j=c[i>>2]|0;h=j-m|0;if(!h){c[i>>2]=0-j;h=l;break}else{c[i>>2]=h;h=l;break}}else{g=a+136|0;j=a+132|0;f=b+72|0;h=c[f>>2]|0;c[f>>2]=(c[((o|0)==0?g:j)>>2]|0)==0?(h|0)==0&1:h+k|0;f=(w|0)==0?g:j;h=d+72|0;i=c[h>>2]|0;if(!(c[f>>2]|0)){c[h>>2]=(i|0)==0&1;h=j;break}else{c[h>>2]=i-m;h=j;break}}while(0);n=(w|0)==0;l=c[(n?h:g)>>2]|0;o=(o|0)==0;m=c[(o?h:g)>>2]|0;g=c[(o?g:h)>>2]|0;switch(c[f>>2]|0){case 2:{h=c[b+68>>2]|0;f=h;h=((h|0)<0)<<31>>31;break}case 3:{h=0-(c[b+68>>2]|0)|0;f=h;h=((h|0)<0)<<31>>31;break}default:{f=c[b+68>>2]|0;h=((f|0)<0)<<31>>31;k=(h|0)<0;j=Ww(0,0,f|0,h|0)|0;o=F()|0;f=k?j:f;h=k?o:h;}}switch(g|0){case 2:{i=c[d+68>>2]|0;g=i;i=((i|0)<0)<<31>>31;break}case 3:{i=0-(c[d+68>>2]|0)|0;g=i;i=((i|0)<0)<<31>>31;break}default:{g=c[d+68>>2]|0;i=((g|0)<0)<<31>>31;k=(i|0)<0;j=Ww(0,0,g|0,i|0)|0;o=F()|0;g=k?j:g;i=k?o:i;}}if((s|q|0)>=0){w=i|h;do if(!(w>>>0>0|(w|0)==0&(g|f)>>>0>1)){if(!x?(c[a+108>>2]|0)!=3:0)break;bd(a,b,e)|0;bd(a,d,e)|0;a=b+60|0;b=c[a>>2]|0;d=d+60|0;c[a>>2]=c[d>>2];c[d>>2]=b;d=c[u>>2]|0;c[u>>2]=c[v>>2];c[v>>2]=d;return}while(0);bd(a,b,e)|0;if(!(c[p>>2]|0))bd(a,d,e)|0;f=c[u>>2]|0;g=c[v>>2]|0;if((f|0)==(g|0)){c[u>>2]=-1;c[v>>2]=-1;return}if((f|0)<(g|0)){cd(a,b,d);return}else{cd(a,d,b);return}}if(r){if(!(i>>>0<0|(i|0)==0&g>>>0<2))return;bd(a,b,e)|0;a=b+60|0;b=c[a>>2]|0;d=d+60|0;c[a>>2]=c[d>>2];c[d>>2]=b;d=c[u>>2]|0;c[u>>2]=c[v>>2];c[v>>2]=d;return}k=(f|0)==1&(h|0)==0;f=h>>>0<0|(h|0)==0&f>>>0<2;if(t){if(!f)return;bd(a,d,e)|0;a=b+60|0;b=c[a>>2]|0;d=d+60|0;c[a>>2]=c[d>>2];c[d>>2]=b;d=c[u>>2]|0;c[u>>2]=c[v>>2];c[v>>2]=d;return}if(!f)return;j=(g|0)==1&(i|0)==0;if(!(i>>>0<0|(i|0)==0&g>>>0<2))return;switch(l|0){case 2:{i=c[b+72>>2]|0;h=((i|0)<0)<<31>>31;break}case 3:{i=0-(c[b+72>>2]|0)|0;h=((i|0)<0)<<31>>31;break}default:{i=c[b+72>>2]|0;h=((i|0)<0)<<31>>31;u=(h|0)<0;v=Ww(0,0,i|0,h|0)|0;t=F()|0;h=u?t:h;i=u?v:i;}}switch(m|0){case 2:{g=c[d+72>>2]|0;f=((g|0)<0)<<31>>31;break}case 3:{g=0-(c[d+72>>2]|0)|0;f=((g|0)<0)<<31>>31;break}default:{g=c[d+72>>2]|0;f=((g|0)<0)<<31>>31;u=(f|0)<0;v=Ww(0,0,g|0,f|0)|0;t=F()|0;f=u?t:f;g=u?v:g;}}if(!x){ad(a,b,d,e)|0;return}if(!(k&j)){a=b+60|0;b=c[a>>2]|0;d=d+60|0;c[a>>2]=c[d>>2];c[d>>2]=b;return}switch(c[a+108>>2]|0){case 0:{if(!(((h|0)>0|(h|0)==0&i>>>0>0)&((f|0)>0|(f|0)==0&g>>>0>0)))return;ad(a,b,d,e)|0;return}case 1:{if(!(((h|0)<0|(h|0)==0&i>>>0<1)&((f|0)<0|(f|0)==0&g>>>0<1)))return;ad(a,b,d,e)|0;return}case 2:{if(!((w|0)==1&((h|0)>0|(h|0)==0&i>>>0>0)&((f|0)>0|(f|0)==0&g>>>0>0))?!(n&((h|0)<0|(h|0)==0&i>>>0<1)&((f|0)<0|(f|0)==0&g>>>0<1)):0)return;ad(a,b,d,e)|0;return}case 3:{ad(a,b,d,e)|0;return}default:return}}if((c[b+56>>2]|0)==(c[d+56>>2]|0)){if((m|0)==(k|0))return;if((c[a+108>>2]|0)!=1)return;if(f){if(!t)return;bd(a,b,e)|0;if(!r)return;c[u>>2]=-1;return}else{if(!r)return;bd(a,d,e)|0;if(!t)return;c[v>>2]=-1;return}}do if(f?(x=c[d+68>>2]|0,(((x|0)>-1?x:0-x|0)|0)==1):0){if((c[a+108>>2]|0)==1?c[d+72>>2]|0:0)break;bd(a,b,e)|0;if(!r)return;c[u>>2]=-1;return}while(0);if(!g)return;x=c[b+68>>2]|0;if((((x|0)>-1?x:0-x|0)|0)!=1)return;if((c[a+108>>2]|0)==1?c[b+72>>2]|0:0)return;bd(a,d,e)|0;if(!t)return;c[v>>2]=-1;return}function fd(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;s=a+20|0;e=c[s>>2]|0;if(!e){d=c[a+16>>2]|0;e=c[d+24>>2]|0;if((e|0)!=(d|0)){f=0;do{h=e+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;j=d+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((h|0)>(j|0)|(h|0)==(j|0)&g>>>0>i>>>0)){if((g|0)==(i|0)&(h|0)==(j|0)?(l=e+8|0,k=c[l>>2]|0,l=c[l+4>>2]|0,n=d+8|0,m=c[n>>2]|0,n=c[n+4>>2]|0,!((l|0)>(n|0)|(l|0)==(n|0)&k>>>0>m>>>0)):0)if(!((l|0)<(n|0)|(l|0)==(n|0)&k>>>0<m>>>0)){if((c[e+24>>2]|0)!=(d|0))f=(c[e+28>>2]|0)==(d|0)?f:e;}else{f=0;d=e;}}else{f=0;d=e;}e=c[e+24>>2]|0;}while((e|0)!=(d|0));if(!((f|0)==0|(f|0)==(d|0))){e=d;do{h=xc(d,f)|0;e=h?e:f;h=e+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;j=e+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;do{f=c[f+24>>2]|0;n=f+8|0;}while(!(((c[n>>2]|0)==(g|0)?(c[n+4>>2]|0)==(h|0):0)?(n=f+16|0,(c[n>>2]|0)==(i|0)?(c[n+4>>2]|0)==(j|0):0):0))}while((f|0)!=(d|0));d=e;}}c[s>>2]=d;e=d;}k=b+20|0;d=c[k>>2]|0;if(!d){d=c[b+16>>2]|0;e=c[d+24>>2]|0;if((e|0)!=(d|0)){f=0;do{h=e+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;j=d+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if(!((h|0)>(j|0)|(h|0)==(j|0)&g>>>0>i>>>0)){if((g|0)==(i|0)&(h|0)==(j|0)?(p=e+8|0,o=c[p>>2]|0,p=c[p+4>>2]|0,r=d+8|0,q=c[r>>2]|0,r=c[r+4>>2]|0,!((p|0)>(r|0)|(p|0)==(r|0)&o>>>0>q>>>0)):0)if(!((p|0)<(r|0)|(p|0)==(r|0)&o>>>0<q>>>0)){if((c[e+24>>2]|0)!=(d|0))f=(c[e+28>>2]|0)==(d|0)?f:e;}else{f=0;d=e;}}else{f=0;d=e;}e=c[e+24>>2]|0;}while((e|0)!=(d|0));if(!((f|0)==0|(f|0)==(d|0))){e=d;do{h=xc(d,f)|0;e=h?e:f;h=e+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;j=e+16|0;i=c[j>>2]|0;j=c[j+4>>2]|0;do{f=c[f+24>>2]|0;r=f+8|0;}while(!(((c[r>>2]|0)==(g|0)?(c[r+4>>2]|0)==(h|0):0)?(r=f+16|0,(c[r>>2]|0)==(i|0)?(c[r+4>>2]|0)==(j|0):0):0))}while((f|0)!=(d|0));d=e;}}c[k>>2]=d;i=c[s>>2]|0;}else i=e;f=i+16|0;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d+16|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((f|0)>(h|0)|(f|0)==(h|0)&e>>>0>g>>>0){b=a;return b|0}if((f|0)<(h|0)|(f|0)==(h|0)&e>>>0<g>>>0)return b|0;f=i+8|0;e=c[f>>2]|0;f=c[f+4>>2]|0;h=d+8|0;g=c[h>>2]|0;h=c[h+4>>2]|0;if((f|0)<(h|0)|(f|0)==(h|0)&e>>>0<g>>>0){b=a;return b|0}if((f|0)>(h|0)|(f|0)==(h|0)&e>>>0>g>>>0)return b|0;if((c[i+24>>2]|0)==(i|0))return b|0;if((c[d+24>>2]|0)==(d|0)){b=a;return b|0}s=xc(i,d)|0;b=s?a:b;return b|0}function gd(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0;U=Eb;Eb=Eb+48|0;S=U+16|0;R=U;T=U+32|0;c[T>>2]=d;M=(c[d+64>>2]|0)==0;o=d;n=c[o>>2]|0;o=c[o+4>>2]|0;h=d+32|0;e=c[h>>2]|0;h=c[h+4>>2]|0;p=(o|0)<(h|0)|(o|0)==(h|0)&n>>>0<e>>>0;t=p?n:e;s=p?o:h;r=p?e:n;q=p?h:o;f=c[d+88>>2]|0;a:do if(!f){f=d;i=h;z=6;}else{e=d;while(1){if(!(+g[f+48>>3]==-1.e+40)){N=0;break a}e=c[f+88>>2]|0;if(!e)break;else{N=f;f=e;e=N;}}i=f+32|0;e=c[i>>2]|0;i=c[i+4>>2]|0;z=6;}while(0);do if((z|0)==6){h=c[f+80>>2]|0;N=h+32|0;if((((c[N>>2]|0)==(e|0)?(c[N+4>>2]|0)==(i|0):0)?(J=h+40|0,N=f+40|0,(c[J>>2]|0)==(c[N>>2]|0)?(c[J+4>>2]|0)==(c[N+4>>2]|0):0):0)?(c[h+88>>2]|0)==0:0){N=h;e=f;break}h=c[f+84>>2]|0;N=h+32|0;if((((c[N>>2]|0)==(e|0)?(c[N+4>>2]|0)==(i|0):0)?(J=h+40|0,N=f+40|0,(c[J>>2]|0)==(c[N>>2]|0)?(c[J+4>>2]|0)==(c[N+4>>2]|0):0):0)?(c[h+88>>2]|0)==0:0){N=h;e=f;break}N=0;e=f;}while(0);m=b+112|0;G=b+120|0;b:do if(c[G>>2]|0)if(p){k=b+116|0;h=c[k>>2]|0;l=m;f=h;if((m|0)==(f|0)){C=k;f=0;break}while(1){j=h+8|0;i=c[j>>2]|0;j=c[j+4>>2]|0;if((j|0)>(o|0)|(j|0)==(o|0)&i>>>0>n>>>0)break;h=c[f+4>>2]|0;f=h;if((m|0)==(f|0)){C=k;f=0;break b}}f=e+32|0;J=c[f+4>>2]|0;C=k;h=(j|0)<(J|0)|((j|0)==(J|0)?i>>>0<(c[f>>2]|0)>>>0:0)?h:l;f=0;break}else{f=m;i=b+116|0;l=c[i>>2]|0;h=l;if((m|0)==(h|0)){C=i;h=0;break}while(1){k=(c[f>>2]|0)+8|0;j=c[k>>2]|0;k=c[k+4>>2]|0;if(!((k|0)>(o|0)|(k|0)==(o|0)&j>>>0>n>>>0))break;f=c[f>>2]|0;if((f|0)==(h|0)){C=i;h=0;break b}}J=e+32|0;I=c[J+4>>2]|0;C=i;h=0;f=(k|0)>(I|0)|((k|0)==(I|0)?j>>>0>(c[J>>2]|0)>>>0:0)?f:l;break}else{C=b+116|0;h=0;f=0;}while(0);v=S+8|0;w=S+8|0;A=b+124|0;D=b+88|0;E=b+92|0;B=b+40|0;H=b+76|0;I=b+80|0;J=b+72|0;x=S+8|0;y=S+8|0;F=b+84|0;j=0;c:while(1){u=(d|0)!=(e|0);i=c[(p?d+92|0:d+96|0)>>2]|0;if(!i)i=f;else{d=j;do{d:do if(c[G>>2]|0)if(p){j=h;n=i+16|0;if((m|0)==(j|0)){j=n;l=c[j+4>>2]|0;j=c[j>>2]|0;z=54;break}if(M){l=n;k=c[l>>2]|0;l=c[l+4>>2]|0;while(1){z=h+8|0;o=c[z+4>>2]|0;if(!((o|0)<(l|0)|((o|0)==(l|0)?(c[z>>2]|0)>>>0<k>>>0:0))){z=53;break d}h=c[j+4>>2]|0;j=h;if((m|0)==(j|0)){z=53;break d}}}while(1){l=h+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;z=n;o=c[z+4>>2]|0;if(!((l|0)<(o|0)|((l|0)==(o|0)?k>>>0<(c[z>>2]|0)>>>0:0))){z=53;break d}h=c[T>>2]|0;if((c[h+76>>2]|0)>=0){o=h+8|0;V=c[o>>2]|0;o=c[o+4>>2]|0;z=S;c[z>>2]=k;c[z+4>>2]=l;z=v;c[z>>2]=V;c[z+4>>2]=o;bd(b,h,S)|0;}h=c[j+4>>2]|0;j=h;if((m|0)==(j|0)){z=53;break}}}else{j=c[C>>2]|0;o=i+16|0;if((j|0)==(f|0)){j=o;l=c[j+4>>2]|0;j=c[j>>2]|0;z=55;break}if(M){l=o;k=c[l>>2]|0;l=c[l+4>>2]|0;while(1){V=(c[f>>2]|0)+8|0;z=c[V+4>>2]|0;if(!((z|0)>(l|0)|((z|0)==(l|0)?(c[V>>2]|0)>>>0>k>>>0:0))){z=53;break d}f=c[f>>2]|0;if((j|0)==(f|0)){z=53;break d}}}while(1){l=(c[f>>2]|0)+8|0;k=c[l>>2]|0;l=c[l+4>>2]|0;V=o;z=c[V+4>>2]|0;if(!((l|0)>(z|0)|((l|0)==(z|0)?k>>>0>(c[V>>2]|0)>>>0:0))){z=53;break d}n=c[T>>2]|0;if((c[n+76>>2]|0)>=0){V=n+8|0;z=c[V>>2]|0;V=c[V+4>>2]|0;j=S;c[j>>2]=k;c[j+4>>2]=l;j=w;c[j>>2]=z;c[j+4>>2]=V;bd(b,n,S)|0;j=c[C>>2]|0;}f=c[f>>2]|0;if((j|0)==(f|0)){z=53;break}}}else z=53;while(0);if((z|0)==53){l=i+16|0;j=c[l>>2]|0;l=c[l+4>>2]|0;if(p)z=54;else z=55;}if((z|0)==54){z=0;if((l|0)>(q|0)|(l|0)==(q|0)&j>>>0>r>>>0)break}else if((z|0)==55){z=0;if((l|0)<(s|0)|(l|0)==(s|0)&j>>>0<t>>>0)break}n=i+16|0;k=c[T>>2]|0;V=k+32|0;if((((j|0)==(c[V>>2]|0)?(l|0)==(c[V+4>>2]|0):0)?(K=c[k+88>>2]|0,K|0):0)?+g[i+48>>3]<+g[K+48>>3]:0)break;if(!(M|(c[k+76>>2]|0)<0)){d=bd(b,k,n)|0;j=c[A>>2]|0;if(j|0)do{k=c[j+76>>2]|0;if((k|0)>-1?(Z=c[T>>2]|0,Y=Z,o=c[Y>>2]|0,Y=c[Y+4>>2]|0,Z=Z+32|0,V=c[Z>>2]|0,Z=c[Z+4>>2]|0,ba=j,W=c[ba>>2]|0,ba=c[ba+4>>2]|0,L=j+32|0,$=L,X=c[$>>2]|0,$=c[$+4>>2]|0,l=(Y|0)>(Z|0)|(Y|0)==(Z|0)&o>>>0>V>>>0,aa=l?Z:Y,Z=l?Y:Z,Y=(ba|0)>($|0)|(ba|0)==($|0)&W>>>0>X>>>0,_=Y?$:ba,$=Y?ba:$,((aa|0)<($|0)|((aa|0)==($|0)?(l?V:o)>>>0<(Y?W:X)>>>0:0))&((_|0)<(Z|0)|((_|0)==(Z|0)?(Y?X:W)>>>0<(l?o:V)>>>0:0))):0){k=c[(c[(c[B>>2]|0)+(k<<2)>>2]|0)+16>>2]|0;if((c[j+60>>2]|0)!=1)k=c[k+28>>2]|0;c[R>>2]=c[L>>2];c[R+4>>2]=c[L+4>>2];c[R+8>>2]=c[L+8>>2];c[R+12>>2]=c[L+12>>2];l=Zj(24)|0;ba=l+8|0;c[S>>2]=l;c[l>>2]=k;c[l+4>>2]=d;c[ba>>2]=c[R>>2];c[ba+4>>2]=c[R+4>>2];c[ba+8>>2]=c[R+8>>2];c[ba+12>>2]=c[R+12>>2];k=c[H>>2]|0;if((k|0)==(c[I>>2]|0))Re(J,S);else{c[k>>2]=l;c[H>>2]=(c[H>>2]|0)+4;}}j=c[j+100>>2]|0;}while((j|0)!=0);j=c[T>>2]|0;c[R>>2]=c[j>>2];c[R+4>>2]=c[j+4>>2];c[R+8>>2]=c[j+8>>2];c[R+12>>2]=c[j+12>>2];j=Zj(24)|0;k=j+8|0;c[S>>2]=j;c[j>>2]=d;c[j+4>>2]=0;c[k>>2]=c[R>>2];c[k+4>>2]=c[R+4>>2];c[k+8>>2]=c[R+8>>2];c[k+12>>2]=c[R+12>>2];k=c[D>>2]|0;if((k|0)==(c[E>>2]|0))Re(F,S);else{c[k>>2]=j;c[D>>2]=(c[D>>2]|0)+4;}}if(!(u|(i|0)!=(N|0))){z=76;break c}if(p){Y=n;Z=c[Y+4>>2]|0;ba=c[T>>2]|0;$=ba+24|0;_=c[$>>2]|0;$=c[$+4>>2]|0;aa=S;c[aa>>2]=c[Y>>2];c[aa+4>>2]=Z;aa=x;c[aa>>2]=_;c[aa+4>>2]=$;ed(b,ba,i,S);}else{Y=n;Z=c[Y+4>>2]|0;ba=c[T>>2]|0;$=ba+24|0;_=c[$>>2]|0;$=c[$+4>>2]|0;aa=S;c[aa>>2]=c[Y>>2];c[aa+4>>2]=Z;aa=y;c[aa>>2]=_;c[aa+4>>2]=$;ed(b,i,ba,S);}ba=i;i=c[(p?i+92|0:i+96|0)>>2]|0;Lc(b,c[T>>2]|0,ba);}while((i|0)!=0);j=d;i=f;d=c[T>>2]|0;}f=c[d+88>>2]|0;if(!f)break;if(!(+g[f+48>>3]==-1.e+40))break;Mc(b,T);d=c[T>>2]|0;if((c[d+76>>2]|0)>-1){bd(b,d,d)|0;d=c[T>>2]|0;}$=d;ba=c[$>>2]|0;$=c[$+4>>2]|0;s=d+32|0;t=c[s>>2]|0;s=c[s+4>>2]|0;aa=($|0)<(s|0)|($|0)==(s|0)&ba>>>0<t>>>0;p=aa;f=i;q=aa?s:$;r=aa?t:ba;s=aa?$:s;t=aa?ba:t;}if((z|0)==76){h=c[T>>2]|0;i=h+76|0;do if((c[i>>2]|0)>-1){e=h+32|0;bd(b,h,e)|0;if(!(c[N+64>>2]|0))bd(b,N,e)|0;e=c[i>>2]|0;d=N+76|0;f=c[d>>2]|0;if((e|0)==(f|0)){c[i>>2]=-1;c[d>>2]=-1;break}if((e|0)<(f|0)){cd(b,h,N);break}else{cd(b,N,h);break}}while(0);ba=c[T>>2]|0;e=ba+96|0;d=c[e>>2]|0;f=ba+92|0;h=c[f>>2]|0;i=(d|0)!=0;j=(h|0)!=0;if(!(!(i|j)?(c[b+52>>2]|0)!=(ba|0):0)){c[(i?d+92|0:b+52|0)>>2]=h;if(j)c[h+96>>2]=d;c[f>>2]=0;c[e>>2]=0;}e=N+96|0;d=c[e>>2]|0;f=N+92|0;h=c[f>>2]|0;i=(d|0)!=0;j=(h|0)!=0;if(!(i|j)?(c[b+52>>2]|0)!=(N|0):0){Eb=U;return}c[(i?d+92|0:b+52|0)>>2]=h;if(j)c[h+96>>2]=d;c[f>>2]=0;c[e>>2]=0;Eb=U;return}e=c[d+76>>2]|0;if(!((j|0)!=0|(e|0)<0)){e=c[(c[(c[B>>2]|0)+(e<<2)>>2]|0)+16>>2]|0;if((c[d+60>>2]|0)==1)h=e;else h=c[e+28>>2]|0;e=c[A>>2]|0;if(e){do{d=c[e+76>>2]|0;if((d|0)>-1?(X=c[T>>2]|0,Y=X,aa=c[Y>>2]|0,Y=c[Y+4>>2]|0,X=X+32|0,ba=c[X>>2]|0,X=c[X+4>>2]|0,M=e,_=c[M>>2]|0,M=c[M+4>>2]|0,O=e+32|0,V=O,Z=c[V>>2]|0,V=c[V+4>>2]|0,$=(Y|0)>(X|0)|(Y|0)==(X|0)&aa>>>0>ba>>>0,N=$?X:Y,X=$?Y:X,Y=(M|0)>(V|0)|(M|0)==(V|0)&_>>>0>Z>>>0,W=Y?V:M,V=Y?M:V,((N|0)<(V|0)|((N|0)==(V|0)?($?ba:aa)>>>0<(Y?_:Z)>>>0:0))&((W|0)<(X|0)|((W|0)==(X|0)?(Y?Z:_)>>>0<($?aa:ba)>>>0:0))):0){d=c[(c[(c[B>>2]|0)+(d<<2)>>2]|0)+16>>2]|0;if((c[e+60>>2]|0)!=1)d=c[d+28>>2]|0;c[R>>2]=c[O>>2];c[R+4>>2]=c[O+4>>2];c[R+8>>2]=c[O+8>>2];c[R+12>>2]=c[O+12>>2];f=Zj(24)|0;ba=f+8|0;c[S>>2]=f;c[f>>2]=d;c[f+4>>2]=h;c[ba>>2]=c[R>>2];c[ba+4>>2]=c[R+4>>2];c[ba+8>>2]=c[R+8>>2];c[ba+12>>2]=c[R+12>>2];d=c[H>>2]|0;if((d|0)==(c[I>>2]|0))Re(J,S);else{c[d>>2]=f;c[H>>2]=(c[H>>2]|0)+4;}}e=c[e+100>>2]|0;}while((e|0)!=0);d=c[T>>2]|0;}d=d+32|0;c[R>>2]=c[d>>2];c[R+4>>2]=c[d+4>>2];c[R+8>>2]=c[d+8>>2];c[R+12>>2]=c[d+12>>2];d=Zj(24)|0;e=d+8|0;c[S>>2]=d;c[d>>2]=h;c[d+4>>2]=0;c[e>>2]=c[R>>2];c[e+4>>2]=c[R+4>>2];c[e+8>>2]=c[R+8>>2];c[e+12>>2]=c[R+12>>2];e=c[D>>2]|0;if((e|0)==(c[E>>2]|0))Re(F,S);else{c[e>>2]=d;c[D>>2]=(c[D>>2]|0)+4;}d=c[T>>2]|0;f=c[d+88>>2]|0;e=c[d+76>>2]|0;}e=(e|0)>-1;if(!f){if(e){bd(b,d,d+32|0)|0;d=c[T>>2]|0;}e=d+96|0;f=c[e>>2]|0;h=d+92|0;i=c[h>>2]|0;j=(f|0)!=0;k=(i|0)!=0;if(!(j|k)?(c[b+52>>2]|0)!=(d|0):0){Eb=U;return}c[(j?f+92|0:b+52|0)>>2]=i;if(k)c[i+96>>2]=f;c[h>>2]=0;c[e>>2]=0;Eb=U;return}if(!e){Mc(b,T);Eb=U;return}i=bd(b,d,d+32|0)|0;Mc(b,T);f=c[T>>2]|0;if(!(c[f+64>>2]|0)){Eb=U;return}e=c[f+96>>2]|0;h=c[f+92>>2]|0;if((((((e|0?(aa=e+16|0,ba=f,(c[aa>>2]|0)==(c[ba>>2]|0)?(c[aa+4>>2]|0)==(c[ba+4>>2]|0):0):0)?(Q=e+24|0,P=c[Q>>2]|0,Q=c[Q+4>>2]|0,ba=f+8|0,(P|0)==(c[ba>>2]|0)?(Q|0)==(c[ba+4>>2]|0):0):0)?c[e+64>>2]|0:0)?(c[e+76>>2]|0)>-1:0)?(ba=e+40|0,aa=c[ba+4>>2]|0,(Q|0)>(aa|0)|((Q|0)==(aa|0)?P>>>0>(c[ba>>2]|0)>>>0:0)):0)?vc(f,e,(a[b+20>>0]|0)!=0)|0:0){ba=bd(b,e,f)|0;d=(c[T>>2]|0)+32|0;c[R>>2]=c[d>>2];c[R+4>>2]=c[d+4>>2];c[R+8>>2]=c[d+8>>2];c[R+12>>2]=c[d+12>>2];d=Zj(24)|0;e=d+8|0;c[S>>2]=d;c[d>>2]=i;c[d+4>>2]=ba;c[e>>2]=c[R>>2];c[e+4>>2]=c[R+4>>2];c[e+8>>2]=c[R+8>>2];c[e+12>>2]=c[R+12>>2];e=c[H>>2]|0;if((e|0)==(c[I>>2]|0))Re(J,S);else{c[e>>2]=d;c[H>>2]=(c[H>>2]|0)+4;}Eb=U;return}if(!h){Eb=U;return}aa=h+16|0;ba=f;if(!((c[aa>>2]|0)==(c[ba>>2]|0)?(c[aa+4>>2]|0)==(c[ba+4>>2]|0):0)){Eb=U;return}d=h+24|0;e=c[d>>2]|0;d=c[d+4>>2]|0;ba=f+8|0;if(!((e|0)==(c[ba>>2]|0)?(d|0)==(c[ba+4>>2]|0):0)){Eb=U;return}if(!(c[h+64>>2]|0)){Eb=U;return}if((c[h+76>>2]|0)<=-1){Eb=U;return}ba=h+40|0;aa=c[ba+4>>2]|0;if(!((d|0)>(aa|0)|((d|0)==(aa|0)?e>>>0>(c[ba>>2]|0)>>>0:0))){Eb=U;return}if(!(vc(f,h,(a[b+20>>0]|0)!=0)|0)){Eb=U;return}ba=bd(b,h,f)|0;d=(c[T>>2]|0)+32|0;c[R>>2]=c[d>>2];c[R+4>>2]=c[d+4>>2];c[R+8>>2]=c[d+8>>2];c[R+12>>2]=c[d+12>>2];d=Zj(24)|0;e=d+8|0;c[S>>2]=d;c[d>>2]=i;c[d+4>>2]=ba;c[e>>2]=c[R>>2];c[e+4>>2]=c[R+4>>2];c[e+8>>2]=c[R+8>>2];c[e+12>>2]=c[R+12>>2];e=c[H>>2]|0;if((e|0)==(c[I>>2]|0))Re(J,S);else{c[e>>2]=d;c[H>>2]=(c[H>>2]|0)+4;}Eb=U;return}function hd(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;j=b+100|0;k=c[j>>2]|0;i=(k|0)==0;if(i?(c[b+104>>2]|0)==0:0)return;l=d+100|0;g=c[l>>2]|0;f=(g|0)==0;if(f?(c[d+104>>2]|0)==0:0)return;if((k|0)!=(d|0)){if((g|0)!=(b|0)){e=b+104|0;h=c[e>>2]|0;c[j>>2]=g;if(!f)c[g+104>>2]=b;f=d+104|0;g=c[f>>2]|0;c[e>>2]=g;if(g|0)c[g+100>>2]=b;c[l>>2]=k;if(!i)c[k+104>>2]=d;c[f>>2]=h;if(h)c[h+100>>2]=d;}else{if(!i)c[k+104>>2]=d;e=d+104|0;f=c[e>>2]|0;if(f|0)c[f+100>>2]=b;i=b+104|0;c[i>>2]=f;c[j>>2]=d;c[e>>2]=b;c[l>>2]=k;e=i;}if(!(c[e>>2]|0)){c[a+124>>2]=b;return}}else{if(!f)c[g+104>>2]=b;e=b+104|0;f=c[e>>2]|0;if(f|0)c[f+100>>2]=d;c[d+104>>2]=f;c[l>>2]=b;c[e>>2]=d;c[j>>2]=g;}if(c[d+104>>2]|0)return;c[a+124>>2]=d;return}function id(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,t=0,u=0.0,v=0,w=0;t=Eb;Eb=Eb+32|0;o=t;p=t+16|0;j=c[a+52>>2]|0;if(!j){Eb=t;return}q=a+124|0;c[q>>2]=j;e=j;do{c[e+104>>2]=c[e+96>>2];f=e;e=c[e+92>>2]|0;c[f+100>>2]=e;n=f+40|0;if((c[n>>2]|0)==(b|0)?(c[n+4>>2]|0)==(d|0):0){i=f+32|0;h=c[i>>2]|0;i=c[i+4>>2]|0;}else{h=f;i=c[h>>2]|0;h=c[h+4>>2]|0;u=+g[f+48>>3];n=f+8|0;n=Ww(b|0,d|0,c[n>>2]|0,c[n+4>>2]|0)|0;u=u*(+(n>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);h=Vw(i|0,h|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;i=F()|0;}n=f+16|0;c[n>>2]=h;c[n+4>>2]=i;}while((e|0)!=0);k=o+8|0;l=a+100|0;m=a+104|0;n=a+96|0;e=j;while(1){h=c[e+100>>2]|0;if(!h)f=0;else{f=0;i=h;do{c[o>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;h=e+16|0;w=c[h+4>>2]|0;j=i+16|0;v=c[j+4>>2]|0;if((w|0)>(v|0)|((w|0)==(v|0)?(c[h>>2]|0)>>>0>(c[j>>2]|0)>>>0:0)){wc(e,i,o);w=k;v=c[w+4>>2]|0;if((v|0)<(d|0)|((v|0)==(d|0)?(c[w>>2]|0)>>>0<b>>>0:0)){w=e+40|0;if((c[w>>2]|0)==(b|0)?(c[w+4>>2]|0)==(d|0):0){h=e+32|0;f=c[h>>2]|0;h=c[h+4>>2]|0;}else{f=e;h=c[f>>2]|0;f=c[f+4>>2]|0;u=+g[e+48>>3];w=e+8|0;w=Ww(b|0,d|0,c[w>>2]|0,c[w+4>>2]|0)|0;u=u*(+(w>>>0)+4294967296.0*+(F()|0));u=u+(u<0.0?-.5:.5);f=Vw(h|0,f|0,~~u>>>0|0,(+s(u)>=1.0?(u>0.0?~~+B(+r(u/4294967296.0),4294967295.0)>>>0:~~+z((u-+(~~u>>>0))/4294967296.0)>>>0):0)|0)|0;h=F()|0;}w=o;c[w>>2]=f;c[w+4>>2]=h;w=k;c[w>>2]=b;c[w+4>>2]=d;}f=Zj(24)|0;h=f+8|0;c[p>>2]=f;c[f>>2]=e;c[f+4>>2]=i;c[h>>2]=c[o>>2];c[h+4>>2]=c[o+4>>2];c[h+8>>2]=c[o+8>>2];c[h+12>>2]=c[o+12>>2];h=c[l>>2]|0;if((h|0)==(c[m>>2]|0))Se(n,p);else{c[h>>2]=f;c[l>>2]=(c[l>>2]|0)+4;}hd(a,e,i);f=1;}else e=i;i=c[e+100>>2]|0;}while((i|0)!=0)}e=c[e+104>>2]|0;if(!e)break;c[e+100>>2]=0;if(!f)break;e=c[q>>2]|0;}c[q>>2]=0;Eb=t;return}function jd(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;l=Eb;Eb=Eb+16|0;d=l;b=c[a+52>>2]|0;c[a+124>>2]=b;if(b|0)do{c[b+104>>2]=c[b+96>>2];k=b;b=c[b+92>>2]|0;c[k+100>>2]=b;}while((b|0)!=0);k=a+96|0;h=c[k>>2]|0;i=a+100|0;j=c[i>>2]|0;c[d>>2]=25;Te(h,j,d);d=c[k>>2]|0;i=(c[i>>2]|0)-d|0;j=i>>2;if(!i){a=1;Eb=l;return a|0}b=0;while(1){h=d+(b<<2)|0;i=c[h>>2]|0;f=c[i>>2]|0;g=c[i+4>>2]|0;if((c[f+100>>2]|0)!=(g|0)?(c[f+104>>2]|0)!=(g|0):0){e=b+1|0;a:do if(e>>>0<j>>>0)do{g=c[d+(e<<2)>>2]|0;f=c[g>>2]|0;g=c[g+4>>2]|0;if((c[f+100>>2]|0)==(g|0))break a;if((c[f+104>>2]|0)==(g|0))break a;e=e+1|0;}while(e>>>0<j>>>0);while(0);d=d+(e<<2)|0;if((e|0)==(j|0)){b=0;d=17;break}c[h>>2]=c[d>>2];c[d>>2]=i;d=c[k>>2]|0;}i=c[d+(b<<2)>>2]|0;hd(a,c[i>>2]|0,c[i+4>>2]|0);b=b+1|0;if(b>>>0>=j>>>0){b=1;d=17;break}d=c[k>>2]|0;}if((d|0)==17){Eb=l;return b|0}return 0}function kd(a,b){a=a|0;b=b|0;var d=0,e=0;d=b+16|0;e=c[d+4>>2]|0;b=a+16|0;a=c[b+4>>2]|0;return (e|0)<(a|0)|((e|0)==(a|0)?(c[d>>2]|0)>>>0<(c[b>>2]|0)>>>0:0)|0}
  function Hn(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Gn(a)|0;do if(!(bl(a)|0)){e=jk(c[a>>2]|0,b<<2)|0;c[a>>2]=e;if(!e)Uk();else{f=e;d=a+4|0;break}}else{f=hk(b<<2)|0;if(!f)Uk();g=c[a>>2]|0;d=a+4|0;e=(c[d>>2]|0)-g|0;if(e|0)bx(f|0,g|0,e|0)|0;c[a>>2]=f;}while(0);c[d>>2]=f+(h<<2);c[a+8>>2]=f+(b<<2);return}function In(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Jn(a,e);Eb=d;return a|0}function Jn(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;jm(b,27,1,1,1);c[b>>2]=4668;g=b+8|0;f=c[d+4>>2]|0;h=g;c[h>>2]=c[d>>2];c[h+4>>2]=f;h=b+5|0;a[h>>0]=2;f=b+7|0;a[f>>0]=2;b=b+6|0;a[b>>0]=2;d=Kn(g)|0;e=Ln(g)|0;while(1){if((d|0)==(e|0)){i=4;break}if(Mn(c[d>>2]|0)|0)d=d+4|0;else break}if((i|0)==4)a[b>>0]=1;d=Kn(g)|0;b=Ln(g)|0;while(1){if((d|0)==(b|0)){i=8;break}if(Nn(c[d>>2]|0)|0)d=d+4|0;else break}if((i|0)==8)a[f>>0]=1;d=Kn(g)|0;b=Ln(g)|0;while(1){if((d|0)==(b|0)){i=12;break}if(On(c[d>>2]|0)|0)d=d+4|0;else break}if((i|0)==12)a[h>>0]=1;return}function Kn(a){a=a|0;return c[a>>2]|0}function Ln(a){a=a|0;return (c[a>>2]|0)+(c[a+4>>2]<<2)|0}function Mn(b){b=b|0;return (a[b+6>>0]|0)==1|0}function Nn(b){b=b|0;return (a[b+7>>0]|0)==1|0}function On(b){b=b|0;return (a[b+5>>0]|0)==1|0}function Pn(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0)a=Wm(Yn(a,d)|0,b)|0;else a=0;return a|0}function Qn(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0)a=Sm(Yn(a,d)|0,b)|0;else a=0;return a|0}function Rn(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0)a=Tm(Yn(a,d)|0,b)|0;else a=0;return a|0}function Sn(a,b){a=a|0;b=b|0;var d=0,e=0;Wn(a,b);d=c[b+12>>2]|0;e=a+8|0;if(d>>>0<(Xn(e)|0)>>>0){a=Yn(e,d)|0;a=Ob[c[(c[a>>2]|0)+12>>2]&63](a,b)|0;}return a|0}function Tn(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0){d=Yn(a,d)|0;Xb[c[(c[d>>2]|0)+16>>2]&127](d,b);}return}function Un(a,b){a=a|0;b=b|0;var d=0;Wn(a,b);d=c[b+12>>2]|0;a=a+8|0;if(d>>>0<(Xn(a)|0)>>>0){d=Yn(a,d)|0;Xb[c[(c[d>>2]|0)+20>>2]&127](d,b);}return}function Vn(a){a=a|0;$j(a);return}function Wn(a,b){a=a|0;b=b|0;var d=0;d=b+16|0;if((c[d>>2]|0)==-1){a=Xn(a+8|0)|0;c[d>>2]=a;c[b+12>>2]=0;}return}function Xn(a){a=a|0;return c[a+4>>2]|0}function Yn(a,b){a=a|0;b=b|0;return c[(c[a>>2]|0)+(b<<2)>>2]|0}function Zn(a){a=a|0;var b=0;b=a+12|0;c[a>>2]=b;c[a+4>>2]=b;c[a+8>>2]=a+44;return}function _n(a){a=a|0;return c[a>>2]|0}function $n(a){a=a|0;return c[a+4>>2]|0}function ao(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;V=Eb;Eb=Eb+352|0;T=V+336|0;d=V+344|0;N=V+328|0;y=V+320|0;I=V+312|0;O=V+304|0;P=V+296|0;Q=V+288|0;U=V+8|0;R=V+280|0;e=V+272|0;f=V+264|0;g=V+256|0;h=V+248|0;i=V+240|0;j=V+232|0;k=V+224|0;l=V+216|0;m=V+208|0;n=V+200|0;o=V+192|0;p=V+184|0;q=V+176|0;r=V+168|0;s=V+160|0;t=V+152|0;u=V+144|0;v=V+136|0;w=V+128|0;x=V+120|0;z=V+112|0;A=V+104|0;B=V+96|0;C=V+88|0;D=V+80|0;E=V+72|0;F=V+64|0;G=V+56|0;H=V+48|0;S=V;J=V+40|0;K=V+32|0;L=V+24|0;M=V+16|0;fl(N,13428);c[T>>2]=c[N>>2];c[T+4>>2]=c[N+4>>2];N=(gl(b,T)|0)&1;a[d>>0]=N;a:do if((ml(b)|0)>>>0<2)d=0;else{N=c[b>>2]|0;do switch(a[N>>0]|0){case 76:{d=co(hl(b)|0)|0;break a}case 84:{d=Ql(hl(b)|0)|0;break a}case 102:{switch((jl(b,1)|0)<<24>>24){case 112:{g=7;break}case 76:{if((((jl(b,2)|0)<<24>>24)+-48|0)>>>0<10)g=7;else g=8;break}default:g=8;}if((g|0)==7){d=So(hl(b)|0)|0;break a}else if((g|0)==8){d=To(hl(b)|0)|0;break a}break}case 97:switch(a[N+1>>0]|0){case 97:{c[b>>2]=N+2;d=hl(b)|0;fl(y,12719);c[T>>2]=c[y>>2];c[T+4>>2]=c[y+4>>2];d=Uo(d,T)|0;break a}case 100:{c[b>>2]=N+2;d=hl(b)|0;fl(I,12717);c[T>>2]=c[I>>2];c[T+4>>2]=c[I+4>>2];d=Vo(d,T)|0;break a}case 110:{c[b>>2]=N+2;d=hl(b)|0;fl(O,12717);c[T>>2]=c[O>>2];c[T+4>>2]=c[O+4>>2];d=Uo(d,T)|0;break a}case 78:{c[b>>2]=N+2;d=hl(b)|0;fl(P,13431);c[T>>2]=c[P>>2];c[T+4>>2]=c[P+4>>2];d=Uo(d,T)|0;break a}case 83:{c[b>>2]=N+2;d=hl(b)|0;fl(Q,13434);c[T>>2]=c[Q>>2];c[T+4>>2]=c[Q+4>>2];d=Uo(d,T)|0;break a}case 116:{c[b>>2]=N+2;U=rl(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=Wo(b,13436,T)|0;break a}case 122:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=Wo(b,13436,T)|0;break a}default:{d=0;break a}}case 99:switch(a[N+1>>0]|0){case 99:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;if(!S)d=0;else{S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=Xo(b,T,U)|0;}break a}case 108:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;do if(S){e=b+8|0;f=Zl(e)|0;while(1){if(nl(b,69)|0){g=33;break}S=ao(d)|0;c[U>>2]=S;if(!S){g=31;break}Yl(e,U);}if((g|0)==31){d=0;break}else if((g|0)==33){sn(U,b,f);d=Yo(b,T,U)|0;break}}else d=0;while(0);break a}case 109:{c[b>>2]=N+2;d=hl(b)|0;fl(R,13446);c[T>>2]=c[R>>2];c[T+4>>2]=c[R+4>>2];d=Uo(d,T)|0;break a}case 111:{c[b>>2]=N+2;d=hl(b)|0;fl(e,13448);c[T>>2]=c[e>>2];c[T+4>>2]=c[e+4>>2];d=Vo(d,T)|0;break a}case 118:{d=Zo(hl(b)|0)|0;break a}default:{d=0;break a}}case 100:switch(a[N+1>>0]|0){case 97:{c[b>>2]=N+2;S=ao(hl(b)|0)|0;c[T>>2]=S;if(!S)d=0;else{a[U>>0]=1;d=_o(b,T,d,U)|0;}break a}case 99:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;if(!S)d=0;else{S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=$o(b,T,U)|0;}break a}case 101:{c[b>>2]=N+2;d=hl(b)|0;fl(f,12784);c[T>>2]=c[f>>2];c[T+4>>2]=c[f+4>>2];d=Vo(d,T)|0;break a}case 108:{c[b>>2]=N+2;S=ao(hl(b)|0)|0;c[T>>2]=S;if(!S)d=0;else{a[U>>0]=0;d=_o(b,T,d,U)|0;}break a}case 110:{d=ap(hl(b)|0)|0;break a}case 115:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;if(!S)d=0;else{S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=bp(b,T,13450,U)|0;}break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;if(!S)d=0;else{S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=cp(b,T,U)|0;}break a}case 118:{c[b>>2]=N+2;d=hl(b)|0;fl(g,13453);c[T>>2]=c[g>>2];c[T+4>>2]=c[g+4>>2];d=Uo(d,T)|0;break a}case 86:{c[b>>2]=N+2;d=hl(b)|0;fl(h,13455);c[T>>2]=c[h>>2];c[T+4>>2]=c[h+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 101:switch(a[N+1>>0]|0){case 111:{c[b>>2]=N+2;d=hl(b)|0;fl(i,13458);c[T>>2]=c[i>>2];c[T+4>>2]=c[i+4>>2];d=Uo(d,T)|0;break a}case 79:{c[b>>2]=N+2;d=hl(b)|0;fl(j,13460);c[T>>2]=c[j>>2];c[T+4>>2]=c[j+4>>2];d=Uo(d,T)|0;break a}case 113:{c[b>>2]=N+2;d=hl(b)|0;fl(k,13463);c[T>>2]=c[k>>2];c[T+4>>2]=c[k+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 103:switch(a[N+1>>0]|0){case 101:{c[b>>2]=N+2;d=hl(b)|0;fl(l,13466);c[T>>2]=c[l>>2];c[T+4>>2]=c[l+4>>2];d=Uo(d,T)|0;break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;fl(m,12790);c[T>>2]=c[m>>2];c[T+4>>2]=c[m+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 105:{switch(a[N+1>>0]|0){case 120:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;if(!S)d=0;else{S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=dp(b,T,U)|0;}break a}case 108:break;default:{d=0;break a}}c[b>>2]=N+2;d=b+8|0;e=Zl(d)|0;while(1){if(nl(b,69)|0){g=82;break}S=ep(hl(b)|0)|0;c[T>>2]=S;if(!S){g=81;break}Yl(d,T);}if((g|0)==81){d=0;break a}else if((g|0)==82){sn(U,b,e);d=fp(b,T,U)|0;break a}break}case 108:switch(a[N+1>>0]|0){case 101:{c[b>>2]=N+2;d=hl(b)|0;fl(n,13469);c[T>>2]=c[n>>2];c[T+4>>2]=c[n+4>>2];d=Uo(d,T)|0;break a}case 115:{c[b>>2]=N+2;d=hl(b)|0;fl(o,13472);c[T>>2]=c[o>>2];c[T+4>>2]=c[o+4>>2];d=Uo(d,T)|0;break a}case 83:{c[b>>2]=N+2;d=hl(b)|0;fl(p,13475);c[T>>2]=c[p>>2];c[T+4>>2]=c[p+4>>2];d=Uo(d,T)|0;break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;fl(q,12897);c[T>>2]=c[q>>2];c[T+4>>2]=c[q+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 109:switch(a[N+1>>0]|0){case 105:{c[b>>2]=N+2;d=hl(b)|0;fl(r,13318);c[T>>2]=c[r>>2];c[T+4>>2]=c[r+4>>2];d=Uo(d,T)|0;break a}case 73:{c[b>>2]=N+2;d=hl(b)|0;fl(s,13479);c[T>>2]=c[s>>2];c[T+4>>2]=c[s+4>>2];d=Uo(d,T)|0;break a}case 108:{c[b>>2]=N+2;d=hl(b)|0;fl(t,12784);c[T>>2]=c[t>>2];c[T+4>>2]=c[t+4>>2];d=Uo(d,T)|0;break a}case 76:{c[b>>2]=N+2;d=hl(b)|0;fl(u,13482);c[T>>2]=c[u>>2];c[T+4>>2]=c[u+4>>2];d=Uo(d,T)|0;break a}case 109:{c[b>>2]=N+2;if(nl(b,95)|0){d=hl(b)|0;fl(v,13485);c[T>>2]=c[v>>2];c[T+4>>2]=c[v+4>>2];d=Vo(d,T)|0;break a}U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=gp(b,T,13485)|0;break a}default:{d=0;break a}}case 110:switch(a[N+1>>0]|0){case 119:case 97:{d=hp(hl(b)|0)|0;break a}case 101:{c[b>>2]=N+2;d=hl(b)|0;fl(w,13488);c[T>>2]=c[w>>2];c[T+4>>2]=c[w+4>>2];d=Uo(d,T)|0;break a}case 103:{c[b>>2]=N+2;d=hl(b)|0;fl(x,13318);c[T>>2]=c[x>>2];c[T+4>>2]=c[x+4>>2];d=Vo(d,T)|0;break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;fl(z,13491);c[T>>2]=c[z>>2];c[T+4>>2]=c[z+4>>2];d=Vo(d,T)|0;break a}case 120:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=ip(b,T)|0;break a}default:{d=0;break a}}case 111:switch(a[N+1>>0]|0){case 110:{d=ap(hl(b)|0)|0;break a}case 111:{c[b>>2]=N+2;d=hl(b)|0;fl(A,13493);c[T>>2]=c[A>>2];c[T+4>>2]=c[A+4>>2];d=Uo(d,T)|0;break a}case 114:{c[b>>2]=N+2;d=hl(b)|0;fl(B,13496);c[T>>2]=c[B>>2];c[T+4>>2]=c[B+4>>2];d=Uo(d,T)|0;break a}case 82:{c[b>>2]=N+2;d=hl(b)|0;fl(C,13498);c[T>>2]=c[C>>2];c[T+4>>2]=c[C+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 112:switch(a[N+1>>0]|0){case 109:{c[b>>2]=N+2;d=hl(b)|0;fl(D,13501);c[T>>2]=c[D>>2];c[T+4>>2]=c[D+4>>2];d=Uo(d,T)|0;break a}case 108:{c[b>>2]=N+2;d=hl(b)|0;fl(E,13505);c[T>>2]=c[E>>2];c[T+4>>2]=c[E+4>>2];d=Uo(d,T)|0;break a}case 76:{c[b>>2]=N+2;d=hl(b)|0;fl(F,13507);c[T>>2]=c[F>>2];c[T+4>>2]=c[F+4>>2];d=Uo(d,T)|0;break a}case 112:{c[b>>2]=N+2;if(nl(b,95)|0){d=hl(b)|0;fl(G,13510);c[T>>2]=c[G>>2];c[T+4>>2]=c[G+4>>2];d=Vo(d,T)|0;break a}U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=gp(b,T,13510)|0;break a}case 115:{c[b>>2]=N+2;d=hl(b)|0;fl(H,13505);c[T>>2]=c[H>>2];c[T+4>>2]=c[H+4>>2];d=Vo(d,T)|0;break a}case 116:{c[b>>2]=N+2;d=hl(b)|0;S=ao(d)|0;c[T>>2]=S;if(!S)d=0;else{S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=bp(b,T,13513,U)|0;}break a}default:{d=0;break a}}case 113:{if((a[N+1>>0]|0)!=117){d=0;break a}c[b>>2]=N+2;d=hl(b)|0;R=ao(d)|0;c[T>>2]=R;if(!R)d=0;else{R=ao(d)|0;c[U>>2]=R;if(!R)d=0;else{R=ao(d)|0;c[S>>2]=R;if(!R)d=0;else d=jp(b,T,U,S)|0;}}break a}case 114:switch(a[N+1>>0]|0){case 99:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;if(!S)d=0;else{S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=kp(b,T,U)|0;}break a}case 109:{c[b>>2]=N+2;d=hl(b)|0;fl(J,13516);c[T>>2]=c[J>>2];c[T+4>>2]=c[J+4>>2];d=Uo(d,T)|0;break a}case 77:{c[b>>2]=N+2;d=hl(b)|0;fl(K,13518);c[T>>2]=c[K>>2];c[T+4>>2]=c[K+4>>2];d=Uo(d,T)|0;break a}case 115:{c[b>>2]=N+2;d=hl(b)|0;fl(L,13521);c[T>>2]=c[L>>2];c[T+4>>2]=c[L+4>>2];d=Uo(d,T)|0;break a}case 83:{c[b>>2]=N+2;d=hl(b)|0;fl(M,13524);c[T>>2]=c[M>>2];c[T+4>>2]=c[M+4>>2];d=Uo(d,T)|0;break a}default:{d=0;break a}}case 115:{switch(a[N+1>>0]|0){case 99:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;if(!S)d=0;else{S=ao(d)|0;c[U>>2]=S;if(!S)d=0;else d=lp(b,T,U)|0;}break a}case 112:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=Ml(b,T)|0;break a}case 114:{d=ap(hl(b)|0)|0;break a}case 116:{c[b>>2]=N+2;U=rl(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=mp(b,13528,T)|0;break a}case 122:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=mp(b,13528,T)|0;break a}case 90:{c[b>>2]=N+2;switch((jl(b,0)|0)<<24>>24){case 84:{U=Ql(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=np(b,T)|0;break a}case 102:{U=So(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=op(b,T)|0;break a}default:{d=0;break a}}}case 80:{c[b>>2]=N+2;d=b+8|0;e=Zl(d)|0;while(1){if(nl(b,69)|0){g=172;break}S=nn(hl(b)|0)|0;c[T>>2]=S;if(!S){g=171;break}Yl(d,T);}if((g|0)==171){d=0;break a}else if((g|0)==172){sn(U,b,e);d=pp(b,U)|0;c[T>>2]=d;d=op(b,T)|0;break a}break}default:{d=0;break a}}break}case 116:switch(a[N+1>>0]|0){case 101:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=mp(b,13537,T)|0;break a}case 105:{c[b>>2]=N+2;U=rl(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=mp(b,13537,T)|0;break a}case 108:{c[b>>2]=N+2;d=hl(b)|0;S=rl(d)|0;c[T>>2]=S;do if(S){e=b+8|0;f=Zl(e)|0;while(1){if(nl(b,69)|0){g=186;break}S=ep(d)|0;c[U>>2]=S;if(!S){g=185;break}Yl(e,U);}if((g|0)==185){d=0;break}else if((g|0)==186){sn(U,b,f);d=qp(b,T,U)|0;break}}else d=0;while(0);break a}case 114:{c[b>>2]=N+2;d=yl(b,13546)|0;break a}case 119:{c[b>>2]=N+2;U=ao(hl(b)|0)|0;c[T>>2]=U;if(!U)d=0;else d=rp(b,T)|0;break a}default:{d=0;break a}}case 57:case 56:case 55:case 54:case 53:case 52:case 51:case 50:case 49:{d=ap(hl(b)|0)|0;break a}default:{d=0;break a}}while(0)}while(0);Eb=V;return d|0}function bo(a,b){a=a|0;b=b|0;return Oo(a+368|0,b)|0}function co(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;v=Eb;Eb=Eb+160|0;t=v+144|0;b=v+136|0;l=v+128|0;m=v+120|0;n=v+112|0;o=v+104|0;p=v+96|0;q=v+88|0;r=v+80|0;s=v+72|0;d=v+64|0;e=v+56|0;f=v+48|0;g=v+40|0;h=v+32|0;i=v+24|0;j=v+16|0;k=v+8|0;u=v;a:do if(nl(a,76)|0)do switch((jl(a,0)|0)<<24>>24|0){case 84:{b=0;break a}case 119:{c[a>>2]=(c[a>>2]|0)+1;a=hl(a)|0;fl(b,13001);c[t>>2]=c[b>>2];c[t+4>>2]=c[b+4>>2];b=eo(a,t)|0;break a}case 98:{fl(l,13009);c[t>>2]=c[l>>2];c[t+4>>2]=c[l+4>>2];if(gl(a,t)|0){c[t>>2]=0;b=fo(a,t)|0;break a}fl(m,13013);c[t>>2]=c[m>>2];c[t+4>>2]=c[m+4>>2];if(!(gl(a,t)|0)){b=0;break a}c[t>>2]=1;b=fo(a,t)|0;break a}case 99:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(n,12091);c[t>>2]=c[n>>2];c[t+4>>2]=c[n+4>>2];b=eo(b,t)|0;break a}case 97:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(o,12096);c[t>>2]=c[o>>2];c[t+4>>2]=c[o+4>>2];b=eo(b,t)|0;break a}case 104:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(p,12108);c[t>>2]=c[p>>2];c[t+4>>2]=c[p+4>>2];b=eo(b,t)|0;break a}case 115:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(q,12122);c[t>>2]=c[q>>2];c[t+4>>2]=c[q+4>>2];b=eo(b,t)|0;break a}case 116:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(r,12128);c[t>>2]=c[r>>2];c[t+4>>2]=c[r+4>>2];b=eo(b,t)|0;break a}case 105:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(s,18757);c[t>>2]=c[s>>2];c[t+4>>2]=c[s+4>>2];b=eo(b,t)|0;break a}case 106:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(d,13017);c[t>>2]=c[d>>2];c[t+4>>2]=c[d+4>>2];b=eo(b,t)|0;break a}case 108:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(e,13019);c[t>>2]=c[e>>2];c[t+4>>2]=c[e+4>>2];b=eo(b,t)|0;break a}case 109:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(f,13021);c[t>>2]=c[f>>2];c[t+4>>2]=c[f+4>>2];b=eo(b,t)|0;break a}case 120:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(g,13024);c[t>>2]=c[g>>2];c[t+4>>2]=c[g+4>>2];b=eo(b,t)|0;break a}case 121:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(h,13027);c[t>>2]=c[h>>2];c[t+4>>2]=c[h+4>>2];b=eo(b,t)|0;break a}case 110:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(i,12189);c[t>>2]=c[i>>2];c[t+4>>2]=c[i+4>>2];b=eo(b,t)|0;break a}case 111:{c[a>>2]=(c[a>>2]|0)+1;b=hl(a)|0;fl(j,12198);c[t>>2]=c[j>>2];c[t+4>>2]=c[j+4>>2];b=eo(b,t)|0;break a}case 102:{c[a>>2]=(c[a>>2]|0)+1;b=go(hl(a)|0)|0;break a}case 100:{c[a>>2]=(c[a>>2]|0)+1;b=ho(hl(a)|0)|0;break a}case 101:{c[a>>2]=(c[a>>2]|0)+1;b=io(hl(a)|0)|0;break a}case 95:{fl(k,12025);c[t>>2]=c[k>>2];c[t+4>>2]=c[k+4>>2];if(!(gl(a,t)|0)){b=0;break a}b=il(hl(a)|0)|0;if(b|0?nl(a,69)|0:0)break a;b=0;break a}default:{b=rl(hl(a)|0)|0;c[t>>2]=b;if(!b)b=0;else{ol(u,a,0);s=pl(u)|0;d=nl(a,69)|0;if(!s)if(d)b=jo(a,t,u)|0;else b=0;else b=d?b:0;}break a}}while(0);else b=0;while(0);Eb=v;return b|0}function eo(a,b){a=a|0;b=b|0;var c=0,d=0;d=Eb;Eb=Eb+16|0;c=d;ol(c,a,1);if(!(pl(c)|0)?nl(a,69)|0:0)a=Ho(a,b,c)|0;else a=0;Eb=d;return a|0}function fo(a,b){a=a|0;b=b|0;return Do(a+368|0,b)|0}function go(b){b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;e=h;if((ml(b)|0)>>>0<9)d=0;else{d=c[b>>2]|0;kl(e,d,d+8|0);d=wm(e)|0;f=en(e)|0;while(1){if((d|0)==(f|0)){g=5;break}if(!($h(a[d>>0]|0)|0)){d=0;break}else d=d+1|0;}if((g|0)==5){c[b>>2]=(c[b>>2]|0)+8;if(nl(b,69)|0)d=yo(b,e)|0;else d=0;}}Eb=h;return d|0}function ho(b){b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;e=h;if((ml(b)|0)>>>0<17)d=0;else{d=c[b>>2]|0;kl(e,d,d+16|0);d=wm(e)|0;f=en(e)|0;while(1){if((d|0)==(f|0)){g=5;break}if(!($h(a[d>>0]|0)|0)){d=0;break}else d=d+1|0;}if((g|0)==5){c[b>>2]=(c[b>>2]|0)+16;if(nl(b,69)|0)d=to(b,e)|0;else d=0;}}Eb=h;return d|0}function io(b){b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;e=h;if((ml(b)|0)>>>0<21)d=0;else{d=c[b>>2]|0;kl(e,d,d+20|0);d=wm(e)|0;f=en(e)|0;while(1){if((d|0)==(f|0)){g=5;break}if(!($h(a[d>>0]|0)|0)){d=0;break}else d=d+1|0;}if((g|0)==5){c[b>>2]=(c[b>>2]|0)+20;if(nl(b,69)|0)d=oo(b,e)|0;else d=0;}}Eb=h;return d|0}function jo(a,b,c){a=a|0;b=b|0;c=c|0;return ko(a+368|0,b,c)|0}function ko(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];lo(a,b,f);Eb=e;return a|0}function lo(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,60,1,1,1);c[a>>2]=4712;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function mo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;g=d+16|0;h=d+8|0;f=d;fl(g,12715);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(h,12711);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=a+12|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function no(a){a=a|0;$j(a);return}function oo(a,b){a=a|0;b=b|0;return po(a+368|0,b)|0}function po(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];qo(a,e);Eb=d;return a|0}function qo(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,64,1,1,1);c[a>>2]=4756;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function ro(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Eb;Eb=Eb+64|0;i=m+48|0;j=m+40|0;k=m;l=m+56|0;h=b+8|0;f=wm(h)|0;if(((en(h)|0)+1-f|0)>>>0>20){h=j+8|0;b=0;e=j;while(1){if((b|0)==20)break;n=a[f+b>>0]|0;o=a[f+(b|1)>>0]|0;a[e>>0]=((o+-48|0)>>>0<10?208:169)+o+(((n+-48|0)>>>0<10?0:9)+n<<4);b=b+2|0;e=e+1|0;}b=h+2|0;e=j;while(1){b=b+-1|0;if(e>>>0>=b>>>0)break;o=a[e>>0]|0;a[e>>0]=a[b>>0]|0;a[b>>0]=o;e=e+1|0;}b=k;e=b+40|0;do{c[b>>2]=0;b=b+4|0;}while((b|0)<(e|0));g[i>>3]=+g[j>>3];kl(l,k,k+(bi(k,40,13083,i)|0)|0);c[i>>2]=c[l>>2];c[i+4>>2]=c[l+4>>2];um(d,i);}Eb=m;return}function so(a){a=a|0;$j(a);return}function to(a,b){a=a|0;b=b|0;return uo(a+368|0,b)|0}function uo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];vo(a,e);Eb=d;return a|0}function vo(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,63,1,1,1);c[a>>2]=4800;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function wo(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Eb;Eb=Eb+64|0;i=m+40|0;j=m+32|0;k=m;l=m+48|0;f=b+8|0;h=wm(f)|0;if(((en(f)|0)+1-h|0)>>>0>16){b=j+8|0;e=0;f=j;while(1){if((e|0)==16)break;n=a[h+e>>0]|0;o=a[h+(e|1)>>0]|0;a[f>>0]=((o+-48|0)>>>0<10?208:169)+o+(((n+-48|0)>>>0<10?0:9)+n<<4);e=e+2|0;f=f+1|0;}e=j;while(1){b=b+-1|0;if(e>>>0>=b>>>0)break;o=a[e>>0]|0;a[e>>0]=a[b>>0]|0;a[b>>0]=o;e=e+1|0;}c[k>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;c[k+16>>2]=0;c[k+20>>2]=0;c[k+24>>2]=0;c[k+28>>2]=0;g[i>>3]=+g[j>>3];kl(l,k,k+(bi(k,32,13144,i)|0)|0);c[i>>2]=c[l>>2];c[i+4>>2]=c[l+4>>2];um(d,i);}Eb=m;return}function xo(a){a=a|0;$j(a);return}function yo(a,b){a=a|0;b=b|0;return zo(a+368|0,b)|0}function zo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Ao(a,e);Eb=d;return a|0}function Ao(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,62,1,1,1);c[a>>2]=4844;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Bo(b,d){b=b|0;d=d|0;var e=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;n=Eb;Eb=Eb+48|0;j=n+24|0;k=n+40|0;l=n;m=n+32|0;h=b+8|0;i=wm(h)|0;if(((en(h)|0)+1-i|0)>>>0>8){b=k+4|0;e=0;h=k;while(1){if((e|0)==8)break;o=a[i+e>>0]|0;p=a[i+(e|1)>>0]|0;a[h>>0]=((p+-48|0)>>>0<10?208:169)+p+(((o+-48|0)>>>0<10?0:9)+o<<4);e=e+2|0;h=h+1|0;}e=k;while(1){b=b+-1|0;if(e>>>0>=b>>>0)break;p=a[e>>0]|0;a[e>>0]=a[b>>0]|0;a[b>>0]=p;e=e+1|0;}c[l>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;c[l+16>>2]=0;c[l+20>>2]=0;g[j>>3]=+f[k>>2];kl(m,l,l+(bi(l,24,13203,j)|0)|0);c[j>>2]=c[m>>2];c[j+4>>2]=c[m+4>>2];um(d,j);}Eb=n;return}function Co(a){a=a|0;$j(a);return}function Do(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Eo(a,(c[b>>2]|0)!=0);return a|0}function Eo(b,d){b=b|0;d=d|0;jm(b,59,1,1,1);c[b>>2]=4888;a[b+8>>0]=d&1;return}function Fo(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g+8|0;f=g;if(!(a[b+8>>0]|0))fl(f,13268);else fl(f,13263);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(d,e);Eb=g;return}function Go(a){a=a|0;$j(a);return}function Ho(a,b,c){a=a|0;b=b|0;c=c|0;return Io(a+368|0,b,c)|0}function Io(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;e=Eb;Eb=Eb+32|0;f=e+24|0;g=e+16|0;i=e+8|0;h=e;a=hm(a,24)|0;k=b;b=c[k+4>>2]|0;j=i;c[j>>2]=c[k>>2];c[j+4>>2]=b;j=d;b=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=b;c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];Jo(a,g,f);Eb=e;return a|0}function Jo(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,61,1,1,1);c[a>>2]=4932;f=b;b=c[f+4>>2]|0;e=a+8|0;c[e>>2]=c[f>>2];c[e+4>>2]=b;e=d;b=c[e+4>>2]|0;d=a+16|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Ko(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;n=Eb;Eb=Eb+64|0;m=n+56|0;e=n+48|0;f=n+16|0;g=n+40|0;h=n+32|0;i=n+24|0;j=n+8|0;k=n;l=b+8|0;if((vm(l)|0)>>>0>3){fl(e,12715);c[m>>2]=c[e>>2];c[m+4>>2]=c[e+4>>2];um(d,m);p=l;o=c[p+4>>2]|0;e=f;c[e>>2]=c[p>>2];c[e+4>>2]=o;c[m>>2]=c[f>>2];c[m+4>>2]=c[f+4>>2];um(d,m);fl(g,12711);c[m>>2]=c[g>>2];c[m+4>>2]=c[g+4>>2];um(d,m);}b=b+16|0;p=Mo(b)|0;if((a[p>>0]|0)==110){fl(h,13318);c[m>>2]=c[h>>2];c[m+4>>2]=c[h+4>>2];um(d,m);No(i,b,1);c[m>>2]=c[i>>2];c[m+4>>2]=c[i+4>>2];um(d,m);}else{i=b;o=c[i+4>>2]|0;p=j;c[p>>2]=c[i>>2];c[p+4>>2]=o;c[m>>2]=c[j>>2];c[m+4>>2]=c[j+4>>2];um(d,m);}if((vm(l)|0)>>>0<4){o=c[l+4>>2]|0;p=k;c[p>>2]=c[l>>2];c[p+4>>2]=o;c[m>>2]=c[k>>2];c[m+4>>2]=c[k+4>>2];um(d,m);}Eb=n;return}function Lo(a){a=a|0;$j(a);return}function Mo(a){a=a|0;return wm(a)|0}function No(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;e=vm(b)|0;kl(a,(c[b>>2]|0)+(e>>>0>d>>>0?d:e+-1|0)|0,c[b+4>>2]|0);return}function Oo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Po(a,e);Eb=d;return a|0}function Po(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,28,1,1,1);c[a>>2]=4976;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Qo(a,b){a=a|0;b=b|0;yn(a+8|0,b);return}function Ro(a){a=a|0;$j(a);return}function So(a){a=a|0;var b=0,d=0,e=0,f=0;e=Eb;Eb=Eb+32|0;b=e+16|0;f=e+8|0;d=e;fl(f,15674);c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];if(!(gl(a,b)|0)){fl(d,15677);c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];if((gl(a,b)|0?(ol(b,a,0),!(pl(b)|0)):0)?nl(a,112)|0:0){ds(a)|0;ol(b,a,0);if(nl(a,95)|0)b=es(a,b)|0;else b=0;}else b=0;}else{ds(a)|0;ol(b,a,0);if(nl(a,95)|0)b=es(a,b)|0;else b=0;}Eb=e;return b|0}function To(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;P=Eb;Eb=Eb+288|0;K=P+8|0;L=P+272|0;M=P;x=P+264|0;C=P+256|0;D=P+248|0;E=P+240|0;F=P+232|0;G=P+224|0;H=P+216|0;d=P+208|0;e=P+200|0;f=P+192|0;g=P+184|0;h=P+176|0;i=P+168|0;j=P+160|0;k=P+152|0;l=P+144|0;m=P+136|0;n=P+128|0;o=P+120|0;p=P+112|0;q=P+104|0;r=P+96|0;s=P+88|0;t=P+80|0;u=P+72|0;v=P+64|0;w=P+56|0;y=P+48|0;z=P+40|0;A=P+32|0;B=P+24|0;N=P+16|0;if(nl(b,102)|0){I=jl(b,0)|0;switch(I<<24>>24){case 76:case 108:{O=1;J=4;break}case 82:case 114:{O=0;J=4;break}default:d=0;}if((J|0)==4){a[L>>0]=O;c[b>>2]=(c[b>>2]|0)+1;tm(M);fl(x,15527);c[K>>2]=c[x>>2];c[K+4>>2]=c[x+4>>2];do if(gl(b,K)|0){fl(K,12719);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;}else{fl(C,15530);c[K>>2]=c[C>>2];c[K+4>>2]=c[C+4>>2];if(gl(b,K)|0){fl(K,12717);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(D,15533);c[K>>2]=c[D>>2];c[K+4>>2]=c[D+4>>2];if(gl(b,K)|0){fl(K,13431);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(E,15536);c[K>>2]=c[E>>2];c[K+4>>2]=c[E+4>>2];if(gl(b,K)|0){fl(K,13434);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(F,15539);c[K>>2]=c[F>>2];c[K+4>>2]=c[F+4>>2];if(gl(b,K)|0){fl(K,13446);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(G,15542);c[K>>2]=c[G>>2];c[K+4>>2]=c[G+4>>2];if(gl(b,K)|0){fl(K,13450);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(H,15545);c[K>>2]=c[H>>2];c[K+4>>2]=c[H+4>>2];if(gl(b,K)|0){fl(K,13453);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(d,15548);c[K>>2]=c[d>>2];c[K+4>>2]=c[d+4>>2];if(gl(b,K)|0){fl(K,13455);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(e,15551);c[K>>2]=c[e>>2];c[K+4>>2]=c[e+4>>2];if(gl(b,K)|0){fl(K,13458);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(f,15554);c[K>>2]=c[f>>2];c[K+4>>2]=c[f+4>>2];if(gl(b,K)|0){fl(K,13460);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(g,15557);c[K>>2]=c[g>>2];c[K+4>>2]=c[g+4>>2];if(gl(b,K)|0){fl(K,13463);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(h,15560);c[K>>2]=c[h>>2];c[K+4>>2]=c[h+4>>2];if(gl(b,K)|0){fl(K,13466);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(i,15563);c[K>>2]=c[i>>2];c[K+4>>2]=c[i+4>>2];if(gl(b,K)|0){fl(K,12790);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(j,15566);c[K>>2]=c[j>>2];c[K+4>>2]=c[j+4>>2];if(gl(b,K)|0){fl(K,13469);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(k,15569);c[K>>2]=c[k>>2];c[K+4>>2]=c[k+4>>2];if(gl(b,K)|0){fl(K,13472);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(l,15572);c[K>>2]=c[l>>2];c[K+4>>2]=c[l+4>>2];if(gl(b,K)|0){fl(K,13475);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(m,15575);c[K>>2]=c[m>>2];c[K+4>>2]=c[m+4>>2];if(gl(b,K)|0){fl(K,12897);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(n,15578);c[K>>2]=c[n>>2];c[K+4>>2]=c[n+4>>2];if(gl(b,K)|0){fl(K,13318);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(o,15581);c[K>>2]=c[o>>2];c[K+4>>2]=c[o+4>>2];if(gl(b,K)|0){fl(K,13479);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(p,15584);c[K>>2]=c[p>>2];c[K+4>>2]=c[p+4>>2];if(gl(b,K)|0){fl(K,12784);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(q,15587);c[K>>2]=c[q>>2];c[K+4>>2]=c[q+4>>2];if(gl(b,K)|0){fl(K,13482);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(r,15590);c[K>>2]=c[r>>2];c[K+4>>2]=c[r+4>>2];if(gl(b,K)|0){fl(K,13488);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(s,15593);c[K>>2]=c[s>>2];c[K+4>>2]=c[s+4>>2];if(gl(b,K)|0){fl(K,13493);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(t,15596);c[K>>2]=c[t>>2];c[K+4>>2]=c[t+4>>2];if(gl(b,K)|0){fl(K,13496);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(u,15599);c[K>>2]=c[u>>2];c[K+4>>2]=c[u+4>>2];if(gl(b,K)|0){fl(K,13498);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(v,15602);c[K>>2]=c[v>>2];c[K+4>>2]=c[v+4>>2];if(gl(b,K)|0){fl(K,13505);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(w,15605);c[K>>2]=c[w>>2];c[K+4>>2]=c[w+4>>2];if(gl(b,K)|0){fl(K,13507);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(y,15608);c[K>>2]=c[y>>2];c[K+4>>2]=c[y+4>>2];if(gl(b,K)|0){fl(K,13516);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(z,15611);c[K>>2]=c[z>>2];c[K+4>>2]=c[z+4>>2];if(gl(b,K)|0){fl(K,13518);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(A,15614);c[K>>2]=c[A>>2];c[K+4>>2]=c[A+4>>2];if(gl(b,K)|0){fl(K,13521);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;break}fl(B,15617);c[K>>2]=c[B>>2];c[K+4>>2]=c[B+4>>2];if(!(gl(b,K)|0)){d=0;break}fl(K,13524);G=K;H=c[G+4>>2]|0;J=M;c[J>>2]=c[G>>2];c[J+4>>2]=H;J=66;}while(0);if((J|0)==66){d=hl(b)|0;J=ao(d)|0;c[K>>2]=J;c[N>>2]=0;e=J;a:do if(!J)d=0;else{switch(I<<24>>24){case 76:case 82:{d=ao(d)|0;c[N>>2]=d;if(!d){d=0;break a}if(O<<24>>24){c[K>>2]=d;c[N>>2]=e;}break}}d=Zr(b,L,M,K,N)|0;}while(0)}}}else d=0;Eb=P;return d|0}function Uo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+16|0;d=g+4|0;e=g;f=hl(a)|0;h=ao(f)|0;c[d>>2]=h;if(!h)a=0;else{h=ao(f)|0;c[e>>2]=h;if(!h)a=0;else a=Ur(a,d,b,e)|0;}Eb=g;return a|0}function Vo(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;e=Eb;Eb=Eb+16|0;d=e;f=ao(hl(a)|0)|0;c[d>>2]=f;if(!f)a=0;else a=Pr(a,b,d)|0;Eb=e;return a|0}function Wo(a,b,c){a=a|0;b=b|0;c=c|0;return Or(a+368|0,b,c,12711)|0}function Xo(a,b,c){a=a|0;b=b|0;c=c|0;return Nr(a+368|0,15416,b,c)|0}function Yo(a,b,c){a=a|0;b=b|0;c=c|0;return Jr(a+368|0,b,c)|0}function Zo(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=Eb;Eb=Eb+32|0;f=h+24|0;e=h+16|0;g=h+8|0;b=h;fl(e,15315);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];if(gl(a,f)|0){Qm(g,a+360|0,0);d=hl(a)|0;e=rl(d)|0;c[f>>2]=e;Um(g);do if(e){if(!(nl(a,95)|0)){e=ao(d)|0;c[g>>2]=e;if(!e)b=0;else{Cn(b,a,g,g+4|0);b=Dr(a,f,b)|0;}break}b=a+8|0;e=Zl(b)|0;while(1){if(nl(a,69)|0){d=9;break}i=ao(d)|0;c[g>>2]=i;if(!i){d=7;break}Yl(b,g);}if((d|0)==7){b=0;break}else if((d|0)==9){sn(g,a,e);b=Cr(a,f,g)|0;break}}else b=0;while(0)}else b=0;Eb=h;return b|0}function _o(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return yr(a+368|0,b,c,d)|0}function $o(a,b,c){a=a|0;b=b|0;c=c|0;return xr(a+368|0,15244,b,c)|0}function ap(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=Eb;Eb=Eb+48|0;f=h+32|0;g=h+8|0;i=h+24|0;b=h+16|0;d=h;c[g>>2]=0;fl(i,14454);c[f>>2]=c[i>>2];c[f+4>>2]=c[i+4>>2];a:do if(gl(a,f)|0){b=hl(a)|0;i=Rq(b)|0;c[g>>2]=i;if(!i)b=0;else{do if((jl(a,0)|0)<<24>>24==73){i=Rl(b,0)|0;c[f>>2]=i;if(!i){b=0;break a}else{i=Sl(a,g,f)|0;c[g>>2]=i;break}}while(0);while(1){if(nl(a,69)|0)break;i=Sq(b)|0;c[f>>2]=i;if(!i){e=35;break}i=Tq(a,g,f)|0;c[g>>2]=i;}if((e|0)==35){b=0;break}i=Uq(b)|0;c[f>>2]=i;if(!i)b=0;else b=Tq(a,g,f)|0;}}else{fl(b,13428);c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];e=gl(a,f)|0;fl(d,14458);c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];if(!(gl(a,f)|0)){b=Uq(hl(a)|0)|0;c[g>>2]=b;if((b|0)==0|e^1)break;b=Vq(a,g)|0;c[g>>2]=b;break}b:do if((((jl(a,0)|0)<<24>>24)+-48|0)>>>0>=10){b=hl(a)|0;i=Rq(b)|0;c[g>>2]=i;if(!i){b=0;break a}if((jl(a,0)|0)<<24>>24==73){i=Rl(b,0)|0;c[f>>2]=i;if(!i){b=0;break a}else{i=Sl(a,g,f)|0;c[g>>2]=i;break}}}else{while(1){b=hl(a)|0;d=Sq(b)|0;c[f>>2]=d;if(!d)break;do if(!(c[g>>2]|0))if(e){i=Vq(a,f)|0;c[g>>2]=i;break}else{c[g>>2]=d;break}else{i=Tq(a,g,f)|0;c[g>>2]=i;}while(0);if(nl(a,69)|0)break b}b=0;break a}while(0);i=Uq(b)|0;c[f>>2]=i;if(!i)b=0;else b=Tq(a,g,f)|0;}while(0);Eb=h;return b|0}function bp(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Qq(a+368|0,b,c,d)|0}function cp(a,b,c){a=a|0;b=b|0;c=c|0;return Mq(a+368|0,b,14405,c)|0}function dp(a,b,c){a=a|0;b=b|0;c=c|0;return Iq(a+368|0,b,c)|0}function ep(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;i=Eb;Eb=Eb+16|0;e=i+8|0;f=i+4|0;g=i;a:do if((jl(b,0)|0)<<24>>24==100)switch((jl(b,1)|0)<<24>>24|0){case 105:{c[b>>2]=(c[b>>2]|0)+2;d=hl(b)|0;j=oq(d)|0;c[e>>2]=j;if(!j)d=0;else{j=ep(d)|0;c[f>>2]=j;if(!j)d=0;else{a[g>>0]=0;d=pq(b,e,f,g)|0;}}break a}case 120:{c[b>>2]=(c[b>>2]|0)+2;d=hl(b)|0;j=ao(d)|0;c[e>>2]=j;if(!j)d=0;else{j=ep(d)|0;c[f>>2]=j;if(!j)d=0;else{a[g>>0]=1;d=pq(b,e,f,g)|0;}}break a}case 88:{c[b>>2]=(c[b>>2]|0)+2;d=hl(b)|0;j=ao(d)|0;c[e>>2]=j;if(!j)d=0;else{j=ao(d)|0;c[f>>2]=j;if(!j)d=0;else{j=ep(d)|0;c[g>>2]=j;if(!j)d=0;else d=qq(b,e,f,g)|0;}}break a}default:{h=20;break a}}else h=20;while(0);if((h|0)==20)d=ao(hl(b)|0)|0;Eb=i;return d|0}function fp(a,b,c){a=a|0;b=b|0;c=c|0;return nq(a+368|0,b,c)|0}function gp(a,b,c){a=a|0;b=b|0;c=c|0;return jq(a+368|0,b,c)|0}function hp(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;m=Eb;Eb=Eb+64|0;g=m+48|0;h=m+57|0;n=m+40|0;i=m+56|0;f=m+32|0;d=m+24|0;j=m+16|0;k=m;e=m+8|0;fl(n,13428);c[g>>2]=c[n>>2];c[g+4>>2]=c[n+4>>2];n=(gl(b,g)|0)&1;a[h>>0]=n;n=(jl(b,1)|0)<<24>>24==97&1;a[i>>0]=n;fl(f,14042);c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];if(!(gl(b,g)|0)?(fl(d,14045),c[g>>2]=c[d>>2],c[g+4>>2]=c[d+4>>2],!(gl(b,g)|0)):0)d=0;else l=3;do if((l|0)==3){f=b+8|0;d=Zl(f)|0;while(1){if(nl(b,95)|0)break;n=ao(hl(b)|0)|0;c[g>>2]=n;if(!n){l=7;break}Yl(f,g);}if((l|0)==7){d=0;break}sn(j,b,d);d=hl(b)|0;n=rl(d)|0;c[k>>2]=n;do if(n){fl(e,14048);c[g>>2]=c[e>>2];c[g+4>>2]=c[e+4>>2];if(!(gl(b,g)|0)){if(!(nl(b,69)|0)){d=0;break}bq(g);d=cq(b,j,k,g,h,i)|0;break}e=Zl(f)|0;while(1){if(nl(b,69)|0){l=15;break}n=ao(d)|0;c[g>>2]=n;if(!n){l=13;break}Yl(f,g);}if((l|0)==13){d=0;break}else if((l|0)==15){sn(g,b,e);d=aq(b,j,k,g,h,i)|0;break}}else d=0;while(0)}while(0);Eb=m;return d|0}function ip(a,b){a=a|0;b=b|0;return $p(a+368|0,14031,b,12711)|0}function jp(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Xp(a+368|0,b,c,d)|0}function kp(a,b,c){a=a|0;b=b|0;c=c|0;return Wp(a+368|0,13950,b,c)|0}function lp(a,b,c){a=a|0;b=b|0;c=c|0;return Sp(a+368|0,13891,b,c)|0}function mp(a,b,c){a=a|0;b=b|0;c=c|0;return Rp(a+368|0,b,c,12711)|0}function np(a,b){a=a|0;b=b|0;return Ip(a+368|0,b)|0}function op(a,b){a=a|0;b=b|0;return Ep(a+368|0,13703,b,12711)|0}function pp(a,b){a=a|0;b=b|0;return Ap(a+368|0,b)|0}function qp(a,b,c){a=a|0;b=b|0;c=c|0;return wp(a+368|0,b,c)|0}function rp(a,b){a=a|0;b=b|0;return sp(a+368|0,b)|0}function sp(a,b){a=a|0;b=b|0;a=hm(a,12)|0;tp(a,c[b>>2]|0);return a|0}function tp(a,b){a=a|0;b=b|0;jm(a,58,1,1,1);c[a>>2]=5020;c[a+8>>2]=b;return}function up(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,13552);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function vp(a){a=a|0;$j(a);return}function wp(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];xp(a,b,f);Eb=e;return a|0}function xp(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,56,1,1,1);c[a>>2]=5064;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function yp(a,b){a=a|0;b=b|0;var d=0;d=c[a+8>>2]|0;if(d|0)Pk(d,b);Qk(b,123);yn(a+12|0,b);Qk(b,125);return}function zp(a){a=a|0;$j(a);return}function Ap(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Bp(a,e);Eb=d;return a|0}function Bp(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,0,1,1,1);c[a>>2]=5108;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Cp(a,b){a=a|0;b=b|0;yn(a+8|0,b);return}function Dp(a){a=a|0;$j(a);return}function Ep(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+32|0;g=f+24|0;h=f+16|0;j=f+8|0;i=f;a=hm(a,28)|0;fl(j,b);d=c[d>>2]|0;fl(i,e);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];Fp(a,h,d,g);Eb=f;return a|0}function Fp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;jm(a,47,1,1,1);c[a>>2]=5152;g=b;f=c[g+4>>2]|0;b=a+8|0;c[b>>2]=c[g>>2];c[b+4>>2]=f;c[a+16>>2]=d;b=e;d=c[b+4>>2]|0;e=a+20|0;c[e>>2]=c[b>>2];c[e+4>>2]=d;return}function Gp(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=Eb;Eb=Eb+32|0;e=d+16|0;h=d+8|0;f=d;j=a+8|0;i=c[j+4>>2]|0;g=h;c[g>>2]=c[j>>2];c[g+4>>2]=i;c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Pk(c[a+16>>2]|0,b);h=a+20|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Hp(a){a=a|0;$j(a);return}function Ip(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Jp(a,c[b>>2]|0);return a|0}function Jp(a,b){a=a|0;b=b|0;jm(a,49,1,1,1);c[a>>2]=5196;c[a+8>>2]=b;return}function Kp(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+48|0;e=d+32|0;h=d+24|0;g=d+8|0;f=d;fl(h,13765);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Mp(g,c[a+8>>2]|0);Np(g,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Lp(a){a=a|0;$j(a);return}function Mp(a,b){a=a|0;b=b|0;jm(a,29,1,1,1);c[a>>2]=5240;c[a+8>>2]=b;return}function Np(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;h=m+48|0;i=m+32|0;j=m+8|0;e=m+24|0;k=m;l=b+12|0;Op(i,l);d=b+16|0;Op(j,d);f=Rk(b)|0;g=a+8|0;Pk(c[g>>2]|0,b);d=c[d>>2]|0;a:do switch(d|0){case -1:{fl(e,12245);c[h>>2]=c[e>>2];c[h+4>>2]=c[e+4>>2];um(b,h);break}case 0:{An(b,f);break}default:{a=1;while(1){if(a>>>0>=d>>>0)break a;fl(k,12899);c[h>>2]=c[k>>2];c[h+4>>2]=c[k+4>>2];um(b,h);c[l>>2]=a;Pk(c[g>>2]|0,b);a=a+1|0;}}}while(0);Pp(j);Pp(i);Eb=m;return}function Op(b,d){b=b|0;d=d|0;c[b>>2]=d;c[b+4>>2]=c[d>>2];a[b+8>>0]=1;c[d>>2]=-1;return}function Pp(b){b=b|0;if(a[b+8>>0]|0)c[c[b>>2]>>2]=c[b+4>>2];return}function Qp(a){a=a|0;$j(a);return}function Rp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+32|0;g=f+24|0;h=f+16|0;j=f+8|0;i=f;a=hm(a,28)|0;fl(j,b);d=c[d>>2]|0;fl(i,e);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];Fp(a,h,d,g);Eb=f;return a|0}function Sp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;fl(h,b);d=c[d>>2]|0;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Tp(a,g,d,e);Eb=f;return a|0}function Tp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;jm(a,48,1,1,1);c[a>>2]=5284;g=b;f=c[g+4>>2]|0;b=a+8|0;c[b>>2]=c[g>>2];c[b+4>>2]=f;c[a+16>>2]=d;c[a+20>>2]=e;return}function Up(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;d=Eb;Eb=Eb+48|0;e=d+32|0;i=d;h=d+24|0;g=d+16|0;f=d+8|0;l=a+8|0;k=c[l+4>>2]|0;j=i;c[j>>2]=c[l>>2];c[j+4>>2]=k;c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);fl(h,12897);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=c[a+16>>2]|0;Xb[c[(c[h>>2]|0)+16>>2]&127](h,b);fl(g,13903);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);a=c[a+20>>2]|0;Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Vp(a){a=a|0;$j(a);return}function Wp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;fl(h,b);d=c[d>>2]|0;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Tp(a,g,d,e);Eb=f;return a|0}function Xp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;a=hm(a,20)|0;Yp(a,c[b>>2]|0,c[d>>2]|0,c[e>>2]|0);return a|0}function Yp(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;jm(a,45,1,1,1);c[a>>2]=5328;c[a+8>>2]=b;c[a+12>>2]=d;c[a+16>>2]=e;return}function Zp(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+48|0;e=d+32|0;i=d+24|0;h=d+16|0;g=d+8|0;f=d;fl(i,12715);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(h,13967);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);fl(g,13973);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+16>>2]|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function _p(a){a=a|0;$j(a);return}function $p(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+32|0;g=f+24|0;h=f+16|0;j=f+8|0;i=f;a=hm(a,28)|0;fl(j,b);d=c[d>>2]|0;fl(i,e);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];Fp(a,h,d,g);Eb=f;return a|0}function aq(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return iq(a+368|0,b,c,d,e,f)|0}function bq(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;return}function cq(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return dq(a+368|0,b,c,d,e,f)|0}function dq(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0,o=0;i=Eb;Eb=Eb+32|0;j=i+24|0;k=i+16|0;m=i+8|0;l=i;b=hm(b,32)|0;o=d;d=c[o+4>>2]|0;n=m;c[n>>2]=c[o>>2];c[n+4>>2]=d;e=c[e>>2]|0;n=f;d=c[n+4>>2]|0;f=l;c[f>>2]=c[n>>2];c[f+4>>2]=d;g=(a[g>>0]|0)!=0;h=(a[h>>0]|0)!=0;c[k>>2]=c[m>>2];c[k+4>>2]=c[m+4>>2];c[j>>2]=c[l>>2];c[j+4>>2]=c[l+4>>2];eq(b,k,e,j,g,h);Eb=i;return b|0}function eq(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0;jm(b,51,1,1,1);c[b>>2]=5372;j=d;i=c[j+4>>2]|0;d=b+8|0;c[d>>2]=c[j>>2];c[d+4>>2]=i;c[b+16>>2]=e;d=f;e=c[d+4>>2]|0;f=b+20|0;c[f>>2]=c[d>>2];c[f+4>>2]=e;a[b+28>>0]=g&1;a[b+29>>0]=h&1;return}function fq(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;j=m+56|0;e=m+48|0;f=m+40|0;g=m+32|0;h=m+24|0;i=m+16|0;k=m+8|0;l=m;if(a[b+28>>0]|0){fl(e,14051);c[j>>2]=c[e>>2];c[j+4>>2]=c[e+4>>2];um(d,j);}fl(f,14063);c[j>>2]=c[f>>2];c[j+4>>2]=c[f+4>>2];um(d,j);if(a[b+29>>0]|0){fl(g,14067);c[j>>2]=c[g>>2];c[j+4>>2]=c[g+4>>2];um(d,j);}Qk(d,32);e=b+8|0;if(!(hq(e)|0)){fl(h,12715);c[j>>2]=c[h>>2];c[j+4>>2]=c[h+4>>2];um(d,j);yn(e,d);fl(i,12711);c[j>>2]=c[i>>2];c[j+4>>2]=c[i+4>>2];um(d,j);}Pk(c[b+16>>2]|0,d);e=b+20|0;if(!(hq(e)|0)){fl(k,12715);c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];um(d,j);yn(e,d);fl(l,12711);c[j>>2]=c[l>>2];c[j+4>>2]=c[l+4>>2];um(d,j);}Eb=m;return}function gq(a){a=a|0;$j(a);return}function hq(a){a=a|0;return (c[a+4>>2]|0)==0|0}function iq(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0,o=0;i=Eb;Eb=Eb+32|0;j=i+24|0;k=i+16|0;m=i+8|0;l=i;b=hm(b,32)|0;o=d;d=c[o+4>>2]|0;n=m;c[n>>2]=c[o>>2];c[n+4>>2]=d;e=c[e>>2]|0;n=f;d=c[n+4>>2]|0;f=l;c[f>>2]=c[n>>2];c[f+4>>2]=d;g=(a[g>>0]|0)!=0;h=(a[h>>0]|0)!=0;c[k>>2]=c[m>>2];c[k+4>>2]=c[m+4>>2];c[j>>2]=c[l>>2];c[j+4>>2]=c[l+4>>2];eq(b,k,e,j,g,h);Eb=i;return b|0}function jq(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;fl(g,d);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];kq(a,b,f);Eb=e;return a|0}function kq(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,44,1,1,1);c[a>>2]=5416;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function lq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;g=d+16|0;h=d+8|0;f=d;fl(g,12715);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(h,12711);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=a+12|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function mq(a){a=a|0;$j(a);return}function nq(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;b=hm(a,20)|0;h=d;a=c[h+4>>2]|0;d=g;c[d>>2]=c[h>>2];c[d+4>>2]=a;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];xp(b,0,f);Eb=e;return b|0}function oq(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;h=Eb;Eb=Eb+32|0;b=h+24|0;d=h+16|0;e=h+8|0;f=h;c[d>>2]=0;if(!(zq(a,d)|0)?(i=ml(a)|0,g=c[d>>2]|0,(g+-1|0)>>>0<i>>>0):0){i=c[a>>2]|0;kl(e,i,i+g|0);c[a>>2]=(c[a>>2]|0)+g;fl(f,14270);c[b>>2]=c[f>>2];c[b+4>>2]=c[f+4>>2];if(Aq(e,b)|0)b=Bq(a)|0;else b=Jl(a,e)|0;}else b=0;Eb=h;return b|0}function pq(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return vq(a+368|0,b,c,d)|0}function qq(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return rq(a+368|0,b,c,d)|0}function rq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;a=hm(a,20)|0;sq(a,c[b>>2]|0,c[d>>2]|0,c[e>>2]|0);return a|0}function sq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;jm(a,66,1,1,1);c[a>>2]=5460;c[a+8>>2]=b;c[a+12>>2]=d;c[a+16>>2]=e;return}function tq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+32|0;e=g+16|0;d=g+8|0;f=g;Qk(b,91);Pk(c[a+8>>2]|0,b);fl(d,14161);c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Qk(b,93);d=a+16|0;a=c[d>>2]|0;if(((Vm(a)|0)+-65&255)>=2){fl(f,14167);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);a=c[d>>2]|0;}Pk(a,b);Eb=g;return}function uq(a){a=a|0;$j(a);return}function vq(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;b=hm(b,20)|0;wq(b,c[d>>2]|0,c[e>>2]|0,(a[f>>0]|0)!=0);return b|0}function wq(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;jm(b,65,1,1,1);c[b>>2]=5504;c[b+8>>2]=d;c[b+12>>2]=e;a[b+16>>0]=f&1;return}function xq(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;f=h+8|0;g=h;if(!(a[b+16>>0]|0)){Qk(d,46);Pk(c[b+8>>2]|0,d);}else{Qk(d,91);Pk(c[b+8>>2]|0,d);Qk(d,93);}e=b+12|0;b=c[e>>2]|0;if(((Vm(b)|0)+-65&255)>=2){fl(g,14167);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];um(d,f);b=c[e>>2]|0;}Pk(b,d);Eb=h;return}function yq(a){a=a|0;$j(a);return}function zq(a,b){a=a|0;b=b|0;var d=0,e=0;c[b>>2]=0;a:do if(((jl(a,0)|0)+-48&255)>9)a=1;else{d=0;while(1){if(((jl(a,0)|0)+-48&255)>=10){a=0;break a}c[b>>2]=d*10;e=((Hq(a)|0)<<24>>24)+-48|0;e=e+(c[b>>2]|0)|0;c[b>>2]=e;d=e;}}while(0);return a|0}function Aq(b,c){b=b|0;c=c|0;var d=0,e=0;d=vm(c)|0;a:do if(d>>>0>(vm(b)|0)>>>0)c=0;else{e=wm(c)|0;d=en(c)|0;c=wm(b)|0;b=e;while(1){if((b|0)==(d|0)){c=1;break a}if((a[b>>0]|0)!=(a[c>>0]|0)){c=0;break a}c=c+1|0;b=b+1|0;}}while(0);return c|0}function Bq(a){a=a|0;return Cq(a+368|0,14281)|0}function Cq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function Dq(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,7,1,1,1);c[a>>2]=5548;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Eq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;h=a+8|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Fq(a,b){a=a|0;b=b|0;var d=0,e=0;e=b+8|0;d=c[e+4>>2]|0;b=a;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Gq(a){a=a|0;$j(a);return}function Hq(b){b=b|0;var d=0;d=c[b>>2]|0;if((d|0)==(c[b+4>>2]|0))b=0;else{c[b>>2]=d+1;b=a[d>>0]|0;}return b|0}function Iq(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;Jq(a,c[b>>2]|0,c[d>>2]|0);return a|0}function Jq(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,43,1,1,1);c[a>>2]=5592;c[a+8>>2]=b;c[a+12>>2]=d;return}function Kq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;h=d+16|0;g=d+8|0;f=d;fl(h,12715);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(g,14347);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);fl(f,12349);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Lq(a){a=a|0;$j(a);return}function Mq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;b=c[b>>2]|0;fl(h,d);e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Nq(a,b,g,e);Eb=f;return a|0}function Nq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;jm(a,46,1,1,1);c[a>>2]=5636;c[a+8>>2]=b;f=d;b=c[f+4>>2]|0;d=a+12|0;c[d>>2]=c[f>>2];c[d+4>>2]=b;c[a+20>>2]=e;return}function Oq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;Pk(c[a+8>>2]|0,b);i=a+12|0;h=c[i+4>>2]|0;g=f;c[g>>2]=c[i>>2];c[g+4>>2]=h;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+20>>2]|0,b);Eb=d;return}function Pq(a){a=a|0;$j(a);return}function Qq(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;b=c[b>>2]|0;fl(h,d);e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Nq(a,b,g,e);Eb=f;return a|0}function Rq(a){a=a|0;var b=0,d=0,e=0;e=Eb;Eb=Eb+16|0;d=e;switch((jl(a,0)|0)<<24>>24){case 84:{b=Ql(hl(a)|0)|0;c[d>>2]=b;if(!b)b=0;else Yl(a+148|0,d);break}case 68:{b=Kl(hl(a)|0)|0;c[d>>2]=b;if(!b)b=0;else Yl(a+148|0,d);break}default:b=Xl(hl(a)|0)|0;}Eb=e;return b|0}function Sq(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;d=g+4|0;e=g;f=hl(a)|0;b=oq(f)|0;c[d>>2]=b;if(b){if((jl(a,0)|0)<<24>>24==73){f=Rl(f,0)|0;c[e>>2]=f;if(!f)b=0;else b=Sl(a,d,e)|0;}}else b=0;Eb=g;return b|0}function Tq(a,b,c){a=a|0;b=b|0;c=c|0;return sr(a+368|0,b,c)|0}function Uq(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;g=Eb;Eb=Eb+32|0;e=g+24|0;b=g+16|0;d=g+8|0;f=g;do if((((jl(a,0)|0)<<24>>24)+-48|0)>>>0<10)b=Sq(hl(a)|0)|0;else{fl(b,14520);c[e>>2]=c[b>>2];c[e+4>>2]=c[b+4>>2];if(gl(a,e)|0){b=$q(hl(a)|0)|0;break}fl(d,14523);c[e>>2]=c[d>>2];c[e+4>>2]=c[d+4>>2];gl(a,e)|0;d=hl(a)|0;b=ar(d,0)|0;c[e>>2]=b;if(b){if((jl(a,0)|0)<<24>>24==73){d=Rl(d,0)|0;c[f>>2]=d;if(!d)b=0;else b=Sl(a,e,f)|0;}}else b=0;}while(0);Eb=g;return b|0}function Vq(a,b){a=a|0;b=b|0;return Wq(a+368|0,b)|0}function Wq(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Xq(a,c[b>>2]|0);return a|0}function Xq(a,b){a=a|0;b=b|0;jm(a,33,1,1,1);c[a>>2]=5680;c[a+8>>2]=b;return}function Yq(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function Zq(a,b){a=a|0;b=b|0;b=c[b+8>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function _q(a){a=a|0;$j(a);return}function $q(a){a=a|0;var b=0,d=0,e=0,f=0;e=Eb;Eb=Eb+16|0;d=e;f=(((jl(a,0)|0)<<24>>24)+-48|0)>>>0<10;b=hl(a)|0;if(f)b=Sq(b)|0;else b=Rq(b)|0;c[d>>2]=b;if(!b)b=0;else b=nr(a,d)|0;Eb=e;return b|0}function ar(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;i=Eb;Eb=Eb+32|0;g=i+16|0;h=i+8|0;f=i;a:do switch((jl(b,0)|0)<<24>>24|0){case 97:switch((jl(b,1)|0)<<24>>24|0){case 97:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14526)|0;break a}case 110:case 100:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14537)|0;break a}case 78:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14547)|0;break a}case 83:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14558)|0;break a}default:{b=0;break a}}case 99:switch((jl(b,1)|0)<<24>>24|0){case 108:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14568)|0;break a}case 109:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14579)|0;break a}case 111:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14589)|0;break a}case 118:{c[b>>2]=(c[b>>2]|0)+2;Qm(g,b+360|0,0);j=b+361|0;e=(d|0)!=0;Qm(h,j,e|(a[j>>0]|0)!=0);j=rl(hl(b)|0)|0;c[f>>2]=j;if(!j)b=0;else{if(e)a[d>>0]=1;b=br(b,f)|0;}Um(h);Um(g);break a}default:{b=0;break a}}case 100:switch((jl(b,1)|0)<<24>>24|0){case 97:{c[b>>2]=(c[b>>2]|0)+2;b=Fl(b,14599)|0;break a}case 101:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14617)|0;break a}case 108:{c[b>>2]=(c[b>>2]|0)+2;b=cr(b)|0;break a}case 118:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14627)|0;break a}case 86:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14637)|0;break a}default:{b=0;break a}}case 101:switch((jl(b,1)|0)<<24>>24|0){case 111:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14648)|0;break a}case 79:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14658)|0;break a}case 113:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14669)|0;break a}default:{b=0;break a}}case 103:switch((jl(b,1)|0)<<24>>24|0){case 101:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14680)|0;break a}case 116:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14691)|0;break a}default:{b=0;break a}}case 105:{if((jl(b,1)|0)<<24>>24==120){c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14701)|0;}else b=0;break}case 108:switch((jl(b,1)|0)<<24>>24|0){case 101:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14712)|0;break a}case 105:{c[b>>2]=(c[b>>2]|0)+2;j=oq(hl(b)|0)|0;c[g>>2]=j;if(!j)b=0;else b=dr(b,g)|0;break a}case 115:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14723)|0;break a}case 83:{c[b>>2]=(c[b>>2]|0)+2;b=wl(b,14734)|0;break a}case 116:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14746)|0;break a}default:{b=0;break a}}case 109:switch((jl(b,1)|0)<<24>>24|0){case 105:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14756)|0;break a}case 73:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14766)|0;break a}case 108:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14617)|0;break a}case 76:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14777)|0;break a}case 109:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14788)|0;break a}default:{b=0;break a}}case 110:switch((jl(b,1)|0)<<24>>24|0){case 97:{c[b>>2]=(c[b>>2]|0)+2;b=zl(b,14799)|0;break a}case 101:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14814)|0;break a}case 103:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14756)|0;break a}case 116:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14825)|0;break a}case 119:{c[b>>2]=(c[b>>2]|0)+2;b=Bl(b,14835)|0;break a}default:{b=0;break a}}case 111:switch((jl(b,1)|0)<<24>>24|0){case 111:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14848)|0;break a}case 114:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14859)|0;break a}case 82:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14869)|0;break a}default:{b=0;break a}}case 112:switch((jl(b,1)|0)<<24>>24|0){case 109:{c[b>>2]=(c[b>>2]|0)+2;b=wl(b,14880)|0;break a}case 108:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14892)|0;break a}case 76:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14902)|0;break a}case 112:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14913)|0;break a}case 115:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14892)|0;break a}case 116:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14924)|0;break a}default:{b=0;break a}}case 113:{if((jl(b,1)|0)<<24>>24==117){c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14935)|0;}else b=0;break}case 114:switch((jl(b,1)|0)<<24>>24|0){case 109:{c[b>>2]=(c[b>>2]|0)+2;b=Cl(b,14945)|0;break a}case 77:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14955)|0;break a}case 115:{c[b>>2]=(c[b>>2]|0)+2;b=Hl(b,14966)|0;break a}case 83:{c[b>>2]=(c[b>>2]|0)+2;b=wl(b,14977)|0;break a}default:{b=0;break a}}case 115:{if((jl(b,1)|0)<<24>>24==115){c[b>>2]=(c[b>>2]|0)+2;b=wl(b,14989)|0;}else b=0;break}case 118:{if((((jl(b,1)|0)<<24>>24)+-48|0)>>>0<10){c[b>>2]=(c[b>>2]|0)+2;j=oq(hl(b)|0)|0;c[g>>2]=j;if(!j)b=0;else b=br(b,g)|0;}else b=0;break}default:b=0;}while(0);Eb=i;return b|0}function br(a,b){a=a|0;b=b|0;return jr(a+368|0,b)|0}function cr(a){a=a|0;return ir(a+368|0,15065)|0}function dr(a,b){a=a|0;b=b|0;return er(a+368|0,b)|0}function er(a,b){a=a|0;b=b|0;a=hm(a,12)|0;fr(a,c[b>>2]|0);return a|0}function fr(a,b){a=a|0;b=b|0;jm(a,19,1,1,1);c[a>>2]=5724;c[a+8>>2]=b;return}function gr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,15001);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function hr(a){a=a|0;$j(a);return}function ir(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function jr(a,b){a=a|0;b=b|0;a=hm(a,12)|0;kr(a,c[b>>2]|0);return a|0}function kr(a,b){a=a|0;b=b|0;jm(a,4,1,1,1);c[a>>2]=5768;c[a+8>>2]=b;return}function lr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,15081);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function mr(a){a=a|0;$j(a);return}function nr(a,b){a=a|0;b=b|0;return or(a+368|0,b)|0}function or(a,b){a=a|0;b=b|0;a=hm(a,12)|0;pr(a,c[b>>2]|0);return a|0}function pr(a,b){a=a|0;b=b|0;jm(a,38,1,1,1);c[a>>2]=5812;c[a+8>>2]=b;return}function qr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,13448);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);a=c[a+8>>2]|0;Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);Eb=d;return}function rr(a){a=a|0;$j(a);return}function sr(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;tr(a,c[b>>2]|0,c[d>>2]|0);return a|0}function tr(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,22,1,1,1);c[a>>2]=5856;c[a+8>>2]=b;c[a+12>>2]=d;return}function ur(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Eb=d;return}function vr(a,b){a=a|0;b=b|0;b=c[b+12>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function wr(a){a=a|0;$j(a);return}function xr(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;fl(h,b);d=c[d>>2]|0;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Tp(a,g,d,e);Eb=f;return a|0}function yr(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;b=hm(b,16)|0;zr(b,c[d>>2]|0,(a[e>>0]|0)!=0,(a[f>>0]|0)!=0);return b|0}function zr(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;jm(b,52,1,1,1);c[b>>2]=5900;c[b+8>>2]=d;a[b+12>>0]=e&1;a[b+13>>0]=f&1;return}function Ar(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+32|0;e=i+24|0;f=i+16|0;g=i+8|0;h=i;if(a[b+12>>0]|0){fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(d,e);}fl(g,15257);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(d,e);if(a[b+13>>0]|0){fl(h,15264);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(d,e);}Pk(c[b+8>>2]|0,d);Eb=i;return}function Br(a){a=a|0;$j(a);return}function Cr(a,b,c){a=a|0;b=b|0;c=c|0;return Ir(a+368|0,b,c)|0}function Dr(a,b,c){a=a|0;b=b|0;c=c|0;return Er(a+368|0,b,c)|0}function Er(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Fr(a,b,f);Eb=e;return a|0}function Fr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,55,1,1,1);c[a>>2]=5944;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Gr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;h=d+16|0;g=d+8|0;f=d;fl(h,12715);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(g,15318);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);yn(a+12|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Hr(a){a=a|0;$j(a);return}function Ir(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Fr(a,b,f);Eb=e;return a|0}function Jr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Kr(a,b,f);Eb=e;return a|0}function Kr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,50,1,1,1);c[a>>2]=5988;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Lr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=Eb;Eb=Eb+32|0;e=d+16|0;g=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(g,12715);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);yn(a+12|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Mr(a){a=a|0;$j(a);return}function Nr(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;fl(h,b);d=c[d>>2]|0;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Tp(a,g,d,e);Eb=f;return a|0}function Or(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+32|0;g=f+24|0;h=f+16|0;j=f+8|0;i=f;a=hm(a,28)|0;fl(j,b);d=c[d>>2]|0;fl(i,e);c[h>>2]=c[j>>2];c[h+4>>2]=c[j+4>>2];c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];Fp(a,h,d,g);Eb=f;return a|0}function Pr(a,b,c){a=a|0;b=b|0;c=c|0;return Qr(a+368|0,b,c)|0}function Qr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;i=b;h=c[i+4>>2]|0;b=g;c[b>>2]=c[i>>2];c[b+4>>2]=h;d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Rr(a,f,d);Eb=e;return a|0}function Rr(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,53,1,1,1);c[a>>2]=6032;f=b;e=c[f+4>>2]|0;b=a+8|0;c[b>>2]=c[f>>2];c[b+4>>2]=e;c[a+16>>2]=d;return}function Sr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=Eb;Eb=Eb+32|0;e=d+24|0;h=d;g=d+16|0;f=d+8|0;k=a+8|0;j=c[k+4>>2]|0;i=h;c[i>>2]=c[k>>2];c[i+4>>2]=j;c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);fl(g,12715);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+16>>2]|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Tr(a){a=a|0;$j(a);return}function Ur(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Vr(a+368|0,b,c,d)|0}function Vr(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;f=Eb;Eb=Eb+16|0;g=f+8|0;h=f;a=hm(a,24)|0;b=c[b>>2]|0;j=d;i=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=i;e=c[e>>2]|0;c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];Wr(a,b,g,e);Eb=f;return a|0}function Wr(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;jm(a,42,1,1,1);c[a>>2]=6076;c[a+8>>2]=b;f=d;b=c[f+4>>2]|0;d=a+12|0;c[d>>2]=c[f>>2];c[d+4>>2]=b;c[a+20>>2]=e;return}function Xr(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;d=m+56|0;e=m+48|0;f=m+40|0;g=m+32|0;h=m;i=m+24|0;j=m+16|0;k=m+8|0;l=a+12|0;fl(d,12790);if(dn(l,d)|0){fl(e,12715);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}fl(f,12715);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);Pk(c[a+8>>2]|0,b);fl(g,15474);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];um(b,d);e=l;f=c[e+4>>2]|0;g=h;c[g>>2]=c[e>>2];c[g+4>>2]=f;c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);fl(i,15477);c[d>>2]=c[i>>2];c[d+4>>2]=c[i+4>>2];um(b,d);Pk(c[a+20>>2]|0,b);fl(j,12711);c[d>>2]=c[j>>2];c[d+4>>2]=c[j+4>>2];um(b,d);fl(d,12790);if(dn(l,d)|0){fl(k,12711);c[d>>2]=c[k>>2];c[d+4>>2]=c[k+4>>2];um(b,d);}Eb=m;return}function Yr(a){a=a|0;$j(a);return}function Zr(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return _r(a+368|0,b,c,d,e)|0}function _r(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0;h=Eb;Eb=Eb+16|0;i=h+8|0;j=h;b=hm(b,28)|0;d=(a[d>>0]|0)!=0;l=e;k=c[l+4>>2]|0;e=j;c[e>>2]=c[l>>2];c[e+4>>2]=k;f=c[f>>2]|0;g=c[g>>2]|0;c[i>>2]=c[j>>2];c[i+4>>2]=c[j+4>>2];$r(b,d,i,f,g);Eb=h;return b|0}function $r(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;jm(b,57,1,1,1);c[b>>2]=6120;c[b+8>>2]=f;c[b+12>>2]=g;f=c[e+4>>2]|0;g=b+16|0;c[g>>2]=c[e>>2];c[g+4>>2]=f;a[b+24>>0]=d&1;return}function as(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;l=m+56|0;h=m+32|0;f=m+24|0;i=m+48|0;j=m+16|0;e=m+8|0;g=m+40|0;k=m;c[h>>2]=d;c[h+4>>2]=b;Qk(d,40);if(!(a[b+24>>0]|0)){cs(h);Qk(d,32);f=b+16|0;h=f;i=c[h+4>>2]|0;j=e;c[j>>2]=c[h>>2];c[j+4>>2]=i;c[l>>2]=c[e>>2];c[l+4>>2]=c[e+4>>2];um(d,l);fl(g,15625);c[l>>2]=c[g>>2];c[l+4>>2]=c[g+4>>2];um(d,l);e=b+12|0;if(c[e>>2]|0){Qk(d,32);h=f;i=c[h+4>>2]|0;j=k;c[j>>2]=c[h>>2];c[j+4>>2]=i;c[l>>2]=c[k>>2];c[l+4>>2]=c[k+4>>2];um(d,l);Qk(d,32);Pk(c[e>>2]|0,d);}}else{e=c[b+12>>2]|0;if(!e)e=b+16|0;else{Pk(e,d);Qk(d,32);e=b+16|0;g=e;b=c[g+4>>2]|0;k=f;c[k>>2]=c[g>>2];c[k+4>>2]=b;c[l>>2]=c[f>>2];c[l+4>>2]=c[f+4>>2];um(d,l);Qk(d,32);}fl(i,15620);c[l>>2]=c[i>>2];c[l+4>>2]=c[i+4>>2];um(d,l);b=e;i=c[b+4>>2]|0;k=j;c[k>>2]=c[b>>2];c[k+4>>2]=i;c[l>>2]=c[j>>2];c[l+4>>2]=c[j+4>>2];um(d,l);Qk(d,32);cs(h);}Qk(d,41);Eb=m;return}function bs(a){a=a|0;$j(a);return}function cs(a){a=a|0;var b=0,d=0,e=0;b=Eb;Eb=Eb+16|0;d=b;e=c[a+4>>2]|0;Qk(c[a>>2]|0,40);Mp(d,c[e+8>>2]|0);Pk(d,c[a>>2]|0);Qk(c[a>>2]|0,41);Eb=b;return}function ds(a){a=a|0;var b=0,d=0;d=Eb;Eb=Eb+16|0;b=d;c[b>>2]=0;if(nl(a,114)|0)js(b,4);if(nl(a,86)|0)js(b,2);if(nl(a,75)|0)js(b,1);Eb=d;return c[b>>2]|0}function es(a,b){a=a|0;b=b|0;return fs(a+368|0,b)|0}function fs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];gs(a,e);Eb=d;return a|0}function gs(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,54,1,1,1);c[a>>2]=6164;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function hs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+16|0;h=d+8|0;f=d;fl(h,15674);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=a+8|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function is(a){a=a|0;$j(a);return}function js(a,b){a=a|0;b=b|0;c[a>>2]=c[a>>2]|b;return}function ks(a){a=a|0;var b=0;b=a+12|0;c[a>>2]=b;c[a+4>>2]=b;c[a+8>>2]=a+44;return}function ls(a,b){a=a|0;b=b|0;return qs(a+368|0,b)|0}function ms(a,b){a=a|0;b=b|0;var d=0,e=0;e=a+4|0;d=c[e>>2]|0;if((d|0)==(c[a+8>>2]|0)){ps(a,(os(a)|0)<<1);d=c[e>>2]|0;}b=c[b>>2]|0;c[e>>2]=d+4;c[d>>2]=b;return}function ns(a,b){a=a|0;b=b|0;return (_n(a)|0)+(b<<2)|0}function os(a){a=a|0;return (c[a+4>>2]|0)-(c[a>>2]|0)>>2|0}function ps(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=os(a)|0;do if(!(cl(a)|0)){e=jk(c[a>>2]|0,b<<2)|0;c[a>>2]=e;if(!e)Uk();else{f=e;d=a+4|0;break}}else{f=hk(b<<2)|0;if(!f)Uk();g=c[a>>2]|0;d=a+4|0;e=(c[d>>2]|0)-g|0;if(e|0)bx(f|0,g|0,e|0)|0;c[a>>2]=f;}while(0);c[d>>2]=f+(h<<2);c[a+8>>2]=f+(b<<2);return}function qs(a,b){a=a|0;b=b|0;a=hm(a,20)|0;rs(a,c[b>>2]|0);return a|0}function rs(b,d){b=b|0;d=d|0;jm(b,31,2,2,2);c[b>>2]=6208;c[b+8>>2]=d;c[b+12>>2]=0;a[b+16>>0]=0;return}function ss(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);b=Wm(c[b+12>>2]|0,d)|0;Um(e);}else b=0;Eb=g;return b|0}function ts(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);b=Sm(c[b+12>>2]|0,d)|0;Um(e);}else b=0;Eb=g;return b|0}function us(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);b=Tm(c[b+12>>2]|0,d)|0;Um(e);}else b=0;Eb=g;return b|0}function vs(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);b=c[b+12>>2]|0;b=Ob[c[(c[b>>2]|0)+12>>2]&63](b,d)|0;Um(e);}Eb=g;return b|0}function ws(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);f=c[b+12>>2]|0;Xb[c[(c[f>>2]|0)+16>>2]&127](f,d);Um(e);}Eb=g;return}function xs(b,d){b=b|0;d=d|0;var e=0,f=0,g=0;g=Eb;Eb=Eb+16|0;e=g;f=b+16|0;if(!(a[f>>0]|0)){Qm(e,f,1);f=c[b+12>>2]|0;Xb[c[(c[f>>2]|0)+20>>2]&127](f,d);Um(e);}Eb=g;return}function ys(a){a=a|0;$j(a);return}function zs(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+16|0;g=j+4|0;h=j;nl(b,76)|0;switch((jl(b,0)|0)<<24>>24){case 78:{e=Fs(hl(b)|0,d)|0;break}case 90:{e=Gs(hl(b)|0,d)|0;break}case 83:{if((jl(b,1)|0)<<24>>24==116)i=13;else{e=hl(b)|0;f=Xl(e)|0;c[g>>2]=f;if((f|0)!=0?(jl(b,0)|0)<<24>>24==73:0){f=(d|0)!=0;e=Rl(e,f)|0;c[h>>2]=e;if(!e)e=0;else{if(f)a[d+1>>0]=1;e=Sl(b,g,h)|0;}}else e=0;}break}default:i=13;}if((i|0)==13){f=hl(b)|0;e=Hs(f,d)|0;c[g>>2]=e;if(e){if((jl(b,0)|0)<<24>>24==73){Yl(b+148|0,g);e=(d|0)!=0;i=Rl(f,e)|0;c[h>>2]=i;if(!i)e=0;else{if(e)a[d+1>>0]=1;e=Sl(b,g,h)|0;}}}else e=0;}Eb=j;return e|0}function As(a,b,c){a=a|0;b=b|0;c=c|0;return Bs(a+368|0,b,c)|0}function Bs(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;i=b;h=c[i+4>>2]|0;b=g;c[b>>2]=c[i>>2];c[b+4>>2]=h;d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Cs(a,f,d);Eb=e;return a|0}function Cs(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,6,1,1,1);c[a>>2]=6252;f=b;e=c[f+4>>2]|0;b=a+8|0;c[b>>2]=c[f>>2];c[b+4>>2]=e;c[a+16>>2]=d;return}function Ds(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;i=a+8|0;h=c[i+4>>2]|0;g=f;c[g>>2]=c[i>>2];c[g+4>>2]=h;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Qk(b,32);Pk(c[a+16>>2]|0,b);Eb=d;return}function Es(a){a=a|0;$j(a);return}function Fs(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+48|0;h=m+32|0;i=m+20|0;j=m+24|0;k=m+8|0;g=m;c[i>>2]=d;if(nl(b,78)|0){e=ds(b)|0;f=(d|0)==0;if(!f)c[d+4>>2]=e;do if(nl(b,79)|0){if(!f)a[d+8>>0]=2;}else{e=(d|0)!=0;if(nl(b,82)|0){if(!e)break;a[d+8>>0]=1;break}else{if(!e)break;a[d+8>>0]=0;break}}while(0);c[j>>2]=0;c[k>>2]=b;c[k+4>>2]=j;c[k+8>>2]=i;fl(g,15881);c[h>>2]=c[g>>2];c[h+4>>2]=c[g+4>>2];if(gl(b,h)|0){g=Al(b,16199)|0;c[j>>2]=g;}f=b+148|0;a:while(1){if(nl(b,69)|0){l=41;break}nl(b,76)|0;b:do if(nl(b,77)|0){if(!(c[j>>2]|0)){e=0;break a}}else{c:do switch((jl(b,0)|0)<<24>>24){case 84:{if(!(jt(k,Ql(hl(b)|0)|0)|0)){e=0;break a}Yl(f,j);break b}case 73:{g=Rl(hl(b)|0,(c[i>>2]|0)!=0)|0;c[h>>2]=g;if((g|0)==0|(c[j>>2]|0)==0){l=26;break a}e=Sl(b,j,h)|0;c[j>>2]=e;e=c[i>>2]|0;if(e|0)a[e+1>>0]=1;Yl(f,j);break b}case 68:{switch((jl(b,1)|0)<<24>>24){case 67:{l=39;break c}case 84:case 116:break;default:break c}if(!(jt(k,Kl(hl(b)|0)|0)|0)){e=0;break a}Yl(f,j);break b}case 83:{if((jl(b,1)|0)<<24>>24==116)l=39;else{e=Xl(hl(b)|0)|0;c[h>>2]=e;if(!(jt(k,e)|0)){l=44;break a}if((c[j>>2]|0)!=(e|0))Yl(f,h);break b}break}case 67:break;default:l=39;}while(0);if((l|0)==39){l=0;g=hl(b)|0;if(!(jt(k,Is(g,c[i>>2]|0)|0)|0)){e=0;break a}Yl(f,j);break}if(!(c[j>>2]|0)){e=0;break a}e=hl(b)|0;if(!(jt(k,kt(e,j,c[i>>2]|0)|0)|0)){e=0;break a}g=am(e,c[j>>2]|0)|0;c[j>>2]=g;if(!g){e=0;break a}Yl(f,j);}while(0)}if((l|0)==26)e=0;else if((l|0)==41)if((c[j>>2]|0)!=0?!(bm(f)|0):0){lt(f);e=c[j>>2]|0;}else e=0;else if((l|0)==44)e=0;}else e=0;Eb=m;return e|0}function Gs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+16|0;d=g+8|0;e=g;if(nl(a,90)|0){f=hl(a)|0;h=il(f)|0;c[d>>2]=h;do if((h|0)!=0?nl(a,69)|0:0){if(nl(a,115)|0){h=dt(c[a>>2]|0,c[a+4>>2]|0)|0;c[a>>2]=h;h=zl(a,16139)|0;c[e>>2]=h;a=et(a,d,e)|0;break}if(!(nl(a,100)|0)){h=zs(f,b)|0;c[e>>2]=h;if(!h)a=0;else{h=dt(c[a>>2]|0,c[a+4>>2]|0)|0;c[a>>2]=h;a=et(a,d,e)|0;}break}ol(e,a,1);if(nl(a,95)|0){h=zs(f,b)|0;c[e>>2]=h;if(!h)a=0;else a=et(a,d,e)|0;}else a=0;}else a=0;while(0)}else a=0;Eb=g;return a|0}function Hs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+32|0;d=f+16|0;g=f+8|0;e=f;fl(g,15877);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];if(!(gl(a,d)|0)?(fl(e,15881),c[d>>2]=c[e>>2],c[d+4>>2]=c[e+4>>2],!(gl(a,d)|0)):0)d=Is(hl(a)|0,b)|0;else{g=Is(hl(a)|0,b)|0;c[d>>2]=g;if(!g)d=0;else d=Js(a,d)|0;}Eb=f;return d|0}function Is(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;f=h+8|0;d=h;e=jl(a,0)|0;do if(e<<24>>24!=85){if((e+-49&255)<9){b=oq(hl(a)|0)|0;g=12;break}fl(d,15943);c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];if(!(gl(a,f)|0)){b=ar(hl(a)|0,b)|0;g=12;break}b=a+8|0;e=Zl(b)|0;while(1){d=hl(a)|0;g=oq(d)|0;c[f>>2]=g;if(!g){g=10;break}Yl(b,f);if(nl(a,69)|0){g=9;break}}if((g|0)==9){sn(f,a,e);b=Qs(a,f)|0;g=14;break}else if((g|0)==10){b=0;break}}else{b=Ps(hl(a)|0)|0;g=12;}while(0);if((g|0)==12)if(!b)b=0;else{d=hl(a)|0;g=14;}if((g|0)==14)b=am(d,b)|0;Eb=h;return b|0}function Js(a,b){a=a|0;b=b|0;return Ks(a+368|0,b)|0}function Ks(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Ls(a,c[b>>2]|0);return a|0}function Ls(a,b){a=a|0;b=b|0;jm(a,34,1,1,1);c[a>>2]=6296;c[a+8>>2]=b;return}function Ms(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,15884);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);Eb=d;return}function Ns(a,b){a=a|0;b=b|0;b=c[b+8>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function Os(a){a=a|0;$j(a);return}function Ps(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+48|0;f=i+40|0;e=i+32|0;b=i+24|0;g=i;h=i+8|0;d=i+16|0;fl(e,16004);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];if(!(gl(a,f)|0)){fl(b,16007);c[f>>2]=c[b>>2];c[f+4>>2]=c[b+4>>2];if(gl(a,f)|0){bq(g);Qm(h,a+362|0,1);fl(d,16010);c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];do if(!(gl(a,f)|0)){b=a+8|0;d=Zl(b)|0;while(1){e=rl(hl(a)|0)|0;c[f>>2]=e;if(!e){e=11;break}Yl(b,f);if(nl(a,69)|0){e=10;break}}if((e|0)==10){sn(g,a,d);e=12;break}else if((e|0)==11){b=0;break}}else e=12;while(0);if((e|0)==12){ol(f,a,0);if(nl(a,95)|0)b=Ws(a,g,f)|0;else b=0;}Um(h);}else b=0;}else{ol(f,a,0);if(nl(a,95)|0)b=Vs(a,f)|0;else b=0;}Eb=i;return b|0}function Qs(a,b){a=a|0;b=b|0;return Rs(a+368|0,b)|0}function Rs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Ss(a,e);Eb=d;return a|0}function Ss(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,41,1,1,1);c[a>>2]=6340;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Ts(a,b){a=a|0;b=b|0;Qk(b,91);yn(a+8|0,b);Qk(b,93);return}function Us(a){a=a|0;$j(a);return}function Vs(a,b){a=a|0;b=b|0;return $s(a+368|0,b)|0}function Ws(a,b,c){a=a|0;b=b|0;c=c|0;return Xs(a+368|0,b,c)|0}function Xs(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;e=Eb;Eb=Eb+32|0;f=e+24|0;g=e+16|0;i=e+8|0;h=e;a=hm(a,24)|0;k=b;b=c[k+4>>2]|0;j=i;c[j>>2]=c[k>>2];c[j+4>>2]=b;j=d;b=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=b;c[g>>2]=c[i>>2];c[g+4>>2]=c[i+4>>2];c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];Ys(a,g,f);Eb=e;return a|0}function Ys(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,40,1,1,1);c[a>>2]=6384;f=b;b=c[f+4>>2]|0;e=a+8|0;c[e>>2]=c[f>>2];c[e+4>>2]=b;e=d;b=c[e+4>>2]|0;d=a+16|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Zs(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=Eb;Eb=Eb+48|0;e=d+32|0;k=d+24|0;h=d;g=d+16|0;f=d+8|0;fl(k,16013);c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];um(b,e);k=a+16|0;j=c[k+4>>2]|0;i=h;c[i>>2]=c[k>>2];c[i+4>>2]=j;c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);fl(g,16021);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);yn(a+8|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function _s(a){a=a|0;$j(a);return}function $s(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];at(a,e);Eb=d;return a|0}function at(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,39,1,1,1);c[a>>2]=6428;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function bt(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+24|0;i=d+16|0;g=d;f=d+8|0;fl(i,16076);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);i=a+8|0;h=c[i+4>>2]|0;a=g;c[a>>2]=c[i>>2];c[a+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,16085);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function ct(a){a=a|0;$j(a);return}function dt(b,c){b=b|0;c=c|0;var d=0,e=0;a:do if((b|0)!=(c|0)){d=a[b>>0]|0;if(d<<24>>24!=95){if(((d<<24>>24)+-48|0)>>>0>=10)break;d=b;while(1){d=d+1|0;if((d|0)==(c|0)){b=c;break a}if(((a[d>>0]|0)+-48|0)>>>0>=10)break a}}d=b+1|0;if((d|0)!=(c|0)){d=a[d>>0]|0;if(((d<<24>>24)+-48|0)>>>0<10){b=b+2|0;break}if(d<<24>>24==95){d=b+2|0;while(1){if((d|0)==(c|0))break a;e=a[d>>0]|0;if(((e<<24>>24)+-48|0)>>>0>=10)break;d=d+1|0;}return (e<<24>>24==95?d+1|0:b)|0}}}while(0);return b|0}function et(a,b,c){a=a|0;b=b|0;c=c|0;return ft(a+368|0,b,c)|0}function ft(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;gt(a,c[b>>2]|0,c[d>>2]|0);return a|0}function gt(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,24,1,1,1);c[a>>2]=6472;c[a+8>>2]=b;c[a+12>>2]=d;return}function ht(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Eb=d;return}function it(a){a=a|0;$j(a);return}function jt(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+16|0;e=i;c[e>>2]=d;f=c[b>>2]|0;if(!d)b=0;else{h=b+4|0;g=c[h>>2]|0;if(!(c[g>>2]|0))c[g>>2]=d;else{g=xt(f,g,e)|0;c[c[h>>2]>>2]=g;}b=c[c[b+8>>2]>>2]|0;if(b|0)a[b+1>>0]=0;b=(c[c[h>>2]>>2]|0)!=0;}Eb=i;return b|0}function kt(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0;j=Eb;Eb=Eb+16|0;h=j;i=j+4|0;f=c[d>>2]|0;if((Vm(f)|0)<<24>>24==36?(g=c[f+8>>2]|0,c[h>>2]=g,(g+-2|0)>>>0<4):0){g=mt(b,h)|0;c[d>>2]=g;}a:do if(!(nl(b,67)|0))if((jl(b,0)|0)<<24>>24==68){f=jl(b,1)|0;switch(f<<24>>24){case 53:case 50:case 49:case 48:break;default:{f=0;break a}}c[h>>2]=(f<<24>>24)+-48;c[b>>2]=(c[b>>2]|0)+2;if(e|0)a[e>>0]=1;a[i>>0]=1;f=nt(b,d,i,h)|0;}else f=0;else{f=nl(b,73)|0;g=jl(b,0)|0;switch(g<<24>>24){case 53:case 51:case 50:case 49:break;default:{f=0;break a}}c[h>>2]=(g<<24>>24)+-48;c[b>>2]=(c[b>>2]|0)+1;if(e|0)a[e>>0]=1;if(f?(zs(hl(b)|0,e)|0)==0:0)f=0;else{a[i>>0]=0;f=nt(b,d,i,h)|0;}}while(0);Eb=j;return f|0}function lt(a){a=a|0;a=a+4|0;c[a>>2]=(c[a>>2]|0)+-4;return}function mt(a,b){a=a|0;b=b|0;return st(a+368|0,b)|0}function nt(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return ot(a+368|0,b,c,d)|0}function ot(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;b=hm(b,20)|0;pt(b,c[d>>2]|0,(a[e>>0]|0)!=0,c[f>>2]|0);return b|0}function pt(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;jm(b,37,1,1,1);c[b>>2]=6516;c[b+8>>2]=d;a[b+12>>0]=e&1;c[b+16>>2]=f;return}function qt(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+32|0;e=h+16|0;f=h+8|0;g=h;if(a[b+12>>0]|0){fl(f,13448);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(d,e);}f=c[b+8>>2]|0;Xb[c[(c[f>>2]|0)+24>>2]&127](g,f);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(d,e);Eb=h;return}function rt(a){a=a|0;$j(a);return}function st(a,b){a=a|0;b=b|0;a=hm(a,12)|0;tt(a,c[b>>2]|0);return a|0}function tt(a,b){a=a|0;b=b|0;jm(a,35,1,1,1);c[a>>2]=6560;c[a+8>>2]=b;return}function ut(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;k=Eb;Eb=Eb+64|0;d=k+48|0;e=k+40|0;f=k+32|0;g=k+24|0;h=k+16|0;i=k+8|0;j=k;switch(c[a+8>>2]|0){case 0:{fl(e,12493);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);break}case 1:{fl(f,12508);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);break}case 2:{fl(g,16295);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];um(b,d);break}case 3:{fl(h,16366);c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);break}case 4:{fl(i,16416);c[d>>2]=c[i>>2];c[d+4>>2]=c[i+4>>2];um(b,d);break}case 5:{fl(j,16466);c[d>>2]=c[j>>2];c[d+4>>2]=c[j+4>>2];um(b,d);break}}Eb=k;return}function vt(a,b){a=a|0;b=b|0;switch(c[b+8>>2]|0){case 0:{fl(a,12438);break}case 1:{fl(a,12448);break}case 2:{fl(a,12448);break}case 3:{fl(a,16252);break}case 4:{fl(a,16266);break}case 5:{fl(a,16280);break}}return}function wt(a){a=a|0;$j(a);return}function xt(a,b,c){a=a|0;b=b|0;c=c|0;return yt(a+368|0,b,c)|0}function yt(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;zt(a,c[b>>2]|0,c[d>>2]|0);return a|0}function zt(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,23,1,1,1);c[a>>2]=6604;c[a+8>>2]=b;c[a+12>>2]=d;return}function At(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(f,14461);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Eb=d;return}function Bt(a,b){a=a|0;b=b|0;b=c[b+12>>2]|0;Xb[c[(c[b>>2]|0)+24>>2]&127](a,b);return}function Ct(a){a=a|0;$j(a);return}function Dt(a,b,c){a=a|0;b=b|0;c=c|0;return Et(a+368|0,b,c)|0}function Et(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;Ft(a,c[b>>2]|0,c[d>>2]|0);return a|0}function Ft(b,d,e){b=b|0;d=d|0;e=e|0;jm(b,13,a[e+5>>0]|0,1,1);c[b>>2]=6648;c[b+8>>2]=d;c[b+12>>2]=e;return}function Gt(a,b){a=a|0;b=b|0;return Wm(c[a+12>>2]|0,b)|0}function Ht(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;i=Eb;Eb=Eb+32|0;d=i+24|0;e=i+16|0;f=i+8|0;g=i;h=a+12|0;j=c[h>>2]|0;Xb[c[(c[j>>2]|0)+16>>2]&127](j,b);if(!(Sm(c[h>>2]|0,b)|0)?!(Tm(c[h>>2]|0,b)|0):0){fl(f,12713);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);}else{fl(e,12715);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}Pk(c[a+8>>2]|0,b);fl(g,16628);c[d>>2]=c[g>>2];c[d+4>>2]=c[g+4>>2];um(b,d);Eb=i;return}function It(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;f=Eb;Eb=Eb+16|0;d=f+8|0;e=f;a=a+12|0;if(!(!(Sm(c[a>>2]|0,b)|0)?!(Tm(c[a>>2]|0,b)|0):0)){fl(e,12711);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}e=c[a>>2]|0;Xb[c[(c[e>>2]|0)+20>>2]&127](e,b);Eb=f;return}function Jt(a){a=a|0;$j(a);return}function Kt(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;return}function Lt(a,b){a=a|0;b=b|0;var d=0,e=0;e=wm(b)|0;b=en(b)|0;d=(b|0)==0;c[a>>2]=d?e+1|0:e;c[a+4>>2]=d?b+1|0:b;return}function Mt(a,b){a=a|0;b=b|0;c[a>>2]=b;c[a+4>>2]=0;return}function Nt(a,b,c){a=a|0;b=b|0;c=c|0;return Ot(a+368|0,b,c)|0}function Ot(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Pt(a,b,f);Eb=e;return a|0}function Pt(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,14,0,0,1);c[a>>2]=6692;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Qt(a,b){return 1}function Rt(a,b){return 1}function St(a,b){a=a|0;b=b|0;a=c[a+8>>2]|0;Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);return}function Tt(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+48|0;f=i+32|0;d=i+24|0;e=i+16|0;g=i+8|0;h=i;if((zn(b)|0)<<24>>24!=93){fl(d,12713);c[f>>2]=c[d>>2];c[f+4>>2]=c[d+4>>2];um(b,f);}fl(e,16688);c[f>>2]=c[e>>2];c[f+4>>2]=c[e+4>>2];um(b,f);d=a+12|0;if(!(Vt(d)|0)){if(Xt(d)|0)Pk(Yt(d)|0,b);}else{Wt(g,d);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];um(b,f);}fl(h,12349);c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];um(b,f);h=c[a+8>>2]|0;Xb[c[(c[h>>2]|0)+20>>2]&127](h,b);Eb=i;return}function Ut(a){a=a|0;$j(a);return}function Vt(a){a=a|0;if(!(c[a+4>>2]|0))a=0;else a=(c[a>>2]|0)!=0;return a|0}function Wt(a,b){a=a|0;b=b|0;kl(a,c[b>>2]|0,c[b+4>>2]|0);return}function Xt(a){a=a|0;if(!(c[a>>2]|0))a=0;else a=(c[a+4>>2]|0)==0;return a|0}function Yt(a){a=a|0;return c[a>>2]|0}function Zt(a,b){a=a|0;b=b|0;a=hm(a,12)|0;Mp(a,c[b>>2]|0);return a|0}function _t(a,b){a=a|0;b=b|0;return iu(a+368|0,b)|0}function $t(a,b,c){a=a|0;b=b|0;c=c|0;return hu(a+368|0,b,c)|0}function au(a,b,c){a=a|0;b=b|0;c=c|0;return gu(a+368|0,b,c)|0}function bu(a,b,c){a=a|0;b=b|0;c=c|0;return cu(a+368|0,b,c)|0}function cu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;e=Eb;Eb=Eb+32|0;f=e+16|0;g=e+8|0;h=e;a=hm(a,20)|0;b=c[b>>2]|0;j=d;i=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=i;c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];Lt(g,f);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];du(a,b,f);Eb=e;return a|0}function du(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,25,1,1,1);c[a>>2]=6736;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function eu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;g=Eb;Eb=Eb+32|0;d=g+24|0;h=g+16|0;e=g+8|0;f=g;Pk(c[a+8>>2]|0,b);fl(h,16738);c[d>>2]=c[h>>2];c[d+4>>2]=c[h+4>>2];um(b,d);a=a+12|0;if(!(Xt(a)|0)){if(Vt(a)|0){Wt(e,a);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}}else Pk(Yt(a)|0,b);fl(f,12349);c[d>>2]=c[f>>2];c[d+4>>2]=c[f+4>>2];um(b,d);Eb=g;return}function fu(a){a=a|0;$j(a);return}function gu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;Mt(g,c[d>>2]|0);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];du(a,b,f);Eb=e;return a|0}function hu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;e=Eb;Eb=Eb+32|0;f=e+16|0;g=e+8|0;h=e;a=hm(a,20)|0;b=c[b>>2]|0;j=d;i=c[j+4>>2]|0;d=h;c[d>>2]=c[j>>2];c[d+4>>2]=i;c[f>>2]=c[h>>2];c[f+4>>2]=c[h+4>>2];Lt(g,f);c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];du(a,b,f);Eb=e;return a|0}function iu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+16|0;f=d+8|0;g=d;a=hm(a,16)|0;i=b;h=c[i+4>>2]|0;b=g;c[b>>2]=c[i>>2];c[b+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];Lt(f,e);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];ju(a,e);Eb=d;return a|0}function ju(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,26,1,1,1);c[a>>2]=6780;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function ku(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+24|0;h=d+16|0;g=d+8|0;f=d;fl(h,16794);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);Wt(g,a+8|0);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,12349);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function lu(a){a=a|0;$j(a);return}function mu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function nu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function ou(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function pu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function qu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function ru(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function su(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function tu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function uu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function vu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function wu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function xu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function yu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function zu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function Au(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;fl(f,b);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Dq(a,e);Eb=d;return a|0}function Bu(b,d,e){b=b|0;d=d|0;e=e|0;c[b>>2]=d;c[b+4>>2]=c[d>>2];a[b+8>>0]=1;c[d>>2]=e;return}function Cu(b){b=b|0;if(a[b+8>>0]|0)c[c[b>>2]>>2]=c[b+4>>2];return}function Du(a,b,c){a=a|0;b=b|0;c=c|0;return Tu(a+368|0,b,c)|0}function Eu(a,b,c){a=a|0;b=b|0;c=c|0;return Pu(a+368|0,b,c)|0}function Fu(a,b,c){a=a|0;b=b|0;c=c|0;return Gu(a+368|0,b,c)|0}function Gu(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;Hu(a,c[b>>2]|0,c[d>>2]|0);return a|0}function Hu(b,d,e){b=b|0;d=d|0;e=e|0;jm(b,3,a[d+5>>0]|0,a[d+6>>0]|0,a[d+7>>0]|0);c[b>>2]=6824;c[b+8>>2]=e;c[b+12>>2]=d;return}function Iu(a,b){a=a|0;b=b|0;return Wm(c[a+12>>2]|0,b)|0}function Ju(a,b){a=a|0;b=b|0;return Sm(c[a+12>>2]|0,b)|0}function Ku(a,b){a=a|0;b=b|0;return Tm(c[a+12>>2]|0,b)|0}function Lu(a,b){a=a|0;b=b|0;var d=0;d=c[a+12>>2]|0;Xb[c[(c[d>>2]|0)+16>>2]&127](d,b);Ou(a,b);return}function Mu(a,b){a=a|0;b=b|0;a=c[a+12>>2]|0;Xb[c[(c[a>>2]|0)+20>>2]&127](a,b);return}function Nu(a){a=a|0;$j(a);return}function Ou(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;i=Eb;Eb=Eb+32|0;g=i+24|0;d=i+16|0;f=i+8|0;h=i;e=a+8|0;a=c[e>>2]|0;if(a&1){fl(d,16906);c[g>>2]=c[d>>2];c[g+4>>2]=c[d+4>>2];um(b,g);a=c[e>>2]|0;}if(a&2){fl(f,16913);c[g>>2]=c[f>>2];c[g+4>>2]=c[f+4>>2];um(b,g);a=c[e>>2]|0;}if(a&4|0){fl(h,16923);c[g>>2]=c[h>>2];c[g+4>>2]=c[h+4>>2];um(b,g);}Eb=i;return}function Pu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Qu(a,b,f);Eb=e;return a|0}function Qu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,2,1,1,1);c[a>>2]=6868;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Ru(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+32|0;e=d+16|0;h=d+8|0;f=d;Pk(c[a+8>>2]|0,b);fl(h,12713);c[e>>2]=c[h>>2];c[e+4>>2]=c[h+4>>2];um(b,e);h=a+12|0;g=c[h+4>>2]|0;a=f;c[a>>2]=c[h>>2];c[a+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Su(a){a=a|0;$j(a);return}function Tu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];Uu(a,b,f);Eb=e;return a|0}function Uu(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,10,1,1,1);c[a>>2]=6912;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function Vu(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+24|0;i=d+16|0;g=d;f=d+8|0;Pk(c[a+8>>2]|0,b);fl(i,12897);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);i=a+12|0;h=c[i+4>>2]|0;a=g;c[a>>2]=c[i>>2];c[a+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,12790);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function Wu(a){a=a|0;$j(a);return}function Xu(a,b){a=a|0;b=b|0;return jv(a+368|0,b)|0}function Yu(a,b){a=a|0;b=b|0;return fv(a+368|0,b)|0}function Zu(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return _u(a+368|0,b,c,d,e,f)|0}function _u(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0;i=Eb;Eb=Eb+16|0;j=i+8|0;k=i;b=hm(b,32)|0;d=c[d>>2]|0;m=e;l=c[m+4>>2]|0;e=k;c[e>>2]=c[m>>2];c[e+4>>2]=l;f=c[f>>2]|0;g=a[g>>0]|0;h=c[h>>2]|0;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];$u(b,d,j,f,g,h);Eb=i;return b|0}function $u(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0;jm(b,15,0,1,0);c[b>>2]=6956;c[b+8>>2]=d;i=e;d=c[i+4>>2]|0;e=b+12|0;c[e>>2]=c[i>>2];c[e+4>>2]=d;c[b+20>>2]=f;a[b+24>>0]=g;c[b+28>>2]=h;return}function av(a,b){return 1}function bv(a,b){return 1}function cv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=c[a+8>>2]|0;Xb[c[(c[a>>2]|0)+16>>2]&127](a,b);fl(f,12713);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function dv(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;i=m+56|0;e=m+48|0;g=m+40|0;f=m+32|0;h=m+24|0;j=m+16|0;k=m+8|0;l=m;fl(e,12715);c[i>>2]=c[e>>2];c[i+4>>2]=c[e+4>>2];um(d,i);yn(b+12|0,d);fl(g,12711);c[i>>2]=c[g>>2];c[i+4>>2]=c[g+4>>2];um(d,i);g=c[b+8>>2]|0;Xb[c[(c[g>>2]|0)+20>>2]&127](g,d);g=b+20|0;e=c[g>>2]|0;if(e&1){fl(f,16906);c[i>>2]=c[f>>2];c[i+4>>2]=c[f+4>>2];um(d,i);e=c[g>>2]|0;}if(e&2){fl(h,16913);c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];um(d,i);e=c[g>>2]|0;}if(e&4|0){fl(j,16923);c[i>>2]=c[j>>2];c[i+4>>2]=c[j+4>>2];um(d,i);}switch(a[b+24>>0]|0){case 1:{fl(k,17108);c[i>>2]=c[k>>2];c[i+4>>2]=c[k+4>>2];um(d,i);break}case 2:{fl(l,17111);c[i>>2]=c[l>>2];c[i+4>>2]=c[l+4>>2];um(d,i);break}}e=b+28|0;if(c[e>>2]|0){Qk(d,32);Pk(c[e>>2]|0,d);}Eb=m;return}function ev(a){a=a|0;$j(a);return}function fv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];gv(a,e);Eb=d;return a|0}function gv(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,17,1,1,1);c[a>>2]=7e3;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function hv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,17164);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);yn(a+8|0,b);Qk(b,41);Eb=d;return}function iv(a){a=a|0;$j(a);return}function jv(a,b){a=a|0;b=b|0;a=hm(a,12)|0;kv(a,c[b>>2]|0);return a|0}function kv(a,b){a=a|0;b=b|0;jm(a,16,1,1,1);c[a>>2]=7044;c[a+8>>2]=b;return}function lv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=Eb;Eb=Eb+32|0;e=d+16|0;g=d+8|0;f=d;fl(g,17228);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function mv(a){a=a|0;$j(a);return}function nv(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function ov(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;jm(a,20,1,1,1);c[a>>2]=7088;f=b;e=c[f+4>>2]|0;b=a+8|0;c[b>>2]=c[f>>2];c[b+4>>2]=e;c[a+16>>2]=d;return}function pv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;i=a+8|0;h=c[i+4>>2]|0;g=f;c[g>>2]=c[i>>2];c[g+4>>2]=h;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+16>>2]|0,b);Eb=d;return}function qv(a){a=a|0;$j(a);return}function rv(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;b=c[b>>2]|0;i=d;h=c[i+4>>2]|0;d=g;c[d>>2]=c[i>>2];c[d+4>>2]=h;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];sv(a,b,f);Eb=e;return a|0}function sv(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;jm(a,1,1,1,1);c[a>>2]=7132;c[a+8>>2]=b;e=d;b=c[e+4>>2]|0;d=a+12|0;c[d>>2]=c[e>>2];c[d+4>>2]=b;return}function tv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;d=Eb;Eb=Eb+32|0;e=d+24|0;i=d+16|0;g=d;f=d+8|0;Pk(c[a+8>>2]|0,b);fl(i,15477);c[e>>2]=c[i>>2];c[e+4>>2]=c[i+4>>2];um(b,e);i=a+12|0;h=c[i+4>>2]|0;a=g;c[a>>2]=c[i>>2];c[a+4>>2]=h;c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);fl(f,12711);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Eb=d;return}function uv(a){a=a|0;$j(a);return}function vv(a){a=a|0;var b=0,d=0,e=0,f=0,g=0;f=Eb;Eb=Eb+16|0;e=f+8|0;b=f;a:do switch((jl(a,0)|0)<<24>>24|0){case 84:switch((jl(a,1)|0)<<24>>24|0){case 86:{c[a>>2]=(c[a>>2]|0)+2;d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Pv(a,e)|0;break a}case 84:{c[a>>2]=(c[a>>2]|0)+2;d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Qv(a,e)|0;break a}case 73:{c[a>>2]=(c[a>>2]|0)+2;d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Rv(a,e)|0;break a}case 83:{c[a>>2]=(c[a>>2]|0)+2;d=rl(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Sv(a,e)|0;break a}case 99:{c[a>>2]=(c[a>>2]|0)+2;if(Tv(a)|0){b=0;break a}if(Tv(a)|0){b=0;break a}d=il(hl(a)|0)|0;c[e>>2]=d;if(!d)b=0;else b=Uv(a,e)|0;break a}case 67:{c[a>>2]=(c[a>>2]|0)+2;d=hl(a)|0;g=rl(d)|0;c[e>>2]=g;do if(g){ol(b,a,1);if(pl(b)|0){b=0;break}if(nl(a,95)|0){g=rl(d)|0;c[b>>2]=g;if(!g)b=0;else b=Vv(a,b,e)|0;}else b=0;}else b=0;while(0);break a}case 87:{c[a>>2]=(c[a>>2]|0)+2;g=zs(hl(a)|0,0)|0;c[e>>2]=g;if(!g)b=0;else b=ql(a,17509,e)|0;break a}case 72:{c[a>>2]=(c[a>>2]|0)+2;g=zs(hl(a)|0,0)|0;c[e>>2]=g;if(!g)b=0;else b=Wv(a,e)|0;break a}default:{c[a>>2]=(c[a>>2]|0)+1;b=(jl(a,0)|0)<<24>>24==118;if(Tv(a)|0){b=0;break a}g=il(hl(a)|0)|0;c[e>>2]=g;do if(g)if(b){b=Xv(a,e)|0;break}else{b=Yv(a,e)|0;break}else b=0;while(0);break a}}case 71:{switch((jl(a,1)|0)<<24>>24|0){case 86:{c[a>>2]=(c[a>>2]|0)+2;g=zs(hl(a)|0,0)|0;c[e>>2]=g;if(!g)b=0;else b=Zv(a,e)|0;break a}case 82:break;default:{b=0;break a}}c[a>>2]=(c[a>>2]|0)+2;g=zs(hl(a)|0,0)|0;c[e>>2]=g;if(!g)b=0;else{g=dm(a,b)|0;if(g|(nl(a,95)|0))b=_v(a,e)|0;else b=0;}break}default:b=0;}while(0);Eb=f;return b|0}function wv(b,d){b=b|0;d=d|0;a[b>>0]=0;a[b+1>>0]=0;c[b+4>>2]=0;a[b+8>>0]=0;d=os(d+332|0)|0;c[b+12>>2]=d;return}function xv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0;f=c[b+12>>2]|0;g=a+332|0;h=os(g)|0;d=a+288|0;b=f;while(1){if(b>>>0>=h>>>0){i=5;break}e=Mv(g,b)|0;e=c[e>>2]|0;a=c[e+8>>2]|0;if(a>>>0>=(Gn(d)|0)>>>0){b=1;break}a=ns(d,a)|0;c[e+12>>2]=c[a>>2];b=b+1|0;}if((i|0)==5){Nv(g,f);b=0;}return b|0}function yv(a){a=a|0;var b=0;a=c[a>>2]|0;if(ml(a)|0?(b=jl(a,0)|0,b<<24>>24!=69):0)return b<<24>>24==46|b<<24>>24==95|0;return 1}function zv(a,b){a=a|0;b=b|0;return Iv(a+368|0,b)|0}function Av(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;return Bv(a+368|0,b,c,d,e,f,g)|0}function Bv(b,d,e,f,g,h,i){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;var j=0,k=0,l=0,m=0,n=0;j=Eb;Eb=Eb+16|0;k=j+8|0;l=j;b=hm(b,36)|0;d=c[d>>2]|0;e=c[e>>2]|0;n=f;m=c[n+4>>2]|0;f=l;c[f>>2]=c[n>>2];c[f+4>>2]=m;g=c[g>>2]|0;h=c[h>>2]|0;i=a[i>>0]|0;c[k>>2]=c[l>>2];c[k+4>>2]=c[l+4>>2];Cv(b,d,e,k,g,h,i);Eb=j;return b|0}function Cv(b,d,e,f,g,h,i){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;i=i|0;jm(b,18,0,1,0);c[b>>2]=7176;c[b+8>>2]=d;c[b+12>>2]=e;d=f;e=c[d+4>>2]|0;f=b+16|0;c[f>>2]=c[d>>2];c[f+4>>2]=e;c[b+24>>2]=g;c[b+28>>2]=h;a[b+32>>0]=i;return}function Dv(a,b){return 1}function Ev(a,b){return 1}function Fv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;h=Eb;Eb=Eb+16|0;d=h+8|0;e=h;f=a+8|0;g=c[f>>2]|0;if(g|0?(Xb[c[(c[g>>2]|0)+16>>2]&127](g,b),!(Wm(c[f>>2]|0,b)|0)):0){fl(e,12713);c[d>>2]=c[e>>2];c[d+4>>2]=c[e+4>>2];um(b,d);}Pk(c[a+12>>2]|0,b);Eb=h;return}function Gv(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;m=Eb;Eb=Eb+64|0;i=m+56|0;f=m+48|0;e=m+40|0;g=m+32|0;h=m+24|0;j=m+16|0;k=m+8|0;l=m;fl(f,12715);c[i>>2]=c[f>>2];c[i+4>>2]=c[f+4>>2];um(d,i);yn(b+16|0,d);fl(e,12711);c[i>>2]=c[e>>2];c[i+4>>2]=c[e+4>>2];um(d,i);e=c[b+8>>2]|0;if(e|0)Xb[c[(c[e>>2]|0)+20>>2]&127](e,d);f=b+28|0;e=c[f>>2]|0;if(e&1){fl(g,16906);c[i>>2]=c[g>>2];c[i+4>>2]=c[g+4>>2];um(d,i);e=c[f>>2]|0;}if(e&2){fl(h,16913);c[i>>2]=c[h>>2];c[i+4>>2]=c[h+4>>2];um(d,i);e=c[f>>2]|0;}if(e&4|0){fl(j,16923);c[i>>2]=c[j>>2];c[i+4>>2]=c[j+4>>2];um(d,i);}switch(a[b+32>>0]|0){case 1:{fl(k,17108);c[i>>2]=c[k>>2];c[i+4>>2]=c[k+4>>2];um(d,i);break}case 2:{fl(l,17111);c[i>>2]=c[l>>2];c[i+4>>2]=c[l+4>>2];um(d,i);break}}e=c[b+24>>2]|0;if(e|0)Pk(e,d);Eb=m;return}function Hv(a){a=a|0;$j(a);return}function Iv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;a=hm(a,16)|0;h=b;g=c[h+4>>2]|0;b=f;c[b>>2]=c[h>>2];c[b+4>>2]=g;c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];Jv(a,e);Eb=d;return a|0}function Jv(a,b){a=a|0;b=b|0;var d=0,e=0;jm(a,9,1,1,1);c[a>>2]=7220;e=b;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;return}function Kv(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=Eb;Eb=Eb+16|0;e=d+8|0;f=d;fl(f,17447);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);yn(a+8|0,b);Qk(b,93);Eb=d;return}function Lv(a){a=a|0;$j(a);return}function Mv(a,b){a=a|0;b=b|0;return (Ov(a)|0)+(b<<2)|0}function Nv(a,b){a=a|0;b=b|0;c[a+4>>2]=(c[a>>2]|0)+(b<<2);return}function Ov(a){a=a|0;return c[a>>2]|0}function Pv(a,b){a=a|0;b=b|0;return mw(a+368|0,17826,b)|0}function Qv(a,b){a=a|0;b=b|0;return lw(a+368|0,17817,b)|0}function Rv(a,b){a=a|0;b=b|0;return kw(a+368|0,17803,b)|0}function Sv(a,b){a=a|0;b=b|0;return jw(a+368|0,17784,b)|0}function Tv(a){a=a|0;var b=0,c=0,d=0;d=Eb;Eb=Eb+16|0;b=d+8|0;c=d;if(!(nl(a,104)|0))if(nl(a,118)|0){ol(b,a,1);if(!(pl(b)|0)?nl(a,95)|0:0){ol(c,a,1);if(pl(c)|0)a=1;else a=(nl(a,95)|0)^1;}else a=1;}else a=1;else{ol(b,a,1);if(pl(b)|0)a=1;else a=(nl(a,95)|0)^1;}Eb=d;return a|0}function Uv(a,b){a=a|0;b=b|0;return iw(a+368|0,17757,b)|0}function Vv(a,b,c){a=a|0;b=b|0;c=c|0;return ew(a+368|0,b,c)|0}function Wv(a,b){a=a|0;b=b|0;return dw(a+368|0,17628,b)|0}function Xv(a,b){a=a|0;b=b|0;return cw(a+368|0,17610,b)|0}function Yv(a,b){a=a|0;b=b|0;return bw(a+368|0,17588,b)|0}function Zv(a,b){a=a|0;b=b|0;return aw(a+368|0,17568,b)|0}function _v(a,b){a=a|0;b=b|0;return $v(a+368|0,17543,b)|0}function $v(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function aw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function bw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function cw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function dw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function ew(a,b,d){a=a|0;b=b|0;d=d|0;a=hm(a,16)|0;fw(a,c[b>>2]|0,c[d>>2]|0);return a|0}function fw(a,b,d){a=a|0;b=b|0;d=d|0;jm(a,21,1,1,1);c[a>>2]=7264;c[a+8>>2]=b;c[a+12>>2]=d;return}function gw(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=Eb;Eb=Eb+32|0;e=d+16|0;g=d+8|0;f=d;fl(g,17669);c[e>>2]=c[g>>2];c[e+4>>2]=c[g+4>>2];um(b,e);Pk(c[a+8>>2]|0,b);fl(f,17694);c[e>>2]=c[f>>2];c[e+4>>2]=c[f+4>>2];um(b,e);Pk(c[a+12>>2]|0,b);Eb=d;return}function hw(a){a=a|0;$j(a);return}function iw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function jw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function kw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function lw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function mw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=Eb;Eb=Eb+16|0;f=e+8|0;g=e;a=hm(a,20)|0;fl(g,b);d=c[d>>2]|0;c[f>>2]=c[g>>2];c[f+4>>2]=c[g+4>>2];ov(a,f,d);Eb=e;return a|0}function nw(b,d,e){b=b|0;d=d|0;e=e|0;c[b>>2]=d;c[b+4>>2]=e;ow(b+8|0);ow(b+148|0);ks(b+288|0);pw(b+332|0);a[b+360>>0]=1;a[b+361>>0]=0;a[b+362>>0]=0;qw(b+368|0);return}function ow(a){a=a|0;var b=0;b=a+12|0;c[a>>2]=b;c[a+4>>2]=b;c[a+8>>2]=a+140;return}function pw(a){a=a|0;var b=0;b=a+12|0;c[a>>2]=b;c[a+4>>2]=b;c[a+8>>2]=a+28;return}function qw(a){a=a|0;rw(a);return}function rw(a){a=a|0;c[a>>2]=0;c[a+4>>2]=0;c[a+4096>>2]=a;return}function tw(a){a=a|0;c[a>>2]=7308;xw(a+4|0);return}function uw(a){a=a|0;tw(a);$j(a);return}function vw(a){a=a|0;return ww(a+4|0)|0}function ww(a){a=a|0;return c[a>>2]|0}function xw(a){a=a|0;var b=0,d=0;if((b=yw(c[a>>2]|0)|0,d=b+8|0,a=c[d>>2]|0,c[d>>2]=a+-1,(a|0)<1))$j(b);return}function yw(a){a=a|0;return a+-12|0}function zw(a){a=a|0;tw(a);$j(a);return}function Aw(a){a=a|0;$j(a);return}function Bw(a,b,c){a=a|0;b=b|0;return Ak(a,b,0)|0}function Cw(a){a=a|0;$j(a);return}function Dw(d,e,f){d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;n=Eb;Eb=Eb+64|0;l=n;do if(!(Ak(e,3368,0)|0)){if(Ew(d,e,0)|0){e=c[f>>2]|0;if(!e){e=1;break}c[f>>2]=c[e>>2];e=1;break}if((e|0)!=0?(g=Ek(e,2128,3296,0)|0,(g|0)!=0):0){e=c[f>>2]|0;if(e|0)c[f>>2]=c[e>>2];e=c[g+8>>2]|0;i=d+8|0;h=c[i>>2]|0;if((e&7&(h^7)|0)==0?((e&96^96)&h|0)==0:0){h=d+12|0;d=c[h>>2]|0;g=g+12|0;e=c[g>>2]|0;if(!(Ak(d,e,0)|0)){if(Ak(d,3360,0)|0){if(!e){e=1;break}e=(Ek(e,2128,3312,0)|0)==0;break}if(d){e=Ek(d,2128,3296,0)|0;if(e|0){if(!(c[i>>2]&1)){e=0;break}e=Fw(e,c[g>>2]|0)|0;break}e=c[h>>2]|0;if(e){e=Ek(e,2128,3328,0)|0;if(e|0){if(!(c[i>>2]&1)){e=0;break}e=Gw(e,c[g>>2]|0)|0;break}e=c[h>>2]|0;if((((e|0)!=0?(j=Ek(e,2128,2112,0)|0,(j|0)!=0):0)?(k=c[g>>2]|0,(k|0)!=0):0)?(m=Ek(k,2128,2112,0)|0,(m|0)!=0):0){c[l>>2]=m;c[l+4>>2]=0;c[l+8>>2]=j;c[l+12>>2]=-1;e=l+16|0;d=l+24|0;g=l+48|0;h=e;i=h+36|0;do{c[h>>2]=0;h=h+4|0;}while((h|0)<(i|0));b[e+36>>1]=0;a[e+38>>0]=0;c[g>>2]=1;$b[c[(c[m>>2]|0)+28>>2]&15](m,l,c[f>>2]|0,1);do if((c[d>>2]|0)==1){if(!(c[f>>2]|0)){e=1;break}c[f>>2]=c[e>>2];e=1;}else e=0;while(0)}else e=0;}else e=0;}else e=0;}else e=1;}else e=0;}else e=0;}else{c[f>>2]=0;e=1;}while(0);Eb=n;return e|0}function Ew(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;if(!(c[a+8>>2]&24))if((b|0)!=0?(e=Ek(b,2128,3280,0)|0,(e|0)!=0):0){d=(c[e+8>>2]&24|0)!=0;f=5;}else d=0;else{d=1;f=5;}if((f|0)==5)d=Ak(a,b,d)|0;return d|0}function Fw(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0;while(1){if(!b){b=0;break}d=Ek(b,2128,3296,0)|0;if(!d){b=0;break}f=c[a+8>>2]|0;if(c[d+8>>2]&~f|0){b=0;break}e=a+12|0;b=c[e>>2]|0;d=d+12|0;if(Ak(b,c[d>>2]|0,0)|0){b=1;break}if((f&1|0)==0|(b|0)==0){b=0;break}a=Ek(b,2128,3296,0)|0;if(!a){h=9;break}b=c[d>>2]|0;}if((h|0)==9){b=c[e>>2]|0;if((b|0)!=0?(g=Ek(b,2128,3328,0)|0,(g|0)!=0):0)b=Gw(g,c[d>>2]|0)|0;else b=0;}return b|0}function Gw(a,b){a=a|0;b=b|0;var d=0;if((((b|0)!=0?(d=Ek(b,2128,3328,0)|0,(d|0)!=0):0)?(c[d+8>>2]&~c[a+8>>2]|0)==0:0)?Ak(c[a+12>>2]|0,c[d+12>>2]|0,0)|0:0)a=Ak(c[a+16>>2]|0,c[d+16>>2]|0,0)|0;else a=0;return a|0}function Hw(a){a=a|0;$j(a);return}function Iw(a,b,c){a=a|0;b=b|0;return Ak(a,b,0)|0}function Jw(a){a=a|0;$j(a);return}
  function Kw(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;if(Ak(b,c[d+8>>2]|0,h)|0)Dk(0,d,e,f,g);else{r=d+52|0;j=a[r>>0]|0;q=d+53|0;i=a[q>>0]|0;p=c[b+12>>2]|0;m=b+16+(p<<3)|0;a[r>>0]=0;a[q>>0]=0;Ow(b+16|0,d,e,f,g,h);k=a[r>>0]|0;j=k|j;l=a[q>>0]|0;i=l|i;a:do if((p|0)>1){n=d+24|0;o=b+8|0;p=d+54|0;b=b+24|0;do{i=i&1;j=j&1;if(a[p>>0]|0)break a;if(!(k<<24>>24)){if(l<<24>>24?(c[o>>2]&1|0)==0:0)break a}else{if((c[n>>2]|0)==1)break a;if(!(c[o>>2]&2))break a}a[r>>0]=0;a[q>>0]=0;Ow(b,d,e,f,g,h);k=a[r>>0]|0;j=k|j;l=a[q>>0]|0;i=l|i;b=b+8|0;}while(b>>>0<m>>>0)}while(0);a[r>>0]=j<<24>>24!=0&1;a[q>>0]=i<<24>>24!=0&1;}return}function Lw(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a:do if(!(Ak(b,c[d+8>>2]|0,g)|0)){if(!(Ak(b,c[d>>2]|0,g)|0)){p=c[b+12>>2]|0;k=b+16+(p<<3)|0;Pw(b+16|0,d,e,f,g);h=b+24|0;if((p|0)<=1)break;b=c[b+8>>2]|0;if((b&2|0)==0?(j=d+36|0,(c[j>>2]|0)!=1):0){if(!(b&1)){b=d+54|0;while(1){if(a[b>>0]|0)break a;if((c[j>>2]|0)==1)break a;Pw(h,d,e,f,g);h=h+8|0;if(h>>>0>=k>>>0)break a}}b=d+24|0;i=d+54|0;while(1){if(a[i>>0]|0)break a;if((c[j>>2]|0)==1?(c[b>>2]|0)==1:0)break a;Pw(h,d,e,f,g);h=h+8|0;if(h>>>0>=k>>>0)break a}}b=d+54|0;while(1){if(a[b>>0]|0)break a;Pw(h,d,e,f,g);h=h+8|0;if(h>>>0>=k>>>0)break a}}if((c[d+16>>2]|0)!=(e|0)?(p=d+20|0,(c[p>>2]|0)!=(e|0)):0){c[d+32>>2]=f;o=d+44|0;if((c[o>>2]|0)!=4){j=b+16+(c[b+12>>2]<<3)|0;k=d+52|0;f=d+53|0;l=d+54|0;m=b+8|0;n=d+24|0;h=0;i=b+16|0;b=0;b:while(1){if(i>>>0>=j>>>0){i=18;break}a[k>>0]=0;a[f>>0]=0;Ow(i,d,e,e,1,g);if(a[l>>0]|0){i=18;break}do if(a[f>>0]|0){if(!(a[k>>0]|0))if(!(c[m>>2]&1)){i=19;break b}else{b=1;break}if((c[n>>2]|0)==1){h=1;i=19;break b}if(!(c[m>>2]&2)){h=1;i=19;break b}else{h=1;b=1;}}while(0);i=i+8|0;}if((i|0)==18)if(b)i=19;else b=4;if((i|0)==19)b=3;c[o>>2]=b;if(h&1)break}c[p>>2]=e;e=d+40|0;c[e>>2]=(c[e>>2]|0)+1;if((c[d+36>>2]|0)!=1)break;if((c[d+24>>2]|0)!=2)break;a[d+54>>0]=1;break}if((f|0)==1)c[d+32>>2]=1;}else Ck(0,d,e,f);while(0);return}function Mw(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;a:do if(!(Ak(b,c[d+8>>2]|0,0)|0)){h=c[b+12>>2]|0;g=b+16+(h<<3)|0;Nw(b+16|0,d,e,f);if((h|0)>1){h=d+54|0;b=b+24|0;do{Nw(b,d,e,f);if(a[h>>0]|0)break a;b=b+8|0;}while(b>>>0<g>>>0)}}else Bk(0,d,e,f);while(0);return}function Nw(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;g=c[a+4>>2]|0;if(d){f=g>>8;if(g&1)f=c[(c[d>>2]|0)+f>>2]|0;}else f=0;a=c[a>>2]|0;$b[c[(c[a>>2]|0)+28>>2]&15](a,b,d+f|0,(g&2|0)==0?2:e);return}function Ow(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,i=0;i=c[a+4>>2]|0;h=i>>8;if(i&1)h=c[(c[e>>2]|0)+h>>2]|0;a=c[a>>2]|0;bc[c[(c[a>>2]|0)+20>>2]&3](a,b,d,e+h|0,(i&2|0)==0?2:f,g);return}function Pw(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;h=c[a+4>>2]|0;g=h>>8;if(h&1)g=c[(c[d>>2]|0)+g>>2]|0;a=c[a>>2]|0;ac[c[(c[a>>2]|0)+24>>2]&7](a,b,d+g|0,(h&2|0)==0?2:e,f);return}function Qw(){return 0}function Rw(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;f=Eb;Eb=Eb+16|0;e=f;c[e>>2]=c[d>>2];a=Pb[c[(c[a>>2]|0)+16>>2]&15](a,b,e)|0;if(a)c[d>>2]=c[e>>2];Eb=f;return a&1|0}function Sw(a){a=a|0;if(!a)a=0;else a=(Ek(a,2128,3296,0)|0)!=0&1;return a|0}function Tw(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=a&65535;e=b&65535;c=A(e,f)|0;d=a>>>16;a=(c>>>16)+(A(e,d)|0)|0;e=b>>>16;b=A(e,f)|0;return (E((a>>>16)+(A(e,d)|0)+(((a&65535)+b|0)>>>16)|0),a+b<<16|c&65535|0)|0}function Uw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;f=c;c=Tw(e,f)|0;a=F()|0;return (E((A(b,f)|0)+(A(d,e)|0)+a|a&0|0),c|0|0)|0}function Vw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;c=a+c>>>0;return (E(b+d+(c>>>0<a>>>0|0)>>>0|0),c|0)|0}function Ww(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;d=b-d-(c>>>0>a>>>0|0)>>>0;return (E(d|0),a-c>>>0|0)|0}function Xw(a){a=a|0;return (a?31-(C(a^a-1)|0)|0:32)|0}function Yw(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;l=a;j=b;k=j;h=d;n=e;i=n;if(!k){g=(f|0)!=0;if(!i){if(g){c[f>>2]=(l>>>0)%(h>>>0);c[f+4>>2]=0;}n=0;f=(l>>>0)/(h>>>0)>>>0;return (E(n|0),f)|0}else{if(!g){n=0;f=0;return (E(n|0),f)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;n=0;f=0;return (E(n|0),f)|0}}g=(i|0)==0;do if(h){if(!g){g=(C(i|0)|0)-(C(k|0)|0)|0;if(g>>>0<=31){m=g+1|0;i=31-g|0;b=g-31>>31;h=m;a=l>>>(m>>>0)&b|k<<i;b=k>>>(m>>>0)&b;g=0;i=l<<i;break}if(!f){n=0;f=0;return (E(n|0),f)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;n=0;f=0;return (E(n|0),f)|0}g=h-1|0;if(g&h|0){i=(C(h|0)|0)+33-(C(k|0)|0)|0;p=64-i|0;m=32-i|0;j=m>>31;o=i-32|0;b=o>>31;h=i;a=m-1>>31&k>>>(o>>>0)|(k<<m|l>>>(i>>>0))&b;b=b&k>>>(i>>>0);g=l<<p&j;i=(k<<p|l>>>(o>>>0))&j|l<<m&i-33>>31;break}if(f|0){c[f>>2]=g&l;c[f+4>>2]=0;}if((h|0)==1){o=j|b&0;p=a|0|0;return (E(o|0),p)|0}else{p=Xw(h|0)|0;o=k>>>(p>>>0)|0;p=k<<32-p|l>>>(p>>>0)|0;return (E(o|0),p)|0}}else{if(g){if(f|0){c[f>>2]=(k>>>0)%(h>>>0);c[f+4>>2]=0;}o=0;p=(k>>>0)/(h>>>0)>>>0;return (E(o|0),p)|0}if(!l){if(f|0){c[f>>2]=0;c[f+4>>2]=(k>>>0)%(i>>>0);}o=0;p=(k>>>0)/(i>>>0)>>>0;return (E(o|0),p)|0}g=i-1|0;if(!(g&i)){if(f|0){c[f>>2]=a|0;c[f+4>>2]=g&k|b&0;}o=0;p=k>>>((Xw(i|0)|0)>>>0);return (E(o|0),p)|0}g=(C(i|0)|0)-(C(k|0)|0)|0;if(g>>>0<=30){b=g+1|0;i=31-g|0;h=b;a=k<<i|l>>>(b>>>0);b=k>>>(b>>>0);g=0;i=l<<i;break}if(!f){o=0;p=0;return (E(o|0),p)|0}c[f>>2]=a|0;c[f+4>>2]=j|b&0;o=0;p=0;return (E(o|0),p)|0}while(0);if(!h){k=i;j=0;i=0;}else{m=d|0|0;l=n|e&0;k=Vw(m|0,l|0,-1,-1)|0;d=F()|0;j=i;i=0;do{e=j;j=g>>>31|j<<1;g=i|g<<1;e=a<<1|e>>>31|0;n=a>>>31|b<<1|0;Ww(k|0,d|0,e|0,n|0)|0;p=F()|0;o=p>>31|((p|0)<0?-1:0)<<1;i=o&1;a=Ww(e|0,n|0,o&m|0,(((p|0)<0?-1:0)>>31|((p|0)<0?-1:0)<<1)&l|0)|0;b=F()|0;h=h-1|0;}while((h|0)!=0);k=j;j=0;}h=0;if(f|0){c[f>>2]=a;c[f+4>>2]=b;}o=(g|0)>>>31|(k|h)<<1|(h<<1|g>>>31)&0|j;p=(g<<1|0>>>31)&-2|i;return (E(o|0),p)|0}function Zw(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Yw(a,b,c,d,0)|0}function _w(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E(b>>>c|0);return a>>>c|(b&(1<<c)-1)<<32-c}E(0);return b>>>c-32|0}function $w(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E(b<<c|(a&(1<<c)-1<<32-c)>>>32-c|0);return a<<c}E(a<<c-32|0);return 0}function ax(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;if((e|0)>=8192){ya(b|0,d|0,e|0)|0;return b|0}h=b|0;g=b+e|0;if((b&3)==(d&3)){while(b&3){if(!e)return h|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0;}e=g&-4|0;f=e-64|0;while((b|0)<=(f|0)){c[b>>2]=c[d>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[b+28>>2]=c[d+28>>2];c[b+32>>2]=c[d+32>>2];c[b+36>>2]=c[d+36>>2];c[b+40>>2]=c[d+40>>2];c[b+44>>2]=c[d+44>>2];c[b+48>>2]=c[d+48>>2];c[b+52>>2]=c[d+52>>2];c[b+56>>2]=c[d+56>>2];c[b+60>>2]=c[d+60>>2];b=b+64|0;d=d+64|0;}while((b|0)<(e|0)){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;}}else{e=g-4|0;while((b|0)<(e|0)){a[b>>0]=a[d>>0]|0;a[b+1>>0]=a[d+1>>0]|0;a[b+2>>0]=a[d+2>>0]|0;a[b+3>>0]=a[d+3>>0]|0;b=b+4|0;d=d+4|0;}}while((b|0)<(g|0)){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;}return h|0}function bx(b,c,d){b=b|0;c=c|0;d=d|0;var e=0;if((c|0)<(b|0)&(b|0)<(c+d|0)){e=b;c=c+d|0;b=b+d|0;while((d|0)>0){b=b-1|0;c=c-1|0;d=d-1|0;a[b>>0]=a[c>>0]|0;}b=e;}else ax(b,c,d)|0;return b|0}function cx(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0;h=b+e|0;d=d&255;if((e|0)>=67){while(b&3){a[b>>0]=d;b=b+1|0;}f=h&-4|0;i=d|d<<8|d<<16|d<<24;g=f-64|0;while((b|0)<=(g|0)){c[b>>2]=i;c[b+4>>2]=i;c[b+8>>2]=i;c[b+12>>2]=i;c[b+16>>2]=i;c[b+20>>2]=i;c[b+24>>2]=i;c[b+28>>2]=i;c[b+32>>2]=i;c[b+36>>2]=i;c[b+40>>2]=i;c[b+44>>2]=i;c[b+48>>2]=i;c[b+52>>2]=i;c[b+56>>2]=i;c[b+60>>2]=i;b=b+64|0;}while((b|0)<(f|0)){c[b>>2]=i;b=b+4|0;}}while((b|0)<(h|0)){a[b>>0]=d;b=b+1|0;}return h-e|0}function dx(a){a=a|0;var b=0,d=0,e=0;e=xa()|0;d=c[i>>2]|0;b=d+a|0;if((a|0)>0&(b|0)<(d|0)|(b|0)<0){Ba(b|0)|0;_(12);return -1}if((b|0)>(e|0))if(!(za(b|0)|0)){_(12);return -1}c[i>>2]=b;return d|0}function ex(a,b){a=a|0;b=b|0;return +Ib[a&7](b|0)}function fx(a,b,c){a=a|0;b=b|0;c=c|0;return +Jb[a&7](b|0,c|0)}function gx(a){a=a|0;return Kb[a&7]()|0}function hx(a,b){a=a|0;b=b|0;return Lb[a&63](b|0)|0}function ix(a,b,c,d){a=a|0;b=b|0;c=+c;d=+d;return Mb[a&3](b|0,+c,+d)|0}function jx(a,b,c,d,e,f,g){a=a|0;b=b|0;c=+c;d=d|0;e=e|0;f=f|0;g=g|0;return Nb[a&1](b|0,+c,d|0,e|0,f|0,g|0)|0}function kx(a,b,c){a=a|0;b=b|0;c=c|0;return Ob[a&63](b|0,c|0)|0}function lx(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return Pb[a&15](b|0,c|0,d|0)|0}function mx(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return Qb[a&15](b|0,c|0,d|0,e|0)|0}function nx(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return Rb[a&7](b|0,c|0,d|0,e|0,f|0)|0}function ox(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;return Sb[a&3](b|0,c|0,d|0,e|0,f|0,g|0)|0}function px(a){a=a|0;Tb[a&3]();}function qx(a,b){a=a|0;b=b|0;Ub[a&127](b|0);}function rx(a,b,c){a=a|0;b=b|0;c=+c;Vb[a&15](b|0,+c);}function sx(a,b,c,d){a=a|0;b=b|0;c=+c;d=+d;Wb[a&1](b|0,+c,+d);}function tx(a,b,c){a=a|0;b=b|0;c=c|0;Xb[a&127](b|0,c|0);}function ux(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;Yb[a&15](b|0,c|0,+d);}function vx(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;Zb[a&31](b|0,c|0,d|0);}function wx(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;_b[a&7](b|0,c|0,d|0,+e);}function xx(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;$b[a&15](b|0,c|0,d|0,e|0);}function yx(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ac[a&7](b|0,c|0,d|0,e|0,f|0);}function zx(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;bc[a&3](b|0,c|0,d|0,e|0,f|0,g|0);}function Ax(a){D(0);return 0.0}function Bx(a,b){D(1);return 0.0}function Cx(){D(2);return 0}function Dx(a){D(3);return 0}function Ex(a,b,c){D(4);return 0}function Fx(a,b,c,d,e,f){D(5);return 0}function Gx(a,b){D(6);return 0}function Hx(a,b,c){D(7);return 0}function Ix(a,b,c,d){D(8);return 0}function Jx(a,b,c,d,e){D(9);return 0}function Kx(a,b,c,d,e,f){D(10);return 0}function Lx(){D(11);}function Mx(){U();}function Nx(a){D(12);}function Ox(a,b){D(13);}function Px(a,b,c){D(14);}function Qx(a,b){D(15);}function Rx(a,b,c){D(16);}function Sx(a,b,c){D(17);}function Tx(a,b,c,d){D(18);}function Ux(a,b,c,d){D(19);}function Vx(a,b,c,d,e){D(20);}function Wx(a,b,c,d,e,f){D(21);}

  // EMSCRIPTEN_END_FUNCS
  var Ib=[Ax,ge,ie,rc,oe,qe,se,ue];var Jb=[Bx,hf,vg,Ng,qh,Bx,Bx,Bx];var Kb=[Cx,Of,ng,rf,Ef,cg,Cx,Cx];var Lb=[Dx,Tc,Fe,th,vw,ff,Mf,Pf,me,nc,oc,pc,mc,jg,lg,mg,og,kc,lc,qc,Lg,Pg,we,Xg,Zg,_g,$g,ye,Ae,hh,pf,sf,sc,Cf,Ff,Gc,ag,dg,jc,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx,Dx];var Mb=[Ex,kf,kh,Ex];var Nb=[Fx,Eh];var Ob=[Gx,km,lm,mm,nm,Mm,Zm,Pn,Qn,Rn,Sn,ss,ts,us,vs,Gt,Qt,Rt,Iu,Ju,Ku,av,bv,Dv,Ev,kd,df,ef,Qf,Sf,Vf,Wf,Xf,rg,tg,ug,tc,Ug,Vg,ah,fh,jh,vf,If,gg,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx,Gx];var Pb=[Hx,uh,_h,wk,Bw,Dw,Iw,wg,wf,nf,Jf,Af,hg,_f,Hx,Hx];var Qb=[Ix,Ec,vh,Fc,Nc,Pc,xf,Lf,ig,Ix,Ix,Ix,Ix,Ix,Ix,Ix];var Rb=[Jx,Rg,Sg,bh,Oc,dh,Qc,Jx];var Sb=[Kx,ch,eh,Kx];var Tb=[Lx,Mx,mk,Lx];var Ub=[Nx,xd,De,yc,Ac,Hc,Ic,Ed,Ce,Cc,Ee,pg,qg,sk,tk,uk,vk,Fk,rm,sm,xm,Em,Im,Pm,an,kn,xn,Vn,no,so,xo,Co,Go,Lo,Ro,vp,zp,Dp,Hp,Lp,Qp,Vp,_p,gq,mq,uq,yq,Gq,Lq,Pq,_q,hr,mr,rr,wr,Br,Hr,Mr,Tr,Yr,bs,is,ys,Es,Os,Us,_s,ct,it,rt,wt,Ct,Jt,Ut,fu,lu,Nu,Su,Wu,ev,iv,mv,qv,uv,Hv,Lv,hw,tw,uw,zw,Aw,Cw,Hw,Jw,gf,Nf,kg,ic,Bd,Kd,Mg,Qg,Yg,ih,wd,qf,Df,bg,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx,Nx];var Vb=[Ox,he,je,Qd,Sd,pe,re,te,ve,Ox,Ox,Ox,Ox,Ox,Ox,Ox];var Wb=[Px,hc];var Xb=[Qx,om,pm,qm,Cm,Dm,Hm,Nm,Om,_m,$m,hn,jn,wn,Tn,Un,mo,ro,wo,Bo,Fo,Ko,Qo,up,yp,Cp,Gp,Kp,Np,Up,Zp,fq,lq,tq,xq,Eq,Fq,Kq,Oq,Yq,Zq,gr,lr,qr,ur,vr,Ar,Gr,Lr,Sr,Xr,as,hs,ws,xs,Ds,Ms,Ns,Ts,Zs,bt,ht,qt,ut,vt,At,Bt,Ht,It,St,Tt,eu,ku,Lu,Mu,Ru,Vu,cv,dv,hv,lv,pv,tv,Fv,Gv,Kv,gw,$d,be,ce,ee,sg,Nd,Yd,Zd,_d,Jg,Kg,Tg,Jc,xe,ze,Be,ph,od,pd,rd,Fh,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx,Qx];var Yb=[Rx,jf,Pd,Bg,Rd,Dg,Og,Cd,Fd,rh,Rx,Rx,Rx,Rx,Rx,Rx];var Zb=[Sx,bf,cf,Rf,Tf,Ld,Md,zg,Wd,Hg,Ig,Wg,gh,tf,lf,mf,Gf,yf,zf,eg,Yf,Zf,Sx,Sx,Sx,Sx,Sx,Sx,Sx,Sx,Sx,Sx];var _b=[Tx,Ag,Cg,nh,oh,Tx,Tx,Tx];var $b=[Ux,zk,Ik,Mw,xg,yg,Ud,Vd,Gg,yd,zd,uf,Hf,fg,Ux,Ux];var ac=[Vx,yk,Hk,Lw,Eg,Fg,lh,mh];var bc=[Wx,xk,Gk,Kw];return {__ZSt18uncaught_exceptionv:Xj,___cxa_can_catch:Rw,___cxa_is_pointer_type:Sw,___embind_register_native_and_builtin_types:ii,___getTypeName:Wj,___muldi3:Uw,___udivdi3:Zw,_bitshift64Lshr:_w,_bitshift64Shl:$w,_emscripten_replace_memory:Hb,_free:ik,_i64Add:Vw,_i64Subtract:Ww,_malloc:hk,_memcpy:ax,_memmove:bx,_memset:cx,_sbrk:dx,dynCall_di:ex,dynCall_dii:fx,dynCall_i:gx,dynCall_ii:hx,dynCall_iidd:ix,dynCall_iidiiii:jx,dynCall_iii:kx,dynCall_iiii:lx,dynCall_iiiii:mx,dynCall_iiiiii:nx,dynCall_iiiiiii:ox,dynCall_v:px,dynCall_vi:qx,dynCall_vid:rx,dynCall_vidd:sx,dynCall_vii:tx,dynCall_viid:ux,dynCall_viii:vx,dynCall_viiid:wx,dynCall_viiii:xx,dynCall_viiiii:yx,dynCall_viiiiii:zx,establishStackSpace:gc,globalCtors:cc,stackAlloc:dc,stackRestore:fc,stackSave:ec}})


  // EMSCRIPTEN_END_ASM
  (asmGlobalArg,asmLibraryArg,buffer);var __ZSt18uncaught_exceptionv=Module["__ZSt18uncaught_exceptionv"]=asm["__ZSt18uncaught_exceptionv"];var ___cxa_can_catch=Module["___cxa_can_catch"]=asm["___cxa_can_catch"];var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=asm["___cxa_is_pointer_type"];var ___embind_register_native_and_builtin_types=Module["___embind_register_native_and_builtin_types"]=asm["___embind_register_native_and_builtin_types"];var ___getTypeName=Module["___getTypeName"]=asm["___getTypeName"];var ___muldi3=Module["___muldi3"]=asm["___muldi3"];var ___udivdi3=Module["___udivdi3"]=asm["___udivdi3"];var _bitshift64Lshr=Module["_bitshift64Lshr"]=asm["_bitshift64Lshr"];var _bitshift64Shl=Module["_bitshift64Shl"]=asm["_bitshift64Shl"];var _emscripten_replace_memory=Module["_emscripten_replace_memory"]=asm["_emscripten_replace_memory"];var _free=Module["_free"]=asm["_free"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _i64Subtract=Module["_i64Subtract"]=asm["_i64Subtract"];var _malloc=Module["_malloc"]=asm["_malloc"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _memmove=Module["_memmove"]=asm["_memmove"];var _memset=Module["_memset"]=asm["_memset"];var _sbrk=Module["_sbrk"]=asm["_sbrk"];var establishStackSpace=Module["establishStackSpace"]=asm["establishStackSpace"];var globalCtors=Module["globalCtors"]=asm["globalCtors"];var stackAlloc=Module["stackAlloc"]=asm["stackAlloc"];var stackRestore=Module["stackRestore"]=asm["stackRestore"];var stackSave=Module["stackSave"]=asm["stackSave"];var dynCall_di=Module["dynCall_di"]=asm["dynCall_di"];var dynCall_dii=Module["dynCall_dii"]=asm["dynCall_dii"];var dynCall_i=Module["dynCall_i"]=asm["dynCall_i"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_iidd=Module["dynCall_iidd"]=asm["dynCall_iidd"];var dynCall_iidiiii=Module["dynCall_iidiiii"]=asm["dynCall_iidiiii"];var dynCall_iii=Module["dynCall_iii"]=asm["dynCall_iii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_iiiii=Module["dynCall_iiiii"]=asm["dynCall_iiiii"];var dynCall_iiiiii=Module["dynCall_iiiiii"]=asm["dynCall_iiiiii"];var dynCall_iiiiiii=Module["dynCall_iiiiiii"]=asm["dynCall_iiiiiii"];var dynCall_v=Module["dynCall_v"]=asm["dynCall_v"];var dynCall_vi=Module["dynCall_vi"]=asm["dynCall_vi"];var dynCall_vid=Module["dynCall_vid"]=asm["dynCall_vid"];var dynCall_vidd=Module["dynCall_vidd"]=asm["dynCall_vidd"];var dynCall_vii=Module["dynCall_vii"]=asm["dynCall_vii"];var dynCall_viid=Module["dynCall_viid"]=asm["dynCall_viid"];var dynCall_viii=Module["dynCall_viii"]=asm["dynCall_viii"];var dynCall_viiid=Module["dynCall_viiid"]=asm["dynCall_viiid"];var dynCall_viiii=Module["dynCall_viiii"]=asm["dynCall_viiii"];var dynCall_viiiii=Module["dynCall_viiiii"]=asm["dynCall_viiiii"];var dynCall_viiiiii=Module["dynCall_viiiiii"]=asm["dynCall_viiiiii"];Module["asm"]=asm;if(memoryInitializer){if(!isDataURI(memoryInitializer)){memoryInitializer=locateFile(memoryInitializer);}{addRunDependency();var applyMemoryInitializer=function(data){if(data.byteLength)data=new Uint8Array(data);HEAPU8.set(data,GLOBAL_BASE);if(Module["memoryInitializerRequest"])delete Module["memoryInitializerRequest"].response;removeRunDependency();};var doBrowserLoad=function(){readAsync(memoryInitializer,applyMemoryInitializer,function(){throw "could not load memory initializer "+memoryInitializer});};var memoryInitializerBytes=tryParseAsDataURI(memoryInitializer);if(memoryInitializerBytes){applyMemoryInitializer(memoryInitializerBytes.buffer);}else if(Module["memoryInitializerRequest"]){var useRequest=function(){var request=Module["memoryInitializerRequest"];var response=request.response;if(request.status!==200&&request.status!==0){var data=tryParseAsDataURI(Module["memoryInitializerRequestURL"]);if(data){response=data.buffer;}else{console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: "+request.status+", retrying "+memoryInitializer);doBrowserLoad();return}}applyMemoryInitializer(response);};if(Module["memoryInitializerRequest"].response){setTimeout(useRequest,0);}else{Module["memoryInitializerRequest"].addEventListener("load",useRequest);}}else{doBrowserLoad();}}}var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else{doRun();}}Module["run"]=run;function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what+="";out(what);err(what);ABORT=true;throw "abort("+what+"). Build with -s ASSERTIONS=1 for more info."}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}noExitRuntime=true;run();

    return Module;
  }

  var clipper = { init: init$1 };

  var jsAngusjClipperjsWeb = createCommonjsModule(function (module, exports) {
  var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  };
  Object.defineProperty(exports, "__esModule", { value: true });


  exports.ClipperError = ClipperError_1.ClipperError;


  exports.ClipType = enums.ClipType;
  exports.EndType = enums.EndType;
  exports.JoinType = enums.JoinType;
  exports.NativeClipperLibLoadedFormat = enums.NativeClipperLibLoadedFormat;
  exports.NativeClipperLibRequestedFormat = enums.NativeClipperLibRequestedFormat;
  exports.PointInPolygonResult = enums.PointInPolygonResult;
  exports.PolyFillType = enums.PolyFillType;



  exports.PolyNode = PolyNode_1.PolyNode;

  exports.PolyTree = PolyTree_1.PolyTree;
  var wasmModule;
  var asmJsModule;
  /**
   * A wrapper for the Native Clipper Library instance with all the operations available.
   */
  var ClipperLibWrapper = /** @class */ (function () {
      /**
       * Internal constructor. Use loadNativeClipperLibInstanceAsync instead.
       *
       * @param instance
       * @param format
       */
      function ClipperLibWrapper(instance, format) {
          this.format = format;
          this.instance = instance;
      }
      /**
       * Performs a polygon clipping (boolean) operation, returning the resulting Paths or throwing an error if failed.
       *
       * The solution parameter in this case is a Paths or PolyTree structure. The Paths structure is simpler than the PolyTree structure. Because of this it is
       * quicker to populate and hence clipping performance is a little better (it's roughly 10% faster). However, the PolyTree data structure provides more
       * information about the returned paths which may be important to users. Firstly, the PolyTree structure preserves nested parent-child polygon relationships
       * (ie outer polygons owning/containing holes and holes owning/containing other outer polygons etc). Also, only the PolyTree structure can differentiate
       * between open and closed paths since each PolyNode has an IsOpen property. (The Path structure has no member indicating whether it's open or closed.)
       * For this reason, when open paths are passed to a Clipper object, the user must use a PolyTree object as the solution parameter, otherwise an exception
       * will be raised.
       *
       * When a PolyTree object is used in a clipping operation on open paths, two ancilliary functions have been provided to quickly separate out open and
       * closed paths from the solution - OpenPathsFromPolyTree and ClosedPathsFromPolyTree. PolyTreeToPaths is also available to convert path data to a Paths
       * structure (irrespective of whether they're open or closed).
       *
       * There are several things to note about the solution paths returned:
       * - they aren't in any specific order
       * - they should never overlap or be self-intersecting (but see notes on rounding)
       * - holes will be oriented opposite outer polygons
       * - the solution fill type can be considered either EvenOdd or NonZero since it will comply with either filling rule
       * - polygons may rarely share a common edge (though this is now very rare as of version 6)
       *
       * @param params - clipping operation data
       * @return {Paths} - the resulting Paths.
       */
      ClipperLibWrapper.prototype.clipToPaths = function (params) {
          return clipFunctions.clipToPaths(this.instance, params);
      };
      /**
       * Performs a polygon clipping (boolean) operation, returning the resulting PolyTree or throwing an error if failed.
       *
       * The solution parameter in this case is a Paths or PolyTree structure. The Paths structure is simpler than the PolyTree structure. Because of this it is
       * quicker to populate and hence clipping performance is a little better (it's roughly 10% faster). However, the PolyTree data structure provides more
       * information about the returned paths which may be important to users. Firstly, the PolyTree structure preserves nested parent-child polygon relationships
       * (ie outer polygons owning/containing holes and holes owning/containing other outer polygons etc). Also, only the PolyTree structure can differentiate
       * between open and closed paths since each PolyNode has an IsOpen property. (The Path structure has no member indicating whether it's open or closed.)
       * For this reason, when open paths are passed to a Clipper object, the user must use a PolyTree object as the solution parameter, otherwise an exception
       * will be raised.
       *
       * When a PolyTree object is used in a clipping operation on open paths, two ancilliary functions have been provided to quickly separate out open and
       * closed paths from the solution - OpenPathsFromPolyTree and ClosedPathsFromPolyTree. PolyTreeToPaths is also available to convert path data to a Paths
       * structure (irrespective of whether they're open or closed).
       *
       * There are several things to note about the solution paths returned:
       * - they aren't in any specific order
       * - they should never overlap or be self-intersecting (but see notes on rounding)
       * - holes will be oriented opposite outer polygons
       * - the solution fill type can be considered either EvenOdd or NonZero since it will comply with either filling rule
       * - polygons may rarely share a common edge (though this is now very rare as of version 6)
       *
       * @param params - clipping operation data
       * @return {PolyTree} - the resulting PolyTree or undefined.
       */
      ClipperLibWrapper.prototype.clipToPolyTree = function (params) {
          return clipFunctions.clipToPolyTree(this.instance, params);
      };
      /**
       * Performs a polygon offset operation, returning the resulting Paths or undefined if failed.
       *
       * This method encapsulates the process of offsetting (inflating/deflating) both open and closed paths using a number of different join types
       * and end types.
       *
       * Preconditions for offsetting:
       * 1. The orientations of closed paths must be consistent such that outer polygons share the same orientation, and any holes have the opposite orientation
       * (ie non-zero filling). Open paths must be oriented with closed outer polygons.
       * 2. Polygons must not self-intersect.
       *
       * Limitations:
       * When offsetting, small artefacts may appear where polygons overlap. To avoid these artefacts, offset overlapping polygons separately.
       *
       * @param params - offset operation params
       * @return {Paths|undefined} - the resulting Paths or undefined if failed.
       */
      ClipperLibWrapper.prototype.offsetToPaths = function (params) {
          return offsetFunctions.offsetToPaths(this.instance, params);
      };
      /**
       * Performs a polygon offset operation, returning the resulting PolyTree or undefined if failed.
       *
       * This method encapsulates the process of offsetting (inflating/deflating) both open and closed paths using a number of different join types
       * and end types.
       *
       * Preconditions for offsetting:
       * 1. The orientations of closed paths must be consistent such that outer polygons share the same orientation, and any holes have the opposite orientation
       * (ie non-zero filling). Open paths must be oriented with closed outer polygons.
       * 2. Polygons must not self-intersect.
       *
       * Limitations:
       * When offsetting, small artefacts may appear where polygons overlap. To avoid these artefacts, offset overlapping polygons separately.
       *
       * @param params - offset operation params
       * @return {PolyTree|undefined} - the resulting PolyTree or undefined if failed.
       */
      ClipperLibWrapper.prototype.offsetToPolyTree = function (params) {
          return offsetFunctions.offsetToPolyTree(this.instance, params);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * This function returns the area of the supplied polygon. It's assumed that the path is closed and does not self-intersect. Depending on orientation,
       * this value may be positive or negative. If Orientation is true, then the area will be positive and conversely, if Orientation is false, then the
       * area will be negative.
       *
       * @param path - The path
       * @return {number} - Area
       */
      ClipperLibWrapper.prototype.area = function (path) {
          return functions.area(path);
      };
      /**
       * Removes vertices:
       * - that join co-linear edges, or join edges that are almost co-linear (such that if the vertex was moved no more than the specified distance the edges
       * would be co-linear)
       * - that are within the specified distance of an adjacent vertex
       * - that are within the specified distance of a semi-adjacent vertex together with their out-lying vertices
       *
       * Vertices are semi-adjacent when they are separated by a single (out-lying) vertex.
       *
       * The distance parameter's default value is approximately âˆš2 so that a vertex will be removed when adjacent or semi-adjacent vertices having their
       * corresponding X and Y coordinates differing by no more than 1 unit. (If the egdes are semi-adjacent the out-lying vertex will be removed too.)
       *
       * @param path - The path to clean
       * @param distance - How close points need to be before they are cleaned
       * @return {Path} - The cleaned path
       */
      ClipperLibWrapper.prototype.cleanPolygon = function (path, distance) {
          if (distance === void 0) { distance = 1.1415; }
          return functions.cleanPolygon(this.instance, path, distance);
      };
      /**
       * Removes vertices:
       * - that join co-linear edges, or join edges that are almost co-linear (such that if the vertex was moved no more than the specified distance the edges
       * would be co-linear)
       * - that are within the specified distance of an adjacent vertex
       * - that are within the specified distance of a semi-adjacent vertex together with their out-lying vertices
       *
       * Vertices are semi-adjacent when they are separated by a single (out-lying) vertex.
       *
       * The distance parameter's default value is approximately âˆš2 so that a vertex will be removed when adjacent or semi-adjacent vertices having their
       * corresponding X and Y coordinates differing by no more than 1 unit. (If the egdes are semi-adjacent the out-lying vertex will be removed too.)
       *
       * @param paths - The paths to clean
       * @param distance - How close points need to be before they are cleaned
       * @return {Paths} - The cleaned paths
       */
      ClipperLibWrapper.prototype.cleanPolygons = function (paths, distance) {
          if (distance === void 0) { distance = 1.1415; }
          return functions.cleanPolygons(this.instance, paths, distance);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * This function filters out open paths from the PolyTree structure and returns only closed paths in a Paths structure.
       *
       * @param polyTree
       * @return {Paths}
       */
      ClipperLibWrapper.prototype.closedPathsFromPolyTree = function (polyTree) {
          return functions.closedPathsFromPolyTree(polyTree);
      };
      /**
       *  Minkowski Difference is performed by subtracting each point in a polygon from the set of points in an open or closed path. A key feature of Minkowski
       *  Difference is that when it's applied to two polygons, the resulting polygon will contain the coordinate space origin whenever the two polygons touch or
       *  overlap. (This function is often used to determine when polygons collide.)
       *
       * @param poly1
       * @param poly2
       * @return {Paths}
       */
      ClipperLibWrapper.prototype.minkowskiDiff = function (poly1, poly2) {
          return functions.minkowskiDiff(this.instance, poly1, poly2);
      };
      /**
       * Minkowski Addition is performed by adding each point in a polygon 'pattern' to the set of points in an open or closed path. The resulting polygon
       * (or polygons) defines the region that the 'pattern' would pass over in moving from the beginning to the end of the 'path'.
       *
       * @param pattern
       * @param path
       * @param pathIsClosed
       * @return {Paths}
       */
      ClipperLibWrapper.prototype.minkowskiSumPath = function (pattern, path, pathIsClosed) {
          return functions.minkowskiSumPath(this.instance, pattern, path, pathIsClosed);
      };
      /**
       * Minkowski Addition is performed by adding each point in a polygon 'pattern' to the set of points in an open or closed path. The resulting polygon
       * (or polygons) defines the region that the 'pattern' would pass over in moving from the beginning to the end of the 'path'.
       *
       * @param pattern
       * @param paths
       * @param pathIsClosed
       * @return {Paths}
       */
      ClipperLibWrapper.prototype.minkowskiSumPaths = function (pattern, paths, pathIsClosed) {
          return functions.minkowskiSumPaths(this.instance, pattern, paths, pathIsClosed);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * This function filters out closed paths from the PolyTree structure and returns only open paths in a Paths structure.
       *
       * @param polyTree
       * @return {ReadonlyPath[]}
       */
      ClipperLibWrapper.prototype.openPathsFromPolyTree = function (polyTree) {
          return functions.openPathsFromPolyTree(polyTree);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * Orientation is only important to closed paths. Given that vertices are declared in a specific order, orientation refers to the direction (clockwise or
       * counter-clockwise) that these vertices progress around a closed path.
       *
       * Orientation is also dependent on axis direction:
       * - On Y-axis positive upward displays, orientation will return true if the polygon's orientation is counter-clockwise.
       * - On Y-axis positive downward displays, orientation will return true if the polygon's orientation is clockwise.
       *
       * Notes:
       * - Self-intersecting polygons have indeterminate orientations in which case this function won't return a meaningful value.
       * - The majority of 2D graphic display libraries (eg GDI, GDI+, XLib, Cairo, AGG, Graphics32) and even the SVG file format have their coordinate origins
       * at the top-left corner of their respective viewports with their Y axes increasing downward. However, some display libraries (eg Quartz, OpenGL) have their
       * coordinate origins undefined or in the classic bottom-left position with their Y axes increasing upward.
       * - For Non-Zero filled polygons, the orientation of holes must be opposite that of outer polygons.
       * - For closed paths (polygons) in the solution returned by the clip method, their orientations will always be true for outer polygons and false
       * for hole polygons (unless the reverseSolution property has been enabled).
       *
       * @param path - Path
       * @return {boolean}
       */
      ClipperLibWrapper.prototype.orientation = function (path) {
          return functions.orientation(path);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * Returns PointInPolygonResult.Outside when false, PointInPolygonResult.OnBoundary when point is on poly and PointInPolygonResult.Inside when point is in
       * poly.
       *
       * It's assumed that 'poly' is closed and does not self-intersect.
       *
       * @param point
       * @param path
       * @return {PointInPolygonResult}
       */
      ClipperLibWrapper.prototype.pointInPolygon = function (point, path) {
          return functions.pointInPolygon(point, path);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * This function converts a PolyTree structure into a Paths structure.
       *
       * @param polyTree
       * @return {Paths}
       */
      ClipperLibWrapper.prototype.polyTreeToPaths = function (polyTree) {
          return functions.polyTreeToPaths(polyTree);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * Reverses the vertex order (and hence orientation) in the specified path.
       *
       * @param path - Path to reverse, which gets overwritten rather than copied
       */
      ClipperLibWrapper.prototype.reversePath = function (path) {
          functions.reversePath(path);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * Reverses the vertex order (and hence orientation) in each contained path.
       *
       * @param paths - Paths to reverse, which get overwritten rather than copied
       */
      ClipperLibWrapper.prototype.reversePaths = function (paths) {
          functions.reversePaths(paths);
      };
      /**
       * Removes self-intersections from the supplied polygon (by performing a boolean union operation using the nominated PolyFillType).
       * Polygons with non-contiguous duplicate vertices (ie 'touching') will be split into two polygons.
       *
       * Note: There's currently no guarantee that polygons will be strictly simple since 'simplifying' is still a work in progress.
       *
       * @param path
       * @param fillType
       * @return {Paths} - The solution
       */
      ClipperLibWrapper.prototype.simplifyPolygon = function (path, fillType) {
          if (fillType === void 0) { fillType = enums.PolyFillType.EvenOdd; }
          return functions.simplifyPolygon(this.instance, path, fillType);
      };
      /**
       * Removes self-intersections from the supplied polygons (by performing a boolean union operation using the nominated PolyFillType).
       * Polygons with non-contiguous duplicate vertices (ie 'vertices are touching') will be split into two polygons.
       *
       * Note: There's currently no guarantee that polygons will be strictly simple since 'simplifying' is still a work in progress.
       *
       * @param paths
       * @param fillType
       * @return {Paths} - The solution
       */
      ClipperLibWrapper.prototype.simplifyPolygons = function (paths, fillType) {
          if (fillType === void 0) { fillType = enums.PolyFillType.EvenOdd; }
          return functions.simplifyPolygons(this.instance, paths, fillType);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * Scales a path by multiplying all its points by a number and then rounding them.
       *
       * @param path - Path to scale
       * @param scale - Scale multiplier
       * @return {Path} - The scaled path
       */
      ClipperLibWrapper.prototype.scalePath = function (path, scale) {
          return functions.scalePath(path, scale);
      };
      //noinspection JSMethodCanBeStatic
      /**
       * Scales all inner paths by multiplying all its points by a number and then rounding them.
       *
       * @param paths - Paths to scale
       * @param scale - Scale multiplier
       * @return {Paths} - The scaled paths
       */
      ClipperLibWrapper.prototype.scalePaths = function (paths, scale) {
          return functions.scalePaths(paths, scale);
      };
      /**
       * Max coordinate value (both positive and negative).
       */
      ClipperLibWrapper.hiRange = constants.hiRange;
      return ClipperLibWrapper;
  }());
  exports.ClipperLibWrapper = ClipperLibWrapper;
  /**
   * Asynchronously tries to load a new native instance of the clipper library to be shared across all method invocations.
   *
   * @param format - Format to load, either WasmThenAsmJs, WasmOnly or AsmJsOnly.
   * @return {Promise<ClipperLibWrapper>} - Promise that resolves with the wrapper instance.
   */
  exports.loadNativeClipperLibInstanceAsync = function (format) { return __awaiter(void 0, void 0, void 0, function () {
      function getModuleAsync(initModule) {
          return new Promise(function (resolve, reject) {
              var finalModule;
              //noinspection JSUnusedLocalSymbols
              var moduleOverrides = {
                  noExitRuntime: true,
                  preRun: function () {
                      if (finalModule) {
                          resolve(finalModule);
                      }
                      else {
                          setTimeout(function () {
                              resolve(finalModule);
                          }, 1);
                      }
                  },
                  quit: function (code, err) {
                      reject(err);
                  }
              };
              finalModule = initModule(moduleOverrides);
          });
      }
      var tryWasm, tryAsmJs, initModule, err_1, initModule, err_2;
      return __generator(this, function (_a) {
          switch (_a.label) {
              case 0:
                  switch (format) {
                      case enums.NativeClipperLibRequestedFormat.WasmWithAsmJsFallback:
                          tryWasm = true;
                          tryAsmJs = true;
                          break;
                      case enums.NativeClipperLibRequestedFormat.WasmOnly:
                          tryWasm = true;
                          tryAsmJs = false;
                          break;
                      case enums.NativeClipperLibRequestedFormat.AsmJsOnly:
                          tryWasm = false;
                          tryAsmJs = true;
                          break;
                      default:
                          throw new ClipperError_1.ClipperError("unknown native clipper format");
                  }
                  if (!tryWasm) return [3 /*break*/, 7];
                  if (!(wasmModule instanceof Error)) return [3 /*break*/, 1];
                  return [3 /*break*/, 7];
              case 1:
                  if (!(wasmModule === undefined)) return [3 /*break*/, 6];
                  _a.label = 2;
              case 2:
                  _a.trys.push([2, 4, , 5]);
                  initModule = clipperWasm.init;
                  return [4 /*yield*/, getModuleAsync(initModule)];
              case 3:
                  wasmModule = _a.sent();
                  return [2 /*return*/, new ClipperLibWrapper(wasmModule, enums.NativeClipperLibLoadedFormat.Wasm)];
              case 4:
                  err_1 = _a.sent();
                  wasmModule = err_1;
                  return [3 /*break*/, 5];
              case 5: return [3 /*break*/, 7];
              case 6: return [2 /*return*/, new ClipperLibWrapper(wasmModule, enums.NativeClipperLibLoadedFormat.Wasm)];
              case 7:
                  if (!tryAsmJs) return [3 /*break*/, 14];
                  if (!(asmJsModule instanceof Error)) return [3 /*break*/, 8];
                  return [3 /*break*/, 14];
              case 8:
                  if (!(asmJsModule === undefined)) return [3 /*break*/, 13];
                  _a.label = 9;
              case 9:
                  _a.trys.push([9, 11, , 12]);
                  initModule = clipper.init;
                  return [4 /*yield*/, getModuleAsync(initModule)];
              case 10:
                  asmJsModule = _a.sent();
                  return [2 /*return*/, new ClipperLibWrapper(asmJsModule, enums.NativeClipperLibLoadedFormat.AsmJs)];
              case 11:
                  err_2 = _a.sent();
                  asmJsModule = err_2;
                  return [3 /*break*/, 12];
              case 12: return [3 /*break*/, 14];
              case 13: return [2 /*return*/, new ClipperLibWrapper(asmJsModule, enums.NativeClipperLibLoadedFormat.AsmJs)];
              case 14: throw new ClipperError_1.ClipperError("could not load native clipper in the desired format");
          }
      });
  }); };

  });

  unwrapExports(jsAngusjClipperjsWeb);
  var jsAngusjClipperjsWeb_1 = jsAngusjClipperjsWeb.ClipperError;
  var jsAngusjClipperjsWeb_2 = jsAngusjClipperjsWeb.ClipType;
  var jsAngusjClipperjsWeb_3 = jsAngusjClipperjsWeb.EndType;
  var jsAngusjClipperjsWeb_4 = jsAngusjClipperjsWeb.JoinType;
  var jsAngusjClipperjsWeb_5 = jsAngusjClipperjsWeb.NativeClipperLibLoadedFormat;
  var jsAngusjClipperjsWeb_6 = jsAngusjClipperjsWeb.NativeClipperLibRequestedFormat;
  var jsAngusjClipperjsWeb_7 = jsAngusjClipperjsWeb.PointInPolygonResult;
  var jsAngusjClipperjsWeb_8 = jsAngusjClipperjsWeb.PolyFillType;
  var jsAngusjClipperjsWeb_9 = jsAngusjClipperjsWeb.PolyNode;
  var jsAngusjClipperjsWeb_10 = jsAngusjClipperjsWeb.PolyTree;
  var jsAngusjClipperjsWeb_11 = jsAngusjClipperjsWeb.ClipperLibWrapper;
  var jsAngusjClipperjsWeb_12 = jsAngusjClipperjsWeb.loadNativeClipperLibInstanceAsync;

  const sources = new Map();

  // Note: later additions will be used in preference to earlier additions.
  // This will allow overriding defective or unavailable sources.
  const addSource = (path, source) => {
    if (sources.has(path)) {
      sources.get(path).unshift(source);
    } else {
      sources.set(path, [source]);
    }
  };

  const getSources = (path) => {
    if (sources.has(path)) {
      return sources.get(path);
    } else {
      return [];
    }
  };

  // Inlined browser-or-node@1.2.1 due to es6 importing issue.

  const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

  /* global window self */

  const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

  /* eslint-disable no-restricted-globals */
  const isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';
  /* eslint-enable no-restricted-globals */

  const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

  const tasks = [];

  // Add task to complete before using system.
  // Note: These are expected to be idempotent.
  const onBoot = (op) => {
    tasks.push(op);
  };

  // Execute tasks to complete before using system.
  const boot = async () => {
    for (const task of tasks) {
      await task();
    }
  };

  const emitted = [];

  const emit$1 = (value) => emitted.push(value);

  // When base is undefined the persistent filesystem is disabled.
  let base;

  const getBase = () => base;

  const qualifyPath = (path = '', project) => {
    if (project !== undefined) {
      return `jsxcad/${project}/${path}`;
    } else if (base !== undefined) {
      return `jsxcad/${base}${path}`;
    } else {
      return `jsxcad//${path}`;
    }
  };

  const setupFilesystem = ({ fileBase }) => {
    // A prefix used to partition the persistent filesystem for multiple projects.
    if (fileBase !== undefined) {
      if (fileBase.endsWith('/')) {
        base = fileBase;
      } else {
        base = `${fileBase}/`;
      }
    }
  };

  const getFilesystem = () => {
    if (base !== undefined) {
      const [filesystem] = base.split('/');
      return filesystem;
    }
  };

  var require$$0 = {};

  var fs = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': require$$0
  });

  const files = new Map();
  const fileCreationWatchers = new Set();

  const getFile = async (options, unqualifiedPath) => {
    if (typeof unqualifiedPath !== 'string') {
      throw Error(`die: ${JSON.stringify(unqualifiedPath)}`);
    }
    const path = qualifyPath(unqualifiedPath);
    let file = files.get(path);
    if (file === undefined) {
      file = { path: unqualifiedPath, watchers: new Set(), storageKey: path };
      files.set(path, file);
      for (const watcher of fileCreationWatchers) {
        await watcher(options, file);
      }
    }
    return file;
  };

  var localforage = createCommonjsModule(function (module, exports) {
  /*!
      localForage -- Offline Storage, Improved
      Version 1.7.3
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  */
  (function(f){{module.exports=f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire=="function"&&commonjsRequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire=="function"&&commonjsRequire;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
  (function (global){
  var Mutation = global.MutationObserver || global.WebKitMutationObserver;

  var scheduleDrain;

  {
    if (Mutation) {
      var called = 0;
      var observer = new Mutation(nextTick);
      var element = global.document.createTextNode('');
      observer.observe(element, {
        characterData: true
      });
      scheduleDrain = function () {
        element.data = (called = ++called % 2);
      };
    } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
      var channel = new global.MessageChannel();
      channel.port1.onmessage = nextTick;
      scheduleDrain = function () {
        channel.port2.postMessage(0);
      };
    } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
      scheduleDrain = function () {

        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
        var scriptEl = global.document.createElement('script');
        scriptEl.onreadystatechange = function () {
          nextTick();

          scriptEl.onreadystatechange = null;
          scriptEl.parentNode.removeChild(scriptEl);
          scriptEl = null;
        };
        global.document.documentElement.appendChild(scriptEl);
      };
    } else {
      scheduleDrain = function () {
        setTimeout(nextTick, 0);
      };
    }
  }

  var draining;
  var queue = [];
  //named nextTick for less confusing stack traces
  function nextTick() {
    draining = true;
    var i, oldQueue;
    var len = queue.length;
    while (len) {
      oldQueue = queue;
      queue = [];
      i = -1;
      while (++i < len) {
        oldQueue[i]();
      }
      len = queue.length;
    }
    draining = false;
  }

  module.exports = immediate;
  function immediate(task) {
    if (queue.push(task) === 1 && !draining) {
      scheduleDrain();
    }
  }

  }).call(this,typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  },{}],2:[function(_dereq_,module,exports){
  var immediate = _dereq_(1);

  /* istanbul ignore next */
  function INTERNAL() {}

  var handlers = {};

  var REJECTED = ['REJECTED'];
  var FULFILLED = ['FULFILLED'];
  var PENDING = ['PENDING'];

  module.exports = Promise;

  function Promise(resolver) {
    if (typeof resolver !== 'function') {
      throw new TypeError('resolver must be a function');
    }
    this.state = PENDING;
    this.queue = [];
    this.outcome = void 0;
    if (resolver !== INTERNAL) {
      safelyResolveThenable(this, resolver);
    }
  }

  Promise.prototype["catch"] = function (onRejected) {
    return this.then(null, onRejected);
  };
  Promise.prototype.then = function (onFulfilled, onRejected) {
    if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
      typeof onRejected !== 'function' && this.state === REJECTED) {
      return this;
    }
    var promise = new this.constructor(INTERNAL);
    if (this.state !== PENDING) {
      var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
      unwrap(promise, resolver, this.outcome);
    } else {
      this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
    }

    return promise;
  };
  function QueueItem(promise, onFulfilled, onRejected) {
    this.promise = promise;
    if (typeof onFulfilled === 'function') {
      this.onFulfilled = onFulfilled;
      this.callFulfilled = this.otherCallFulfilled;
    }
    if (typeof onRejected === 'function') {
      this.onRejected = onRejected;
      this.callRejected = this.otherCallRejected;
    }
  }
  QueueItem.prototype.callFulfilled = function (value) {
    handlers.resolve(this.promise, value);
  };
  QueueItem.prototype.otherCallFulfilled = function (value) {
    unwrap(this.promise, this.onFulfilled, value);
  };
  QueueItem.prototype.callRejected = function (value) {
    handlers.reject(this.promise, value);
  };
  QueueItem.prototype.otherCallRejected = function (value) {
    unwrap(this.promise, this.onRejected, value);
  };

  function unwrap(promise, func, value) {
    immediate(function () {
      var returnValue;
      try {
        returnValue = func(value);
      } catch (e) {
        return handlers.reject(promise, e);
      }
      if (returnValue === promise) {
        handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
      } else {
        handlers.resolve(promise, returnValue);
      }
    });
  }

  handlers.resolve = function (self, value) {
    var result = tryCatch(getThen, value);
    if (result.status === 'error') {
      return handlers.reject(self, result.value);
    }
    var thenable = result.value;

    if (thenable) {
      safelyResolveThenable(self, thenable);
    } else {
      self.state = FULFILLED;
      self.outcome = value;
      var i = -1;
      var len = self.queue.length;
      while (++i < len) {
        self.queue[i].callFulfilled(value);
      }
    }
    return self;
  };
  handlers.reject = function (self, error) {
    self.state = REJECTED;
    self.outcome = error;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callRejected(error);
    }
    return self;
  };

  function getThen(obj) {
    // Make sure we only access the accessor once as required by the spec
    var then = obj && obj.then;
    if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
      return function appyThen() {
        then.apply(obj, arguments);
      };
    }
  }

  function safelyResolveThenable(self, thenable) {
    // Either fulfill, reject or reject with error
    var called = false;
    function onError(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.reject(self, value);
    }

    function onSuccess(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.resolve(self, value);
    }

    function tryToUnwrap() {
      thenable(onSuccess, onError);
    }

    var result = tryCatch(tryToUnwrap);
    if (result.status === 'error') {
      onError(result.value);
    }
  }

  function tryCatch(func, value) {
    var out = {};
    try {
      out.value = func(value);
      out.status = 'success';
    } catch (e) {
      out.status = 'error';
      out.value = e;
    }
    return out;
  }

  Promise.resolve = resolve;
  function resolve(value) {
    if (value instanceof this) {
      return value;
    }
    return handlers.resolve(new this(INTERNAL), value);
  }

  Promise.reject = reject;
  function reject(reason) {
    var promise = new this(INTERNAL);
    return handlers.reject(promise, reason);
  }

  Promise.all = all;
  function all(iterable) {
    var self = this;
    if (Object.prototype.toString.call(iterable) !== '[object Array]') {
      return this.reject(new TypeError('must be an array'));
    }

    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }

    var values = new Array(len);
    var resolved = 0;
    var i = -1;
    var promise = new this(INTERNAL);

    while (++i < len) {
      allResolver(iterable[i], i);
    }
    return promise;
    function allResolver(value, i) {
      self.resolve(value).then(resolveFromAll, function (error) {
        if (!called) {
          called = true;
          handlers.reject(promise, error);
        }
      });
      function resolveFromAll(outValue) {
        values[i] = outValue;
        if (++resolved === len && !called) {
          called = true;
          handlers.resolve(promise, values);
        }
      }
    }
  }

  Promise.race = race;
  function race(iterable) {
    var self = this;
    if (Object.prototype.toString.call(iterable) !== '[object Array]') {
      return this.reject(new TypeError('must be an array'));
    }

    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }

    var i = -1;
    var promise = new this(INTERNAL);

    while (++i < len) {
      resolver(iterable[i]);
    }
    return promise;
    function resolver(value) {
      self.resolve(value).then(function (response) {
        if (!called) {
          called = true;
          handlers.resolve(promise, response);
        }
      }, function (error) {
        if (!called) {
          called = true;
          handlers.reject(promise, error);
        }
      });
    }
  }

  },{"1":1}],3:[function(_dereq_,module,exports){
  (function (global){
  if (typeof global.Promise !== 'function') {
    global.Promise = _dereq_(2);
  }

  }).call(this,typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  },{"2":2}],4:[function(_dereq_,module,exports){

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function getIDB() {
      /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
      try {
          if (typeof indexedDB !== 'undefined') {
              return indexedDB;
          }
          if (typeof webkitIndexedDB !== 'undefined') {
              return webkitIndexedDB;
          }
          if (typeof mozIndexedDB !== 'undefined') {
              return mozIndexedDB;
          }
          if (typeof OIndexedDB !== 'undefined') {
              return OIndexedDB;
          }
          if (typeof msIndexedDB !== 'undefined') {
              return msIndexedDB;
          }
      } catch (e) {
          return;
      }
  }

  var idb = getIDB();

  function isIndexedDBValid() {
      try {
          // Initialize IndexedDB; fall back to vendor-prefixed versions
          // if needed.
          if (!idb) {
              return false;
          }
          // We mimic PouchDB here;
          //
          // We test for openDatabase because IE Mobile identifies itself
          // as Safari. Oh the lulz...
          var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

          var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

          // Safari <10.1 does not meet our requirements for IDB support (#5572)
          // since Safari 10.1 shipped with fetch, we can use that to detect it
          return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
          // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange !== 'undefined';
      } catch (e) {
          return false;
      }
  }

  // Abstracts constructing a Blob object, so it also works in older
  // browsers that don't support the native Blob constructor. (i.e.
  // old QtWebKit versions, at least).
  // Abstracts constructing a Blob object, so it also works in older
  // browsers that don't support the native Blob constructor. (i.e.
  // old QtWebKit versions, at least).
  function createBlob(parts, properties) {
      /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
      parts = parts || [];
      properties = properties || {};
      try {
          return new Blob(parts, properties);
      } catch (e) {
          if (e.name !== 'TypeError') {
              throw e;
          }
          var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();
          for (var i = 0; i < parts.length; i += 1) {
              builder.append(parts[i]);
          }
          return builder.getBlob(properties.type);
      }
  }

  // This is CommonJS because lie is an external dependency, so Rollup
  // can just ignore it.
  if (typeof Promise === 'undefined') {
      // In the "nopromises" build this will just throw if you don't have
      // a global promise object, but it would throw anyway later.
      _dereq_(3);
  }
  var Promise$1 = Promise;

  function executeCallback(promise, callback) {
      if (callback) {
          promise.then(function (result) {
              callback(null, result);
          }, function (error) {
              callback(error);
          });
      }
  }

  function executeTwoCallbacks(promise, callback, errorCallback) {
      if (typeof callback === 'function') {
          promise.then(callback);
      }

      if (typeof errorCallback === 'function') {
          promise["catch"](errorCallback);
      }
  }

  function normalizeKey(key) {
      // Cast the key to a string, as that's all we can set as a key.
      if (typeof key !== 'string') {
          console.warn(key + ' used as a key, but it is not a string.');
          key = String(key);
      }

      return key;
  }

  function getCallback() {
      if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
          return arguments[arguments.length - 1];
      }
  }

  // Some code originally from async_storage.js in
  // [Gaia](https://github.com/mozilla-b2g/gaia).

  var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
  var supportsBlobs = void 0;
  var dbContexts = {};
  var toString = Object.prototype.toString;

  // Transaction Modes
  var READ_ONLY = 'readonly';
  var READ_WRITE = 'readwrite';

  // Transform a binary string to an array buffer, because otherwise
  // weird stuff happens when you try to work with the binary string directly.
  // It is known.
  // From http://stackoverflow.com/questions/14967647/ (continues on next line)
  // encode-decode-image-with-base64-breaks-image (2013-04-21)
  function _binStringToArrayBuffer(bin) {
      var length = bin.length;
      var buf = new ArrayBuffer(length);
      var arr = new Uint8Array(buf);
      for (var i = 0; i < length; i++) {
          arr[i] = bin.charCodeAt(i);
      }
      return buf;
  }

  //
  // Blobs are not supported in all versions of IndexedDB, notably
  // Chrome <37 and Android <5. In those versions, storing a blob will throw.
  //
  // Various other blob bugs exist in Chrome v37-42 (inclusive).
  // Detecting them is expensive and confusing to users, and Chrome 37-42
  // is at very low usage worldwide, so we do a hacky userAgent check instead.
  //
  // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
  // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
  // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
  //
  // Code borrowed from PouchDB. See:
  // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
  //
  function _checkBlobSupportWithoutCaching(idb) {
      return new Promise$1(function (resolve) {
          var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob(['']);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

          txn.onabort = function (e) {
              // If the transaction aborts now its due to not being able to
              // write to the database, likely due to the disk being full
              e.preventDefault();
              e.stopPropagation();
              resolve(false);
          };

          txn.oncomplete = function () {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              // MS Edge pretends to be Chrome 42:
              // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
      })["catch"](function () {
          return false; // error, so assume unsupported
      });
  }

  function _checkBlobSupport(idb) {
      if (typeof supportsBlobs === 'boolean') {
          return Promise$1.resolve(supportsBlobs);
      }
      return _checkBlobSupportWithoutCaching(idb).then(function (value) {
          supportsBlobs = value;
          return supportsBlobs;
      });
  }

  function _deferReadiness(dbInfo) {
      var dbContext = dbContexts[dbInfo.name];

      // Create a deferred object representing the current database operation.
      var deferredOperation = {};

      deferredOperation.promise = new Promise$1(function (resolve, reject) {
          deferredOperation.resolve = resolve;
          deferredOperation.reject = reject;
      });

      // Enqueue the deferred operation.
      dbContext.deferredOperations.push(deferredOperation);

      // Chain its promise to the database readiness.
      if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
      } else {
          dbContext.dbReady = dbContext.dbReady.then(function () {
              return deferredOperation.promise;
          });
      }
  }

  function _advanceReadiness(dbInfo) {
      var dbContext = dbContexts[dbInfo.name];

      // Dequeue a deferred operation.
      var deferredOperation = dbContext.deferredOperations.pop();

      // Resolve its promise (which is part of the database readiness
      // chain of promises).
      if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
      }
  }

  function _rejectReadiness(dbInfo, err) {
      var dbContext = dbContexts[dbInfo.name];

      // Dequeue a deferred operation.
      var deferredOperation = dbContext.deferredOperations.pop();

      // Reject its promise (which is part of the database readiness
      // chain of promises).
      if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
      }
  }

  function _getConnection(dbInfo, upgradeNeeded) {
      return new Promise$1(function (resolve, reject) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

          if (dbInfo.db) {
              if (upgradeNeeded) {
                  _deferReadiness(dbInfo);
                  dbInfo.db.close();
              } else {
                  return resolve(dbInfo.db);
              }
          }

          var dbArgs = [dbInfo.name];

          if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
          }

          var openreq = idb.open.apply(idb, dbArgs);

          if (upgradeNeeded) {
              openreq.onupgradeneeded = function (e) {
                  var db = openreq.result;
                  try {
                      db.createObjectStore(dbInfo.storeName);
                      if (e.oldVersion <= 1) {
                          // Added when support for blob shims was added
                          db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                      }
                  } catch (ex) {
                      if (ex.name === 'ConstraintError') {
                          console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                      } else {
                          throw ex;
                      }
                  }
              };
          }

          openreq.onerror = function (e) {
              e.preventDefault();
              reject(openreq.error);
          };

          openreq.onsuccess = function () {
              resolve(openreq.result);
              _advanceReadiness(dbInfo);
          };
      });
  }

  function _getOriginalConnection(dbInfo) {
      return _getConnection(dbInfo, false);
  }

  function _getUpgradedConnection(dbInfo) {
      return _getConnection(dbInfo, true);
  }

  function _isUpgradeNeeded(dbInfo, defaultVersion) {
      if (!dbInfo.db) {
          return true;
      }

      var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
      var isDowngrade = dbInfo.version < dbInfo.db.version;
      var isUpgrade = dbInfo.version > dbInfo.db.version;

      if (isDowngrade) {
          // If the version is not the default one
          // then warn for impossible downgrade.
          if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
          }
          // Align the versions to prevent errors.
          dbInfo.version = dbInfo.db.version;
      }

      if (isUpgrade || isNewStore) {
          // If the store is new then increment the version (if needed).
          // This will trigger an "upgradeneeded" event which is required
          // for creating a store.
          if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                  dbInfo.version = incVersion;
              }
          }

          return true;
      }

      return false;
  }

  // encode a blob for indexeddb engines that don't support blobs
  function _encodeBlob(blob) {
      return new Promise$1(function (resolve, reject) {
          var reader = new FileReader();
          reader.onerror = reject;
          reader.onloadend = function (e) {
              var base64 = btoa(e.target.result || '');
              resolve({
                  __local_forage_encoded_blob: true,
                  data: base64,
                  type: blob.type
              });
          };
          reader.readAsBinaryString(blob);
      });
  }

  // decode an encoded blob
  function _decodeBlob(encodedBlob) {
      var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
      return createBlob([arrayBuff], { type: encodedBlob.type });
  }

  // is this one of our fancy encoded blobs?
  function _isEncodedBlob(value) {
      return value && value.__local_forage_encoded_blob;
  }

  // Specialize the default `ready()` function by making it dependent
  // on the current database operations. Thus, the driver will be actually
  // ready when it's been initialized (default) *and* there are no pending
  // operations on the database (initiated by some other instances).
  function _fullyReady(callback) {
      var self = this;

      var promise = self._initReady().then(function () {
          var dbContext = dbContexts[self._dbInfo.name];

          if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
          }
      });

      executeTwoCallbacks(promise, callback, callback);
      return promise;
  }

  // Try to establish a new db connection to replace the
  // current one which is broken (i.e. experiencing
  // InvalidStateError while creating a transaction).
  function _tryReconnect(dbInfo) {
      _deferReadiness(dbInfo);

      var dbContext = dbContexts[dbInfo.name];
      var forages = dbContext.forages;

      for (var i = 0; i < forages.length; i++) {
          var forage = forages[i];
          if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
          }
      }
      dbInfo.db = null;

      return _getOriginalConnection(dbInfo).then(function (db) {
          dbInfo.db = db;
          if (_isUpgradeNeeded(dbInfo)) {
              // Reopen the database for upgrading.
              return _getUpgradedConnection(dbInfo);
          }
          return db;
      }).then(function (db) {
          // store the latest db reference
          // in case the db was upgraded
          dbInfo.db = dbContext.db = db;
          for (var i = 0; i < forages.length; i++) {
              forages[i]._dbInfo.db = db;
          }
      })["catch"](function (err) {
          _rejectReadiness(dbInfo, err);
          throw err;
      });
  }

  // FF doesn't like Promises (micro-tasks) and IDDB store operations,
  // so we have to do it with callbacks
  function createTransaction(dbInfo, mode, callback, retries) {
      if (retries === undefined) {
          retries = 1;
      }

      try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
      } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
              return Promise$1.resolve().then(function () {
                  if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                      // increase the db version, to create the new ObjectStore
                      if (dbInfo.db) {
                          dbInfo.version = dbInfo.db.version + 1;
                      }
                      // Reopen the database for upgrading.
                      return _getUpgradedConnection(dbInfo);
                  }
              }).then(function () {
                  return _tryReconnect(dbInfo).then(function () {
                      createTransaction(dbInfo, mode, callback, retries - 1);
                  });
              })["catch"](callback);
          }

          callback(err);
      }
  }

  function createDbContext() {
      return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
      };
  }

  // Open the IndexedDB database (automatically creates one if one didn't
  // previously exist), using any options set in the config.
  function _initStorage(options) {
      var self = this;
      var dbInfo = {
          db: null
      };

      if (options) {
          for (var i in options) {
              dbInfo[i] = options[i];
          }
      }

      // Get the current context of the database;
      var dbContext = dbContexts[dbInfo.name];

      // ...or create a new context.
      if (!dbContext) {
          dbContext = createDbContext();
          // Register the new context in the global container.
          dbContexts[dbInfo.name] = dbContext;
      }

      // Register itself as a running localForage in the current context.
      dbContext.forages.push(self);

      // Replace the default `ready()` function with the specialized one.
      if (!self._initReady) {
          self._initReady = self.ready;
          self.ready = _fullyReady;
      }

      // Create an array of initialization states of the related localForages.
      var initPromises = [];

      function ignoreErrors() {
          // Don't handle errors here,
          // just makes sure related localForages aren't pending.
          return Promise$1.resolve();
      }

      for (var j = 0; j < dbContext.forages.length; j++) {
          var forage = dbContext.forages[j];
          if (forage !== self) {
              // Don't wait for itself...
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
      }

      // Take a snapshot of the related localForages.
      var forages = dbContext.forages.slice(0);

      // Initialize the connection process only when
      // all the related localForages aren't pending.
      return Promise$1.all(initPromises).then(function () {
          dbInfo.db = dbContext.db;
          // Get the connection or open a new one without upgrade.
          return _getOriginalConnection(dbInfo);
      }).then(function (db) {
          dbInfo.db = db;
          if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
              // Reopen the database for upgrading.
              return _getUpgradedConnection(dbInfo);
          }
          return db;
      }).then(function (db) {
          dbInfo.db = dbContext.db = db;
          self._dbInfo = dbInfo;
          // Share the final connection amongst related localForages.
          for (var k = 0; k < forages.length; k++) {
              var forage = forages[k];
              if (forage !== self) {
                  // Self is already up-to-date.
                  forage._dbInfo.db = dbInfo.db;
                  forage._dbInfo.version = dbInfo.version;
              }
          }
      });
  }

  function getItem(key, callback) {
      var self = this;

      key = normalizeKey(key);

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                  if (err) {
                      return reject(err);
                  }

                  try {
                      var store = transaction.objectStore(self._dbInfo.storeName);
                      var req = store.get(key);

                      req.onsuccess = function () {
                          var value = req.result;
                          if (value === undefined) {
                              value = null;
                          }
                          if (_isEncodedBlob(value)) {
                              value = _decodeBlob(value);
                          }
                          resolve(value);
                      };

                      req.onerror = function () {
                          reject(req.error);
                      };
                  } catch (e) {
                      reject(e);
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Iterate over all items stored in database.
  function iterate(iterator, callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                  if (err) {
                      return reject(err);
                  }

                  try {
                      var store = transaction.objectStore(self._dbInfo.storeName);
                      var req = store.openCursor();
                      var iterationNumber = 1;

                      req.onsuccess = function () {
                          var cursor = req.result;

                          if (cursor) {
                              var value = cursor.value;
                              if (_isEncodedBlob(value)) {
                                  value = _decodeBlob(value);
                              }
                              var result = iterator(value, cursor.key, iterationNumber++);

                              // when the iterator callback retuns any
                              // (non-`undefined`) value, then we stop
                              // the iteration immediately
                              if (result !== void 0) {
                                  resolve(result);
                              } else {
                                  cursor["continue"]();
                              }
                          } else {
                              resolve();
                          }
                      };

                      req.onerror = function () {
                          reject(req.error);
                      };
                  } catch (e) {
                      reject(e);
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);

      return promise;
  }

  function setItem(key, value, callback) {
      var self = this;

      key = normalizeKey(key);

      var promise = new Promise$1(function (resolve, reject) {
          var dbInfo;
          self.ready().then(function () {
              dbInfo = self._dbInfo;
              if (toString.call(value) === '[object Blob]') {
                  return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
                      if (blobSupport) {
                          return value;
                      }
                      return _encodeBlob(value);
                  });
              }
              return value;
          }).then(function (value) {
              createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                  if (err) {
                      return reject(err);
                  }

                  try {
                      var store = transaction.objectStore(self._dbInfo.storeName);

                      // The reason we don't _save_ null is because IE 10 does
                      // not support saving the `null` type in IndexedDB. How
                      // ironic, given the bug below!
                      // See: https://github.com/mozilla/localForage/issues/161
                      if (value === null) {
                          value = undefined;
                      }

                      var req = store.put(value, key);

                      transaction.oncomplete = function () {
                          // Cast to undefined so the value passed to
                          // callback/promise is the same as what one would get out
                          // of `getItem()` later. This leads to some weirdness
                          // (setItem('foo', undefined) will return `null`), but
                          // it's not my fault localStorage is our baseline and that
                          // it's weird.
                          if (value === undefined) {
                              value = null;
                          }

                          resolve(value);
                      };
                      transaction.onabort = transaction.onerror = function () {
                          var err = req.error ? req.error : req.transaction.error;
                          reject(err);
                      };
                  } catch (e) {
                      reject(e);
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function removeItem(key, callback) {
      var self = this;

      key = normalizeKey(key);

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                  if (err) {
                      return reject(err);
                  }

                  try {
                      var store = transaction.objectStore(self._dbInfo.storeName);
                      // We use a Grunt task to make this safe for IE and some
                      // versions of Android (including those used by Cordova).
                      // Normally IE won't like `.delete()` and will insist on
                      // using `['delete']()`, but we have a build step that
                      // fixes this for us now.
                      var req = store["delete"](key);
                      transaction.oncomplete = function () {
                          resolve();
                      };

                      transaction.onerror = function () {
                          reject(req.error);
                      };

                      // The request will be also be aborted if we've exceeded our storage
                      // space.
                      transaction.onabort = function () {
                          var err = req.error ? req.error : req.transaction.error;
                          reject(err);
                      };
                  } catch (e) {
                      reject(e);
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function clear(callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
                  if (err) {
                      return reject(err);
                  }

                  try {
                      var store = transaction.objectStore(self._dbInfo.storeName);
                      var req = store.clear();

                      transaction.oncomplete = function () {
                          resolve();
                      };

                      transaction.onabort = transaction.onerror = function () {
                          var err = req.error ? req.error : req.transaction.error;
                          reject(err);
                      };
                  } catch (e) {
                      reject(e);
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function length(callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                  if (err) {
                      return reject(err);
                  }

                  try {
                      var store = transaction.objectStore(self._dbInfo.storeName);
                      var req = store.count();

                      req.onsuccess = function () {
                          resolve(req.result);
                      };

                      req.onerror = function () {
                          reject(req.error);
                      };
                  } catch (e) {
                      reject(e);
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function key(n, callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          if (n < 0) {
              resolve(null);

              return;
          }

          self.ready().then(function () {
              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                  if (err) {
                      return reject(err);
                  }

                  try {
                      var store = transaction.objectStore(self._dbInfo.storeName);
                      var advanced = false;
                      var req = store.openCursor();

                      req.onsuccess = function () {
                          var cursor = req.result;
                          if (!cursor) {
                              // this means there weren't enough keys
                              resolve(null);

                              return;
                          }

                          if (n === 0) {
                              // We have the first key, return it if that's what they
                              // wanted.
                              resolve(cursor.key);
                          } else {
                              if (!advanced) {
                                  // Otherwise, ask the cursor to skip ahead n
                                  // records.
                                  advanced = true;
                                  cursor.advance(n);
                              } else {
                                  // When we get here, we've got the nth key.
                                  resolve(cursor.key);
                              }
                          }
                      };

                      req.onerror = function () {
                          reject(req.error);
                      };
                  } catch (e) {
                      reject(e);
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function keys(callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
                  if (err) {
                      return reject(err);
                  }

                  try {
                      var store = transaction.objectStore(self._dbInfo.storeName);
                      var req = store.openCursor();
                      var keys = [];

                      req.onsuccess = function () {
                          var cursor = req.result;

                          if (!cursor) {
                              resolve(keys);
                              return;
                          }

                          keys.push(cursor.key);
                          cursor["continue"]();
                      };

                      req.onerror = function () {
                          reject(req.error);
                      };
                  } catch (e) {
                      reject(e);
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function dropInstance(options, callback) {
      callback = getCallback.apply(this, arguments);

      var currentConfig = this.config();
      options = typeof options !== 'function' && options || {};
      if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
      }

      var self = this;
      var promise;
      if (!options.name) {
          promise = Promise$1.reject('Invalid arguments');
      } else {
          var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

          var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i = 0; i < forages.length; i++) {
                  forages[i]._dbInfo.db = db;
              }
              return db;
          });

          if (!options.storeName) {
              promise = dbPromise.then(function (db) {
                  _deferReadiness(options);

                  var dbContext = dbContexts[options.name];
                  var forages = dbContext.forages;

                  db.close();
                  for (var i = 0; i < forages.length; i++) {
                      var forage = forages[i];
                      forage._dbInfo.db = null;
                  }

                  var dropDBPromise = new Promise$1(function (resolve, reject) {
                      var req = idb.deleteDatabase(options.name);

                      req.onerror = req.onblocked = function (err) {
                          var db = req.result;
                          if (db) {
                              db.close();
                          }
                          reject(err);
                      };

                      req.onsuccess = function () {
                          var db = req.result;
                          if (db) {
                              db.close();
                          }
                          resolve(db);
                      };
                  });

                  return dropDBPromise.then(function (db) {
                      dbContext.db = db;
                      for (var i = 0; i < forages.length; i++) {
                          var _forage = forages[i];
                          _advanceReadiness(_forage._dbInfo);
                      }
                  })["catch"](function (err) {
                      (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                      throw err;
                  });
              });
          } else {
              promise = dbPromise.then(function (db) {
                  if (!db.objectStoreNames.contains(options.storeName)) {
                      return;
                  }

                  var newVersion = db.version + 1;

                  _deferReadiness(options);

                  var dbContext = dbContexts[options.name];
                  var forages = dbContext.forages;

                  db.close();
                  for (var i = 0; i < forages.length; i++) {
                      var forage = forages[i];
                      forage._dbInfo.db = null;
                      forage._dbInfo.version = newVersion;
                  }

                  var dropObjectPromise = new Promise$1(function (resolve, reject) {
                      var req = idb.open(options.name, newVersion);

                      req.onerror = function (err) {
                          var db = req.result;
                          db.close();
                          reject(err);
                      };

                      req.onupgradeneeded = function () {
                          var db = req.result;
                          db.deleteObjectStore(options.storeName);
                      };

                      req.onsuccess = function () {
                          var db = req.result;
                          db.close();
                          resolve(db);
                      };
                  });

                  return dropObjectPromise.then(function (db) {
                      dbContext.db = db;
                      for (var j = 0; j < forages.length; j++) {
                          var _forage2 = forages[j];
                          _forage2._dbInfo.db = db;
                          _advanceReadiness(_forage2._dbInfo);
                      }
                  })["catch"](function (err) {
                      (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
                      throw err;
                  });
              });
          }
      }

      executeCallback(promise, callback);
      return promise;
  }

  var asyncStorage = {
      _driver: 'asyncStorage',
      _initStorage: _initStorage,
      _support: isIndexedDBValid(),
      iterate: iterate,
      getItem: getItem,
      setItem: setItem,
      removeItem: removeItem,
      clear: clear,
      length: length,
      key: key,
      keys: keys,
      dropInstance: dropInstance
  };

  function isWebSQLValid() {
      return typeof openDatabase === 'function';
  }

  // Sadly, the best way to save binary data in WebSQL/localStorage is serializing
  // it to Base64, so this is how we store it to prevent very strange errors with less
  // verbose ways of binary <-> string data storage.
  var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  var BLOB_TYPE_PREFIX = '~~local_forage_type~';
  var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

  var SERIALIZED_MARKER = '__lfsc__:';
  var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

  // OMG the serializations!
  var TYPE_ARRAYBUFFER = 'arbf';
  var TYPE_BLOB = 'blob';
  var TYPE_INT8ARRAY = 'si08';
  var TYPE_UINT8ARRAY = 'ui08';
  var TYPE_UINT8CLAMPEDARRAY = 'uic8';
  var TYPE_INT16ARRAY = 'si16';
  var TYPE_INT32ARRAY = 'si32';
  var TYPE_UINT16ARRAY = 'ur16';
  var TYPE_UINT32ARRAY = 'ui32';
  var TYPE_FLOAT32ARRAY = 'fl32';
  var TYPE_FLOAT64ARRAY = 'fl64';
  var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

  var toString$1 = Object.prototype.toString;

  function stringToBuffer(serializedString) {
      // Fill the string into a ArrayBuffer.
      var bufferLength = serializedString.length * 0.75;
      var len = serializedString.length;
      var i;
      var p = 0;
      var encoded1, encoded2, encoded3, encoded4;

      if (serializedString[serializedString.length - 1] === '=') {
          bufferLength--;
          if (serializedString[serializedString.length - 2] === '=') {
              bufferLength--;
          }
      }

      var buffer = new ArrayBuffer(bufferLength);
      var bytes = new Uint8Array(buffer);

      for (i = 0; i < len; i += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

          /*jslint bitwise: true */
          bytes[p++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return buffer;
  }

  // Converts a buffer to a string to store, serialized, in the backend
  // storage library.
  function bufferToString(buffer) {
      // base64-arraybuffer
      var bytes = new Uint8Array(buffer);
      var base64String = '';
      var i;

      for (i = 0; i < bytes.length; i += 3) {
          /*jslint bitwise: true */
          base64String += BASE_CHARS[bytes[i] >> 2];
          base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
          base64String += BASE_CHARS[bytes[i + 2] & 63];
      }

      if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + '=';
      } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + '==';
      }

      return base64String;
  }

  // Serialize a value, afterwards executing a callback (which usually
  // instructs the `setItem()` callback/promise to be executed). This is how
  // we store binary data with localStorage.
  function serialize(value, callback) {
      var valueType = '';
      if (value) {
          valueType = toString$1.call(value);
      }

      // Cannot use `value instanceof ArrayBuffer` or such here, as these
      // checks fail when running the tests using casper.js...
      //
      // TODO: See why those tests fail and use a better solution.
      if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
          // Convert binary arrays to a string and prefix the string with
          // a special marker.
          var buffer;
          var marker = SERIALIZED_MARKER;

          if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
          } else {
              buffer = value.buffer;

              if (valueType === '[object Int8Array]') {
                  marker += TYPE_INT8ARRAY;
              } else if (valueType === '[object Uint8Array]') {
                  marker += TYPE_UINT8ARRAY;
              } else if (valueType === '[object Uint8ClampedArray]') {
                  marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === '[object Int16Array]') {
                  marker += TYPE_INT16ARRAY;
              } else if (valueType === '[object Uint16Array]') {
                  marker += TYPE_UINT16ARRAY;
              } else if (valueType === '[object Int32Array]') {
                  marker += TYPE_INT32ARRAY;
              } else if (valueType === '[object Uint32Array]') {
                  marker += TYPE_UINT32ARRAY;
              } else if (valueType === '[object Float32Array]') {
                  marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === '[object Float64Array]') {
                  marker += TYPE_FLOAT64ARRAY;
              } else {
                  callback(new Error('Failed to get type for BinaryArray'));
              }
          }

          callback(marker + bufferToString(buffer));
      } else if (valueType === '[object Blob]') {
          // Conver the blob to a binaryArray and then to a string.
          var fileReader = new FileReader();

          fileReader.onload = function () {
              // Backwards-compatible prefix for the blob type.
              var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };

          fileReader.readAsArrayBuffer(value);
      } else {
          try {
              callback(JSON.stringify(value));
          } catch (e) {
              console.error("Couldn't convert value into a JSON string: ", value);

              callback(null, e);
          }
      }
  }

  // Deserialize data we've inserted into a value column/field. We place
  // special markers into our strings to mark them as encoded; this isn't
  // as nice as a meta field, but it's the only sane thing we can do whilst
  // keeping localStorage support intact.
  //
  // Oftentimes this will just deserialize JSON content, but if we have a
  // special marker (SERIALIZED_MARKER, defined above), we will extract
  // some kind of arraybuffer/binary data/typed array out of the string.
  function deserialize(value) {
      // If we haven't marked this string as being specially serialized (i.e.
      // something other than serialized JSON), we can just return it and be
      // done with it.
      if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
      }

      // The following code deals with deserializing some kind of Blob or
      // TypedArray. First we separate out the type of data we're dealing
      // with from the data itself.
      var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
      var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

      var blobType;
      // Backwards-compatible blob type serialization strategy.
      // DBs created with older versions of localForage will simply not have the blob type.
      if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
      }
      var buffer = stringToBuffer(serializedString);

      // Return the right type based on the code/type set during
      // serialization.
      switch (type) {
          case TYPE_ARRAYBUFFER:
              return buffer;
          case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
          case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
          case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
          case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
          case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
          case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
          case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
          case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
          case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
          case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
          default:
              throw new Error('Unkown type: ' + type);
      }
  }

  var localforageSerializer = {
      serialize: serialize,
      deserialize: deserialize,
      stringToBuffer: stringToBuffer,
      bufferToString: bufferToString
  };

  /*
   * Includes code from:
   *
   * base64-arraybuffer
   * https://github.com/niklasvh/base64-arraybuffer
   *
   * Copyright (c) 2012 Niklas von Hertzen
   * Licensed under the MIT license.
   */

  function createDbTable(t, dbInfo, callback, errorCallback) {
      t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
  }

  // Open the WebSQL database (automatically creates one if one didn't
  // previously exist), using any options set in the config.
  function _initStorage$1(options) {
      var self = this;
      var dbInfo = {
          db: null
      };

      if (options) {
          for (var i in options) {
              dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
          }
      }

      var dbInfoPromise = new Promise$1(function (resolve, reject) {
          // Open the database; the openDatabase API will automatically
          // create it for us if it doesn't exist.
          try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e) {
              return reject(e);
          }

          // Create our key/value table if it doesn't exist.
          dbInfo.db.transaction(function (t) {
              createDbTable(t, dbInfo, function () {
                  self._dbInfo = dbInfo;
                  resolve();
              }, function (t, error) {
                  reject(error);
              });
          }, reject);
      });

      dbInfo.serializer = localforageSerializer;
      return dbInfoPromise;
  }

  function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
      t.executeSql(sqlStatement, args, callback, function (t, error) {
          if (error.code === error.SYNTAX_ERR) {
              t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
                  if (!results.rows.length) {
                      // if the table is missing (was deleted)
                      // re-create it table and retry
                      createDbTable(t, dbInfo, function () {
                          t.executeSql(sqlStatement, args, callback, errorCallback);
                      }, errorCallback);
                  } else {
                      errorCallback(t, error);
                  }
              }, errorCallback);
          } else {
              errorCallback(t, error);
          }
      }, errorCallback);
  }

  function getItem$1(key, callback) {
      var self = this;

      key = normalizeKey(key);

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              var dbInfo = self._dbInfo;
              dbInfo.db.transaction(function (t) {
                  tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
                      var result = results.rows.length ? results.rows.item(0).value : null;

                      // Check to see if this is serialized content we need to
                      // unpack.
                      if (result) {
                          result = dbInfo.serializer.deserialize(result);
                      }

                      resolve(result);
                  }, function (t, error) {
                      reject(error);
                  });
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function iterate$1(iterator, callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              var dbInfo = self._dbInfo;

              dbInfo.db.transaction(function (t) {
                  tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
                      var rows = results.rows;
                      var length = rows.length;

                      for (var i = 0; i < length; i++) {
                          var item = rows.item(i);
                          var result = item.value;

                          // Check to see if this is serialized content
                          // we need to unpack.
                          if (result) {
                              result = dbInfo.serializer.deserialize(result);
                          }

                          result = iterator(result, item.key, i + 1);

                          // void(0) prevents problems with redefinition
                          // of `undefined`.
                          if (result !== void 0) {
                              resolve(result);
                              return;
                          }
                      }

                      resolve();
                  }, function (t, error) {
                      reject(error);
                  });
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function _setItem(key, value, callback, retriesLeft) {
      var self = this;

      key = normalizeKey(key);

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              // The localStorage API doesn't return undefined values in an
              // "expected" way, so undefined is always cast to null in all
              // drivers. See: https://github.com/mozilla/localForage/pull/42
              if (value === undefined) {
                  value = null;
              }

              // Save the original value to pass to the callback.
              var originalValue = value;

              var dbInfo = self._dbInfo;
              dbInfo.serializer.serialize(value, function (value, error) {
                  if (error) {
                      reject(error);
                  } else {
                      dbInfo.db.transaction(function (t) {
                          tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
                              resolve(originalValue);
                          }, function (t, error) {
                              reject(error);
                          });
                      }, function (sqlError) {
                          // The transaction failed; check
                          // to see if it's a quota error.
                          if (sqlError.code === sqlError.QUOTA_ERR) {
                              // We reject the callback outright for now, but
                              // it's worth trying to re-run the transaction.
                              // Even if the user accepts the prompt to use
                              // more storage on Safari, this error will
                              // be called.
                              //
                              // Try to re-run the transaction.
                              if (retriesLeft > 0) {
                                  resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
                                  return;
                              }
                              reject(sqlError);
                          }
                      });
                  }
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function setItem$1(key, value, callback) {
      return _setItem.apply(this, [key, value, callback, 1]);
  }

  function removeItem$1(key, callback) {
      var self = this;

      key = normalizeKey(key);

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              var dbInfo = self._dbInfo;
              dbInfo.db.transaction(function (t) {
                  tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
                      resolve();
                  }, function (t, error) {
                      reject(error);
                  });
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Deletes every item in the table.
  // TODO: Find out if this resets the AUTO_INCREMENT number.
  function clear$1(callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              var dbInfo = self._dbInfo;
              dbInfo.db.transaction(function (t) {
                  tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
                      resolve();
                  }, function (t, error) {
                      reject(error);
                  });
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Does a simple `COUNT(key)` to get the number of items stored in
  // localForage.
  function length$1(callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              var dbInfo = self._dbInfo;
              dbInfo.db.transaction(function (t) {
                  // Ahhh, SQL makes this one soooooo easy.
                  tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
                      var result = results.rows.item(0).c;
                      resolve(result);
                  }, function (t, error) {
                      reject(error);
                  });
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Return the key located at key index X; essentially gets the key from a
  // `WHERE id = ?`. This is the most efficient way I can think to implement
  // this rarely-used (in my experience) part of the API, but it can seem
  // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
  // the ID of each key will change every time it's updated. Perhaps a stored
  // procedure for the `setItem()` SQL would solve this problem?
  // TODO: Don't change ID on `setItem()`.
  function key$1(n, callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              var dbInfo = self._dbInfo;
              dbInfo.db.transaction(function (t) {
                  tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
                      var result = results.rows.length ? results.rows.item(0).key : null;
                      resolve(result);
                  }, function (t, error) {
                      reject(error);
                  });
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  function keys$1(callback) {
      var self = this;

      var promise = new Promise$1(function (resolve, reject) {
          self.ready().then(function () {
              var dbInfo = self._dbInfo;
              dbInfo.db.transaction(function (t) {
                  tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
                      var keys = [];

                      for (var i = 0; i < results.rows.length; i++) {
                          keys.push(results.rows.item(i).key);
                      }

                      resolve(keys);
                  }, function (t, error) {
                      reject(error);
                  });
              });
          })["catch"](reject);
      });

      executeCallback(promise, callback);
      return promise;
  }

  // https://www.w3.org/TR/webdatabase/#databases
  // > There is no way to enumerate or delete the databases available for an origin from this API.
  function getAllStoreNames(db) {
      return new Promise$1(function (resolve, reject) {
          db.transaction(function (t) {
              t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
                  var storeNames = [];

                  for (var i = 0; i < results.rows.length; i++) {
                      storeNames.push(results.rows.item(i).name);
                  }

                  resolve({
                      db: db,
                      storeNames: storeNames
                  });
              }, function (t, error) {
                  reject(error);
              });
          }, function (sqlError) {
              reject(sqlError);
          });
      });
  }

  function dropInstance$1(options, callback) {
      callback = getCallback.apply(this, arguments);

      var currentConfig = this.config();
      options = typeof options !== 'function' && options || {};
      if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
      }

      var self = this;
      var promise;
      if (!options.name) {
          promise = Promise$1.reject('Invalid arguments');
      } else {
          promise = new Promise$1(function (resolve) {
              var db;
              if (options.name === currentConfig.name) {
                  // use the db reference of the current instance
                  db = self._dbInfo.db;
              } else {
                  db = openDatabase(options.name, '', '', 0);
              }

              if (!options.storeName) {
                  // drop all database tables
                  resolve(getAllStoreNames(db));
              } else {
                  resolve({
                      db: db,
                      storeNames: [options.storeName]
                  });
              }
          }).then(function (operationInfo) {
              return new Promise$1(function (resolve, reject) {
                  operationInfo.db.transaction(function (t) {
                      function dropTable(storeName) {
                          return new Promise$1(function (resolve, reject) {
                              t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
                                  resolve();
                              }, function (t, error) {
                                  reject(error);
                              });
                          });
                      }

                      var operations = [];
                      for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                          operations.push(dropTable(operationInfo.storeNames[i]));
                      }

                      Promise$1.all(operations).then(function () {
                          resolve();
                      })["catch"](function (e) {
                          reject(e);
                      });
                  }, function (sqlError) {
                      reject(sqlError);
                  });
              });
          });
      }

      executeCallback(promise, callback);
      return promise;
  }

  var webSQLStorage = {
      _driver: 'webSQLStorage',
      _initStorage: _initStorage$1,
      _support: isWebSQLValid(),
      iterate: iterate$1,
      getItem: getItem$1,
      setItem: setItem$1,
      removeItem: removeItem$1,
      clear: clear$1,
      length: length$1,
      key: key$1,
      keys: keys$1,
      dropInstance: dropInstance$1
  };

  function isLocalStorageValid() {
      try {
          return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
          // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
      } catch (e) {
          return false;
      }
  }

  function _getKeyPrefix(options, defaultConfig) {
      var keyPrefix = options.name + '/';

      if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + '/';
      }
      return keyPrefix;
  }

  // Check if localStorage throws when saving an item
  function checkIfLocalStorageThrows() {
      var localStorageTestKey = '_localforage_support_test';

      try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);

          return false;
      } catch (e) {
          return true;
      }
  }

  // Check if localStorage is usable and allows to save an item
  // This method checks if localStorage is usable in Safari Private Browsing
  // mode, or in any other case where the available quota for localStorage
  // is 0 and there wasn't any saved items yet.
  function _isLocalStorageUsable() {
      return !checkIfLocalStorageThrows() || localStorage.length > 0;
  }

  // Config the localStorage backend, using options set in the config.
  function _initStorage$2(options) {
      var self = this;
      var dbInfo = {};
      if (options) {
          for (var i in options) {
              dbInfo[i] = options[i];
          }
      }

      dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

      if (!_isLocalStorageUsable()) {
          return Promise$1.reject();
      }

      self._dbInfo = dbInfo;
      dbInfo.serializer = localforageSerializer;

      return Promise$1.resolve();
  }

  // Remove all keys from the datastore, effectively destroying all data in
  // the app's key/value store!
  function clear$2(callback) {
      var self = this;
      var promise = self.ready().then(function () {
          var keyPrefix = self._dbInfo.keyPrefix;

          for (var i = localStorage.length - 1; i >= 0; i--) {
              var key = localStorage.key(i);

              if (key.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key);
              }
          }
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Retrieve an item from the store. Unlike the original async_storage
  // library in Gaia, we don't modify return values at all. If a key's value
  // is `undefined`, we pass that value to the callback function.
  function getItem$2(key, callback) {
      var self = this;

      key = normalizeKey(key);

      var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key);

          // If a result was found, parse it from the serialized
          // string into a JS object. If result isn't truthy, the key
          // is likely undefined and we'll pass it straight to the
          // callback.
          if (result) {
              result = dbInfo.serializer.deserialize(result);
          }

          return result;
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Iterate over all items in the store.
  function iterate$2(iterator, callback) {
      var self = this;

      var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length = localStorage.length;

          // We use a dedicated iterator instead of the `i` variable below
          // so other keys we fetch in localStorage aren't counted in
          // the `iterationNumber` argument passed to the `iterate()`
          // callback.
          //
          // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
          var iterationNumber = 1;

          for (var i = 0; i < length; i++) {
              var key = localStorage.key(i);
              if (key.indexOf(keyPrefix) !== 0) {
                  continue;
              }
              var value = localStorage.getItem(key);

              // If a result was found, parse it from the serialized
              // string into a JS object. If result isn't truthy, the
              // key is likely undefined and we'll pass it straight
              // to the iterator.
              if (value) {
                  value = dbInfo.serializer.deserialize(value);
              }

              value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

              if (value !== void 0) {
                  return value;
              }
          }
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Same as localStorage's key() method, except takes a callback.
  function key$2(n, callback) {
      var self = this;
      var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          var result;
          try {
              result = localStorage.key(n);
          } catch (error) {
              result = null;
          }

          // Remove the prefix from the key, if a key is found.
          if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
          }

          return result;
      });

      executeCallback(promise, callback);
      return promise;
  }

  function keys$2(callback) {
      var self = this;
      var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          var length = localStorage.length;
          var keys = [];

          for (var i = 0; i < length; i++) {
              var itemKey = localStorage.key(i);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                  keys.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
          }

          return keys;
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Supply the number of keys in the datastore to the callback function.
  function length$2(callback) {
      var self = this;
      var promise = self.keys().then(function (keys) {
          return keys.length;
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Remove an item from the store, nice and simple.
  function removeItem$2(key, callback) {
      var self = this;

      key = normalizeKey(key);

      var promise = self.ready().then(function () {
          var dbInfo = self._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key);
      });

      executeCallback(promise, callback);
      return promise;
  }

  // Set a key's value and run an optional callback once the value is set.
  // Unlike Gaia's implementation, the callback function is passed the value,
  // in case you want to operate on that value only after you're sure it
  // saved, or something like that.
  function setItem$2(key, value, callback) {
      var self = this;

      key = normalizeKey(key);

      var promise = self.ready().then(function () {
          // Convert undefined values to null.
          // https://github.com/mozilla/localForage/pull/42
          if (value === undefined) {
              value = null;
          }

          // Save the original value to pass to the callback.
          var originalValue = value;

          return new Promise$1(function (resolve, reject) {
              var dbInfo = self._dbInfo;
              dbInfo.serializer.serialize(value, function (value, error) {
                  if (error) {
                      reject(error);
                  } else {
                      try {
                          localStorage.setItem(dbInfo.keyPrefix + key, value);
                          resolve(originalValue);
                      } catch (e) {
                          // localStorage capacity exceeded.
                          // TODO: Make this a specific error/event.
                          if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                              reject(e);
                          }
                          reject(e);
                      }
                  }
              });
          });
      });

      executeCallback(promise, callback);
      return promise;
  }

  function dropInstance$2(options, callback) {
      callback = getCallback.apply(this, arguments);

      options = typeof options !== 'function' && options || {};
      if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
      }

      var self = this;
      var promise;
      if (!options.name) {
          promise = Promise$1.reject('Invalid arguments');
      } else {
          promise = new Promise$1(function (resolve) {
              if (!options.storeName) {
                  resolve(options.name + '/');
              } else {
                  resolve(_getKeyPrefix(options, self._defaultConfig));
              }
          }).then(function (keyPrefix) {
              for (var i = localStorage.length - 1; i >= 0; i--) {
                  var key = localStorage.key(i);

                  if (key.indexOf(keyPrefix) === 0) {
                      localStorage.removeItem(key);
                  }
              }
          });
      }

      executeCallback(promise, callback);
      return promise;
  }

  var localStorageWrapper = {
      _driver: 'localStorageWrapper',
      _initStorage: _initStorage$2,
      _support: isLocalStorageValid(),
      iterate: iterate$2,
      getItem: getItem$2,
      setItem: setItem$2,
      removeItem: removeItem$2,
      clear: clear$2,
      length: length$2,
      key: key$2,
      keys: keys$2,
      dropInstance: dropInstance$2
  };

  var sameValue = function sameValue(x, y) {
      return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
  };

  var includes = function includes(array, searchElement) {
      var len = array.length;
      var i = 0;
      while (i < len) {
          if (sameValue(array[i], searchElement)) {
              return true;
          }
          i++;
      }

      return false;
  };

  var isArray = Array.isArray || function (arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
  };

  // Drivers are stored here when `defineDriver()` is called.
  // They are shared across all instances of localForage.
  var DefinedDrivers = {};

  var DriverSupport = {};

  var DefaultDrivers = {
      INDEXEDDB: asyncStorage,
      WEBSQL: webSQLStorage,
      LOCALSTORAGE: localStorageWrapper
  };

  var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

  var OptionalDriverMethods = ['dropInstance'];

  var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

  var DefaultConfig = {
      description: '',
      driver: DefaultDriverOrder.slice(),
      name: 'localforage',
      // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
      // we can use without a prompt.
      size: 4980736,
      storeName: 'keyvaluepairs',
      version: 1.0
  };

  function callWhenReady(localForageInstance, libraryMethod) {
      localForageInstance[libraryMethod] = function () {
          var _args = arguments;
          return localForageInstance.ready().then(function () {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
      };
  }

  function extend() {
      for (var i = 1; i < arguments.length; i++) {
          var arg = arguments[i];

          if (arg) {
              for (var _key in arg) {
                  if (arg.hasOwnProperty(_key)) {
                      if (isArray(arg[_key])) {
                          arguments[0][_key] = arg[_key].slice();
                      } else {
                          arguments[0][_key] = arg[_key];
                      }
                  }
              }
          }
      }

      return arguments[0];
  }

  var LocalForage = function () {
      function LocalForage(options) {
          _classCallCheck(this, LocalForage);

          for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                  var driver = DefaultDrivers[driverTypeKey];
                  var driverName = driver._driver;
                  this[driverTypeKey] = driverName;

                  if (!DefinedDrivers[driverName]) {
                      // we don't need to wait for the promise,
                      // since the default drivers can be defined
                      // in a blocking manner
                      this.defineDriver(driver);
                  }
              }
          }

          this._defaultConfig = extend({}, DefaultConfig);
          this._config = extend({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;

          this._wrapLibraryMethodsWithReady();
          this.setDriver(this._config.driver)["catch"](function () {});
      }

      // Set any config values for localForage; can be called anytime before
      // the first API call (e.g. `getItem`, `setItem`).
      // We loop through options so we don't overwrite existing config
      // values.


      LocalForage.prototype.config = function config(options) {
          // If the options argument is an object, we use it to set values.
          // Otherwise, we return either a specified config value or all
          // config values.
          if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
              // If localforage is ready and fully initialized, we can't set
              // any new configuration values. Instead, we return an error.
              if (this._ready) {
                  return new Error("Can't call config() after localforage " + 'has been used.');
              }

              for (var i in options) {
                  if (i === 'storeName') {
                      options[i] = options[i].replace(/\W/g, '_');
                  }

                  if (i === 'version' && typeof options[i] !== 'number') {
                      return new Error('Database version must be a number.');
                  }

                  this._config[i] = options[i];
              }

              // after all config options are set and
              // the driver option is used, try setting it
              if ('driver' in options && options.driver) {
                  return this.setDriver(this._config.driver);
              }

              return true;
          } else if (typeof options === 'string') {
              return this._config[options];
          } else {
              return this._config;
          }
      };

      // Used to define a custom driver, shared across all instances of
      // localForage.


      LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise = new Promise$1(function (resolve, reject) {
              try {
                  var driverName = driverObject._driver;
                  var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

                  // A driver name should be defined and not overlap with the
                  // library-defined, default drivers.
                  if (!driverObject._driver) {
                      reject(complianceError);
                      return;
                  }

                  var driverMethods = LibraryMethods.concat('_initStorage');
                  for (var i = 0, len = driverMethods.length; i < len; i++) {
                      var driverMethodName = driverMethods[i];

                      // when the property is there,
                      // it should be a method even when optional
                      var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                      if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
                          reject(complianceError);
                          return;
                      }
                  }

                  var configureMissingMethods = function configureMissingMethods() {
                      var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
                          return function () {
                              var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
                              var promise = Promise$1.reject(error);
                              executeCallback(promise, arguments[arguments.length - 1]);
                              return promise;
                          };
                      };

                      for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                          var optionalDriverMethod = OptionalDriverMethods[_i];
                          if (!driverObject[optionalDriverMethod]) {
                              driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                          }
                      }
                  };

                  configureMissingMethods();

                  var setDriverSupport = function setDriverSupport(support) {
                      if (DefinedDrivers[driverName]) {
                          console.info('Redefining LocalForage driver: ' + driverName);
                      }
                      DefinedDrivers[driverName] = driverObject;
                      DriverSupport[driverName] = support;
                      // don't use a then, so that we can define
                      // drivers that have simple _support methods
                      // in a blocking manner
                      resolve();
                  };

                  if ('_support' in driverObject) {
                      if (driverObject._support && typeof driverObject._support === 'function') {
                          driverObject._support().then(setDriverSupport, reject);
                      } else {
                          setDriverSupport(!!driverObject._support);
                      }
                  } else {
                      setDriverSupport(true);
                  }
              } catch (e) {
                  reject(e);
              }
          });

          executeTwoCallbacks(promise, callback, errorCallback);
          return promise;
      };

      LocalForage.prototype.driver = function driver() {
          return this._driver || null;
      };

      LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
      };

      LocalForage.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$1.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
      };

      LocalForage.prototype.ready = function ready(callback) {
          var self = this;

          var promise = self._driverSet.then(function () {
              if (self._ready === null) {
                  self._ready = self._initDriver();
              }

              return self._ready;
          });

          executeTwoCallbacks(promise, callback, callback);
          return promise;
      };

      LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self = this;

          if (!isArray(drivers)) {
              drivers = [drivers];
          }

          var supportedDrivers = this._getSupportedDrivers(drivers);

          function setDriverToConfig() {
              self._config.driver = self.driver();
          }

          function extendSelfWithDriver(driver) {
              self._extend(driver);
              setDriverToConfig();

              self._ready = self._initStorage(self._config);
              return self._ready;
          }

          function initDriver(supportedDrivers) {
              return function () {
                  var currentDriverIndex = 0;

                  function driverPromiseLoop() {
                      while (currentDriverIndex < supportedDrivers.length) {
                          var driverName = supportedDrivers[currentDriverIndex];
                          currentDriverIndex++;

                          self._dbInfo = null;
                          self._ready = null;

                          return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                      }

                      setDriverToConfig();
                      var error = new Error('No available storage method found.');
                      self._driverSet = Promise$1.reject(error);
                      return self._driverSet;
                  }

                  return driverPromiseLoop();
              };
          }

          // There might be a driver initialization in progress
          // so wait for it to finish in order to avoid a possible
          // race condition to set _dbInfo
          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
              return Promise$1.resolve();
          }) : Promise$1.resolve();

          this._driverSet = oldDriverSetDone.then(function () {
              var driverName = supportedDrivers[0];
              self._dbInfo = null;
              self._ready = null;

              return self.getDriver(driverName).then(function (driver) {
                  self._driver = driver._driver;
                  setDriverToConfig();
                  self._wrapLibraryMethodsWithReady();
                  self._initDriver = initDriver(supportedDrivers);
              });
          })["catch"](function () {
              setDriverToConfig();
              var error = new Error('No available storage method found.');
              self._driverSet = Promise$1.reject(error);
              return self._driverSet;
          });

          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
      };

      LocalForage.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
      };

      LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend(this, libraryMethodsAndProperties);
      };

      LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];
          for (var i = 0, len = drivers.length; i < len; i++) {
              var driverName = drivers[i];
              if (this.supports(driverName)) {
                  supportedDrivers.push(driverName);
              }
          }
          return supportedDrivers;
      };

      LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          // Add a stub for each driver API method that delays the call to the
          // corresponding driver method until localForage is ready. These stubs
          // will be replaced by the driver methods as soon as the driver is
          // loaded, so there is no performance impact.
          for (var i = 0, len = LibraryMethods.length; i < len; i++) {
              callWhenReady(this, LibraryMethods[i]);
          }
      };

      LocalForage.prototype.createInstance = function createInstance(options) {
          return new LocalForage(options);
      };

      return LocalForage;
  }();

  // The actual localForage object that we expose as a module or via a
  // global. It's extended by pulling in one of our other libraries.


  var localforage_js = new LocalForage();

  module.exports = localforage_js;

  },{"3":3}]},{},[4])(4)
  });
  });

  let dbInstance;

  const db = () => {
    if (dbInstance === undefined) {
      dbInstance = localforage.createInstance({
        name: 'jsxcad',
        driver: localforage.INDEXEDDB,
        storeName: 'jsxcad',
        description: 'jsxcad local filesystem'
      });
    }
    return dbInstance;
  };

  /* global self */

  const watchers = new Set();

  const log = async (entry) => {
    if (isWebWorker) {
      return self.ask({ log: { entry } });
    }

    for (const watcher of watchers) {
      watcher(entry);
    }
  };

  const conversation = ({ agent, say }) => {
    let id = 0;
    const openQuestions = {};
    const ask = (question) => {
      const promise = new Promise((resolve, reject) => { openQuestions[id] = { resolve, reject }; });
      say({ id, question });
      id += 1;
      return promise;
    };
    const hear = async (message) => {
      const { id, question, answer, error } = message;
      // Check hasOwnProperty to detect undefined values.
      if (message.hasOwnProperty('answer')) {
        const { resolve, reject } = openQuestions[id];
        if (error) {
          reject(error);
        } else {
          resolve(answer);
        }
        delete openQuestions[id];
      } else if (message.hasOwnProperty('question')) {
        const answer = await agent({ ask, question });
        say({ id, answer });
      } else {
        throw Error('die');
      }
    };
    return { ask, hear };
  };



  var v8 = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  /*! https://mths.be/punycode v1.4.1 by @mathias */


  /** Highest positive signed 32-bit float value */
  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  var base$1 = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80
  var delimiter = '-'; // '\x2D'
  var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */
  var errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  };

  /** Convenience shortcuts */
  var baseMinusTMin = base$1 - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;

  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */
  function error(type) {
    throw new RangeError(errors[type]);
  }

  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */
  function map$3(array, fn) {
    var length = array.length;
    var result = [];
    while (length--) {
      result[length] = fn(array[length]);
    }
    return result;
  }

  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */
  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';
    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    }
    // Avoid `split(regex)` for IE8 compatibility. See #17.
    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map$3(labels, fn).join('.');
    return result + encoded;
  }

  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */
  function ucs2decode(string) {
    var output = [],
      counter = 0,
      length = string.length,
      value,
      extra;
    while (counter < length) {
      value = string.charCodeAt(counter++);
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);
        if ((extra & 0xFC00) == 0xDC00) { // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }

  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */
  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }

  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */
  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base$1) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }

  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */
  function encode(input) {
    var n,
      delta,
      handledCPCount,
      basicLength,
      bias,
      j,
      m,
      q,
      k,
      t,
      currentValue,
      output = [],
      /** `inputLength` will hold the number of code points in `input`. */
      inputLength,
      /** Cached calculation results */
      handledCPCountPlusOne,
      baseMinusT,
      qMinusT;

    // Convert the input in UCS-2 to Unicode
    input = ucs2decode(input);

    // Cache the length
    inputLength = input.length;

    // Initialize the state
    n = initialN;
    delta = 0;
    bias = initialBias;

    // Handle the basic code points
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length;

    // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.

    // Finish the basic string - if it is not empty - with a delimiter
    if (basicLength) {
      output.push(delimiter);
    }

    // Main encoding loop:
    while (handledCPCount < inputLength) {

      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }

      // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow
      handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base$1; /* no condition */ ; k += base$1) {
            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
            if (q < t) {
              break;
            }
            qMinusT = q - t;
            baseMinusT = base$1 - t;
            output.push(
              stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
            );
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;

    }
    return output.join('');
  }

  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */
  function toASCII(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ?
        'xn--' + encode(string) :
        string;
    });
  }

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init$2 () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init$2();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init$2();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  var isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var inherits;
  if (typeof Object.create === 'function'){
    inherits = function inherits(ctor, superCtor) {
      // implementation from standard node.js 'util' module
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  var inherits$1 = inherits;

  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  }

  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  function deprecate(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global$1.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  }

  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = process.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  }

  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      _extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }

  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    array.forEach(function(val, idx) {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value)
        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '', array = false, braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray$1(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray$1(ar) {
    return Array.isArray(ar);
  }

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }

  function isNull(arg) {
    return arg === null;
  }

  function isNullOrUndefined(arg) {
    return arg == null;
  }

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  function isString(arg) {
    return typeof arg === 'string';
  }

  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }

  function isUndefined(arg) {
    return arg === void 0;
  }

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
  }

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  function isPrimitive(arg) {
    return arg === null ||
           typeof arg === 'boolean' ||
           typeof arg === 'number' ||
           typeof arg === 'string' ||
           typeof arg === 'symbol' ||  // ES6 symbol
           typeof arg === 'undefined';
  }

  function isBuffer$1(maybeBuf) {
    return isBuffer(maybeBuf);
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }


  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }


  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];

  // 26 Feb 16:19:34
  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }


  // log is just a thin wrapper to console.log that prepends a timestamp
  function log$1() {
    console.log('%s - %s', timestamp(), format.apply(null, arguments));
  }

  function _extend(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;

    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var util = {
    inherits: inherits$1,
    _extend: _extend,
    log: log$1,
    isBuffer: isBuffer$1,
    isPrimitive: isPrimitive,
    isFunction: isFunction,
    isError: isError,
    isDate: isDate,
    isObject: isObject,
    isRegExp: isRegExp,
    isUndefined: isUndefined,
    isSymbol: isSymbol,
    isString: isString,
    isNumber: isNumber,
    isNullOrUndefined: isNullOrUndefined,
    isNull: isNull,
    isBoolean: isBoolean,
    isArray: isArray$1,
    inspect: inspect,
    deprecate: deprecate,
    format: format,
    debuglog: debuglog
  };

  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.


  // If obj.hasOwnProperty has been overridden, then calling
  // obj.hasOwnProperty(prop) will break.
  // See: https://github.com/joyent/node/issues/1707
  function hasOwnProperty$1(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var isArray$2 = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };
  function stringifyPrimitive(v) {
    switch (typeof v) {
      case 'string':
        return v;

      case 'boolean':
        return v ? 'true' : 'false';

      case 'number':
        return isFinite(v) ? v : '';

      default:
        return '';
    }
  }

  function stringify (obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }

    if (typeof obj === 'object') {
      return map$4(objectKeys(obj), function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (isArray$2(obj[k])) {
          return map$4(obj[k], function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);

    }

    if (!name) return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq +
           encodeURIComponent(stringifyPrimitive(obj));
  }
  function map$4 (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      res.push(f(xs[i], i));
    }
    return res;
  }

  var objectKeys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
  };

  function parse(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr, vstr, k, v;

      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }

      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);

      if (!hasOwnProperty$1(obj, k)) {
        obj[k] = v;
      } else if (isArray$2(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }

    return obj;
  }

  // Copyright Joyent, Inc. and other Node contributors.
  var require$$0$1 = {
    parse: urlParse,
    resolve: urlResolve,
    resolveObject: urlResolveObject,
    format: urlFormat,
    Url: Url
  };
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }

  // Reference: RFC 3986, RFC 1808, RFC 2396

  // define these here so at least they only have to be
  // compiled once on the first module load.
  var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    };

  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && isObject(url) && url instanceof Url) return url;

    var u = new Url;
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    return parse$1(this, url, parseQueryString, slashesDenoteHost);
  };

  function parse$1(self, url, parseQueryString, slashesDenoteHost) {
    if (!isString(url)) {
      throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    var queryIndex = url.indexOf('?'),
      splitter =
      (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, '/');
    url = uSplit.join(splitter);

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
      // Try fast path regexp
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        self.path = rest;
        self.href = rest;
        self.pathname = simplePath[1];
        if (simplePath[2]) {
          self.search = simplePath[2];
          if (parseQueryString) {
            self.query = parse(self.search.substr(1));
          } else {
            self.query = self.search.substr(1);
          }
        } else if (parseQueryString) {
          self.search = '';
          self.query = {};
        }
        return self;
      }
    }

    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      self.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === '//';
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        self.slashes = true;
      }
    }
    var i, hec, l, p;
    if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

      // there's a hostname.
      // the first instance of /, ?, ;, or # ends the host.
      //
      // If there is an @ in the hostname, then non-host chars *are* allowed
      // to the left of the last @ sign, unless some host-ending character
      // comes *before* the @-sign.
      // URLs are obnoxious.
      //
      // ex:
      // http://a@b@c/ => user:a@b host:c
      // http://a@b?@c => user:a host:c path:/?@c

      // v0.12 TODO(isaacs): This is not quite how Chrome does things.
      // Review our test case against browsers more comprehensively.

      // find the first instance of any hostEndingChars
      var hostEnd = -1;
      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }

      // at this point, either we have an explicit point where the
      // auth portion cannot go past, or the last @ char is the decider.
      var auth, atSign;
      if (hostEnd === -1) {
        // atSign can be anywhere.
        atSign = rest.lastIndexOf('@');
      } else {
        // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf('@', hostEnd);
      }

      // Now we have a portion which is definitely the auth.
      // Pull that off.
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        self.auth = decodeURIComponent(auth);
      }

      // the host is the remaining to the left of the first non-host char
      hostEnd = -1;
      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      // if we still have not hit it, then the entire thing is a host.
      if (hostEnd === -1)
        hostEnd = rest.length;

      self.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);

      // pull out port.
      parseHost(self);

      // we've indicated that there is a hostname,
      // so even if it's empty, it has to be present.
      self.hostname = self.hostname || '';

      // if hostname begins with [ and ends with ]
      // assume that it's an IPv6 address.
      var ipv6Hostname = self.hostname[0] === '[' &&
        self.hostname[self.hostname.length - 1] === ']';

      // validate a little.
      if (!ipv6Hostname) {
        var hostparts = self.hostname.split(/\./);
        for (i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = '';
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                // we replace non-ASCII char with a temporary placeholder
                // we need this to make sure size of hostname is not
                // broken by replacing non-ASCII by nothing
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            }
            // we test again with ASCII char only
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = '/' + notHost.join('.') + rest;
              }
              self.hostname = validParts.join('.');
              break;
            }
          }
        }
      }

      if (self.hostname.length > hostnameMaxLen) {
        self.hostname = '';
      } else {
        // hostnames are always lower case.
        self.hostname = self.hostname.toLowerCase();
      }

      if (!ipv6Hostname) {
        // IDNA Support: Returns a punycoded representation of "domain".
        // It only converts parts of the domain name that
        // have non-ASCII characters, i.e. it doesn't matter if
        // you call it with a domain that already is ASCII-only.
        self.hostname = toASCII(self.hostname);
      }

      p = self.port ? ':' + self.port : '';
      var h = self.hostname || '';
      self.host = h + p;
      self.href += self.host;

      // strip [ and ] from the hostname
      // the host field still retains them, though
      if (ipv6Hostname) {
        self.hostname = self.hostname.substr(1, self.hostname.length - 2);
        if (rest[0] !== '/') {
          rest = '/' + rest;
        }
      }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

      // First, make 100% sure that any "autoEscape" chars get
      // escaped, even if encodeURIComponent doesn't think they
      // need to be.
      for (i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1)
          continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }


    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
      // got a fragment string.
      self.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
      self.search = rest.substr(qm);
      self.query = rest.substr(qm + 1);
      if (parseQueryString) {
        self.query = parse(self.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      // no query string, but parseQueryString still requested
      self.search = '';
      self.query = {};
    }
    if (rest) self.pathname = rest;
    if (slashedProtocol[lowerProto] &&
      self.hostname && !self.pathname) {
      self.pathname = '/';
    }

    //to support http.request
    if (self.pathname || self.search) {
      p = self.pathname || '';
      var s = self.search || '';
      self.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    self.href = format$1(self);
    return self;
  }

  // format a parsed object into a url string
  function urlFormat(obj) {
    // ensure it's an object, and not a string url.
    // If it's an obj, this is a no-op.
    // this way, you can call url_format() on strings
    // to clean up potentially wonky urls.
    if (isString(obj)) obj = parse$1({}, obj);
    return format$1(obj);
  }

  function format$1(self) {
    var auth = self.auth || '';
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ':');
      auth += '@';
    }

    var protocol = self.protocol || '',
      pathname = self.pathname || '',
      hash = self.hash || '',
      host = false,
      query = '';

    if (self.host) {
      host = auth + self.host;
    } else if (self.hostname) {
      host = auth + (self.hostname.indexOf(':') === -1 ?
        self.hostname :
        '[' + this.hostname + ']');
      if (self.port) {
        host += ':' + self.port;
      }
    }

    if (self.query &&
      isObject(self.query) &&
      Object.keys(self.query).length) {
      query = stringify(self.query);
    }

    var search = self.search || (query && ('?' + query)) || '';

    if (protocol && protocol.substr(-1) !== ':') protocol += ':';

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (self.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = '//' + (host || '');
      if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
    } else if (!host) {
      host = '';
    }

    if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
    if (search && search.charAt(0) !== '?') search = '?' + search;

    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
  }

  Url.prototype.format = function() {
    return format$1(this);
  };

  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }

  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };

  function urlResolveObject(source, relative) {
    if (!source) return relative;
    return urlParse(source, false, true).resolveObject(relative);
  }

  Url.prototype.resolveObject = function(relative) {
    if (isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }

    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
      result.href = result.format();
      return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
      // take everything except the protocol from relative
      var rkeys = Object.keys(relative);
      for (var rk = 0; rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== 'protocol')
          result[rkey] = relative[rkey];
      }

      //urlParse appends trailing / to urls like http://www.example.com
      if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
        result.path = result.pathname = '/';
      }

      result.href = result.format();
      return result;
    }
    var relPath;
    if (relative.protocol && relative.protocol !== result.protocol) {
      // if it's a known url protocol, then changing
      // the protocol does weird things
      // first, if it's not file:, then we MUST have a host,
      // and if there was a path
      // to begin with, then we MUST have a path.
      // if it is file:, then the host is dropped,
      // because that's known to be hostless.
      // anything else is assumed to be absolute.
      if (!slashedProtocol[relative.protocol]) {
        var keys = Object.keys(relative);
        for (var v = 0; v < keys.length; v++) {
          var k = keys[v];
          result[k] = relative[k];
        }
        result.href = result.format();
        return result;
      }

      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        relPath = (relative.pathname || '').split('/');
        while (relPath.length && !(relative.host = relPath.shift()));
        if (!relative.host) relative.host = '';
        if (!relative.hostname) relative.hostname = '';
        if (relPath[0] !== '') relPath.unshift('');
        if (relPath.length < 2) relPath.unshift('');
        result.pathname = relPath.join('/');
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || '';
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      // to support http.request
      if (result.pathname || result.search) {
        var p = result.pathname || '';
        var s = result.search || '';
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }

    var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
        relative.host ||
        relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
        (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];
    relPath = relative.pathname && relative.pathname.split('/') || [];
    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
      result.hostname = '';
      result.port = null;
      if (result.host) {
        if (srcPath[0] === '') srcPath[0] = result.host;
        else srcPath.unshift(result.host);
      }
      result.host = '';
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === '') relPath[0] = relative.host;
          else relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }
    var authInHost;
    if (isRelAbs) {
      // it's absolute.
      result.host = (relative.host || relative.host === '') ?
        relative.host : result.host;
      result.hostname = (relative.hostname || relative.hostname === '') ?
        relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
      // fall through to the dot-handling below.
    } else if (relPath.length) {
      // it's relative
      // throw away the existing file, and take the new path instead.
      if (!srcPath) srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!isNullOrUndefined(relative.search)) {
      // just pull out the search.
      // like href='?foo'.
      // Put this after the other two cases because it simplifies the booleans
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        authInHost = result.host && result.host.indexOf('@') > 0 ?
          result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      //to support http.request
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
          (result.search ? result.search : '');
      }
      result.href = result.format();
      return result;
    }

    if (!srcPath.length) {
      // no path at all.  easy.
      // we've already handled the other stuff above.
      result.pathname = null;
      //to support http.request
      if (result.search) {
        result.path = '/' + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last === '.') {
        srcPath.splice(i, 1);
      } else if (last === '..') {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift('..');
      }
    }

    if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
      srcPath.unshift('');
    }

    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
      srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

    // put the host back
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? '' :
        srcPath.length ? srcPath.shift() : '';
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      authInHost = result.host && result.host.indexOf('@') > 0 ?
        result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    mustEndAbs = mustEndAbs || (result.host && srcPath.length);

    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift('');
    }

    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
        (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };

  Url.prototype.parseHost = function() {
    return parseHost(this);
  };

  function parseHost(self) {
    var host = self.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ':') {
        self.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) self.hostname = host;
  }

  const word = '[a-fA-F\\d:]';
  const b = options => options && options.includeBoundaries ?
  	`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` :
  	'';

  const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';

  const v6seg = '[a-fA-F\\d]{1,4}';
  const v6 = `
(
(?:${v6seg}:){7}(?:${v6seg}|:)|                                // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                         // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(:${v6seg}){1,2}|:)|                 // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(:${v6seg}){0,1}:${v4}|(:${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(:${v6seg}){0,2}:${v4}|(:${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(:${v6seg}){0,3}:${v4}|(:${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(:${v6seg}){0,4}:${v4}|(:${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::((?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))           // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(%[0-9a-zA-Z]{1,})?                                           // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();

  const ip = options => options && options.exact ?
  	new RegExp(`(?:^${v4}$)|(?:^${v6}$)`) :
  	new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, 'g');

  ip.v4 = options => options && options.exact ? new RegExp(`^${v4}$`) : new RegExp(`${b(options)}${v4}${b(options)}`, 'g');
  ip.v6 = options => options && options.exact ? new RegExp(`^${v6}$`) : new RegExp(`${b(options)}${v6}${b(options)}`, 'g');

  var ipRegex = ip;

  var tlds = [
    "aaa",
    "aarp",
    "abarth",
    "abb",
    "abbott",
    "abbvie",
    "abc",
    "able",
    "abogado",
    "abudhabi",
    "ac",
    "academy",
    "accenture",
    "accountant",
    "accountants",
    "aco",
    "actor",
    "ad",
    "adac",
    "ads",
    "adult",
    "ae",
    "aeg",
    "aero",
    "aetna",
    "af",
    "afamilycompany",
    "afl",
    "africa",
    "ag",
    "agakhan",
    "agency",
    "ai",
    "aig",
    "aigo",
    "airbus",
    "airforce",
    "airtel",
    "akdn",
    "al",
    "alfaromeo",
    "alibaba",
    "alipay",
    "allfinanz",
    "allstate",
    "ally",
    "alsace",
    "alstom",
    "am",
    "americanexpress",
    "americanfamily",
    "amex",
    "amfam",
    "amica",
    "amsterdam",
    "analytics",
    "android",
    "anquan",
    "anz",
    "ao",
    "aol",
    "apartments",
    "app",
    "apple",
    "aq",
    "aquarelle",
    "ar",
    "arab",
    "aramco",
    "archi",
    "army",
    "arpa",
    "art",
    "arte",
    "as",
    "asda",
    "asia",
    "associates",
    "at",
    "athleta",
    "attorney",
    "au",
    "auction",
    "audi",
    "audible",
    "audio",
    "auspost",
    "author",
    "auto",
    "autos",
    "avianca",
    "aw",
    "aws",
    "ax",
    "axa",
    "az",
    "azure",
    "ba",
    "baby",
    "baidu",
    "banamex",
    "bananarepublic",
    "band",
    "bank",
    "bar",
    "barcelona",
    "barclaycard",
    "barclays",
    "barefoot",
    "bargains",
    "baseball",
    "basketball",
    "bauhaus",
    "bayern",
    "bb",
    "bbc",
    "bbt",
    "bbva",
    "bcg",
    "bcn",
    "bd",
    "be",
    "beats",
    "beauty",
    "beer",
    "bentley",
    "berlin",
    "best",
    "bestbuy",
    "bet",
    "bf",
    "bg",
    "bh",
    "bharti",
    "bi",
    "bible",
    "bid",
    "bike",
    "bing",
    "bingo",
    "bio",
    "biz",
    "bj",
    "black",
    "blackfriday",
    "blockbuster",
    "blog",
    "bloomberg",
    "blue",
    "bm",
    "bms",
    "bmw",
    "bn",
    "bnpparibas",
    "bo",
    "boats",
    "boehringer",
    "bofa",
    "bom",
    "bond",
    "boo",
    "book",
    "booking",
    "bosch",
    "bostik",
    "boston",
    "bot",
    "boutique",
    "box",
    "br",
    "bradesco",
    "bridgestone",
    "broadway",
    "broker",
    "brother",
    "brussels",
    "bs",
    "bt",
    "budapest",
    "bugatti",
    "build",
    "builders",
    "business",
    "buy",
    "buzz",
    "bv",
    "bw",
    "by",
    "bz",
    "bzh",
    "ca",
    "cab",
    "cafe",
    "cal",
    "call",
    "calvinklein",
    "cam",
    "camera",
    "camp",
    "cancerresearch",
    "canon",
    "capetown",
    "capital",
    "capitalone",
    "car",
    "caravan",
    "cards",
    "care",
    "career",
    "careers",
    "cars",
    "casa",
    "case",
    "caseih",
    "cash",
    "casino",
    "cat",
    "catering",
    "catholic",
    "cba",
    "cbn",
    "cbre",
    "cbs",
    "cc",
    "cd",
    "ceb",
    "center",
    "ceo",
    "cern",
    "cf",
    "cfa",
    "cfd",
    "cg",
    "ch",
    "chanel",
    "channel",
    "charity",
    "chase",
    "chat",
    "cheap",
    "chintai",
    "christmas",
    "chrome",
    "church",
    "ci",
    "cipriani",
    "circle",
    "cisco",
    "citadel",
    "citi",
    "citic",
    "city",
    "cityeats",
    "ck",
    "cl",
    "claims",
    "cleaning",
    "click",
    "clinic",
    "clinique",
    "clothing",
    "cloud",
    "club",
    "clubmed",
    "cm",
    "cn",
    "co",
    "coach",
    "codes",
    "coffee",
    "college",
    "cologne",
    "com",
    "comcast",
    "commbank",
    "community",
    "company",
    "compare",
    "computer",
    "comsec",
    "condos",
    "construction",
    "consulting",
    "contact",
    "contractors",
    "cooking",
    "cookingchannel",
    "cool",
    "coop",
    "corsica",
    "country",
    "coupon",
    "coupons",
    "courses",
    "cpa",
    "cr",
    "credit",
    "creditcard",
    "creditunion",
    "cricket",
    "crown",
    "crs",
    "cruise",
    "cruises",
    "csc",
    "cu",
    "cuisinella",
    "cv",
    "cw",
    "cx",
    "cy",
    "cymru",
    "cyou",
    "cz",
    "dabur",
    "dad",
    "dance",
    "data",
    "date",
    "dating",
    "datsun",
    "day",
    "dclk",
    "dds",
    "de",
    "deal",
    "dealer",
    "deals",
    "degree",
    "delivery",
    "dell",
    "deloitte",
    "delta",
    "democrat",
    "dental",
    "dentist",
    "desi",
    "design",
    "dev",
    "dhl",
    "diamonds",
    "diet",
    "digital",
    "direct",
    "directory",
    "discount",
    "discover",
    "dish",
    "diy",
    "dj",
    "dk",
    "dm",
    "dnp",
    "do",
    "docs",
    "doctor",
    "dog",
    "domains",
    "dot",
    "download",
    "drive",
    "dtv",
    "dubai",
    "duck",
    "dunlop",
    "dupont",
    "durban",
    "dvag",
    "dvr",
    "dz",
    "earth",
    "eat",
    "ec",
    "eco",
    "edeka",
    "edu",
    "education",
    "ee",
    "eg",
    "email",
    "emerck",
    "energy",
    "engineer",
    "engineering",
    "enterprises",
    "epson",
    "equipment",
    "er",
    "ericsson",
    "erni",
    "es",
    "esq",
    "estate",
    "esurance",
    "et",
    "etisalat",
    "eu",
    "eurovision",
    "eus",
    "events",
    "exchange",
    "expert",
    "exposed",
    "express",
    "extraspace",
    "fage",
    "fail",
    "fairwinds",
    "faith",
    "family",
    "fan",
    "fans",
    "farm",
    "farmers",
    "fashion",
    "fast",
    "fedex",
    "feedback",
    "ferrari",
    "ferrero",
    "fi",
    "fiat",
    "fidelity",
    "fido",
    "film",
    "final",
    "finance",
    "financial",
    "fire",
    "firestone",
    "firmdale",
    "fish",
    "fishing",
    "fit",
    "fitness",
    "fj",
    "fk",
    "flickr",
    "flights",
    "flir",
    "florist",
    "flowers",
    "fly",
    "fm",
    "fo",
    "foo",
    "food",
    "foodnetwork",
    "football",
    "ford",
    "forex",
    "forsale",
    "forum",
    "foundation",
    "fox",
    "fr",
    "free",
    "fresenius",
    "frl",
    "frogans",
    "frontdoor",
    "frontier",
    "ftr",
    "fujitsu",
    "fujixerox",
    "fun",
    "fund",
    "furniture",
    "futbol",
    "fyi",
    "ga",
    "gal",
    "gallery",
    "gallo",
    "gallup",
    "game",
    "games",
    "gap",
    "garden",
    "gay",
    "gb",
    "gbiz",
    "gd",
    "gdn",
    "ge",
    "gea",
    "gent",
    "genting",
    "george",
    "gf",
    "gg",
    "ggee",
    "gh",
    "gi",
    "gift",
    "gifts",
    "gives",
    "giving",
    "gl",
    "glade",
    "glass",
    "gle",
    "global",
    "globo",
    "gm",
    "gmail",
    "gmbh",
    "gmo",
    "gmx",
    "gn",
    "godaddy",
    "gold",
    "goldpoint",
    "golf",
    "goo",
    "goodyear",
    "goog",
    "google",
    "gop",
    "got",
    "gov",
    "gp",
    "gq",
    "gr",
    "grainger",
    "graphics",
    "gratis",
    "green",
    "gripe",
    "grocery",
    "group",
    "gs",
    "gt",
    "gu",
    "guardian",
    "gucci",
    "guge",
    "guide",
    "guitars",
    "guru",
    "gw",
    "gy",
    "hair",
    "hamburg",
    "hangout",
    "haus",
    "hbo",
    "hdfc",
    "hdfcbank",
    "health",
    "healthcare",
    "help",
    "helsinki",
    "here",
    "hermes",
    "hgtv",
    "hiphop",
    "hisamitsu",
    "hitachi",
    "hiv",
    "hk",
    "hkt",
    "hm",
    "hn",
    "hockey",
    "holdings",
    "holiday",
    "homedepot",
    "homegoods",
    "homes",
    "homesense",
    "honda",
    "horse",
    "hospital",
    "host",
    "hosting",
    "hot",
    "hoteles",
    "hotels",
    "hotmail",
    "house",
    "how",
    "hr",
    "hsbc",
    "ht",
    "hu",
    "hughes",
    "hyatt",
    "hyundai",
    "ibm",
    "icbc",
    "ice",
    "icu",
    "id",
    "ie",
    "ieee",
    "ifm",
    "ikano",
    "il",
    "im",
    "imamat",
    "imdb",
    "immo",
    "immobilien",
    "in",
    "inc",
    "industries",
    "infiniti",
    "info",
    "ing",
    "ink",
    "institute",
    "insurance",
    "insure",
    "int",
    "intel",
    "international",
    "intuit",
    "investments",
    "io",
    "ipiranga",
    "iq",
    "ir",
    "irish",
    "is",
    "ismaili",
    "ist",
    "istanbul",
    "it",
    "itau",
    "itv",
    "iveco",
    "jaguar",
    "java",
    "jcb",
    "jcp",
    "je",
    "jeep",
    "jetzt",
    "jewelry",
    "jio",
    "jll",
    "jm",
    "jmp",
    "jnj",
    "jo",
    "jobs",
    "joburg",
    "jot",
    "joy",
    "jp",
    "jpmorgan",
    "jprs",
    "juegos",
    "juniper",
    "kaufen",
    "kddi",
    "ke",
    "kerryhotels",
    "kerrylogistics",
    "kerryproperties",
    "kfh",
    "kg",
    "kh",
    "ki",
    "kia",
    "kim",
    "kinder",
    "kindle",
    "kitchen",
    "kiwi",
    "km",
    "kn",
    "koeln",
    "komatsu",
    "kosher",
    "kp",
    "kpmg",
    "kpn",
    "kr",
    "krd",
    "kred",
    "kuokgroup",
    "kw",
    "ky",
    "kyoto",
    "kz",
    "la",
    "lacaixa",
    "lamborghini",
    "lamer",
    "lancaster",
    "lancia",
    "land",
    "landrover",
    "lanxess",
    "lasalle",
    "lat",
    "latino",
    "latrobe",
    "law",
    "lawyer",
    "lb",
    "lc",
    "lds",
    "lease",
    "leclerc",
    "lefrak",
    "legal",
    "lego",
    "lexus",
    "lgbt",
    "li",
    "liaison",
    "lidl",
    "life",
    "lifeinsurance",
    "lifestyle",
    "lighting",
    "like",
    "lilly",
    "limited",
    "limo",
    "lincoln",
    "linde",
    "link",
    "lipsy",
    "live",
    "living",
    "lixil",
    "lk",
    "llc",
    "loan",
    "loans",
    "locker",
    "locus",
    "loft",
    "lol",
    "london",
    "lotte",
    "lotto",
    "love",
    "lpl",
    "lplfinancial",
    "lr",
    "ls",
    "lt",
    "ltd",
    "ltda",
    "lu",
    "lundbeck",
    "lupin",
    "luxe",
    "luxury",
    "lv",
    "ly",
    "ma",
    "macys",
    "madrid",
    "maif",
    "maison",
    "makeup",
    "man",
    "management",
    "mango",
    "map",
    "market",
    "marketing",
    "markets",
    "marriott",
    "marshalls",
    "maserati",
    "mattel",
    "mba",
    "mc",
    "mckinsey",
    "md",
    "me",
    "med",
    "media",
    "meet",
    "melbourne",
    "meme",
    "memorial",
    "men",
    "menu",
    "merckmsd",
    "metlife",
    "mg",
    "mh",
    "miami",
    "microsoft",
    "mil",
    "mini",
    "mint",
    "mit",
    "mitsubishi",
    "mk",
    "ml",
    "mlb",
    "mls",
    "mm",
    "mma",
    "mn",
    "mo",
    "mobi",
    "mobile",
    "moda",
    "moe",
    "moi",
    "mom",
    "monash",
    "money",
    "monster",
    "mormon",
    "mortgage",
    "moscow",
    "moto",
    "motorcycles",
    "mov",
    "movie",
    "movistar",
    "mp",
    "mq",
    "mr",
    "ms",
    "msd",
    "mt",
    "mtn",
    "mtr",
    "mu",
    "museum",
    "mutual",
    "mv",
    "mw",
    "mx",
    "my",
    "mz",
    "na",
    "nab",
    "nadex",
    "nagoya",
    "name",
    "nationwide",
    "natura",
    "navy",
    "nba",
    "nc",
    "ne",
    "nec",
    "net",
    "netbank",
    "netflix",
    "network",
    "neustar",
    "new",
    "newholland",
    "news",
    "next",
    "nextdirect",
    "nexus",
    "nf",
    "nfl",
    "ng",
    "ngo",
    "nhk",
    "ni",
    "nico",
    "nike",
    "nikon",
    "ninja",
    "nissan",
    "nissay",
    "nl",
    "no",
    "nokia",
    "northwesternmutual",
    "norton",
    "now",
    "nowruz",
    "nowtv",
    "np",
    "nr",
    "nra",
    "nrw",
    "ntt",
    "nu",
    "nyc",
    "nz",
    "obi",
    "observer",
    "off",
    "office",
    "okinawa",
    "olayan",
    "olayangroup",
    "oldnavy",
    "ollo",
    "om",
    "omega",
    "one",
    "ong",
    "onl",
    "online",
    "onyourside",
    "ooo",
    "open",
    "oracle",
    "orange",
    "org",
    "organic",
    "origins",
    "osaka",
    "otsuka",
    "ott",
    "ovh",
    "pa",
    "page",
    "panasonic",
    "paris",
    "pars",
    "partners",
    "parts",
    "party",
    "passagens",
    "pay",
    "pccw",
    "pe",
    "pet",
    "pf",
    "pfizer",
    "pg",
    "ph",
    "pharmacy",
    "phd",
    "philips",
    "phone",
    "photo",
    "photography",
    "photos",
    "physio",
    "pics",
    "pictet",
    "pictures",
    "pid",
    "pin",
    "ping",
    "pink",
    "pioneer",
    "pizza",
    "pk",
    "pl",
    "place",
    "play",
    "playstation",
    "plumbing",
    "plus",
    "pm",
    "pn",
    "pnc",
    "pohl",
    "poker",
    "politie",
    "porn",
    "post",
    "pr",
    "pramerica",
    "praxi",
    "press",
    "prime",
    "pro",
    "prod",
    "productions",
    "prof",
    "progressive",
    "promo",
    "properties",
    "property",
    "protection",
    "pru",
    "prudential",
    "ps",
    "pt",
    "pub",
    "pw",
    "pwc",
    "py",
    "qa",
    "qpon",
    "quebec",
    "quest",
    "qvc",
    "racing",
    "radio",
    "raid",
    "re",
    "read",
    "realestate",
    "realtor",
    "realty",
    "recipes",
    "red",
    "redstone",
    "redumbrella",
    "rehab",
    "reise",
    "reisen",
    "reit",
    "reliance",
    "ren",
    "rent",
    "rentals",
    "repair",
    "report",
    "republican",
    "rest",
    "restaurant",
    "review",
    "reviews",
    "rexroth",
    "rich",
    "richardli",
    "ricoh",
    "rightathome",
    "ril",
    "rio",
    "rip",
    "rmit",
    "ro",
    "rocher",
    "rocks",
    "rodeo",
    "rogers",
    "room",
    "rs",
    "rsvp",
    "ru",
    "rugby",
    "ruhr",
    "run",
    "rw",
    "rwe",
    "ryukyu",
    "sa",
    "saarland",
    "safe",
    "safety",
    "sakura",
    "sale",
    "salon",
    "samsclub",
    "samsung",
    "sandvik",
    "sandvikcoromant",
    "sanofi",
    "sap",
    "sarl",
    "sas",
    "save",
    "saxo",
    "sb",
    "sbi",
    "sbs",
    "sc",
    "sca",
    "scb",
    "schaeffler",
    "schmidt",
    "scholarships",
    "school",
    "schule",
    "schwarz",
    "science",
    "scjohnson",
    "scor",
    "scot",
    "sd",
    "se",
    "search",
    "seat",
    "secure",
    "security",
    "seek",
    "select",
    "sener",
    "services",
    "ses",
    "seven",
    "sew",
    "sex",
    "sexy",
    "sfr",
    "sg",
    "sh",
    "shangrila",
    "sharp",
    "shaw",
    "shell",
    "shia",
    "shiksha",
    "shoes",
    "shop",
    "shopping",
    "shouji",
    "show",
    "showtime",
    "shriram",
    "si",
    "silk",
    "sina",
    "singles",
    "site",
    "sj",
    "sk",
    "ski",
    "skin",
    "sky",
    "skype",
    "sl",
    "sling",
    "sm",
    "smart",
    "smile",
    "sn",
    "sncf",
    "so",
    "soccer",
    "social",
    "softbank",
    "software",
    "sohu",
    "solar",
    "solutions",
    "song",
    "sony",
    "soy",
    "space",
    "sport",
    "spot",
    "spreadbetting",
    "sr",
    "srl",
    "ss",
    "st",
    "stada",
    "staples",
    "star",
    "statebank",
    "statefarm",
    "stc",
    "stcgroup",
    "stockholm",
    "storage",
    "store",
    "stream",
    "studio",
    "study",
    "style",
    "su",
    "sucks",
    "supplies",
    "supply",
    "support",
    "surf",
    "surgery",
    "suzuki",
    "sv",
    "swatch",
    "swiftcover",
    "swiss",
    "sx",
    "sy",
    "sydney",
    "symantec",
    "systems",
    "sz",
    "tab",
    "taipei",
    "talk",
    "taobao",
    "target",
    "tatamotors",
    "tatar",
    "tattoo",
    "tax",
    "taxi",
    "tc",
    "tci",
    "td",
    "tdk",
    "team",
    "tech",
    "technology",
    "tel",
    "telefonica",
    "temasek",
    "tennis",
    "teva",
    "tf",
    "tg",
    "th",
    "thd",
    "theater",
    "theatre",
    "tiaa",
    "tickets",
    "tienda",
    "tiffany",
    "tips",
    "tires",
    "tirol",
    "tj",
    "tjmaxx",
    "tjx",
    "tk",
    "tkmaxx",
    "tl",
    "tm",
    "tmall",
    "tn",
    "to",
    "today",
    "tokyo",
    "tools",
    "top",
    "toray",
    "toshiba",
    "total",
    "tours",
    "town",
    "toyota",
    "toys",
    "tr",
    "trade",
    "trading",
    "training",
    "travel",
    "travelchannel",
    "travelers",
    "travelersinsurance",
    "trust",
    "trv",
    "tt",
    "tube",
    "tui",
    "tunes",
    "tushu",
    "tv",
    "tvs",
    "tw",
    "tz",
    "ua",
    "ubank",
    "ubs",
    "ug",
    "uk",
    "unicom",
    "university",
    "uno",
    "uol",
    "ups",
    "us",
    "uy",
    "uz",
    "va",
    "vacations",
    "vana",
    "vanguard",
    "vc",
    "ve",
    "vegas",
    "ventures",
    "verisign",
    "versicherung",
    "vet",
    "vg",
    "vi",
    "viajes",
    "video",
    "vig",
    "viking",
    "villas",
    "vin",
    "vip",
    "virgin",
    "visa",
    "vision",
    "vistaprint",
    "viva",
    "vivo",
    "vlaanderen",
    "vn",
    "vodka",
    "volkswagen",
    "volvo",
    "vote",
    "voting",
    "voto",
    "voyage",
    "vu",
    "vuelos",
    "wales",
    "walmart",
    "walter",
    "wang",
    "wanggou",
    "watch",
    "watches",
    "weather",
    "weatherchannel",
    "webcam",
    "weber",
    "website",
    "wed",
    "wedding",
    "weibo",
    "weir",
    "wf",
    "whoswho",
    "wien",
    "wiki",
    "williamhill",
    "win",
    "windows",
    "wine",
    "winners",
    "wme",
    "wolterskluwer",
    "woodside",
    "work",
    "works",
    "world",
    "wow",
    "ws",
    "wtc",
    "wtf",
    "xbox",
    "xerox",
    "xfinity",
    "xihuan",
    "xin",
    "à¤•à¥‰à¤®", // xn--11b4c3d
    "ã‚»ãƒ¼ãƒ«", // xn--1ck2e1b
    "ä½›å±±", // xn--1qqw23a
    "à²­à²¾à²°à²¤", // xn--2scrj9c
    "æ…ˆå–„", // xn--30rr7y
    "é›†å›¢", // xn--3bst00m
    "åœ¨çº¿", // xn--3ds443g
    "í•œêµ­", // xn--3e0b707e
    "à¬­à¬¾à¬°à¬¤", // xn--3hcrj9c
    "å¤§ä¼—æ±½è½¦", // xn--3oq18vl8pn36a
    "ç‚¹çœ‹", // xn--3pxu8k
    "à¸„à¸­à¸¡", // xn--42c2d9a
    "à¦­à¦¾à§°à¦¤", // xn--45br5cyl
    "à¦­à¦¾à¦°à¦¤", // xn--45brj9c
    "å…«å¦", // xn--45q11c
    "Ù…ÙˆÙ‚Ø¹", // xn--4gbrim
    "à¦¬à¦¾à¦‚à¦²à¦¾", // xn--54b7fta0cc
    "å…¬ç›Š", // xn--55qw42g
    "å…¬å¸", // xn--55qx5d
    "é¦™æ ¼é‡Œæ‹‰", // xn--5su34j936bgsg
    "ç½‘ç«™", // xn--5tzm5g
    "ç§»åŠ¨", // xn--6frz82g
    "æˆ‘çˆ±ä½ ", // xn--6qq986b3xl
    "Ð¼Ð¾ÑÐºÐ²Ð°", // xn--80adxhks
    "Ò›Ð°Ð·", // xn--80ao21a
    "ÐºÐ°Ñ‚Ð¾Ð»Ð¸Ðº", // xn--80aqecdr1a
    "Ð¾Ð½Ð»Ð°Ð¹Ð½", // xn--80asehdb
    "ÑÐ°Ð¹Ñ‚", // xn--80aswg
    "è”é€š", // xn--8y0a063a
    "ÑÑ€Ð±", // xn--90a3ac
    "Ð±Ð³", // xn--90ae
    "Ð±ÐµÐ»", // xn--90ais
    "×§×•×", // xn--9dbq2a
    "æ—¶å°š", // xn--9et52u
    "å¾®åš", // xn--9krt00a
    "æ·¡é©¬é”¡", // xn--b4w605ferd
    "ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³", // xn--bck1b9a5dre4c
    "Ð¾Ñ€Ð³", // xn--c1avg
    "à¤¨à¥‡à¤Ÿ", // xn--c2br7g
    "ã‚¹ãƒˆã‚¢", // xn--cck2b3b
    "ì‚¼ì„±", // xn--cg4bki
    "à®šà®¿à®™à¯à®•à®ªà¯à®ªà¯‚à®°à¯", // xn--clchc0ea0b2g2a9gcd
    "å•†æ ‡", // xn--czr694b
    "å•†åº—", // xn--czrs0t
    "å•†åŸŽ", // xn--czru2d
    "Ð´ÐµÑ‚Ð¸", // xn--d1acj3b
    "Ð¼ÐºÐ´", // xn--d1alf
    "ÐµÑŽ", // xn--e1a4c
    "ãƒã‚¤ãƒ³ãƒˆ", // xn--eckvdtc9d
    "æ–°é—»", // xn--efvy88h
    "å·¥è¡Œ", // xn--estv75g
    "å®¶é›»", // xn--fct429k
    "ÙƒÙˆÙ…", // xn--fhbei
    "ä¸­æ–‡ç½‘", // xn--fiq228c5hs
    "ä¸­ä¿¡", // xn--fiq64b
    "ä¸­å›½", // xn--fiqs8s
    "ä¸­åœ‹", // xn--fiqz9s
    "å¨±ä¹", // xn--fjq720a
    "è°·æ­Œ", // xn--flw351e
    "à°­à°¾à°°à°¤à±", // xn--fpcrj9c3d
    "à¶½à¶‚à¶šà·", // xn--fzc2c9e2c
    "é›»è¨Šç›ˆç§‘", // xn--fzys8d69uvgm
    "è´­ç‰©", // xn--g2xx48c
    "ã‚¯ãƒ©ã‚¦ãƒ‰", // xn--gckr3f0f
    "àª­àª¾àª°àª¤", // xn--gecrj9c
    "é€šè²©", // xn--gk3at1e
    "à¤­à¤¾à¤°à¤¤à¤®à¥", // xn--h2breg3eve
    "à¤­à¤¾à¤°à¤¤", // xn--h2brj9c
    "à¤­à¤¾à¤°à¥‹à¤¤", // xn--h2brj9c8c
    "ç½‘åº—", // xn--hxt814e
    "à¤¸à¤‚à¤—à¤ à¤¨", // xn--i1b6b1a6a2e
    "é¤åŽ…", // xn--imr513n
    "ç½‘ç»œ", // xn--io0a7i
    "ÐºÐ¾Ð¼", // xn--j1aef
    "ÑƒÐºÑ€", // xn--j1amh
    "é¦™æ¸¯", // xn--j6w193g
    "è¯ºåŸºäºš", // xn--jlq61u9w7b
    "é£Ÿå“", // xn--jvr189m
    "é£žåˆ©æµ¦", // xn--kcrx77d1x4a
    "å°æ¹¾", // xn--kprw13d
    "å°ç£", // xn--kpry57d
    "æ‰‹è¡¨", // xn--kpu716f
    "æ‰‹æœº", // xn--kput3i
    "Ð¼Ð¾Ð½", // xn--l1acc
    "Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±", // xn--lgbbat1ad8j
    "Ø¹Ù…Ø§Ù†", // xn--mgb9awbf
    "Ø§Ø±Ø§Ù…ÙƒÙˆ", // xn--mgba3a3ejt
    "Ø§ÛŒØ±Ø§Ù†", // xn--mgba3a4f16a
    "Ø§Ù„Ø¹Ù„ÙŠØ§Ù†", // xn--mgba7c0bbn0a
    "Ø§ØªØµØ§Ù„Ø§Øª", // xn--mgbaakc7dvf
    "Ø§Ù…Ø§Ø±Ø§Øª", // xn--mgbaam7a8h
    "Ø¨Ø§Ø²Ø§Ø±", // xn--mgbab2bd
    "Ù…ÙˆØ±ÙŠØªØ§Ù†ÙŠØ§", // xn--mgbah1a3hjkrd
    "Ù¾Ø§Ú©Ø³ØªØ§Ù†", // xn--mgbai9azgqp6j
    "Ø§Ù„Ø§Ø±Ø¯Ù†", // xn--mgbayh7gpa
    "Ø¨Ø§Ø±Øª", // xn--mgbbh1a
    "Ø¨Ú¾Ø§Ø±Øª", // xn--mgbbh1a71e
    "Ø§Ù„Ù…ØºØ±Ø¨", // xn--mgbc0a9azcg
    "Ø§Ø¨ÙˆØ¸Ø¨ÙŠ", // xn--mgbca7dzdo
    "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©", // xn--mgberp4a5d4ar
    "Ú€Ø§Ø±Øª", // xn--mgbgu82a
    "ÙƒØ§Ø«ÙˆÙ„ÙŠÙƒ", // xn--mgbi4ecexp
    "Ø³ÙˆØ¯Ø§Ù†", // xn--mgbpl2fh
    "Ù‡Ù…Ø±Ø§Ù‡", // xn--mgbt3dhd
    "Ø¹Ø±Ø§Ù‚", // xn--mgbtx2b
    "Ù…Ù„ÙŠØ³ÙŠØ§", // xn--mgbx4cd0ab
    "æ¾³é–€", // xn--mix891f
    "ë‹·ì»´", // xn--mk1bu44c
    "æ”¿åºœ", // xn--mxtq1m
    "Ø´Ø¨ÙƒØ©", // xn--ngbc5azd
    "Ø¨ÙŠØªÙƒ", // xn--ngbe9e0a
    "Ø¹Ø±Ø¨", // xn--ngbrx
    "áƒ’áƒ”", // xn--node
    "æœºæž„", // xn--nqv7f
    "ç»„ç»‡æœºæž„", // xn--nqv7fs00ema
    "å¥åº·", // xn--nyqy26a
    "à¹„à¸—à¸¢", // xn--o3cw4h
    "Ø³ÙˆØ±ÙŠØ©", // xn--ogbpf8fl
    "æ‹›è˜", // xn--otu796d
    "Ñ€ÑƒÑ", // xn--p1acf
    "Ñ€Ñ„", // xn--p1ai
    "ç å®", // xn--pbt977c
    "ØªÙˆÙ†Ø³", // xn--pgbs0dh
    "å¤§æ‹¿", // xn--pssy2u
    "ã¿ã‚“ãª", // xn--q9jyb4c
    "ã‚°ãƒ¼ã‚°ãƒ«", // xn--qcka1pmc
    "ÎµÏ…", // xn--qxa6a
    "ÎµÎ»", // xn--qxam
    "ä¸–ç•Œ", // xn--rhqv96g
    "æ›¸ç±", // xn--rovu88b
    "à´­à´¾à´°à´¤à´‚", // xn--rvc1e0am3e
    "à¨­à¨¾à¨°à¨¤", // xn--s9brj9c
    "ç½‘å€", // xn--ses554g
    "ë‹·ë„·", // xn--t60b56a
    "ã‚³ãƒ ", // xn--tckwe
    "å¤©ä¸»æ•™", // xn--tiq49xqyj
    "æ¸¸æˆ", // xn--unup4y
    "vermÃ¶gensberater", // xn--vermgensberater-ctb
    "vermÃ¶gensberatung", // xn--vermgensberatung-pwb
    "ä¼ä¸š", // xn--vhquv
    "ä¿¡æ¯", // xn--vuq861b
    "å˜‰é‡Œå¤§é…’åº—", // xn--w4r85el8fhu5dnra
    "å˜‰é‡Œ", // xn--w4rs40l
    "Ù…ØµØ±", // xn--wgbh1c
    "Ù‚Ø·Ø±", // xn--wgbl6a
    "å¹¿ä¸œ", // xn--xhq521b
    "à®‡à®²à®™à¯à®•à¯ˆ", // xn--xkc2al3hye2a
    "à®‡à®¨à¯à®¤à®¿à®¯à®¾", // xn--xkc2dl3a5ee0h
    "Õ°Õ¡Õµ", // xn--y9a3aq
    "æ–°åŠ å¡", // xn--yfro4i67o
    "ÙÙ„Ø³Ø·ÙŠÙ†", // xn--ygbi2ammx
    "æ”¿åŠ¡", // xn--zfr164b
    "xxx",
    "xyz",
    "yachts",
    "yahoo",
    "yamaxun",
    "yandex",
    "ye",
    "yodobashi",
    "yoga",
    "yokohama",
    "you",
    "youtube",
    "yt",
    "yun",
    "za",
    "zappos",
    "zara",
    "zero",
    "zip",
    "zm",
    "zone",
    "zuerich",
    "zw"
  ];

  var urlRegex = options => {
  	options = {
  		strict: true,
  		...options
  	};

  	const protocol = `(?:(?:[a-z]+:)?//)${options.strict ? '' : '?'}`;
  	const auth = '(?:\\S+(?::\\S*)?@)?';
  	const ip = ipRegex.v4().source;
  	const host = '(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)';
  	const domain = '(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*';
  	const tld = `(?:\\.${options.strict ? '(?:[a-z\\u00a1-\\uffff]{2,})' : `(?:${tlds.sort((a, b) => b.length - a.length).join('|')})`})\\.?`;
  	const port = '(?::\\d{2,5})?';
  	const path = '(?:[/?#][^\\s"]*)?';
  	const regex = `(?:${protocol}|www\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;

  	return options.exact ? new RegExp(`(?:^${regex}$)`, 'i') : new RegExp(regex, 'ig');
  };

  const URL = commonjsGlobal.window ? window.URL : require$$0$1.URL;
  const urlRegex$1 = urlRegex({ exact: true });

  const REGEX_HTTP_PROTOCOL = /^https?:\/\//i;

  var isUrlHttp = url => {
    try {
      const { href } = new URL(url);
      return REGEX_HTTP_PROTOCOL.test(href) && urlRegex$1.test(href)
    } catch (err) {
      return false
    }
  };

  var nodeFetch = {};

  // Copyright Joyent, Inc. and other Node contributors.

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  function dirname(path) {
    var result = splitPath(path),
        root = result[0],
        dir = result[1];

    if (!root && !dir) {
      // No dirname whatsoever
      return '.';
    }

    if (dir) {
      // It has a dirname, strip trailing slash
      dir = dir.substr(0, dir.length - 1);
    }

    return root + dir;
  }

  /* global self */

  const { promises } = fs;
  const { serialize } = v8;

  // FIX Convert data by representation.

  const writeFile = async (options, path, data) => {
    data = await data;
    // FIX: Should be checking for a proxy fs, not webworker.
    if (isWebWorker) {
      return self.ask({ writeFile: { options: { ...options, as: 'bytes' }, path, data: await data } });
    }

    const { doSerialize = true, ephemeral, project = getFilesystem() } = options;
    let originalProject = getFilesystem();
    if (project !== originalProject) {
      log({ op: 'text', text: `Write ${path} of ${project}` });
      // Switch to the source filesystem, if necessary.
      setupFilesystem({ fileBase: project });
    }

    await log({ op: 'text', text: `Write ${path}` });
    const file = await getFile(options, path);
    file.data = data;

    for (const watcher of file.watchers) {
      await watcher(options, file);
    }

    const base = getBase();
    if (!ephemeral && base !== undefined) {
      const persistentPath = qualifyPath(path);
      if (isNode) {
        try {
          await promises.mkdir(dirname(persistentPath), { recursive: true });
        } catch (error) {
        }
        try {
          if (doSerialize) {
            data = serialize(data);
          }
          await promises.writeFile(persistentPath, data);
        } catch (error) {
        }
      } else if (isBrowser) {
        await db().setItem(persistentPath, data);
      }
    }

    if (project !== originalProject) {
      // Switch back to the original filesystem, if necessary.
      setupFilesystem({ fileBase: originalProject });
    }
  };

  /* global self */

  const { promises: promises$1 } = fs;
  const { deserialize } = v8;

  const getUrlFetcher = async () => {
    if (typeof window !== 'undefined') {
      return window.fetch;
    } else {
      return nodeFetch;
    }
  };

  const getFileFetcher = async (qualify = qualifyPath, doSerialize = true) => {
    if (isNode) {
      // FIX: Put this through getFile, also.
      return async (path) => {
        let data = await promises$1.readFile(qualify(path));
        if (doSerialize) {
          data = deserialize(data);
        }
        return data;
      };
    } else if (isBrowser) {
      return async (path) => {
        const data = await db().getItem(qualify(path));
        if (data !== null) {
          return data;
        }
      };
    } else {
      throw Error('die');
    }
  };

  // Fetch from internal store.
  const fetchPersistent = async (path, doSerialize) => {
    try {
      const base = getBase();
      if (base !== undefined) {
        const fetchFile = await getFileFetcher(qualifyPath, doSerialize);
        const data = await fetchFile(path);
        return data;
      }
    } catch (e) {
      if (e.code && e.code === 'ENOENT') {
        return;
      }
      console.log(e);
    }
  };

  // Fetch from external sources.
  const fetchSources = async (options = {}, sources) => {
    const fetchUrl = await getUrlFetcher();
    const fetchFile = await getFileFetcher(path => path, false);
    // Try to load the data from a source.
    for (const source of sources) {
      if (typeof source === 'string') {
        try {
          if (isUrlHttp(source)) {
            log({ op: 'text', text: `# Fetching ${source}` });
            const response = await fetchUrl(source);
            if (response.ok) {
              return new Uint8Array(await response.arrayBuffer());
            }
          } else {
            // Assume a file path.
            const data = await fetchFile(source);
            if (data !== undefined) {
              return data;
            }
          }
        } catch (e) {
        }
      } else {
        throw Error('die');
      }
    }
  };

  const readFile = async (options, path) => {
    const { allowFetch = true, ephemeral } = options;
    if (isWebWorker) {
      return self.ask({ readFile: { options, path } });
    }
    const { sources = [], project = getFilesystem(), useCache = true } = options;
    let originalProject = getFilesystem();
    if (project !== originalProject) {
      log({ op: 'text', text: `Read ${path} of ${project}` });
      // Switch to the source filesystem, if necessary.
      setupFilesystem({ fileBase: project });
    } else {
      log({ op: 'text', text: `Read ${path}` });
    }
    const file = await getFile(options, path);
    if (file.data === undefined || useCache === false) {
      file.data = await fetchPersistent(path, true);
    }
    if (project !== originalProject) {
      // Switch back to the original filesystem, if necessary.
      setupFilesystem({ fileBase: originalProject });
    }
    if (file.data === undefined && allowFetch) {
      file.data = await fetchSources({}, sources);
      if (!ephemeral && file.data !== undefined) {
        // Update persistent cache.
        await writeFile({ ...options, doSerialize: true }, path, file.data);
      }
    }
    if (file.data !== undefined) {
      if (file.data.then) {
        // Resolve any outstanding promises.
        file.data = await file.data;
      }
    }
    return file.data;
  };

  let clipper$1;

  const setup = async () => {
    if (clipper$1 === undefined) {
      clipper$1 = await jsAngusjClipperjsWeb_12(
        // let it autodetect which one to use, but also available WasmOnly and AsmJsOnly
        // NativeClipperLibRequestedFormat.WasmWithAsmJsFallback
        jsAngusjClipperjsWeb_6.WasmOnly
      );
      clipper$1.strictlySimple = true;
      clipper$1.preserveCollinear = true;
    }
  };

  function IntPoint (x, y) {
    this.x = x;
    this.y = y;
  }
  onBoot(setup);

  // CHECK: Should this be sqrt(2)?
  const CLEAN_DISTANCE = 1;

  const RESOLUTION = 1e6;

  const clockOrder = (a) => isClockwise(a) ? 1 : 0;

  // Reorder in-place such that counterclockwise paths preceed clockwise paths.
  const clockSort = (surface) => {
    surface.sort((a, b) => clockOrder(a) - clockOrder(b));
    return surface;
  };

  const toInt = (integer) => Math.round(integer * RESOLUTION);
  const toFloat = (integer) => integer / RESOLUTION;

  const fromSurface = (surface, normalize) => {
    const normalized = surface.map(path => path.map(normalize));
    const scaled = normalized.map(path => path.map(([X, Y]) => [toInt(X), toInt(Y), 0]));
    const filtered = scaled.filter(path => toPlane(path) !== undefined);
    return filtered.map(path => path.map(([X, Y]) => new IntPoint(X, Y)));
  };

  const fromSurfaceAsClosedPaths = (surface, normalize) => {
    const normalized = surface.map(path => path.map(normalize));
    const integers = normalized.map(path => path.map(([X, Y]) => [toInt(X), toInt(Y), 0]));
    const filtered = integers.filter(path => toPlane(path) !== undefined);
    return filtered.map(path => ({ data: path.map(([X, Y]) => new IntPoint(X, Y)), closed: true }));
  };

  const fromSurfaceToIntegers = (surface, normalize) => {
    const normalized = surface.map(path => path.map(normalize));
    const integers = normalized.map(path => path.map(([X, Y]) => [toInt(X), toInt(Y), 0]));
    return integers;
  };

  const fromIntegersToClosedPaths = (integers) => {
    return integers.map(path => ({ data: path.map(([X, Y]) => new IntPoint(X, Y)), closed: true }));
  };

  const fromOpenPaths = (paths, normalize) => {
    const openPaths = [];
    for (const path of paths) {
      if (isOpen(path)) {
        const openPath = [];
        for (let i = 1; i < path.length; i++) {
          const [x, y] = normalize(path[i]);
          openPath.push(new IntPoint(toInt(x), toInt(y)));
        }
        openPaths.push(openPath);
      }
    }
    return openPaths;
  };

  const fromPaths = (paths, normalize) => {
    const clipperPaths = [];
    const closedPaths = fromClosedPaths(paths, normalize);
    if (closedPaths.length > 0) {
      clipperPaths.push({ data: closedPaths, closed: true });
    }
    const openPaths = fromOpenPaths(paths, normalize);
    if (openPaths.length > 0) {
      clipperPaths.push({ data: openPaths, closed: false });
    }
    return clipperPaths;
  };

  const fromClosedPaths = (paths, normalize) => {
    const closedPaths = [];
    for (const path of paths) {
      if (isClosed(path)) {
        const closedPath = [];
        for (let i = 0; i < path.length; i++) {
          const [x, y] = normalize(path[i]);
          closedPath.push(new IntPoint(toInt(x), toInt(y)));
        }
        closedPaths.push(closedPath);
      }
    }
    return closedPaths;
  };

  const toSurface = (clipperPaths, normalize) =>
    clockSort(clipperPaths.map(clipperPath => deduplicate(clipperPath.map(({ x, y }) => normalize([toFloat(x), toFloat(y), 0])))));

  const toPaths = (clipper, polytree, normalize) => {
    const paths = [];
    for (const path of clipper.openPathsFromPolyTree(polytree)) {
      paths.push([null, ...path.map(({ x, y }) => normalize([toFloat(x), toFloat(y), 0]))]);
    }
    for (const path of clipper.closedPathsFromPolyTree(polytree)) {
      paths.push(path.map(({ x, y }) => normalize([toFloat(x), toFloat(y), 0])));
    }
    return paths;
  };

  // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)
  const measureBoundingBox$2 = (surface) => {
    if (surface.measureBoundingBox === undefined) {
      const max = [-Infinity, -Infinity, 0];
      const min = [Infinity, Infinity, 0];
      for (const polygon of surface) {
        for (const point of polygon) {
          if (point === null) {
            // Support open paths.
            continue;
          }
          if (point[0] < min[0]) min[0] = point[0];
          if (point[1] < min[1]) min[1] = point[1];
          if (point[0] > max[0]) max[0] = point[0];
          if (point[1] > max[1]) max[1] = point[1];
        }
      }
      surface.measureBoundingBox = [min, max];
    }
    return surface.measureBoundingBox;
  };

  const iota$1 = 1e-5;
  const X$7 = 0;
  const Y$7 = 1;

  // No overlap tolerance.
  const doesNotOverlapOrAbut = (a, b) => {
    if (a.length === 0 || b.length === 0) {
      return true;
    }
    const [minA, maxA] = measureBoundingBox$2(a);
    const [minB, maxB] = measureBoundingBox$2(b);
    if (maxA[X$7] < minB[X$7] - iota$1) { return true; }
    if (maxA[Y$7] < minB[Y$7] - iota$1) { return true; }
    if (maxB[X$7] < minA[X$7] - iota$1) { return true; }
    if (maxB[Y$7] < minA[Y$7] - iota$1) { return true; }
    return false;
  };

  const difference = (a, ...z0Surfaces) => {
    if (a === undefined || a.length === 0) {
      return [];
    }
    const normalize = createNormalize2();
    while (z0Surfaces.length >= 1) {
      const b = z0Surfaces.shift();
      if (b.length === 0) {
        continue;
      } else if (doesNotOverlapOrAbut(a, b)) {
        continue;
      } else {
        const aPolygons = fromSurface(a, normalize);
        if (aPolygons.length === 0) {
          return [];
        }
        const bPolygons = fromSurface(b, normalize);
        if (bPolygons.length === 0) {
          continue;
        }
        const result = clipper$1.clipToPaths(
          {
            clipType: jsAngusjClipperjsWeb_2.Difference,
            subjectInputs: [{ data: aPolygons, closed: true }],
            clipInputs: [{ data: bPolygons, closed: true }],
            subjectFillType: jsAngusjClipperjsWeb_8.Positive
          });
        a = toSurface(result, normalize);
      }
    }
    return a;
  };

  /**
   * Produces a surface that is the intersection of all provided surfaces.
   * The union of no surfaces is the empty surface.
   * The union of one surface is that surface.
   * @param {Array<Z0Surface>} surfaces - the z0 surfaces to union.
   * @returns {Z0Surface} the resulting z0 surface.
   */
  const intersection = (a, ...z0Surfaces) => {
    if (a === undefined || a.length === 0) {
      return [];
    }
    const normalize = createNormalize2();
    while (z0Surfaces.length >= 1) {
      const b = z0Surfaces.shift();
      if (doesNotOverlapOrAbut(a, b)) {
        return [];
      } else {
        const aPolygons = fromSurface(a, normalize);
        if (aPolygons.length === 0) {
          return [];
        }
        const bPolygons = fromSurface(b, normalize);
        if (bPolygons.length === 0) {
          return [];
        }
        const result = clipper$1.clipToPaths(
          {
            clipType: jsAngusjClipperjsWeb_2.Intersection,
            subjectInputs: [{ data: aPolygons, closed: true }],
            clipInputs: [{ data: bPolygons, closed: true }],
            subjectFillType: jsAngusjClipperjsWeb_8.Positive
          });
        a = toSurface(result, normalize);
      }
    }
    return a;
  };

  /**
   * Produces a surface that is the intersection of all provided surfaces.
   * The union of no surfaces is the empty surface.
   * The union of one surface is that surface.
   * @param {Array<Z0Surface>} surfaces - the z0 surfaces to union.
   * @returns {Z0Surface} the resulting z0 surface.
   */
  const intersectionOfPathsBySurfaces = (a, ...z0Surfaces) => {
    if (a === undefined || a.length === 0 || z0Surfaces.length === 0) {
      return [];
    }
    const normalize = createNormalize2();
    while (z0Surfaces.length >= 1) {
      const b = z0Surfaces.shift();
      if (doesNotOverlapOrAbut(a, b)) {
        return [];
      } else {
        const subjectInputs = fromPaths(a, normalize);
        if (subjectInputs.length === 0) {
          return [];
        }
        const clipInputs = fromSurfaceAsClosedPaths(b, normalize);
        if (clipInputs.length === 0) {
          return [];
        }
        const result = clipper$1.clipToPolyTree(
          {
            clipType: jsAngusjClipperjsWeb_2.Intersection,
            subjectInputs,
            clipInputs,
            subjectFillType: jsAngusjClipperjsWeb_8.Positive
          });
        a = toPaths(clipper$1, result, normalize);
      }
    }
    return a;
  };

  var earcut_1 = earcut;
  var default_1 = earcut;

  function earcut(data, holeIndices, dim) {

      dim = dim || 2;

      var hasHoles = holeIndices && holeIndices.length,
          outerLen = hasHoles ? holeIndices[0] * dim : data.length,
          outerNode = linkedList(data, 0, outerLen, dim, true),
          triangles = [];

      if (!outerNode || outerNode.next === outerNode.prev) return triangles;

      var minX, minY, maxX, maxY, x, y, invSize;

      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

      // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
      if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];

          for (var i = dim; i < outerLen; i += dim) {
              x = data[i];
              y = data[i + 1];
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
          }

          // minX, minY and invSize are later used to transform coords into integers for z-order calculation
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
      }

      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

      return triangles;
  }

  // create a circular doubly linked list from polygon points in the specified winding order
  function linkedList(data, start, end, dim, clockwise) {
      var i, last;

      if (clockwise === (signedArea(data, start, end, dim) > 0)) {
          for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
      } else {
          for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      }

      if (last && equals$3(last, last.next)) {
          removeNode(last);
          last = last.next;
      }

      return last;
  }

  // eliminate colinear or duplicate points
  function filterPoints(start, end) {
      if (!start) return start;
      if (!end) end = start;

      var p = start,
          again;
      do {
          again = false;

          if (!p.steiner && (equals$3(p, p.next) || area(p.prev, p, p.next) === 0)) {
              removeNode(p);
              p = end = p.prev;
              if (p === p.next) break;
              again = true;

          } else {
              p = p.next;
          }
      } while (again || p !== end);

      return end;
  }

  // main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;

      // interlink polygon nodes in z-order
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

      var stop = ear,
          prev, next;

      // iterate through ears, slicing them one by one
      while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;

          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
              // cut off the triangle
              triangles.push(prev.i / dim);
              triangles.push(ear.i / dim);
              triangles.push(next.i / dim);

              removeNode(ear);

              // skipping the next vertex leads to less sliver triangles
              ear = next.next;
              stop = next.next;

              continue;
          }

          ear = next;

          // if we looped through the whole remaining polygon and can't find any more ears
          if (ear === stop) {
              // try filtering points and slicing again
              if (!pass) {
                  earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

              // if this didn't work, try curing all small self-intersections locally
              } else if (pass === 1) {
                  ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                  earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

              // as a last resort, try splitting the remaining polygon into two
              } else if (pass === 2) {
                  splitEarcut(ear, triangles, dim, minX, minY, invSize);
              }

              break;
          }
      }
  }

  // check whether a polygon node forms a valid ear with adjacent nodes
  function isEar(ear) {
      var a = ear.prev,
          b = ear,
          c = ear.next;

      if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

      // now make sure we don't have other points inside the potential ear
      var p = ear.next.next;

      while (p !== ear.prev) {
          if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
              area(p.prev, p, p.next) >= 0) return false;
          p = p.next;
      }

      return true;
  }

  function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev,
          b = ear,
          c = ear.next;

      if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

      // triangle bbox; min & max are calculated like this for speed
      var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
          minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
          maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
          maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

      // z-order range for the current triangle bbox;
      var minZ = zOrder(minTX, minTY, minX, minY, invSize),
          maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

      var p = ear.prevZ,
          n = ear.nextZ;

      // look for points inside the triangle in both directions
      while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p !== ear.prev && p !== ear.next &&
              pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
              area(p.prev, p, p.next) >= 0) return false;
          p = p.prevZ;

          if (n !== ear.prev && n !== ear.next &&
              pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
              area(n.prev, n, n.next) >= 0) return false;
          n = n.nextZ;
      }

      // look for remaining points in decreasing z-order
      while (p && p.z >= minZ) {
          if (p !== ear.prev && p !== ear.next &&
              pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
              area(p.prev, p, p.next) >= 0) return false;
          p = p.prevZ;
      }

      // look for remaining points in increasing z-order
      while (n && n.z <= maxZ) {
          if (n !== ear.prev && n !== ear.next &&
              pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
              area(n.prev, n, n.next) >= 0) return false;
          n = n.nextZ;
      }

      return true;
  }

  // go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
          var a = p.prev,
              b = p.next.next;

          if (!equals$3(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

              triangles.push(a.i / dim);
              triangles.push(p.i / dim);
              triangles.push(b.i / dim);

              // remove two nodes involved
              removeNode(p);
              removeNode(p.next);

              p = start = b;
          }
          p = p.next;
      } while (p !== start);

      return filterPoints(p);
  }

  // try splitting polygon into two and triangulate them independently
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      // look for a valid diagonal that divides the polygon into two
      var a = start;
      do {
          var b = a.next.next;
          while (b !== a.prev) {
              if (a.i !== b.i && isValidDiagonal(a, b)) {
                  // split the polygon in two by the diagonal
                  var c = splitPolygon(a, b);

                  // filter colinear points around the cuts
                  a = filterPoints(a, a.next);
                  c = filterPoints(c, c.next);

                  // run earcut on each half
                  earcutLinked(a, triangles, dim, minX, minY, invSize);
                  earcutLinked(c, triangles, dim, minX, minY, invSize);
                  return;
              }
              b = b.next;
          }
          a = a.next;
      } while (a !== start);
  }

  // link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [],
          i, len, start, end, list;

      for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next) list.steiner = true;
          queue.push(getLeftmost(list));
      }

      queue.sort(compareX);

      // process holes from left to right
      for (i = 0; i < queue.length; i++) {
          eliminateHole(queue[i], outerNode);
          outerNode = filterPoints(outerNode, outerNode.next);
      }

      return outerNode;
  }

  function compareX(a, b) {
      return a.x - b.x;
  }

  // find a bridge between vertices that connects hole with an outer ring and and link it
  function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {
          var b = splitPolygon(outerNode, hole);

          // filter collinear points around the cuts
          filterPoints(outerNode, outerNode.next);
          filterPoints(b, b.next);
      }
  }

  // David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge(hole, outerNode) {
      var p = outerNode,
          hx = hole.x,
          hy = hole.y,
          qx = -Infinity,
          m;

      // find a segment intersected by a ray from the hole's leftmost point to the left;
      // segment's endpoint with lesser x will be potential connection point
      do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
              var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
              if (x <= hx && x > qx) {
                  qx = x;
                  if (x === hx) {
                      if (hy === p.y) return p;
                      if (hy === p.next.y) return p.next;
                  }
                  m = p.x < p.next.x ? p : p.next;
              }
          }
          p = p.next;
      } while (p !== outerNode);

      if (!m) return null;

      if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

      // look for points inside the triangle of hole point, segment intersection and endpoint;
      // if there are no points found, we have a valid connection;
      // otherwise choose the point of the minimum angle with the ray as connection point

      var stop = m,
          mx = m.x,
          my = m.y,
          tanMin = Infinity,
          tan;

      p = m;

      do {
          if (hx >= p.x && p.x >= mx && hx !== p.x &&
                  pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

              tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

              if (locallyInside(p, hole) &&
                  (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                  m = p;
                  tanMin = tan;
              }
          }

          p = p.next;
      } while (p !== stop);

      return m;
  }

  // whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }

  // interlink polygon nodes in z-order
  function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
          if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
      } while (p !== start);

      p.prevZ.nextZ = null;
      p.prevZ = null;

      sortLinked(p);
  }

  // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize,
          inSize = 1;

      do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;

          while (p) {
              numMerges++;
              q = p;
              pSize = 0;
              for (i = 0; i < inSize; i++) {
                  pSize++;
                  q = q.nextZ;
                  if (!q) break;
              }
              qSize = inSize;

              while (pSize > 0 || (qSize > 0 && q)) {

                  if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                      e = p;
                      p = p.nextZ;
                      pSize--;
                  } else {
                      e = q;
                      q = q.nextZ;
                      qSize--;
                  }

                  if (tail) tail.nextZ = e;
                  else list = e;

                  e.prevZ = tail;
                  tail = e;
              }

              p = q;
          }

          tail.nextZ = null;
          inSize *= 2;

      } while (numMerges > 1);

      return list;
  }

  // z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder(x, y, minX, minY, invSize) {
      // coords are transformed into non-negative 15-bit integer range
      x = 32767 * (x - minX) * invSize;
      y = 32767 * (y - minY) * invSize;

      x = (x | (x << 8)) & 0x00FF00FF;
      x = (x | (x << 4)) & 0x0F0F0F0F;
      x = (x | (x << 2)) & 0x33333333;
      x = (x | (x << 1)) & 0x55555555;

      y = (y | (y << 8)) & 0x00FF00FF;
      y = (y | (y << 4)) & 0x0F0F0F0F;
      y = (y | (y << 2)) & 0x33333333;
      y = (y | (y << 1)) & 0x55555555;

      return x | (y << 1);
  }

  // find the leftmost node of a polygon ring
  function getLeftmost(start) {
      var p = start,
          leftmost = start;
      do {
          if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
          p = p.next;
      } while (p !== start);

      return leftmost;
  }

  // check if a point lies within a convex triangle
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
             (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
             (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  }

  // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
             (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
              (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
              equals$3(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
  }

  // signed area of a triangle
  function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }

  // check if two points are equal
  function equals$3(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
  }

  // check if two segments intersect
  function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));

      if (o1 !== o2 && o3 !== o4) return true; // general case

      if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
      if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
      if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
      if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

      return false;
  }

  // for collinear points p, q, r, check if point q lies on segment pr
  function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }

  function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
  }

  // check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon(a, b) {
      var p = a;
      do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                  intersects(p, p.next, a, b)) return true;
          p = p.next;
      } while (p !== a);

      return false;
  }

  // check if a polygon diagonal is locally inside the polygon
  function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ?
          area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
          area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }

  // check if the middle point of a polygon diagonal is inside the polygon
  function middleInside(a, b) {
      var p = a,
          inside = false,
          px = (a.x + b.x) / 2,
          py = (a.y + b.y) / 2;
      do {
          if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                  (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
              inside = !inside;
          p = p.next;
      } while (p !== a);

      return inside;
  }

  // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y),
          b2 = new Node(b.i, b.x, b.y),
          an = a.next,
          bp = b.prev;

      a.next = b;
      b.prev = a;

      a2.next = an;
      an.prev = a2;

      b2.next = a2;
      a2.prev = b2;

      bp.next = b2;
      b2.prev = bp;

      return b2;
  }

  // create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);

      if (!last) {
          p.prev = p;
          p.next = p;

      } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
      }
      return p;
  }

  function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;

      if (p.prevZ) p.prevZ.nextZ = p.nextZ;
      if (p.nextZ) p.nextZ.prevZ = p.prevZ;
  }

  function Node(i, x, y) {
      // vertex index in coordinates array
      this.i = i;

      // vertex coordinates
      this.x = x;
      this.y = y;

      // previous and next vertex nodes in a polygon ring
      this.prev = null;
      this.next = null;

      // z-order curve value
      this.z = null;

      // previous and next nodes in z-order
      this.prevZ = null;
      this.nextZ = null;

      // indicates whether this is a steiner point
      this.steiner = false;
  }

  // return a percentage difference between the polygon area and its triangulation area;
  // used to verify correctness of triangulation
  earcut.deviation = function (data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
              var start = holeIndices[i] * dim;
              var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
              polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
      }

      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
              (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
              (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
      }

      return polygonArea === 0 && trianglesArea === 0 ? 0 :
          Math.abs((trianglesArea - polygonArea) / polygonArea);
  };

  function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
      }
      return sum;
  }

  // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
  earcut.flatten = function (data) {
      var dim = data[0][0].length,
          result = {vertices: [], holes: [], dimensions: dim},
          holeIndex = 0;

      for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
              for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
              holeIndex += data[i - 1].length;
              result.holes.push(holeIndex);
          }
      }
      return result;
  };
  earcut_1.default = default_1;

  const makeConvex = (surface, normalize = createNormalize2()) => {
    if (surface.length === 0) {
      return [];
    }
    const subjectInputs = fromSurfaceAsClosedPaths(surface, normalize);
    if (subjectInputs.length === 0) {
      return [];
    }
    const request =
      {
        clipType: jsAngusjClipperjsWeb_2.Union,
        subjectInputs,
        subjectFillType: jsAngusjClipperjsWeb_8.Positive
      };
    const result = clipper$1.clipToPolyTree(request);
    const convexSurface = [];

    // eslint-disable-next-line camelcase
    const walkContour = ({ contour, childs }) => {
      const earContour = [];
      const holes = [];
      for (const { x, y } of clipper$1.cleanPolygon(contour, CLEAN_DISTANCE)) {
        earContour.push(x, y);
      }
      // eslint-disable-next-line camelcase
      for (const child of childs) {
        walkHole(child, earContour, holes);
      }
      const triangles = earcut_1(earContour, holes);
      for (let i = 0; i < triangles.length; i += 3) {
        const a = triangles[i + 0];
        const b = triangles[i + 1];
        const c = triangles[i + 2];
        const triangle = [normalize([earContour[a * 2 + 0] / RESOLUTION, earContour[a * 2 + 1] / RESOLUTION, 0]),
                          normalize([earContour[b * 2 + 0] / RESOLUTION, earContour[b * 2 + 1] / RESOLUTION, 0]),
                          normalize([earContour[c * 2 + 0] / RESOLUTION, earContour[c * 2 + 1] / RESOLUTION, 0])];
        convexSurface.push(triangle);
      }
    };

    // eslint-disable-next-line camelcase
    const walkHole = ({ contour, childs }, earContour, holes) => {
      const start = earContour.length;
      for (const { x, y } of clipper$1.cleanPolygon(contour, CLEAN_DISTANCE)) {
        earContour.push(x, y);
      }
      if (earContour.length > start) {
        holes.push(start >>> 1);
      }
      // eslint-disable-next-line camelcase
      for (const child of childs) {
        walkContour(child);
      }
    };

    for (const child of result.childs) {
      walkContour(child);
    }

    const normalized = convexSurface.map(path => path.map(normalize)).filter(path => toPlane(path) !== undefined);
    const rectified = [];
    for (const polygon of normalized) {
      if (isClockwise(polygon)) {
        rectified.push(flip(polygon));
      } else {
        rectified.push(polygon);
      }
    }
    return normalized;
  };

  // import { RESOLUTION } from './convert';

  const THRESHOLD$1 = 1e-5; // * RESOLUTION;

  // We expect a surface of reconciled triangles.

  const fixTJunctions = (surface) => {
    const vertices = new Set();

    for (const path of surface) {
      for (const point of path) {
        vertices.add(point);
      }
    }

    const watertightPaths = [];
    for (const path of surface) {
      const watertightPath = [];
      for (const [start, end] of getEdges(path)) {
        watertightPath.push(start);
        const span = distance(start, end);
        const colinear = [];
        for (const vertex of vertices) {
          // FIX: Threshold
          if (Math.abs(distance(start, vertex) + distance(vertex, end) - span) < THRESHOLD$1) {
            // FIX: Clip an ear instead.
            // Vertex is on the open edge.
            colinear.push(vertex);
          }
        }
        // Arrange by distance from start.
        colinear.sort((a, b) => distance(start, a) - distance(start, b));
        // Insert into the path.
        watertightPath.push(...colinear);
      }
      pushWhenValid(watertightPaths, watertightPath);
    }

    return watertightPaths;
  };

  // Here we have a surface with a confused orientation.
  // This reorients the most exterior paths to be ccw.

  const reorient = (surface, normalize = p => p) => {
    const integers = fromSurfaceToIntegers(surface, normalize);
    const fixed = fixTJunctions(integers);
    const subjectInputs = fromIntegersToClosedPaths(fixed);
    if (subjectInputs.length === 0) {
      return [];
    }
    const result = clipper$1.clipToPaths({
      clipType: jsAngusjClipperjsWeb_2.Union,
      subjectInputs,
      subjectFillType: jsAngusjClipperjsWeb_8.NonZero
    });
    return toSurface(result, normalize);
  };

  /**
   * Produces a surface that is the union of all provided surfaces.
   * The union of no surfaces is the empty surface.
   * The union of one surface is that surface.
   * @param {Array<Z0Surface>} surfaces - the z0 surfaces to union.
   * @returns {Z0Surface} the resulting z0 surface.
   */
  const union = (...z0Surfaces) => {
    if (z0Surfaces.length === 0) {
      return [];
    }
    const normalize = createNormalize2();
    while (z0Surfaces.length >= 2) {
      const a = z0Surfaces.shift();
      const b = z0Surfaces.shift();
      if (doesNotOverlapOrAbut(a, b)) {
        z0Surfaces.push([].concat(a, b));
      } else {
        const aPolygons = fromSurface(a, normalize);
        const bPolygons = fromSurface(b, normalize);
        if (aPolygons.length === 0) {
          z0Surfaces.push(b);
        } else if (bPolygons.length === 0) {
          z0Surfaces.push(a);
        } else {
          const result = clipper$1.clipToPaths(
            {
              clipType: jsAngusjClipperjsWeb_2.Union,
              subjectInputs: [{ data: aPolygons, closed: true }],
              clipInputs: [{ data: bPolygons, closed: true }],
              subjectFillType: jsAngusjClipperjsWeb_8.Positive
            });
          z0Surfaces.push(toSurface(result, normalize));
        }
      }
    }
    return z0Surfaces[0];
  };

  const outline = reorient;

  /**
   * Creates a new unbounded 2D line initialized with the given values.
   *
   * This is a 2d plane, similar to the [x, y, z, w] form of the 3d plane.
   *
   * @param {Number} x X coordinate of the unit normal
   * @param {Number} y Y coordinate of the unit normal
   * @param {Number} w length (positive) of the normal segment
   * @returns {line2} a new unbounded 2D line
   */
  const fromValues$2 = (x = 0, y = 1, w = 0) => [x, y, w];

  /**
   * Return the direction of the given line.
   *
   * @return {vec2} a new relative vector in the direction of the line
   */
  const direction = (line) => negate$1(normal(line));

  /**
   * Create a new 2D line that passes through the given points
   *
   * @param {vec2} p1 start point of the 2D line
   * @param {vec2} p2 end point of the 2D line
   * @returns {line2} a new unbounded 2D line
   */
  const fromPoints$2 = (p1, p2) => {
    const direction = subtract$1(p2, p1);
    const normalizedNormal = normalize$1(normal(direction));
    const distance = dot$1(p1, normalizedNormal);
    return fromValues$2(normalizedNormal[0], normalizedNormal[1], distance);
  };

  /**
   * Return the point of intersection between the given lines.
   *
   * The point will have Infinity values if the lines are paralell.
   * The point will have NaN values if the lines are the same.
   *
   * @param {line2} line1 a 2D line for reference
   * @param {line2} line2 a 2D line for reference
   * @return {vec2} the point of intersection
   */
  const intersectPointOfLines = (line1, line2) =>
    solve2Linear(line1[0], line1[1], line2[0], line2[1], line1[2], line2[2]);

  const EPS = 1e-5;
  const X$8 = 0;
  const Y$8 = 1;
  const yCoordinateBinningFactor = 1e6;

  const interpolateXForY = (point1, point2, y) => {
    let f1 = y - point1[1];
    let f2 = point2[1] - point1[1];
    if (f2 < 0) {
      f1 = -f1;
      f2 = -f2;
    }
    let t;
    if (f1 <= 0) {
      t = 0.0;
    } else if (f1 >= f2) {
      t = 1.0;
    } else if (f2 < 1e-10) { // FIXME Should this be EPS?
      t = 0.5;
    } else {
      t = f1 / f2;
    }
    // lerp
    let result = point1[0] + t * (point2[0] - point1[0]);
    return result;
  };

  const fnNumberSort = (a, b) => {
    return a - b;
  };

  const insertSorted = (data, element, comparator) => {
    let leftBound = 0;
    let rightBound = data.length;
    while (rightBound > leftBound) {
      const index = Math.floor((leftBound + rightBound) / 2);
      if (comparator(element, data[index]) > 0) {
        leftBound = index + 1;
      } else {
        rightBound = index;
      }
    }
    data.splice(leftBound, 0, element);
  };

  const binY = (yCoordinateBins, y) => {
    const yCoordinateBin = Math.floor(y * yCoordinateBinningFactor);
    if (yCoordinateBins.has(yCoordinateBin)) {
      return yCoordinateBins.get(yCoordinateBin);
    } else if (yCoordinateBins.has(yCoordinateBin + 1)) {
      return yCoordinateBins.get(yCoordinateBin + 1);
    } else if (yCoordinateBins.has(yCoordinateBin - 1)) {
      return yCoordinateBins.get(yCoordinateBin - 1);
    } else {
      yCoordinateBins.set(yCoordinateBin, y);
      return y;
    }
  };

  /**
   * Retesselation for a z0Surface.
   */

  const binPolygons = (sourcePolygons) => {
    const normalizedPolygons = [];
    const polygonTopVertexIndexes = []; // array of indexes of topmost vertex per polygon
    const topYToPolygonIndexes = {};
    const topYToPolygon = new Map();
    const yCoordinateToPolygonIndexes = {};

    const yCoordinateBins = new Map();
    const yCoordinateToPolygons = new Map();

    // Make a list of all encountered y coordinates
    // And build a map of all polygons that have a vertex at a certain y coordinate:
    for (let polygonIndex = 0; polygonIndex < sourcePolygons.length; polygonIndex++) {
      const polygon = sourcePolygons[polygonIndex];
      let points = [];
      let minIndex = -1;
      if (polygon.length > 0) {
        let minY = Infinity;
        let maxY = -Infinity;
        // The order of iteration here is significant.
        // for (let index = 0; index < polygon.length; index++)
        for (let index = polygon.length - 1; index >= 0; index--) {
          const point = polygon[index];
          // perform binning of y coordinates: If we have multiple vertices very
          // close to each other, give them the same y coordinate:
          const y = binY(yCoordinateBins, point[Y$8]);
          if (y > maxY) {
            maxY = y;
          }
          if (y < minY) {
            minY = y;
            minIndex = points.length;
          }
          points.push([point[X$8], y]);
        }
        for (let index = polygon.length - 1; index >= 0; index--) {
          const y = points[index][Y$8];
          if (!(y in yCoordinateToPolygonIndexes)) {
            yCoordinateToPolygonIndexes[y] = {};
          }
          yCoordinateToPolygonIndexes[y][normalizedPolygons.length] = true;
          if (!yCoordinateToPolygons.has(y)) {
            yCoordinateToPolygons.set(y, []);
          }
          yCoordinateToPolygons.get(y).unshift(polygon);
        }
        if (minY >= maxY) {
          // degenerate polygon, all vertices have same y coordinate. Just ignore it from now:
          points = [];
          minIndex = 0;
          // Note that topYToPolygonIndexes is not updated for these cases.
        } else {
          if (!(minY in topYToPolygonIndexes)) {
            topYToPolygonIndexes[minY] = [];
          }
          topYToPolygonIndexes[minY].unshift(normalizedPolygons.length);
          if (!topYToPolygon.has(minY)) {
            topYToPolygon.set(minY, polygon);
          }
        }
      }
      // This includes empty polygons.
      // These are keyed by the polygon index.
      normalizedPolygons.push(points);
      polygonTopVertexIndexes.push(minIndex);
    }

    const yCoordinates = [...yCoordinateToPolygons.keys()].sort(fnNumberSort);

    return {
      yCoordinates,
      yCoordinateToPolygons,
      yCoordinateToPolygonIndexes,
      topYToPolygonIndexes,
      normalizedPolygons,
      polygonTopVertexIndexes
    };
  };

  const recomputeActivePolygons = ({ activePolygons, polygonIndexesWithCorner, normalizedPolygons, yCoordinate }) => {
    for (let activePolygonIndex = 0; activePolygonIndex < activePolygons.length; activePolygonIndex++) {
      const activePolygon = activePolygons[activePolygonIndex];
      const polygonIndex = activePolygon.polygonIndex;
      if (polygonIndexesWithCorner[polygonIndex]) {
        // this active polygon has a corner at this y coordinate:
        const polygon = normalizedPolygons[polygonIndex];
        const numVertices = polygon.length;
        let newLeftVertexIndex = activePolygon.leftVertexIndex;
        let newRightVertexIndex = activePolygon.rightVertexIndex;
        // See if we need to increase leftVertexIndex or decrease rightVertexIndex:
        while (true) {
          let nextLeftVertexIndex = newLeftVertexIndex + 1;
          if (nextLeftVertexIndex >= numVertices) nextLeftVertexIndex = 0;
          if (polygon[nextLeftVertexIndex][1] !== yCoordinate) break;
          newLeftVertexIndex = nextLeftVertexIndex;
        }
        let nextRightVertexIndex = newRightVertexIndex - 1;
        if (nextRightVertexIndex < 0) nextRightVertexIndex = numVertices - 1;
        if (polygon[nextRightVertexIndex][1] === yCoordinate) {
          newRightVertexIndex = nextRightVertexIndex;
        }
        if ((newLeftVertexIndex !== activePolygon.leftVertexIndex) && (newLeftVertexIndex === newRightVertexIndex)) {
          // We have increased leftVertexIndex or decreased rightVertexIndex, and now they point to the same vertex
          // This means that this is the bottom point of the polygon. We'll remove it:
          activePolygons.splice(activePolygonIndex, 1);
          activePolygonIndex -= 1;
        } else {
          activePolygon.leftVertexIndex = newLeftVertexIndex;
          activePolygon.rightVertexIndex = newRightVertexIndex;
          activePolygon.topLeft = polygon[newLeftVertexIndex];
          activePolygon.topRight = polygon[newRightVertexIndex];
          let nextLeftVertexIndex = newLeftVertexIndex + 1;
          if (nextLeftVertexIndex >= numVertices) nextLeftVertexIndex = 0;
          activePolygon.bottomLeft = polygon[nextLeftVertexIndex];
          let nextRightVertexIndex = newRightVertexIndex - 1;
          if (nextRightVertexIndex < 0) nextRightVertexIndex = numVertices - 1;
          activePolygon.bottomRight = polygon[nextRightVertexIndex];
        }
      }
    }
  };

  const findNextYCoordinate = ({ yIndex, yCoordinates, yCoordinate, topYToPolygonIndexes, normalizedPolygons, polygonTopVertexIndexes, activePolygons }) => {
    let nextYCoordinate;
    if (yIndex >= yCoordinates.length - 1) {
      // last row, all polygons must be finished here:
      return null;
    }
    nextYCoordinate = Number(yCoordinates[yIndex + 1]);
    const middleYCoordinate = 0.5 * (yCoordinate + nextYCoordinate);
    // update activePolygons by adding any polygons that start here:
    const startingPolygonIndexes = topYToPolygonIndexes[yCoordinate];
    for (let polygonIndexKey in startingPolygonIndexes) {
      const polygonIndex = startingPolygonIndexes[polygonIndexKey];
      const polygon = normalizedPolygons[polygonIndex];
      const numVertices = polygon.length;
      const topVertexIndex = polygonTopVertexIndexes[polygonIndex];
      // the top of the polygon may be a horizontal line. In that case topVertexIndex can point to any point on this line.
      // Find the left and right topmost vertices which have the current y coordinate:
      let topLeftVertexIndex = topVertexIndex;
      while (true) {
        let i = topLeftVertexIndex + 1;
        if (i >= numVertices) i = 0;
        if (polygon[i][1] !== yCoordinate) break;
        if (i === topVertexIndex) break; // should not happen, but just to prevent endless loops
        topLeftVertexIndex = i;
      }
      let topRightVertexIndex = topVertexIndex;
      while (true) {
        let i = topRightVertexIndex - 1;
        if (i < 0) i = numVertices - 1;
        if (polygon[i][1] !== yCoordinate) break;
        if (i === topLeftVertexIndex) break; // should not happen, but just to prevent endless loops
        topRightVertexIndex = i;
      }
      let nextLeftVertexIndex = topLeftVertexIndex + 1;
      if (nextLeftVertexIndex >= numVertices) nextLeftVertexIndex = 0;
      let nextRightVertexIndex = topRightVertexIndex - 1;
      if (nextRightVertexIndex < 0) nextRightVertexIndex = numVertices - 1;
      const newActivePolygon = {
        polygonIndex,
        leftVertexIndex: topLeftVertexIndex,
        rightVertexIndex: topRightVertexIndex,
        topLeft: polygon[topLeftVertexIndex],
        topRight: polygon[topRightVertexIndex],
        bottomLeft: polygon[nextLeftVertexIndex],
        bottomRight: polygon[nextRightVertexIndex]
      };
      insertSorted(activePolygons, newActivePolygon, (el1, el2) => {
        const x1 = interpolateXForY(el1.topLeft, el1.bottomLeft, middleYCoordinate);
        const x2 = interpolateXForY(el2.topLeft, el2.bottomLeft, middleYCoordinate);
        if (x1 > x2) return 1;
        if (x1 < x2) return -1;
        return 0;
      });
    }
    return nextYCoordinate;
  };

  const buildOutputPolygons = ({ activePolygons, yCoordinate, nextYCoordinate, newPolygonRow, yIndex, previousPolygonRow, destinationPolygons }) => {
    // Now activePolygons is up to date

    // Build the output polygons for the next row in newPolygonRow:
    for (let activepolygonKey in activePolygons) {
      const activePolygon = activePolygons[activepolygonKey];

      let x = interpolateXForY(activePolygon.topLeft, activePolygon.bottomLeft, yCoordinate);
      const topLeft = [x, yCoordinate];
      x = interpolateXForY(activePolygon.topRight, activePolygon.bottomRight, yCoordinate);
      const topRight = [x, yCoordinate];
      x = interpolateXForY(activePolygon.topLeft, activePolygon.bottomLeft, nextYCoordinate);
      const bottomLeft = [x, nextYCoordinate];
      x = interpolateXForY(activePolygon.topRight, activePolygon.bottomRight, nextYCoordinate);
      const bottomRight = [x, nextYCoordinate];
      const outPolygon = {
        topLeft,
        topRight,
        bottomLeft,
        bottomRight,
        leftLine: fromPoints$2(topLeft, bottomLeft),
        rightLine: fromPoints$2(bottomRight, topRight)
      };
      if (newPolygonRow.length > 0) {
        // Stitch together congruent edges.
        const previousOutPolygon = newPolygonRow[newPolygonRow.length - 1];
        // Note that must be equal for all tops and all bottoms.
        // Which means that we can compare for overlap in x.

        switch ('old') {
          case 'old': {
            const d1 = distance$1(outPolygon.topLeft, previousOutPolygon.topRight);
            const d2 = distance$1(outPolygon.bottomLeft, previousOutPolygon.bottomRight);
            if ((d1 < EPS) && (d2 < EPS)) {
              // we can join this polygon with the one to the left:
              outPolygon.topLeft = previousOutPolygon.topLeft;
              outPolygon.leftLine = previousOutPolygon.leftLine;
              outPolygon.bottomLeft = previousOutPolygon.bottomLeft;
              // newPolygonRow.splice(newPolygonRow.length - 1, 1);
              newPolygonRow.pop();
            }
            break;
          }
          case 'new': {
            if (outPolygon.topLeft[X$8] <= previousOutPolygon.topRight[X$8] + EPS) {
              // These polygons overlap x-wise.
              // we can join this polygon with the one to the left:
              outPolygon.topLeft = previousOutPolygon.topLeft;
              outPolygon.leftLine = previousOutPolygon.leftLine;
              outPolygon.bottomLeft = previousOutPolygon.bottomLeft;
              newPolygonRow.pop();
            }
            break;
          }
        }
      }
      newPolygonRow.push(outPolygon);
    }

    // Merge the old row with the next row.
    if (yIndex > 0) {
      // try to match the new polygons against the previous row:
      const previousContinuedIndexes = {};
      const matchedIndexes = {};
      for (let i = 0; i < newPolygonRow.length; i++) {
        const thisPolygon = newPolygonRow[i];
        for (let ii = 0; ii < previousPolygonRow.length; ii++) {
          if (!matchedIndexes[ii]) { // not already processed?
            // We have a match if the sidelines are equal or if the top coordinates
            // are on the sidelines of the previous polygon
            const previousPolygon = previousPolygonRow[ii];
            if (distance$1(previousPolygon.bottomLeft, thisPolygon.topLeft) < EPS) {
              if (distance$1(previousPolygon.bottomRight, thisPolygon.topRight) < EPS) {
                // Yes, the top of this polygon matches the bottom of the previous:
                matchedIndexes[ii] = true;
                // Now check if the joined polygon would remain convex:
                const v1 = direction(thisPolygon.leftLine);
                const v2 = direction(previousPolygon.leftLine);
                const d1 = v1[0] - v2[0];

                const v3 = direction(thisPolygon.rightLine);
                const v4 = direction(previousPolygon.rightLine);
                const d2 = v3[0] - v4[0];

                const leftLineContinues = Math.abs(d1) < EPS;
                const rightLineContinues = Math.abs(d2) < EPS;
                const leftLineIsConvex = leftLineContinues || (d1 >= 0);
                const rightLineIsConvex = rightLineContinues || (d2 >= 0);
                if (leftLineIsConvex && rightLineIsConvex) {
                  // yes, both sides have convex corners:
                  // This polygon will continue the previous polygon
                  thisPolygon.outPolygon = previousPolygon.outPolygon;
                  thisPolygon.leftLineContinues = leftLineContinues;
                  thisPolygon.rightLineContinues = rightLineContinues;
                  previousContinuedIndexes[ii] = true;
                }
                break;
              }
            }
          }
        }
      }
      const staging = [];
      for (let ii = 0; ii < previousPolygonRow.length; ii++) {
        if (!previousContinuedIndexes[ii]) {
          // polygon ends here
          // Finish the polygon with the last point(s):
          const previousPolygon = previousPolygonRow[ii];
          previousPolygon.outPolygon.rightPoints.push(previousPolygon.bottomRight);
          if (distance$1(previousPolygon.bottomRight, previousPolygon.bottomLeft) > EPS) {
            // polygon ends with a horizontal line:
            previousPolygon.outPolygon.leftPoints.push(previousPolygon.bottomLeft);
          }
          // reverse the left half so we get a counterclockwise circle:
          previousPolygon.outPolygon.leftPoints.reverse();
          const polygon = previousPolygon.outPolygon.rightPoints.concat(previousPolygon.outPolygon.leftPoints);
          staging.push(polygon);
        }
      }
      destinationPolygons.push(...staging);
    }

    // Prepare for the next new row.
    for (let i = 0; i < newPolygonRow.length; i++) {
      const thisPolygon = newPolygonRow[i];
      if (!thisPolygon.outPolygon) {
        // polygon starts here:
        thisPolygon.outPolygon = {
          leftPoints: [],
          rightPoints: []
        };
        thisPolygon.outPolygon.leftPoints.push(thisPolygon.topLeft);
        if (distance$1(thisPolygon.topLeft, thisPolygon.topRight) > EPS) {
          // we have a horizontal line at the top:
          thisPolygon.outPolygon.rightPoints.push(thisPolygon.topRight);
        }
      } else {
        // continuation of a previous row
        if (!thisPolygon.leftLineContinues) {
          thisPolygon.outPolygon.leftPoints.push(thisPolygon.topLeft);
        }
        if (!thisPolygon.rightLineContinues) {
          thisPolygon.outPolygon.rightPoints.push(thisPolygon.topRight);
        }
      }
    }
    previousPolygonRow = newPolygonRow;

    return previousPolygonRow;
  };

  const retessellate = (sourcePolygons) => {
    if (sourcePolygons.length < 2) {
      return sourcePolygons;
    }
    let { yCoordinates, yCoordinateToPolygonIndexes, topYToPolygonIndexes, normalizedPolygons, polygonTopVertexIndexes } = binPolygons(sourcePolygons);
    const destinationPolygons = [];
    // Now we will iterate over all y coordinates, from lowest to highest y coordinate
    // activePolygons: source polygons that are 'active', i.e. intersect with our y coordinate
    //   Is sorted so the polygons are in left to right order
    // Each element in activePolygons has these properties:
    //        polygonIndex: the index of the source polygon (i.e. an index into the sourcepolygons
    //                      and normalizedPolygons arrays)
    //        leftVertexIndex: the index of the vertex at the left side of the polygon (lowest x)
    //                         that is at or just above the current y coordinate
    //        rightVertexIndex: dito at right hand side of polygon
    //        topLeft, bottomLeft: coordinates of the left side of the polygon crossing the current y coordinate
    //        topRight, bottomRight: coordinates of the right hand side of the polygon crossing the current y coordinate
    let activePolygons = [];
    let previousPolygonRow = [];
    for (let yIndex = 0; yIndex < yCoordinates.length; yIndex++) {
      const newPolygonRow = [];
      const yCoordinate = yCoordinates[yIndex];

      // update activePolygons for this y coordinate:
      // - Remove any polygons that end at this y coordinate
      // - update leftVertexIndex and rightVertexIndex (which point to the current vertex index
      //   at the the left and right side of the polygon
      // Iterate over all polygons that have a corner at this y coordinate:
      const polygonIndexesWithCorner = yCoordinateToPolygonIndexes[yCoordinate];
      recomputeActivePolygons({ activePolygons, polygonIndexesWithCorner, normalizedPolygons, yCoordinate });
      const nextYCoordinate = findNextYCoordinate({ yIndex, yCoordinates, yCoordinate, topYToPolygonIndexes, normalizedPolygons, polygonTopVertexIndexes, activePolygons });
      if (nextYCoordinate === null) {
        activePolygons = [];
      }
      previousPolygonRow = buildOutputPolygons({ activePolygons, yCoordinate, nextYCoordinate, newPolygonRow, yIndex, previousPolygonRow, destinationPolygons });
    }
    return destinationPolygons
             .filter(polygon => polygon.length >= 3)
             .map(polygon => polygon.map(([x, y]) => [x, y, 0]));
  };

  // Cut the corners to produce triangles.
  const triangulateConvexPolygon = (polygon) => {
    const surface = [];
    for (let i = 2; i < polygon.length; i++) {
      surface.push([polygon[0], polygon[i - 1], polygon[i]]);
    }
    return surface;
  };

  const makeConvex$1 = (surface, normalize3 = createNormalize3(), plane) => {
    if (surface.length === undefined) {
      throw Error('die');
    }
    if (surface.length === 0) {
      // An empty surface is not non-convex.
      return surface;
    }
    if (surface.length === 1) {
      const polygon = surface[0];
      if (polygon.length === 3) {
        // A triangle is already convex.
        return surface;
      }
      if (polygon.length > 3 && isConvex(polygon)) {
        return triangulateConvexPolygon(polygon.map(normalize3));
      }
    }
    if (plane === undefined) {
      plane = toPlane$1(surface);
      if (plane === undefined) {
        return [];
      }
    }
    const [to, from] = toXYPlaneTransforms(plane);
    const z0Surface = transform$4(to, surface.map(path => path.map(normalize3)));
    const convexZ0Surface = makeConvex(z0Surface);
    const convexSurface = transform$4(from, convexZ0Surface).map(path => path.map(normalize3));
    return convexSurface;
  };

  // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)
  const measureBoundingBox$3 = (surface) => {
    if (surface.measureBoundingBox === undefined) {
      const min = [Infinity, Infinity, Infinity];
      const max = [-Infinity, -Infinity, -Infinity];
      for (const path of surface) {
        for (const point of path) {
          if (point[0] < min[0]) min[0] = point[0];
          if (point[1] < min[1]) min[1] = point[1];
          if (point[2] < min[2]) min[2] = point[2];
          if (point[0] > max[0]) max[0] = point[0];
          if (point[1] > max[1]) max[1] = point[1];
          if (point[2] > max[2]) max[2] = point[2];
        }
      }
      surface.measureBoundingBox = [min, max];
    }
    return surface.measureBoundingBox;
  };

  const measureBoundingSphere = (surface) => {
    if (surface.measureBoundingSphere === undefined) {
      const box = measureBoundingBox$3(surface);
      const center = scale(0.5, add(box[0], box[1]));
      const radius = distance(center, box[1]);
      surface.measureBoundingSphere = [center, radius];
    }
    return surface.measureBoundingSphere;
  };

  const transformImpl = (matrix, polygons) => polygons.map(polygon => transform$3(matrix, polygon));

  const transform$5 = cacheTransform(transformImpl);

  const outline$1 = (surface, normalize = createNormalize3(), plane = toPlane$1(surface)) => {
    if (plane === undefined) {
      return [];
    }
    // FIX: Detect when the surfaces aren't in the same plane.
    const [toZ0, fromZ0] = toXYPlaneTransforms(plane);
    const z0Surface = transform$5(toZ0, surface.map(path => path.map(normalize)));
    const outlinedZ0Surface = outline(z0Surface, normalize);
    return transform$5(fromZ0, outlinedZ0Surface).map(path => path.map(normalize));
  };

  const retessellate$1 = (surface, normalize3 = createNormalize3(), plane) => {
    if (surface.length < 2) {
      return surface;
    }
    if (plane === undefined) {
      plane = toPlane$1(surface);
      if (plane === undefined) {
        return [];
      }
    }
    const [toZ0, fromZ0] = toXYPlaneTransforms(plane);
    const z0Surface = transform$5(toZ0, surface.map(path => path.map(normalize3)));
    const retessellated = retessellate(z0Surface);
    return transform$5(fromZ0, retessellated).map(path => path.map(normalize3));
  };

  const transform$6 = (matrix, solid) => solid.map(surface => transform$4(matrix, surface));

  const alignVertices = (solid, normalize3 = createNormalize3()) => {
    const aligned = solid.map(surface =>
      surface.map(polygon => deduplicate(polygon.map(normalize3)))
          .filter(polygon => polygon.length >= 3)
          .filter(polygon => toPlane(polygon) !== undefined));
    return aligned;
  };

  const canonicalize$6 = (solid) => solid.map(canonicalize$5);

  // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)
  const measureBoundingBox$4 = (solid) => {
    if (solid.measureBoundingBox === undefined) {
      const min = [Infinity, Infinity, Infinity];
      const max = [-Infinity, -Infinity, -Infinity];
      for (const surface of solid) {
        const [minSurface, maxSurface] = measureBoundingBox$3(surface);
        if (minSurface[0] < min[0]) min[0] = minSurface[0];
        if (minSurface[1] < min[1]) min[1] = minSurface[1];
        if (minSurface[2] < min[2]) min[2] = minSurface[2];
        if (maxSurface[0] > max[0]) max[0] = maxSurface[0];
        if (maxSurface[1] > max[1]) max[1] = maxSurface[1];
        if (maxSurface[2] > max[2]) max[2] = maxSurface[2];
      }
      solid.measureBoundingBox = [min, max];
    }
    return solid.measureBoundingBox;
  };

  const eachPoint$1 = (thunk, solid) => {
    for (const surface of solid) {
      eachPoint(thunk, surface);
    }
  };

  // Expects aligned vertices.

  const findOpenEdges = (solid, isOpen = true) => {
    const test = (closed) => isOpen ? !closed : closed;

    const edges = new Set();
    for (const surface of solid) {
      for (const face of surface) {
        for (const edge of getEdges(face)) {
          edges.add(JSON.stringify(edge));
        }
      }
    }
    const openEdges = [];
    for (const surface of solid) {
      for (const face of surface) {
        for (const [start, end] of getEdges(face)) {
          if (test(edges.has(JSON.stringify([end, start])))) {
            openEdges.push([start, end]);
          }
        }
      }
    }
    return openEdges;
  };

  const flip$5 = (solid) => solid.map(surface => flip$4(surface));

  // The resolution is 1 / multiplier.
  const multiplier = 1e5;

  const X$9 = 0;
  const Y$9 = 1;
  const Z$5 = 2;
  const W$3 = 3;

  const createNormalize4 = () => {
    const map = new Map();
    const normalize4 = (coordinate) => {
      // Apply a spatial quantization to the 4 dimensional coordinate.
      const nx = Math.floor(coordinate[X$9] * multiplier - 0.5);
      const ny = Math.floor(coordinate[Y$9] * multiplier - 0.5);
      const nz = Math.floor(coordinate[Z$5] * multiplier - 0.5);
      const nw = Math.floor(coordinate[W$3] * multiplier - 0.5);
      // Look for an existing inhabitant.
      const value = map.get(`${nx}/${ny}/${nz}/${nw}`);
      if (value !== undefined) {
        return value;
      }
      // One of the ~0 or ~1 values will match the rounded values above.
      // The other will match the adjacent cell.
      const nx0 = nx;
      const ny0 = ny;
      const nz0 = nz;
      const nw0 = nw;
      const nx1 = nx0 + 1;
      const ny1 = ny0 + 1;
      const nz1 = nz0 + 1;
      const nw1 = nw0 + 1;
      // Populate the space of the quantized value and its adjacencies.
      // const normalized = [nx1 / multiplier, ny1 / multiplier, nz1 / multiplier, nw1 / multiplier];
      // FIX: Rename the function to reflect that it seems that we cannot quantize planes,
      // but we can form a consensus among nearby planes.
      const normalized = coordinate;
      map.set(`${nx0}/${ny0}/${nz0}/${nw0}`, normalized);
      map.set(`${nx0}/${ny0}/${nz0}/${nw1}`, normalized);
      map.set(`${nx0}/${ny0}/${nz1}/${nw0}`, normalized);
      map.set(`${nx0}/${ny0}/${nz1}/${nw1}`, normalized);
      map.set(`${nx0}/${ny1}/${nz0}/${nw0}`, normalized);
      map.set(`${nx0}/${ny1}/${nz0}/${nw1}`, normalized);
      map.set(`${nx0}/${ny1}/${nz1}/${nw0}`, normalized);
      map.set(`${nx0}/${ny1}/${nz1}/${nw1}`, normalized);
      map.set(`${nx1}/${ny0}/${nz0}/${nw0}`, normalized);
      map.set(`${nx1}/${ny0}/${nz0}/${nw1}`, normalized);
      map.set(`${nx1}/${ny0}/${nz1}/${nw0}`, normalized);
      map.set(`${nx1}/${ny0}/${nz1}/${nw1}`, normalized);
      map.set(`${nx1}/${ny1}/${nz0}/${nw0}`, normalized);
      map.set(`${nx1}/${ny1}/${nz0}/${nw1}`, normalized);
      map.set(`${nx1}/${ny1}/${nz1}/${nw0}`, normalized);
      map.set(`${nx1}/${ny1}/${nz1}/${nw1}`, normalized);
      // This is now the normalized value for this region.
      return normalized;
    };
    return normalize4;
  };

  let doDefragment = 'none';

  const fromPolygons = (options = {}, polygons, normalize3 = createNormalize3()) => {
    const normalize4 = createNormalize4();
    const coplanarGroups = new Map();

    for (const polygon of polygons) {
      if (polygon.length < 3) {
        // Polygon became degenerate.
        continue;
      }
      const plane = toPlane(polygon);
      if (plane === undefined) {
        // Polygon is degenerate -- probably on a line.
        continue;
      }
      // Here we use a strict plane identity to merge.
      // This may result in fragmentation.
      // const key = JSON.stringify(toPlane(polygon));
      const key = normalize4(toPlane(polygon));
      const groups = coplanarGroups.get(key);
      if (groups === undefined) {
        const group = [polygon];
        group.plane = key;
        coplanarGroups.set(key, group);
      } else {
        groups.push(polygon);
      }
    }

    // The solid is a list of surfaces, which are lists of coplanar polygons.
    const defragmented = [];

    // Possibly erase substructure and make convex.
    for (const polygons of coplanarGroups.values()) {
      let surface;
      switch (doDefragment) {
        case 'makeConvex':
          surface = makeConvex$1(polygons, normalize3, toPlane(polygons[0]));
          break;
        case 'retessellate':
          surface = retessellate$1(polygons, normalize3, toPlane(polygons[0]));
          break;
        case 'none':
        default:
          surface = polygons;
          break;
      }
      defragmented.push(surface);
    }

    return defragmented;
    // return makeWatertight(defragmented, normalize3);
  };

  const outline$2 = (solid, normalize) => {
    const polygons = [];
    for (const surface of solid) {
      const plane = toPlane$1(surface);
      for (const polygon of outline$1(surface)) {
        polygon.plane = plane;
        polygons.push(polygon);
      }
    }
    return polygons;
  };

  const reconcile = (solid, normalize = createNormalize3()) =>
    alignVertices(solid, normalize);

  // Relax the coplanar arrangement into polygon soup.
  const toPolygons = (solid) => {
    const polygons = [];
    for (const surface of solid) {
      polygons.push(...surface);
    }
    return polygons;
  };

  const update = (geometry, updates) => {
    const updated = {};
    for (const key of Object.keys(geometry)) {
      if (typeof key !== 'symbol') {
        updated[key] = geometry[key];
      }
    }
    for (const key of Object.keys(updates)) {
      updated[key] = updates[key];
    }
    return updated;
  };

  const rewrite = (geometry, op) => {
    const walk = (geometry) => {
      if (geometry.assembly) {
        return op(geometry, _ => update(geometry, { assembly: geometry.assembly.map(walk) }), walk);
      } else if (geometry.disjointAssembly) {
        return op(geometry, _ => update(geometry, { disjointAssembly: geometry.disjointAssembly.map(walk) }), walk);
      } else if (geometry.layers) {
        return op(geometry, _ => update(geometry, { layers: geometry.layers.map(walk) }), walk);
      } else if (geometry.connection) {
        return op(geometry,
                  _ => update(geometry, { geometries: geometry.geometries.map(walk), connectors: geometry.connectors.map(walk) }),
                  walk);
      } else if (geometry.item) {
        return op(geometry, _ => update(geometry, { item: walk(geometry.item) }), walk);
      } else if (geometry.paths) {
        return op(geometry, _ => geometry, walk);
      } else if (geometry.plan) {
        return op(geometry, _ => update(geometry, { content: walk(geometry.content) }), walk);
      } else if (geometry.points) {
        return op(geometry, _ => geometry, walk);
      } else if (geometry.solid) {
        return op(geometry, _ => geometry, walk);
      } else if (geometry.surface) {
        return op(geometry, _ => geometry, walk);
      } else if (geometry.untransformed) {
        return op(geometry, _ => update(geometry, { untransformed: walk(geometry.untransformed) }), walk);
      } else if (geometry.z0Surface) {
        return op(geometry, _ => geometry, walk);
      } else {
        throw Error('die: Unknown geometry');
      }
    };
    return walk(geometry);
  };

  const visit = (geometry, op) => {
    const walk = (geometry) => {
      if (geometry.assembly) {
        op(geometry, _ => geometry.assembly.forEach(walk));
      } else if (geometry.disjointAssembly) {
        op(geometry, _ => geometry.disjointAssembly.forEach(walk));
      } else if (geometry.layers) {
        op(geometry, _ => geometry.layers.forEach(walk));
      } else if (geometry.connection) {
        op(geometry, _ => { geometry.geometries.forEach(walk); geometry.connectors.forEach(walk); });
      } else if (geometry.item) {
        op(geometry, _ => walk(geometry.item));
      } else if (geometry.paths) {
        op(geometry, _ => undefined);
      } else if (geometry.plan) {
        op(geometry, _ => { walk(geometry.content); });
      } else if (geometry.points) {
        op(geometry, _ => undefined);
      } else if (geometry.solid) {
        op(geometry, _ => undefined);
      } else if (geometry.surface) {
        op(geometry, _ => undefined);
      } else if (geometry.untransformed) {
        op(geometry, _ => walk(geometry.untransformed));
      } else if (geometry.z0Surface) {
        op(geometry, _ => undefined);
      } else {
        throw Error('die: Unknown geometry');
      }
    };
    walk(geometry);
  };

  const reconcile$1 = (geometry, normalize = createNormalize3()) =>
    rewrite(geometry,
            (geometry, descend) => {
              if (geometry.solid) {
                return {
                  solid: reconcile(geometry.solid, normalize),
                  tags: geometry.tags
                };
              } else {
                return descend();
              }
            });

  const makeWatertight$1 = (geometry, normalize = createNormalize3(), onFixed) =>
    rewrite(geometry,
            (geometry, descend) => {
              if (geometry.solid) {
                return {
                  solid: makeWatertight(geometry.solid, normalize, onFixed),
                  tags: geometry.tags
                };
              } else {
                return descend();
              }
            });

  const isWatertight$1 = (geometry) => {
    let watertight = true;
    visit(geometry,
          (geometry, descend) => {
            if (geometry.solid && !isWatertight(geometry.solid)) {
              watertight = false;
            }
            return descend();
          });
    return watertight;
  };

  // Remove any symbols (which refer to cached values).
  const fresh = (geometry) => {
    const fresh = {};
    for (const key of Object.keys(geometry)) {
      if (typeof key !== 'symbol') {
        fresh[key] = geometry[key];
      }
    }
    return fresh;
  };

  const shallowEq = (a, b) => {
    if (a === undefined) throw Error('die');
    if (b === undefined) throw Error('die');
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };

  // Rewrite on the way back up the call-path.
  const rewriteUp = (geometry, op) => {
    // FIX: Minimize identity churn.
    const walk = (geometry) => {
      const q = (postopGeometry) => {
        if (postopGeometry === undefined) {
          return geometry;
        } else if (postopGeometry === geometry) {
          return geometry;
        } else {
          return fresh(postopGeometry);
        }
      };

      if (geometry.assembly) {
        const assembly = geometry.assembly.map(walk);
        if (shallowEq(assembly, geometry.assembly)) {
          return q(op(geometry));
        } else {
          return q(op({ ...geometry, assembly }));
        }
      } else if (geometry.disjointAssembly) {
        const disjointAssembly = geometry.disjointAssembly.map(walk);
        if (shallowEq(disjointAssembly, geometry.disjointAssembly)) {
          return q(op(geometry));
        } else {
          return q(op({ ...geometry, disjointAssembly }));
        }
      } else if (geometry.layers) {
        const layers = geometry.layers.map(walk);
        if (shallowEq(layers, geometry.layers)) {
          return q(op(geometry));
        } else {
          return q(op({ ...geometry, layers }));
        }
      } else if (geometry.connection) {
        const geometries = geometry.geometries.map(walk);
        const connectors = geometry.connectors.map(walk);
        if (shallowEq(geometries, geometry.geometries) &&
            shallowEq(connectors, geometry.connectors)) {
          return q(op(geometry));
        } else {
          return q(op({ ...geometry, geometries, connectors }));
        }
      } else if (geometry.item) {
        const item = walk(geometry.item);
        if (item === geometry.item) {
          return q(op(geometry));
        } else {
          return q(op({ ...geometry, item }));
        }    } else if (geometry.paths) {
        return q(op(geometry));
      } else if (geometry.plan) {
        const content = walk(geometry.content);
        if (content === geometry.content) {
          return q(op(geometry));
        } else {
          return q(op({ ...geometry, content }));
        }
      } else if (geometry.points) {
        return q(op(geometry));
      } else if (geometry.solid) {
        return q(op(geometry));
      } else if (geometry.surface) {
        return q(op(geometry));
      } else if (geometry.untransformed) {
        const untransformed = walk(geometry.untransformed);
        if (untransformed === geometry.untransformed) {
          return q(op(geometry));
        } else {
          return q(op({ ...geometry, untransformed }));
        }
      } else if (geometry.z0Surface) {
        return q(op(geometry));
      } else {
        throw Error('die: Unknown geometry');
      }
    };

    return walk(geometry);
  };

  // FIX: Refactor the geometry walkers.

  const allTags = (geometry) => {
    const collectedTags = new Set();
    const op = ({ tags }) => {
      if (tags !== undefined) {
        for (const tag of tags) {
          collectedTags.add(tag);
        }
      }
    };
    rewriteUp(geometry, op);
    return collectedTags;
  };

  const assembleImpl = (...taggedGeometries) => ({ assembly: taggedGeometries });

  const assemble = cache(assembleImpl);

  const canonicalize$7 = (paths) => {
    let canonicalized = paths.map(canonicalize$1);
    if (paths.properties !== undefined) {
      // Transfer properties.
      canonicalized.properties = paths.properties;
    }
    return canonicalized;
  };

  // FIX: Determine the correct behaviour here.

  const difference$1 = (pathset, ...pathsets) => pathset;

  const eachPoint$2 = (thunk, paths) => {
    for (const path of paths) {
      for (const point of path) {
        if (point !== null) {
          thunk(point);
        }
      }
    }
  };

  const flip$6 = (paths) => paths.map(flip);

  const intersection$1 = (pathset, ...pathsets) => pathset;

  const transform$7 = (matrix, paths) => paths.map(path => transform$1(matrix, path));

  // FIX: Deduplication.

  const union$1 = (...pathsets) => [].concat(...pathsets);

  const translate$2 = ([x = 0, y = 0, z = 0], paths) => transform$7(fromTranslation([x, y, z]), paths);

  const transform$8 = (matrix, points) => points.map(point => transform(matrix, point));
  const translate$3 = ([x = 0, y = 0, z = 0], points) => transform$8(fromTranslation([x, y, z]), points);

  const canonicalize$8 = (points) => points.map(canonicalize);

  const eachPoint$3 = (thunk, points) => {
    for (const point of points) {
      thunk(point);
    }
  };

  const flip$7 = (points) => points;

  const transformedGeometry = Symbol('transformedGeometry');

  const toTransformedGeometry = (geometry) => {
    if (geometry[transformedGeometry] === undefined) {
      const walk = (matrix, geometry) => {
        const { tags } = geometry;
        if (geometry.matrix) {
          // Preserve any tags applied to the untransformed geometry.
          // FIX: Ensure tags are merged between transformed and untransformed upon resolution.
          return walk(multiply$1(matrix, geometry.matrix),
                      geometry.untransformed);
        } else if (geometry.assembly) {
          return {
            assembly: geometry.assembly.map(geometry => walk(matrix, geometry)),
            tags
          };
        } else if (geometry.disjointAssembly) {
          return {
            disjointAssembly: geometry.disjointAssembly.map(geometry => walk(matrix, geometry)),
            tags
          };
        } else if (geometry.layers) {
          return {
            layers: geometry.layers.map(geometry => walk(matrix, geometry)),
            tags
          };
        } else if (geometry.item) {
          return {
            item: walk(matrix, geometry.item),
            tags
          };
        } else if (geometry.connection) {
          return {
            // A connection is a list of geometry with connections (connectors that have been connected)
            // The join can be released, to yield the geometry with the disconnected connections reconnected.
            connection: geometry.connection,
            geometries: geometry.geometries.map(geometry => walk(matrix, geometry)),
            connectors: geometry.connectors.map(connector => walk(matrix, connector)),
            tags
          };
        } else if (geometry.paths) {
          return {
            paths: transform$7(matrix, geometry.paths),
            tags
          };
        } else if (geometry.plan) {
          return {
            plan: geometry.plan,
            marks: transform$8(matrix, geometry.marks),
            planes: geometry.planes.map(plane => transform$2(matrix, plane)),
            content: walk(matrix, geometry.content),
            visualization: walk(matrix, geometry.visualization),
            tags
          };
        } else if (geometry.points) {
          return {
            points: transform$8(matrix, geometry.points),
            tags
          };
        } else if (geometry.solid) {
          return {
            solid: transform$6(matrix, reconcile(geometry.solid)),
            tags
          };
        } else if (geometry.surface) {
          return {
            surface: transform$4(matrix, geometry.surface),
            tags
          };
        } else if (geometry.z0Surface) {
          // FIX: Consider transforms that preserve z0.
          return {
            surface: transform$4(matrix, geometry.z0Surface),
            tags
          };
        } else {
          throw Error(`die: ${JSON.stringify(geometry)}`);
        }
      };
      geometry[transformedGeometry] = walk(identity(), geometry);
    }
    return geometry[transformedGeometry];
  };

  const canonicalize$9 = (rawGeometry) => {
    const geometry = toTransformedGeometry(rawGeometry);
    const canonicalized = {};
    if (geometry.points !== undefined) {
      canonicalized.points = canonicalize$8(geometry.points);
    } else if (geometry.paths !== undefined) {
      canonicalized.paths = canonicalize$7(geometry.paths);
    } else if (geometry.plan !== undefined) {
      canonicalized.plan = geometry.plan;
      canonicalized.marks = canonicalize$8(geometry.marks);
      canonicalized.planes = geometry.planes.map(canonicalize$3);
      canonicalized.visualization = canonicalize$9(geometry.visualization);
      canonicalized.content = canonicalize$9(geometry.content);
    } else if (geometry.connection) {
      canonicalized.connection = geometry.connection;
      canonicalized.geometries = geometry.geometries.map(canonicalize$9);    canonicalized.connectors = geometry.connectors.map(canonicalize$9);  } else if (geometry.surface !== undefined) {
      canonicalized.surface = canonicalize$5(geometry.surface);
    } else if (geometry.z0Surface !== undefined) {
      canonicalized.z0Surface = canonicalize$5(geometry.z0Surface);
    } else if (geometry.solid !== undefined) {
      canonicalized.solid = canonicalize$6(geometry.solid);
    } else if (geometry.assembly !== undefined) {
      canonicalized.assembly = geometry.assembly.map(canonicalize$9);
    } else if (geometry.layers !== undefined) {
      canonicalized.layers = geometry.layers.map(canonicalize$9);
    } else if (geometry.disjointAssembly !== undefined) {
      canonicalized.disjointAssembly = geometry.disjointAssembly.map(canonicalize$9);
    } else if (geometry.item !== undefined) {
      canonicalized.item = canonicalize$9(geometry.item);
    } else {
      throw Error('die');
    }
    if (geometry.tags !== undefined) {
      canonicalized.tags = geometry.tags;
    }
    return canonicalized;
  };

  const eachItem = (geometry, op) => {
    const walk = (geometry, descend) => { op(geometry); descend(); };
    visit(geometry, walk);
  };

  const getPaths = (geometry) => {
    const pathsets = [];
    eachItem(geometry,
             item => {
               if (item.paths) {
                 pathsets.push(item);
               }
             });
    return pathsets;
  };

  const getSolids = (geometry) => {
    const solids = [];
    eachItem(geometry,
             item => {
               if (item.solid) {
                 solids.push(item);
               }
             });
    return solids;
  };

  const getSurfaces = (geometry) => {
    const surfaces = [];
    eachItem(geometry,
             item => {
               if (item.surface) {
                 surfaces.push(item);
               }
             });
    return surfaces;
  };

  const getZ0Surfaces = (geometry) => {
    const z0Surfaces = [];
    eachItem(geometry,
             item => {
               if (item.z0Surface) {
                 z0Surfaces.push(item);
               }
             });
    return z0Surfaces;
  };

  const EPSILON$2 = 1e-5;
  // const EPSILON2 = 1e-10;

  const COPLANAR$1 = 0; // Neither front nor back.
  const FRONT$1 = 1;
  const BACK$1 = 2;
  const SPANNING$1 = 3; // Both front and back.

  const dot$2 = (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2];

  // const toType = (plane, point) => {
  //   // const t = planeDistance(plane, point);
  //   const t = plane[0] * point[0] + plane[1] * point[1] + plane[2] * point[2] - plane[3];
  //   if (t < -EPSILON) {
  //     return BACK;
  //   } else if (t > EPSILON) {
  //     return FRONT;
  //   } else {
  //     return COPLANAR;
  //   }
  // };

  const pointType$1 = [];

  const splitConvex = (normalize, plane, points, polygonPlane, back, front) => {
    const buildList = (points) => {
      const nodes = [];
      let head = null;
      let tail = null;
      const addLink = (point, type, next = null, link = null, visited = false) => {
        const node = { point, type, next, link, visited };
        if (head === null) {
          head = node;
          head.next = head;
        } else {
          tail.next = node;
        }
        nodes.push(node);
        tail = node;
        tail.next = head;
      };
      for (let index = 0; index < points.length; index++) {
        addLink(points[index], pointType$1[index]);
      }
      return nodes;
    };

    const orderSpans = (spans) => {
      const trendVector = subtract(spans[0].point, spans[1].point);
      const trend = (point) => dot$2(point, trendVector);
      const orderByTrend = (a, b) => {
        const ta = trend(a.point);
        const tb = trend(b.point);
        return ta - tb;
      };
      spans.sort(orderByTrend);
      return spans;
    };

    const buildSpans = (head) => {
      const spans = [];
      let node = head;
      do {
        const next = node.next;
        if ((node.type === FRONT$1 && next.type !== FRONT$1) ||
            (node.type !== FRONT$1 && next.type === FRONT$1)) {
          // Interpolate a span-point.
          const spanPoint = normalize(splitLineSegmentByPlane(plane, node.point, next.point));
          const span = { point: spanPoint, type: COPLANAR$1, next, link: null, visited: true };
          node.next = span;
          // Remember the split for ordering.
          spans.push(span);
        }
        node = next;
      } while (node !== head);
      return orderSpans(spans);
    };

    const nodes = buildList(points);
    const spans = buildSpans(nodes[0]);

    while (spans.length >= 2) {
      const a = spans.pop();
      const b = spans.pop();
      a.link = b;
      b.link = a;
    }

    for (const start of nodes) {
      if (start.visited === true) {
        continue;
      }

      const points = [];
      let node = start;
      let type = 0;
      do {
        node.visited = true;
        type |= node.type;
        points.push(node.point);
        if (node.link !== null) {
          node = node.link;
          points.push(node.point);
          node.visited = true;
        }
        node = node.next;
      } while (node !== start);
      if (type === FRONT$1) {
        pushWhenValid(front, points, polygonPlane);
      } else if (type === BACK$1) {
        pushWhenValid(back, points, polygonPlane);
      } else {
        throw Error('die');
      }
    }
  };

  const splitPolygon$1 = (normalize, plane, polygon, back, abutting, overlapping, front) => {
    /*
      // This slows things down on average, probably due to not having the bounding sphere computed.
      // Check for non-intersection due to distance from the plane.
      const [center, radius] = measureBoundingSphere(polygon);
      let distance = planeDistance(plane, center) + EPSILON;
      if (distance > radius) {
        front.push(polygon);
        return;
      } else if (distance < -radius) {
        back.push(polygon);
        return;
      }
    */
    let polygonType = COPLANAR$1;
    const polygonPlane = toPlane(polygon);
    if (polygonPlane === undefined) {
      // Degenerate polygon
      return;
    }
    if (!equals$2(polygonPlane, plane)) {
      for (let nth = 0; nth < polygon.length; nth++) {
        // const type = toType(plane, polygon[nth]);
        // const t = planeDistance(plane, point);
        const point = polygon[nth];
        const t = plane[0] * point[0] + plane[1] * point[1] + plane[2] * point[2] - plane[3];
        if (t < -EPSILON$2) {
          polygonType |= BACK$1;
          pointType$1[nth] = BACK$1;
        } else if (t > EPSILON$2) {
          polygonType |= FRONT$1;
          pointType$1[nth] = FRONT$1;
        } else {
          polygonType |= COPLANAR$1;
          pointType$1[nth] = COPLANAR$1;
        }
      }
    }

    // Put the polygon in the correct list, splitting it when necessary.
    switch (polygonType) {
      case COPLANAR$1:
        if (dot$2(plane, polygonPlane) > 0) {
          // The plane and the polygon face the same way, so the spaces overlap.
          overlapping.push(polygon);
        } else {
          // The plane and the polygon face the opposite directions, so the spaces abut.
          abutting.push(polygon);
        }
        return;
      case FRONT$1:
        front.push(polygon);
        return;
      case BACK$1:
        back.push(polygon);
        return;
      case SPANNING$1: {
        const frontPoints = [];
        const backPoints = [];
        const spanPoints = [];

        const last = polygon.length - 1;
        let startPoint = polygon[last];
        let startType = pointType$1[last];
        for (let nth = 0; nth < polygon.length; nth++) {
          const endPoint = polygon[nth];
          const endType = pointType$1[nth];
          if (startType !== BACK$1) {
            // The inequality is important as it includes COPLANAR points.
            frontPoints.push(startPoint);
          }
          if (startType !== FRONT$1) {
            // The inequality is important as it includes COPLANAR points.
            backPoints.push(startPoint);
          }
          if ((startType | endType) === SPANNING$1) {
            // This should exclude COPLANAR points.
            // Compute the point that touches the splitting plane.
            const spanPoint = normalize(splitLineSegmentByPlane(plane, startPoint, endPoint));
            frontPoints.push(spanPoint);
            backPoints.push(spanPoint);
            spanPoints.push(spanPoint);
          }
          startPoint = endPoint;
          startType = endType;
        }
        if (spanPoints.length <= 2) {
          pushWhenValid(front, frontPoints, polygonPlane);
          pushWhenValid(back, backPoints, polygonPlane);
        } else {
          splitConvex(normalize, plane, polygon, polygonPlane, back, front);
        }
        /*
        if ((spans.length % 2) === 0) {
          throw Error('die: Even number of spans.');
        }
        if (spans.length > 3) {
          const trendVector = subtract(spans[0][SPAN_POINT], spans[1][SPAN_POINT]);
          const trend = (point) => dot(point, trendVector);
          spans.sort(([a], [b]) => a === null ? -1 : trend(a) - trend(b));
          // The order needs to be such that the span joins follow the winding
          // direction.
          for (let i = 0; i < spans; i++) {
            spans[i][BACK_SPAN] = spans[spans.length - i][BACK_SPAN_BACKWARD];
          }
          // Each span-pair is now an enter + exit, given the winding rule.
          // But not necessarily an enter + exit for the same contour.
          // We must re-arrange so that the contours are connected properly.
          // Check to split points.
          // Now the span points are sequenced.
          // Restitch the graph.
          while (spans.length > 0) {
            const exit = spans.pop();
            const enter = spans.pop();
            // Prepend the enter nodes to the exit nodes.
            enter[FRONT_SPAN].unshift(...exit[FRONT_SPAN]);
            enter[BACK_SPAN].unshift(...exit[BACK_SPAN]);
            if (spans.length > 0) {
              // If the enter ends with the next exit, join them up.
              const nextExit = tail(spans);
              if (equalsPoint(nextExit[SPAN_POINT], tail(enter[FRONT_SPAN]))) {
                nextExit[FRONT_SPAN].unshift(...enter[FRONT_SPAN]);
              } else {
                pushWhenValid(front, enter[FRONT_SPAN], polygonPlane);
              }
              if (equalsPoint(nextExit[SPAN_POINT], tail(enter[BACK_SPAN]))) {
                nextExit[BACK_SPAN].unshift(...enter[BACK_SPAN]);
              } else {
                pushWhenValid(back, enter[BACK_SPAN], polygonPlane);
              }
            } else {
              // These are the final spans, they cannot be deferred.
              pushWhenValid(front, enter[FRONT_SPAN], polygonPlane);
              pushWhenValid(back, enter[BACK_SPAN], polygonPlane);
            }
          }
        } else {
          pushWhenValid(front, spans[0][FRONT_SPAN], polygonPlane);
          pushWhenValid(back, spans[0][BACK_SPAN], polygonPlane);
        }
  */
        break;
      }
    }
  };

  const BRANCH = 0;
  const IN_LEAF = 1;
  const OUT_LEAF = 2;

  const X$a = 0;
  const Y$a = 1;
  const Z$6 = 2;

  const inLeaf = {
    plane: null,
    same: [],
    kind: IN_LEAF,
    back: null,
    front: null
  };

  const outLeaf = {
    plane: null,
    same: [],
    kind: OUT_LEAF,
    back: null,
    front: null
  };

  const fromBoundingBoxes = ([aMin, aMax], [bMin, bMax], front = outLeaf, back = inLeaf) => {
    const cMin = max(aMin, bMin);
    const cMax = min(aMax, bMax);
    const bsp = {
      // Bottom
      kind: BRANCH,
      plane: [0, 0, -1, -cMin[Z$6] + EPSILON$2 * 1000],
      front,
      back: {
        // Top
        kind: BRANCH,
        plane: [0, 0, 1, cMax[Z$6] + EPSILON$2 * 1000],
        front,
        back: {
          // Left
          kind: BRANCH,
          plane: [-1, 0, 0, -cMin[X$a] + EPSILON$2 * 1000],
          front,
          back: {
            // Right
            kind: BRANCH,
            plane: [1, 0, 0, cMax[X$a] + EPSILON$2 * 1000],
            front,
            back: {
              // Back
              kind: BRANCH,
              plane: [0, -1, 0, -cMin[Y$a] + EPSILON$2 * 1000],
              front,
              back: {
                // Front
                kind: BRANCH,
                plane: [0, 1, 0, cMax[Y$a] + EPSILON$2 * 1000],
                front: outLeaf,
                back
              }
            }
          }
        }
      }
    };
    return bsp;
  };

  const fromPolygonsToBspTree = (polygons, normalize) => {
    if (polygons.length === 0) {
      // Everything is outside of an empty geometry.
      return outLeaf;
    }
    let same = [];
    let front = [];
    let back = [];
    let plane = toPlane(polygons[polygons.length >> 1]);

    if (plane === undefined) {
      throw Error('die');
    }

    for (const polygon of polygons) {
      splitPolygon$1(normalize,
                   plane,
                   polygon,
                   /* back= */back,
                   /* abutting= */back,
                   /* overlapping= */same,
                   /* front= */front);
    }

    const bsp = {
      back: back.length === 0 ? inLeaf : fromPolygonsToBspTree(back, normalize),
      front: front.length === 0 ? outLeaf : fromPolygonsToBspTree(front, normalize),
      kind: BRANCH,
      plane,
      same
    };

    return bsp;
  };

  const fromPolygons$1 = (polygons, normalize) =>
    // fromPolygonsToBspTree(polygons.filter(polygon => toPlane(polygon) !== undefined), normalize);
    fromPolygonsToBspTree(polygons, normalize);

  const fromSolid = (solid, normalize) => {
    const polygons = [];
    for (const surface of solid) {
      polygons.push(...surface);
    }
    return fromPolygons$1(polygons, normalize);
  };

  const keepIn = (polygons) => {
    for (const polygon of polygons) {
      polygon.leaf = inLeaf;
    }
    return polygons;
  };

  const keepOut = (polygons) => {
    for (const polygon of polygons) {
      polygon.leaf = outLeaf;
    }
    return polygons;
  };

  // Merge the result of a split.
  const merge = (front, back) => {
    const merged = [];
    const scan = (polygons) => {
      for (const polygon of polygons) {
        if (polygon.leaf) {
          if (polygon.sibling && polygon.sibling.leaf === polygon.leaf) {
            polygon.parent.leaf = polygon.leaf;
            polygon.leaf = null;
            polygon.sibling.leaf = undefined;
            merged.push(polygon.parent);
          } else {
            merged.push(polygon);
          }
        }
      }
    };
    scan(front);
    scan(back);
    return merged;
  };

  const clean = (polygons) => {
    for (const polygon of polygons) {
      delete polygon.parent;
      delete polygon.sibling;
    }
    return polygons;
  };

  const removeInteriorPolygonsForUnionKeepingOverlap = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return [];
    } else if (bsp === outLeaf) {
      return keepOut(polygons);
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back,
                     /* abutting= */back,
                     /* overlapping= */front,
                     /* front= */front);
      }
      const trimmedFront = removeInteriorPolygonsForUnionKeepingOverlap(bsp.front, front, normalize);
      const trimmedBack = removeInteriorPolygonsForUnionKeepingOverlap(bsp.back, back, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  const removeInteriorPolygonsForUnionDroppingOverlap = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return [];
    } else if (bsp === outLeaf) {
      return keepOut(polygons);
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back,
                     /* abutting= */back,
                     /* overlapping= */back,
                     /* front= */front);
      }
      const trimmedFront = removeInteriorPolygonsForUnionDroppingOverlap(bsp.front, front, normalize);
      const trimmedBack = removeInteriorPolygonsForUnionDroppingOverlap(bsp.back, back, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  const removeExteriorPolygonsForSection = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return keepIn(polygons);
    } else if (bsp === outLeaf) {
      return [];
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back,
                     /* abutting= */front,
                     /* overlapping= */back,
                     /* front= */front);
      }
      const trimmedFront = removeExteriorPolygonsForSection(bsp.front, front, normalize);
      const trimmedBack = removeExteriorPolygonsForSection(bsp.back, back, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  const removeExteriorPolygonsForCutDroppingOverlap = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return keepIn(polygons);
    } else if (bsp === outLeaf) {
      return [];
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back, // keepward
                     /* abutting= */front, // dropward
                     /* overlapping= */front, // dropward
                     /* front= */front); // dropward
      }
      const trimmedFront = removeExteriorPolygonsForCutDroppingOverlap(bsp.front, front, normalize);
      const trimmedBack = removeExteriorPolygonsForCutDroppingOverlap(bsp.back, back, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  const removeExteriorPolygonsForCutKeepingOverlap = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return keepIn(polygons);
    } else if (bsp === outLeaf) {
      return [];
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back, // keepward
                     /* abutting= */front, // dropward
                     /* overlapping= */back, // keepward
                     /* front= */front); // dropward
      }
      const trimmedFront = removeExteriorPolygonsForCutKeepingOverlap(bsp.front, front, normalize);
      const trimmedBack = removeExteriorPolygonsForCutKeepingOverlap(bsp.back, back, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  const removeInteriorPolygonsForDifference = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return [];
    } else if (bsp === outLeaf) {
      return keepOut(polygons);
    } else {
      const outward = [];
      const inward = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */inward,
                     /* abutting= */outward, // keepward
                     /* overlapping= */inward, // dropward
                     /* front= */outward);
      }
      const trimmedFront = removeInteriorPolygonsForDifference(bsp.front, outward, normalize);
      const trimmedBack = removeInteriorPolygonsForDifference(bsp.back, inward, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  const removeExteriorPolygonsForDifference = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return keepIn(polygons);
    } else if (bsp === outLeaf) {
      return [];
    } else {
      const outward = [];
      const inward = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */inward,
                     /* abutting= */outward, // dropward
                     /* overlapping= */outward, // dropward
                     /* front= */outward);
      }
      const trimmedFront = removeExteriorPolygonsForDifference(bsp.front, outward, normalize);
      const trimmedBack = removeExteriorPolygonsForDifference(bsp.back, inward, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  const removeExteriorPolygonsForIntersectionKeepingOverlap = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return keepIn(polygons);
    } else if (bsp === outLeaf) {
      return [];
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back,
                     /* abutting= */front,
                     /* overlapping= */back,
                     /* front= */front);
      }
      const trimmedFront = removeExteriorPolygonsForIntersectionKeepingOverlap(bsp.front, front, normalize);
      const trimmedBack = removeExteriorPolygonsForIntersectionKeepingOverlap(bsp.back, back, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  const removeExteriorPolygonsForIntersectionDroppingOverlap = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return keepIn(polygons);
    } else if (bsp === outLeaf) {
      return [];
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back,
                     /* abutting= */front,
                     /* overlapping= */front,
                     /* front= */front);
      }
      const trimmedFront = removeExteriorPolygonsForIntersectionDroppingOverlap(bsp.front, front, normalize);
      const trimmedBack = removeExteriorPolygonsForIntersectionDroppingOverlap(bsp.back, back, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return merge(trimmedFront, trimmedBack);
      }
    }
  };

  // Don't merge the fragments for this one.
  const dividePolygons = (bsp, polygons, normalize) => {
    if (bsp === inLeaf) {
      return polygons;
    } else if (bsp === outLeaf) {
      return polygons;
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back,
                     /* abutting= */front,
                     /* overlapping= */back,
                     /* front= */front);
      }
      const trimmedFront = dividePolygons(bsp.front, front, normalize);
      const trimmedBack = dividePolygons(bsp.back, back, normalize);

      if (trimmedFront.length === 0) {
        return trimmedBack;
      } else if (trimmedBack.length === 0) {
        return trimmedFront;
      } else {
        return [].concat(trimmedFront, trimmedBack);
      }
    }
  };

  const separatePolygonsForBoundPolygons = (bsp, polygons, normalize) => {
    if (polygons.length === 0) {
      return [];
    } else if (bsp === inLeaf) {
      return keepIn(polygons);
    } else if (bsp === outLeaf) {
      return keepOut(polygons);
    } else {
      const front = [];
      const back = [];
      for (let i = 0; i < polygons.length; i++) {
        splitPolygon$1(normalize,
                     bsp.plane,
                     polygons[i],
                     /* back= */back, // toward keepIn
                     /* abutting= */front, // toward keepOut
                     /* overlapping= */back, // toward keepIn
                     /* front= */front); // toward keepOut
      }
      const trimmedFront = separatePolygonsForBoundPolygons(bsp.front, front, normalize);
      const trimmedBack = separatePolygonsForBoundPolygons(bsp.back, back, normalize);

      return [...trimmedFront, ...trimmedBack];
    }
  };

  const boundPolygons = (bsp, polygons, normalize) => {
    const inPolygons = [];
    const outPolygons = [];
    for (const polygon of separatePolygonsForBoundPolygons(bsp, polygons, normalize)) {
      if (polygon.leaf === inLeaf) {
        inPolygons.push(polygon);
      } else if (polygon.leaf === outLeaf) {
        outPolygons.push(polygon);
      }
    }
    return [clean(inPolygons), clean(outPolygons)];
  };

  const cut$1 = (solid, surface, normalize = createNormalize3()) => {
    // Build a classifier from the planar polygon.
    const cutBsp = fromPolygons$1(surface, normalize);
    const solidPolygons = toPolygons(alignVertices(solid, normalize));

    // Classify the solid with it.
    const trimmedSolid = removeExteriorPolygonsForCutDroppingOverlap(cutBsp, solidPolygons, normalize);

    // The solid will have holes that need to be patched with the parts of the
    // planar polygon that are on the solid boundary.
    const solidBsp = fromPolygons$1(solidPolygons, normalize);
    const trimmedPolygons = removeExteriorPolygonsForCutKeepingOverlap(solidBsp, surface, normalize);

    return fromPolygons({}, [...trimmedSolid, ...trimmedPolygons], normalize);
  };

  const cutOpen = (solid, surface, normalize = createNormalize3()) => {
    // Build a classifier from the planar polygon.
    const cutBsp = fromPolygons$1(surface, normalize);
    const solidPolygons = toPolygons(alignVertices(solid, normalize));

    // Classify the solid with it.
    const trimmedSolid = removeExteriorPolygonsForCutDroppingOverlap(cutBsp, solidPolygons, normalize);

    return fromPolygons({}, trimmedSolid, normalize);
  };

  const containsPoint = (bsp, point, history = []) => {
    while (true) {
      history.push(bsp);
      if (bsp === inLeaf) {
        return true;
      } else if (bsp === outLeaf) {
        return false;
      } else {
        const plane = bsp.plane;
        // const t = planeDistance(plane, point);
        const t = plane[0] * point[0] + plane[1] * point[1] + plane[2] * point[2] - plane[3];
        if (t <= 0) {
          // Consider points on the surface to be contained.
          bsp = bsp.back;
        } else {
          bsp = bsp.front;
        }
      }
    }
  };

  const X$b = 0;
  const Y$b = 1;
  const Z$7 = 2;

  const walkX = (min, max, resolution) => {
    const midX = Math.floor((min[X$b] + max[X$b]) / 2);
    if (midX === min[X$b]) { return walkY(min, max, resolution); }
    return {
      back: walkX(min, [midX, max[Y$b], max[Z$7]], resolution),
      front: walkX([midX, min[Y$b], min[Z$7]], max, resolution),
      kind: BRANCH,
      plane: [1, 0, 0, midX * resolution],
      same: []
    };
  };

  const walkY = (min, max, resolution) => {
    const midY = Math.floor((min[Y$b] + max[Y$b]) / 2);
    if (midY === min[Y$b]) { return walkZ(min, max, resolution); }
    return {
      back: walkY(min, [max[X$b], midY, max[Z$7]], resolution),
      front: walkY([min[X$b], midY, min[Z$7]], max, resolution),
      kind: BRANCH,
      plane: [0, 1, 0, midY * resolution],
      same: []
    };
  };

  const walkZ = (min, max, resolution) => {
    const midZ = Math.floor((min[Z$7] + max[Z$7]) / 2);
    if (midZ === min[Z$7]) { return inLeaf; }
    return {
      back: walkZ(min, [max[X$b], max[Y$b], midZ], resolution),
      front: walkZ([min[X$b], min[Y$b], midZ], max, resolution),
      kind: BRANCH,
      plane: [0, 0, 1, midZ * resolution],
      same: []
    };
  };

  const deform = (solid, transform, min, max, resolution) => {
    const normalize = createNormalize3();

    const solidPolygons = toPolygons(alignVertices(solid));

    const floor = ([x, y, z]) => [Math.floor(x / resolution), Math.floor(y / resolution), Math.floor(z / resolution)];
    const ceil = ([x, y, z]) => [Math.ceil(x / resolution), Math.ceil(y / resolution), Math.ceil(z / resolution)];

    const bsp = walkX(floor(min), ceil(max), resolution);

    // Classify the solid with it.
    const dividedPolygons = [];

    for (const polygon of dividePolygons(bsp, solidPolygons, normalize)) {
      if (polygon.length > 3) {
        for (let nth = 2; nth < polygon.length; nth++) {
          dividedPolygons.push([polygon[0], polygon[nth - 1], polygon[nth]]);
        }
      } else if (polygon.length === 3) {
        dividedPolygons.push(polygon);
      }
    }

    const realignedPolygons = alignVertices([dividedPolygons])[0];

    const vertices = new Map();

    // We only need this for non-deterministic transforms.
    // Let's require transforms be deterministic functions.
    for (const path of realignedPolygons) {
      for (const point of path) {
        const tag = JSON.stringify(point);
        if (!vertices.has(tag)) {
          vertices.set(tag, transform(point));
        }
      }
    }

    // Now the solid should have vertexes at the given heights, and we can apply the transform.
    const transformedPolygons = realignedPolygons.map(path => path.map(point => vertices.get(JSON.stringify(point))));

    return fromPolygons({}, transformedPolygons);
  };

  const boxPartition = (bbBsp, aBB, bBB, bbOutLeaf, aPolygons, normalize) => {
    const [aIn, aOut] = boundPolygons(bbBsp, aPolygons, normalize);
    const aBsp = fromBoundingBoxes(aBB, bBB, bbOutLeaf, fromPolygons$1(aIn, normalize));
    return [aIn, aOut, aBsp];
  };
  // export default nullPartition;

  const MIN = 0;

  const difference$2 = (aSolid, ...bSolids) => {
    if (bSolids.length === 0) {
      return aSolid;
    }

    const normalize = createNormalize3();
    let a = toPolygons(alignVertices(aSolid, normalize));
    let bs = bSolids
        .map(b => toPolygons(alignVertices(b, normalize)))
        .filter(b => !doesNotOverlap(a, b));

    while (bs.length > 0) {
      const b = bs.shift();

      const aBB = measureBoundingBox(a);
      const bBB = measureBoundingBox(b);
      const bbBsp = fromBoundingBoxes(aBB, bBB, outLeaf, inLeaf);

      const [aIn, aOut, aBsp] = boxPartition(bbBsp, aBB, bBB, inLeaf, a, normalize);
      const [bIn, , bBsp] = boxPartition(bbBsp, aBB, bBB, outLeaf, b, normalize);

      if (aIn.length === 0) {
        const bbMin = max(aBB[MIN], bBB[MIN]);
        // There are two ways for aIn to be empty: the space is fully enclosed or fully vacated.
        const aBsp = fromPolygons$1(a, normalize);
        if (containsPoint(aBsp, bbMin)) {
          // The space is fully enclosed; invert b.
          a = [...aOut, ...flip$3(bIn)];
        } else {
          // The space is fully vacated; nothing to be cut.
          continue;
        }
      } else if (bIn.length === 0) {
        const bbMin = max(aBB[MIN], bBB[MIN]);
        // There are two ways for bIn to be empty: the space is fully enclosed or fully vacated.
        const bBsp = fromPolygons$1(b, normalize);
        if (containsPoint(bBsp, bbMin)) {
          // The space is fully enclosed; only the out region remains.
          a = aOut;
        } else {
          // The space is fully vacated; nothing to cut with.
          continue;
        }
      } else {
        // Remove the parts of a that are inside b.
        const aTrimmed = removeInteriorPolygonsForDifference(bBsp, aIn, normalize);
        // Remove the parts of b that are outside a.
        const bTrimmed = removeExteriorPolygonsForDifference(aBsp, bIn, normalize);

        a = clean([...aOut, ...aTrimmed, ...flip$3(bTrimmed)]);
      }
    }
    return fromPolygons({}, a, normalize);
  };

  const MIN$1 = 0;

  // An asymmetric binary merge.
  const intersection$2 = (...solids) => {
    if (solids.length === 0) {
      return [];
    }
    if (solids.length === 1) {
      return solids[0];
    }
    const normalize = createNormalize3();
    const s = solids.map(solid => toPolygons(alignVertices(solid, normalize)));
    while (s.length > 1) {
      const a = s.shift();
      const b = s.shift();

      if (doesNotOverlap(a, b)) {
        return [];
      }

      const aBB = measureBoundingBox(a);
      const bBB = measureBoundingBox(b);
      const bbBsp = fromBoundingBoxes(aBB, bBB, outLeaf, inLeaf);

      const [aIn, , aBsp] = boxPartition(bbBsp, aBB, bBB, outLeaf, a, normalize);
      const [bIn, , bBsp] = boxPartition(bbBsp, aBB, bBB, outLeaf, b, normalize);

      if (aIn.length === 0) {
        const bbMin = max(aBB[MIN$1], bBB[MIN$1]);
        // There are two ways for aIn to be empty: the space is fully exclosed or fully vacated.
        const aBsp = fromPolygons$1(a, normalize);
        if (containsPoint(aBsp, bbMin)) {
          // The space is fully enclosed.
          s.push(bIn);
        } else {
          // The space is fully vacated.
          return [];
        }
      } else if (bIn.length === 0) {
        const bbMin = max(aBB[MIN$1], bBB[MIN$1]);
        // There are two ways for bIn to be empty: the space is fully exclosed or fully vacated.
        const bBsp = fromPolygons$1(b, normalize);
        if (containsPoint(bBsp, bbMin)) {
          // The space is fully enclosed.
          s.push(aIn);
        } else {
          // The space is fully vacated.
          return [];
        }
      } else {
        const aTrimmed = removeExteriorPolygonsForIntersectionKeepingOverlap(bBsp, aIn, normalize);
        const bTrimmed = removeExteriorPolygonsForIntersectionDroppingOverlap(aBsp, bIn, normalize);

        s.push(clean([...aTrimmed, ...bTrimmed]));
      }
    }
    return fromPolygons({}, s[0], normalize);
  };

  const section = (solid, surfaces, normalize) => {
    const bsp = fromSolid(alignVertices(solid, normalize), normalize);
    return surfaces.map(surface => removeExteriorPolygonsForSection(bsp, surface, normalize));
  };

  const MIN$2 = 0;

  // An asymmetric binary merge.
  const union$2 = (...solids) => {
    if (solids.length === 0) {
      return [];
    }
    if (solids.length === 1) {
      return solids[0];
    }
    const normalize = createNormalize3();
    const s = solids.map(solid => toPolygons(alignVertices(solid, normalize)));
    while (s.length >= 2) {
      const a = s.shift();
      const b = s.shift();

      if (doesNotOverlap(a, b)) {
        s.push([...a, ...b]);
        continue;
      }

      const aBB = measureBoundingBox(a);
      const bBB = measureBoundingBox(b);
      const bbBsp = fromBoundingBoxes(aBB, bBB, outLeaf, inLeaf);

      const [aIn, aOut, aBsp] = boxPartition(bbBsp, aBB, bBB, inLeaf, a, normalize);
      const [bIn, bOut, bBsp] = boxPartition(bbBsp, aBB, bBB, inLeaf, b, normalize);

      if (aIn.length === 0) {
        const bbMin = max(aBB[MIN$2], bBB[MIN$2]);
        // There are two ways for aIn to be empty: the space is fully enclosed or fully vacated.
        const aBsp = fromPolygons$1(a, normalize);
        if (containsPoint(aBsp, bbMin)) {
          // The space is fully enclosed; bIn is redundant.
          s.push([...aOut, ...aIn, ...bOut]);
        } else {
          s.push([...aOut, ...aIn, ...bOut]);
          // The space is fully vacated; nothing overlaps b.
          s.push([...a, ...b]);
        }
      } else if (bIn.length === 0) {
        const bbMin = max(aBB[MIN$2], bBB[MIN$2]);
        // There are two ways for bIn to be empty: the space is fully enclosed or fully vacated.
        const bBsp = fromPolygons$1(b, normalize);
        if (containsPoint(bBsp, bbMin)) {
          // The space is fully enclosed; aIn is redundant.
          s.push([...aOut, ...bIn, ...bOut]);
        } else {
          // The space is fully vacated; nothing overlaps a.
          s.push([...a, ...b]);
        }
      } else {
        const aTrimmed = removeInteriorPolygonsForUnionKeepingOverlap(bBsp, aIn, normalize);
        const bTrimmed = removeInteriorPolygonsForUnionDroppingOverlap(aBsp, bIn, normalize);

        s.push(clean([...aOut, ...bTrimmed, ...bOut, ...aTrimmed]));
      }
    }
    return fromPolygons({}, s[0], normalize);
  };

  // The resolution is 1 / multiplier.
  const multiplier$1 = 1e5;

  const X$c = 0;
  const Y$c = 1;
  const Z$8 = 2;
  const W$4 = 3;

  // FIX: Make this efficient.
  // FIX: Move to math-plane.
  const equals$4 = (a, b) => {
    const map = new Map();
    const normalize4 = (coordinate) => {
      // Apply a spatial quantization to the 4 dimensional coordinate.
      const nx = Math.floor(coordinate[X$c] * multiplier$1 - 0.5);
      const ny = Math.floor(coordinate[Y$c] * multiplier$1 - 0.5);
      const nz = Math.floor(coordinate[Z$8] * multiplier$1 - 0.5);
      const nw = Math.floor(coordinate[W$4] * multiplier$1 - 0.5);
      // Look for an existing inhabitant.
      const value = map.get(`${nx}/${ny}/${nz}/${nw}`);
      if (value !== undefined) {
        return value;
      }
      // One of the ~0 or ~1 values will match the rounded values above.
      // The other will match the adjacent cell.
      const nx0 = nx;
      const ny0 = ny;
      const nz0 = nz;
      const nw0 = nw;
      const nx1 = nx0 + 1;
      const ny1 = ny0 + 1;
      const nz1 = nz0 + 1;
      const nw1 = nw0 + 1;
      // Populate the space of the quantized value and its adjacencies.
      // const normalized = [nx1 / multiplier, ny1 / multiplier, nz1 / multiplier, nw1 / multiplier];
      // FIX: Rename the function to reflect that it seems that we cannot quantize planes,
      // but we can form a consensus among nearby planes.
      const normalized = coordinate;
      map.set(`${nx0}/${ny0}/${nz0}/${nw0}`, normalized);
      map.set(`${nx0}/${ny0}/${nz0}/${nw1}`, normalized);
      map.set(`${nx0}/${ny0}/${nz1}/${nw0}`, normalized);
      map.set(`${nx0}/${ny0}/${nz1}/${nw1}`, normalized);
      map.set(`${nx0}/${ny1}/${nz0}/${nw0}`, normalized);
      map.set(`${nx0}/${ny1}/${nz0}/${nw1}`, normalized);
      map.set(`${nx0}/${ny1}/${nz1}/${nw0}`, normalized);
      map.set(`${nx0}/${ny1}/${nz1}/${nw1}`, normalized);
      map.set(`${nx1}/${ny0}/${nz0}/${nw0}`, normalized);
      map.set(`${nx1}/${ny0}/${nz0}/${nw1}`, normalized);
      map.set(`${nx1}/${ny0}/${nz1}/${nw0}`, normalized);
      map.set(`${nx1}/${ny0}/${nz1}/${nw1}`, normalized);
      map.set(`${nx1}/${ny1}/${nz0}/${nw0}`, normalized);
      map.set(`${nx1}/${ny1}/${nz0}/${nw1}`, normalized);
      map.set(`${nx1}/${ny1}/${nz1}/${nw0}`, normalized);
      map.set(`${nx1}/${ny1}/${nz1}/${nw1}`, normalized);
      // This is now the normalized value for this region.
      return normalized;
    };

    if (a === undefined || b === undefined) {
      return false;
    }

    return normalize4(a) === normalize4(b);
  };

  const toPlane$2 = (surface) => {
    if (surface.plane !== undefined) {
      return surface.plane;
    } else {
      for (const polygon of surface) {
        const plane = toPlane(polygon);
        if (plane !== undefined) {
          surface.plane = plane;
          return surface.plane;
        }
      }
    }
  };

  const transform$9 = (matrix, polygons) => polygons.map(polygon => transform$3(matrix, polygon));

  const mayOverlap = ([centerA, radiusA], [centerB, radiusB]) => distance(centerA, centerB) < radiusA + radiusB;

  const difference$3 = (baseSurface, ...surfaces) => {
    if (baseSurface.length === 0) {
      // Empty geometry can't get more empty.
      return [];
    }
    const baseBounds = measureBoundingSphere(baseSurface);
    surfaces = surfaces.filter(surface => surface.length > 0 &&
                                          equals$4(toPlane$2(baseSurface), toPlane$2(surface)) &&
                                          mayOverlap(baseBounds, measureBoundingSphere(surface)));
    if (surfaces.length === 0) {
      // Nothing to be removed.
      return baseSurface;
    }
    // FIX: Detect when the surfaces aren't in the same plane.
    const [toZ0, fromZ0] = toXYPlaneTransforms(toPlane$2(baseSurface));
    const z0Surface = transform$9(toZ0, baseSurface);
    const z0Surfaces = surfaces.map(surface => transform$9(toZ0, surface));
    const z0Difference = difference(z0Surface, ...z0Surfaces);
    return transform$9(fromZ0, z0Difference);
  };

  const intersection$3 = (...surfaces) => {
    if (surfaces.length === 0) {
      return [];
    }
    for (const surface of surfaces) {
      if (surface.length === 0 || !equals$4(toPlane$2(surfaces[0]), toPlane$2(surface))) {
        return [];
      }
    }
    // FIX: Detect when the surfaces aren't in the same plane.
    const [toZ0, fromZ0] = toXYPlaneTransforms(toPlane$2(surfaces[0]));
    const z0Surface = intersection(...surfaces.map(surface => transform$9(toZ0, surface)));
    return transform$9(fromZ0, z0Surface);
  };

  const union$3 = (...surfaces) => {
    // Trim initial empty surfaces.
    while (surfaces.length > 0 && surfaces[0].length === 0) {
      surfaces.shift();
    }
    if (surfaces.length === 0) {
      return [];
    }
    // (But then, are these really the right semantics?)
    const baseSurface = surfaces.shift();
    const basePlane = toPlane$2(baseSurface);
    surfaces = surfaces.filter(surface => surface.length >= 1 &&
                               (equals$4(toPlane$2(baseSurface), toPlane$2(surface))));
    if (surfaces.length === 0) {
      return baseSurface;
    }
    const [toZ0, fromZ0] = toXYPlaneTransforms(basePlane);
    const z0Surface = union(transform$9(toZ0, baseSurface),
                                      ...surfaces.map(surface => transform$9(toZ0, surface)));
    return transform$9(fromZ0, z0Surface);
  };

  const differenceImpl = (geometry, ...geometries) => {
    const op = (geometry, descend) => {
      if (geometry.solid) {
        const todo = [];
        for (const geometry of geometries) {
          for (const { solid } of getSolids(geometry)) {
            todo.push(solid);
          }
        }
        return { solid: difference$2(geometry.solid, ...todo), tags: geometry.tags };
      } else if (geometry.surface) {
        const todo = [];
        for (const geometry of geometries) {
          for (const { surface } of getSurfaces(geometry)) {
            todo.push(surface);
          }
          for (const { z0Surface } of getZ0Surfaces(geometry)) {
            todo.push(z0Surface);
          }
        }
        return { surface: difference$3(geometry.surface, ...todo), tags: geometry.tags };
      } else if (geometry.z0Surface) {
        const todoSurfaces = [];
        const todoZ0Surfaces = [];
        for (const geometry of geometries) {
          for (const { surface } of getSurfaces(geometry)) {
            todoSurfaces.push(surface);
          }
          for (const { z0Surface } of getZ0Surfaces(geometry)) {
            todoZ0Surfaces.push(z0Surface);
          }
        }
        if (todoSurfaces.length > 0) {
          return { surface: difference$3(geometry.z0Surface, ...todoSurfaces, ...todoZ0Surfaces), tags: geometry.tags };
        } else {
          return { surface: difference(geometry.z0Surface, ...todoZ0Surfaces), tags: geometry.tags };
        }
      } else if (geometry.paths) {
        const todo = [];
        for (const geometry of geometries) {
          for (const { paths } of getPaths(geometry)) {
            todo.push(paths);
          }
        }
        return { paths: difference$1(geometry.paths, ...todo), tags: geometry.tags };
      } else {
        return descend();
      }
    };

    return rewrite(geometry, op);
  };

  const difference$4 = cache(differenceImpl);

  const hasMatchingTag = (set, tags, whenSetUndefined = false) => {
    if (set === undefined) {
      return whenSetUndefined;
    } else if (tags !== undefined && tags.some(tag => set.includes(tag))) {
      return true;
    } else {
      return false;
    }
  };

  const buildCondition = (conditionTags, conditionSpec) => {
    switch (conditionSpec) {
      case 'has':
        return (geometryTags) => hasMatchingTag(geometryTags, conditionTags);
      case 'has not':
        return (geometryTags) => !hasMatchingTag(geometryTags, conditionTags);
      default:
        return undefined;
    }
  };

  const rewriteTagsImpl = (add, remove, geometry, conditionTags, conditionSpec) => {
    const condition = buildCondition(conditionTags, conditionSpec);
    const composeTags = (geometryTags) => {
      if (condition === undefined || condition(geometryTags)) {
        if (geometryTags === undefined) {
          return add.filter(tag => !remove.includes(tag));
        } else {
          return [...add, ...geometryTags].filter(tag => !remove.includes(tag));
        }
      } else {
        return geometryTags;
      }
    };

    const op = (geometry) => {
      if (geometry.assembly || geometry.disjointAssembly) {
        // These structural geometries don't take tags.
        return geometry;
      }
      const composedTags = composeTags(geometry.tags);
      if (composedTags === undefined) {
        const copy = { ...geometry };
        delete copy.tags;
        return copy;
      } if (composedTags === geometry.tags) {
        return geometry;
      } else {
        return { ...geometry, tags: composedTags };
      }
    };

    return rewriteUp(geometry, op);
  };

  const rewriteTags = cacheRewriteTags(rewriteTagsImpl);

  // Dropped elements displace as usual, but are not included in positive output.

  const drop = (tags, geometry) => rewriteTags(['compose/non-positive'], [], geometry, tags, 'has');

  const eachPoint$4 = (operation, geometry) => {
    const walk = (geometry) => {
      if (geometry.assembly) {
        geometry.assembly.forEach(walk);
      } else if (geometry.layers) {
        geometry.layers.forEach(walk);
      } else if (geometry.disjointAssembly) {
        geometry.disjointAssembly.forEach(walk);
      } else if (geometry.connection) {
        geometry.geometries.forEach(walk);
      } else if (geometry.item) {
        walk(geometry.item);
      } else if (geometry.points) {
        eachPoint$3(operation, geometry.points);
      } else if (geometry.paths) {
        eachPoint$2(operation, geometry.paths);
      } else if (geometry.solid) {
        eachPoint$1(operation, geometry.solid);
      } else if (geometry.surface) {
        eachPoint(operation, geometry.surface);
      } else if (geometry.z0Surface) {
        eachPoint(operation, geometry.z0Surface);
      }
    };

    walk(geometry);
  };

  const flip$8 = (geometry) => {
    const op = (geometry) => {
      if (geometry.points) {
        return { ...geometry, points: flip$7(geometry.points) };
      } else if (geometry.paths) {
        return { ...geometry, paths: flip$6(geometry.paths) };
      } else if (geometry.surface) {
        return { ...geometry, surface: flip$4(geometry.surface) };
      } else if (geometry.z0Surface) {
        return { ...geometry, surface: flip$4(geometry.z0Surface) };
      } else if (geometry.solid) {
        return { ...geometry, solid: flip$5(geometry.solid) };
      } else if (geometry.assembly) {
        return geometry;
      } else if (geometry.layers) {
        return geometry;
      } else if (geometry.disjointAssembly) {
        return geometry;
      } else if (geometry.plan) {
        if (geometry.plan.connector) {
          // FIX: Mirror visualization?
          return { ...geometry, planes: geometry.planes.map(flip$2) };
        } else {
          return { ...geometry, content: flip$8(geometry.content) };
        }
      } else if (geometry.connection) {
        return {
          ...geometry,
          geometries: geometry.geometries.map(flip$8),
          connectors: geometry.connectors.map(flip$8)
        };
      } else if (geometry.item) {
        // FIX: How should items deal with flip?
        return geometry;
      } else {
        throw Error(`die: ${JSON.stringify(geometry)}`);
      }
    };
    return rewriteUp(geometry, op);
  };

  const fromPathToSurfaceImpl = (path) => {
    return { surface: [path] };
  };

  const fromPathToSurface = cache(fromPathToSurfaceImpl);

  const fromPathToZ0SurfaceImpl = (path) => {
    return { z0Surface: [path] };
  };

  const fromPathToZ0Surface = cache(fromPathToZ0SurfaceImpl);

  const fromPathsToSurfaceImpl = (paths) => {
    return { surface: makeConvex$1(paths) };
  };

  const fromPathsToSurface = cache(fromPathsToSurfaceImpl);

  const fromPathsToZ0SurfaceImpl = (paths) => {
    return { z0Surface: paths };
  };

  const fromPathsToZ0Surface = cache(fromPathsToZ0SurfaceImpl);

  const fromSurfaceToPathsImpl = (surface) => {
    return { paths: surface };
  };

  const fromSurfaceToPaths = cache(fromSurfaceToPathsImpl);

  const getAnySurfaces = (geometry) => {
    const surfaces = [];
    eachItem(geometry,
             item => {
               if (item.surface) {
                 surfaces.push(item);
               }
               if (item.z0Surface) {
                 surfaces.push(item);
               }
             });
    return surfaces;
  };

  const getConnections = (geometry) => {
    const connections = [];
    eachItem(geometry,
             item => {
               if (item.connection) {
                 connections.push(item);
               }
             });
    return connections;
  };

  const getItems = (geometry) => {
    const items = [];
    const op = (geometry, descend) => {
      if (geometry.item) {
        items.push(geometry);
      } else {
        descend();
      }
    };
    visit(geometry, op);
    return items;
  };

  // Retrieve leaf geometry.

  const getLeafs = (geometry) => {
    const leafs = [];
    const op = (geometry, descend) => {
      if (geometry.assembly || geometry.disjointAssembly || geometry.layers || geometry.content) {
        descend();
      } else {
        leafs.push(geometry);
      }
    };
    visit(geometry, op);
    return leafs;
  };

  const getPlans = (geometry) => {
    const plans = [];
    eachItem(geometry,
             item => {
               if (item.plan) {
                 plans.push(item);
               }
             });
    return plans;
  };

  const intersectionImpl = (geometry, ...geometries) => {
    const op = (geometry, descend) => {
      if (geometry.solid) {
        const todo = [];
        for (const geometry of geometries) {
          for (const { solid } of getSolids(geometry)) {
            todo.push(solid);
          }
        }
        return { solid: intersection$2(geometry.solid, ...todo), tags: geometry.tags };
      } else if (geometry.surface) {
        const todo = [];
        for (const geometry of geometries) {
          for (const { surface } of getSurfaces(geometry)) {
            todo.push(surface);
          }
          for (const { z0Surface } of getZ0Surfaces(geometry)) {
            todo.push(z0Surface);
          }
        }
        return { surface: intersection$3(geometry.surface, ...todo), tags: geometry.tags };
      } else if (geometry.z0Surface) {
        const todoSurfaces = [];
        const todoZ0Surfaces = [];
        for (const geometry of geometries) {
          for (const { surface } of getSurfaces(geometry)) {
            todoSurfaces.push(surface);
          }
          for (const { z0Surface } of getZ0Surfaces(geometry)) {
            todoZ0Surfaces.push(z0Surface);
          }
        }
        if (todoSurfaces.length > 0) {
          return { surface: intersection$3(geometry.z0Surface, ...todoSurfaces, ...todoZ0Surfaces), tags: geometry.tags };
        } else {
          return { surface: intersection(geometry.z0Surface, ...todoZ0Surfaces), tags: geometry.tags };
        }
      } else if (geometry.paths) {
        const todo = [];
        for (const geometry of geometries) {
          for (const { paths } of getPaths(geometry)) {
            todo.push(paths);
          }
        }
        return { paths: intersection$1(geometry.paths, ...todo), tags: geometry.tags };
      } else {
        return descend();
      }
    };

    return rewrite(geometry, op);
  };

  const intersection$4 = cache(intersectionImpl);

  const keep = (tags, geometry) => rewriteTags(['compose/non-positive'], [], geometry, tags, 'has not');

  const disjointAssembly = Symbol('disjointAssembly');

  const toDisjointAssembly = (geometry) => {
    if (geometry.matrix) {
      // Transforming is identity-producing, so disjoint before transforming.
      return toTransformedGeometry({ ...geometry, untransformed: toDisjointGeometry(geometry.untransformed) });
    } else if (geometry[disjointAssembly]) {
      return geometry[disjointAssembly];
    } else if (geometry.item) {
      return { ...geometry, item: toDisjointAssembly(geometry.item) };
    } else if (geometry.connection) {
      return {
        ...geometry,
        connectors: geometry.connectors.map(toDisjointGeometry),
        geometries: geometry.geometries.map(toDisjointGeometry)
      };
    } else if (geometry.layers) {
      return {
        ...geometry,
        layers: geometry.layers.map(toDisjointGeometry)
      };
    } else if (geometry.assembly) {
      if (geometry.assembly.length === 0) {
        return { disjointAssembly: [] };
      }
      if (geometry.assembly.length === 1) {
        return toDisjointAssembly(geometry.assembly[0]);
      }
      const disjoint = [];
      for (let nth = geometry.assembly.length - 1; nth >= 0; nth--) {
        const item = toDisjointAssembly(geometry.assembly[nth]);
        if (item !== undefined) {
          disjoint.unshift(difference$4(item, ...disjoint));
        }
      }
      if (disjoint.length === 0) {
        return;
      }
      const result = { disjointAssembly: disjoint };
      geometry[disjointAssembly] = result;
      return result;
    } else {
      return geometry;
    }
  };

  const toDisjointGeometry = (inputGeometry) => {
    const disjointAssembly = toDisjointAssembly(inputGeometry);
    if (disjointAssembly === undefined) {
      return { disjointAssembly: [] };
    } else {
      return disjointAssembly;
    }
  };

  const keptGeometry = Symbol('keptGeometry');

  // Produce a disjoint geometry suitable for display.

  const toKeptGeometry = (geometry) => {
    if (geometry[keptGeometry] === undefined) {
      const disjointGeometry = toDisjointGeometry(geometry);
      const walk = (geometry) => {
        if (geometry[keptGeometry] !== undefined) {
          return geometry[keptGeometry];
        } else if (geometry.tags === undefined || !geometry.tags.includes('compose/non-positive')) {
          if (geometry.disjointAssembly) {
            const kept = geometry.disjointAssembly.map(walk).filter(item => item !== undefined);
            if (kept.length > 0) {
              const kept = {
                ...geometry,
                disjointAssembly: geometry.disjointAssembly.map(walk).filter(item => item !== undefined)
              };
              geometry[keptGeometry] = kept;
              return kept;
            } else {
              return undefined;
            }
          } else if (geometry.item) {
            return {
              ...geometry,
              item: toKeptGeometry(geometry.item)
            };
          } else if (geometry.plan) {
            return {
              ...geometry,
              content: toKeptGeometry(geometry.content)
            };
          } else if (geometry.connection) {
            return {
              ...geometry,
              geometries: geometry.geometries.map(toKeptGeometry)
            };
          } else {
            return geometry;
          }
        }
      };
      const kept = walk(disjointGeometry);
      geometry[keptGeometry] = kept || { disjointAssembly: [] };
    }
    return geometry[keptGeometry];
  };

  const measureBoundingBoxGeneric = (geometry) => {
    let minPoint = [Infinity, Infinity, Infinity];
    let maxPoint = [-Infinity, -Infinity, -Infinity];
    eachPoint$4(point => {
      minPoint = min(minPoint, point);
      maxPoint = max(maxPoint, point);
    },
              geometry);
    return [minPoint, maxPoint];
  };

  const measureBoundingBox$5 = (rawGeometry) => {
    const geometry = toKeptGeometry(rawGeometry);

    let minPoint = [Infinity, Infinity, Infinity];
    let maxPoint = [-Infinity, -Infinity, -Infinity];

    const update = ([itemMinPoint, itemMaxPoint]) => {
      minPoint = min(minPoint, itemMinPoint);
      maxPoint = max(maxPoint, itemMaxPoint);
    };

    const walk = (item) => {
      if (item.assembly) {
        item.assembly.forEach(walk);
      } else if (item.layers) {
        item.layers.forEach(walk);
      } else if (item.connection) {
        item.geometries.map(walk);
      } else if (item.disjointAssembly) {
        item.disjointAssembly.forEach(walk);
      } else if (item.item) {
        walk(item.item);
      } else if (item.solid) {
        update(measureBoundingBox$4(item.solid));
      } else if (item.surface) {
        update(measureBoundingBox$3(item.surface));
      } else if (item.z0Surface) {
        update(measureBoundingBox$1(item.z0Surface));
      } else if (item.plan) {
        if (item.plan.page) {
          update(item.marks);
        }
        walk(item.content);
      } else {
        update(measureBoundingBoxGeneric(item));
      }
    };

    walk(geometry);

    return [minPoint, maxPoint];
  };

  const nonNegative = (tags, geometry) => rewriteTags(['compose/non-negative'], [], geometry, tags, 'has');

  const outlineImpl = (geometry) => {
    const normalize = createNormalize3();

    // FIX: This assumes general coplanarity.
    const keptGeometry = toKeptGeometry(geometry);
    const outlines = [];
    for (const { solid } of getSolids(keptGeometry)) {
      outlines.push(outline$2(solid));
    }
    for (const { surface } of getSurfaces(keptGeometry)) {
      outlines.push(outline$1(surface, normalize));
    }
    for (const { z0Surface } of getZ0Surfaces(keptGeometry)) {
      outlines.push(outline(z0Surface, normalize));
    }
    return outlines.map(outline => ({ paths: outline }));
  };

  const outline$3 = cache(outlineImpl);

  // The resolution is 1 / multiplier.
  const multiplier$2 = 1e5;

  const X$d = 0;
  const Y$d = 1;
  const Z$9 = 2;

  const createPointNormalizer = () => {
    const map = new Map();
    const normalize = (coordinate) => {
      // Apply a spatial quantization to the 3 dimensional coordinate.
      const nx = Math.floor(coordinate[X$d] * multiplier$2 - 0.5);
      const ny = Math.floor(coordinate[Y$d] * multiplier$2 - 0.5);
      const nz = Math.floor(coordinate[Z$9] * multiplier$2 - 0.5);
      // Look for an existing inhabitant.
      const value = map.get(`${nx}/${ny}/${nz}`);
      if (value !== undefined) {
        return value;
      }
      // One of the ~0 or ~1 values will match the rounded values above.
      // The other will match the adjacent cell.
      const nx0 = nx;
      const ny0 = ny;
      const nz0 = nz;
      const nx1 = nx0 + 1;
      const ny1 = ny0 + 1;
      const nz1 = nz0 + 1;
      // Populate the space of the quantized coordinate and its adjacencies.
      // const normalized = [nx1 / multiplier, ny1 / multiplier, nz1 / multiplier];
      const normalized = coordinate;
      map.set(`${nx0}/${ny0}/${nz0}`, normalized);
      map.set(`${nx0}/${ny0}/${nz1}`, normalized);
      map.set(`${nx0}/${ny1}/${nz0}`, normalized);
      map.set(`${nx0}/${ny1}/${nz1}`, normalized);
      map.set(`${nx1}/${ny0}/${nz0}`, normalized);
      map.set(`${nx1}/${ny0}/${nz1}`, normalized);
      map.set(`${nx1}/${ny1}/${nz0}`, normalized);
      map.set(`${nx1}/${ny1}/${nz1}`, normalized);
      // This is now the normalized coordinate for this region.
      return normalized;
    };
    return normalize;
  };

  const toPoints = (geometry) => {
    const normalize = createPointNormalizer();
    const points = new Set();
    eachPoint$4(point => points.add(normalize(point)), geometry);
    return { points: [...points] };
  };

  const transformImpl$1 = (matrix, untransformed) => {
    if (matrix.some(value => typeof value !== 'number' || isNaN(value))) {
      throw Error('die');
    }
    return { matrix, untransformed, tags: untransformed.tags };
  };

  const transform$a = cacheTransform(transformImpl$1);

  // Union is a little more complex, since it can make violate disjointAssembly invariants.

  const unifySolids = (geometry, ...geometries) => {
    const todo = [];
    for (const geometry of geometries) {
      for (const { solid } of getSolids(geometry)) {
        todo.push(solid);
      }
    }
    return { solid: union$2(geometry.solid, ...todo), tags: geometry.tags };
  };

  const unifySurfaces = (geometry, ...geometries) => {
    const todo = [];
    for (const geometry of geometries) {
      for (const { surface } of getSurfaces(geometry)) {
        todo.push(surface);
      }
      for (const { z0Surface } of getZ0Surfaces(geometry)) {
        todo.push(z0Surface);
      }
    }
    return { surface: union$3(geometry.surface, ...todo), tags: geometry.tags };
  };

  const unifyZ0Surfaces = (geometry, ...geometries) => {
    const todoSurfaces = [];
    const todoZ0Surfaces = [];
    for (const geometry of geometries) {
      for (const { surface } of getSurfaces(geometry)) {
        todoSurfaces.push(surface);
      }
      for (const { z0Surface } of getZ0Surfaces(geometry)) {
        todoZ0Surfaces.push(z0Surface);
      }
    }
    if (todoSurfaces.length > 0) {
      return { surface: union$3(geometry.z0Surface, ...todoSurfaces, ...todoZ0Surfaces), tags: geometry.tags };
    } else {
      return { surface: union(geometry.z0Surface, ...todoZ0Surfaces), tags: geometry.tags };
    }
  };

  const unifyPaths = (geometry, ...geometries) => {
    const todo = [];
    for (const geometry of geometries) {
      for (const { paths } of getPaths(geometry)) {
        todo.push(paths);
      }
    }
    return { paths: union$1(geometry.paths, ...todo), tags: geometry.tags };
  };

  const unionImpl = (geometry, ...geometries) => {
    const op = (geometry, descend) => {
      if (geometry.solid) {
        return unifySolids(geometry, ...geometries);
      } else if (geometry.surface) {
        return unifySurfaces(geometry, ...geometries);
      } else if (geometry.z0Surface) {
        return unifyZ0Surfaces(geometry, ...geometries);
      } else if (geometry.paths) {
        return unifyPaths(geometry, ...geometries);
      } else if (geometry.assembly || geometry.disjointAssembly) {
        const payload = geometry.assembly || geometry.disjointAssembly;
        // We consider assemblies to have an implicit Empty() at the end.
        return {
          assembly: [
            ...payload,
            unifySolids({ solid: [] }, ...geometries),
            unifySurfaces({ surface: [] }, ...geometries),
            unifyPaths({ paths: [] }, ...geometries)
          ],
          tags: geometry.tags
        };
      } else if (geometry.layers) {
        // We consider layers to have an implicit Empty() at the end.
        return {
          layers: [
            ...geometry.layers,
            unifySolids({ solid: [] }, ...geometries),
            unifySurfaces({ surface: [] }, ...geometries),
            unifyPaths({ paths: [] }, ...geometries)
          ],
          tags: geometry.tags
        };
      } else {
        return descend();
      }
    };

    return rewrite(geometry, op);
  };

  const union$4 = cache(unionImpl);

  const translate$4 = (vector, assembly) => transform$a(fromTranslation(vector), assembly);
  const scale$3 = (vector, assembly) => transform$a(fromScaling(vector), assembly);

  class Shape {
    close () {
      const geometry = this.toKeptGeometry();
      if (!isSingleOpenPath(geometry)) {
        throw Error('Close requires a single open path.');
      }
      return Shape.fromClosedPath(close(geometry.paths[0]));
    }

    concat (...shapes) {
      const paths = [];
      for (const shape of [this, ...shapes]) {
        const geometry = shape.toKeptGeometry();
        if (!isSingleOpenPath(geometry)) {
          throw Error('Concatenation requires single open paths.');
        }
        paths.push(geometry.paths[0]);
      }
      return Shape.fromOpenPath(concatenate(...paths));
    }

    constructor (geometry = { assembly: [] },
                 context) {
      if (geometry.geometry) {
        throw Error('die: { geometry: ... } is not valid geometry.');
      }
      this.geometry = geometry;
      this.context = context;
    }

    eachPoint (operation) {
      eachPoint$4(operation, this.toKeptGeometry());
    }

    flip () {
      return fromGeometry(flip$8(toKeptGeometry$1(this)), this.context);
    }

    setTags (tags) {
      return fromGeometry({ ...toGeometry(this), tags }, this.context);
    }

    toDisjointGeometry (options = {}) {
      return toDisjointGeometry(toGeometry(this));
    }

    toKeptGeometry (options = {}) {
      return toKeptGeometry(toGeometry(this));
    }

    getContext (symbol) {
      return this.context[symbol];
    }

    toGeometry () {
      return this.geometry;
    }

    toTransformedGeometry () {
      return toTransformedGeometry(this.toGeometry());
    }

    toPoints () {
      return toPoints(this.toKeptGeometry()).points;
    }

    transform (matrix) {
      if (matrix.some(item => typeof item !== 'number' || isNaN(item))) {
        throw Error('die: matrix is malformed');
      }
      return fromGeometry(transform$a(matrix, this.toGeometry()), this.context);
    }

    reconcile () {
      return fromGeometry(reconcile$1(this.toKeptGeometry()));
    }

    assertWatertight () {
      if (!this.isWatertight()) {
        throw Error('not watertight');
      }
      return this;
    }

    isWatertight () {
      return isWatertight$1(this.toKeptGeometry());
    }

    makeWatertight (threshold) {
      return fromGeometry(makeWatertight$1(this.toKeptGeometry(), undefined, undefined));
    }
  }

  const isSingleOpenPath = ({ paths }) => (paths !== undefined) && (paths.length === 1) && (paths[0][0] === null);

  Shape.fromClosedPath = (path, context) => fromGeometry({ paths: [close(path)] }, context);
  Shape.fromGeometry = (geometry, context) => new Shape(geometry, context);
  Shape.fromOpenPath = (path, context) => fromGeometry({ paths: [open(path)] }, context);
  Shape.fromPath = (path, context) => fromGeometry({ paths: [path] }, context);
  Shape.fromPaths = (paths, context) => fromGeometry({ paths: paths }, context);
  Shape.fromPathToSurface = (path, context) => fromGeometry(fromPathToSurface(path), context);
  Shape.fromPathToZ0Surface = (path, context) => fromGeometry(fromPathToZ0Surface(path), context);
  Shape.fromPathsToSurface = (paths, context) => fromGeometry(fromPathsToSurface(paths), context);
  Shape.fromPathsToZ0Surface = (paths, context) => fromGeometry(fromPathsToZ0Surface(paths), context);
  Shape.fromPoint = (point, context) => fromGeometry({ points: [point] }, context);
  Shape.fromPoints = (points, context) => fromGeometry({ points: points }, context);
  Shape.fromPolygonsToSolid = (polygons, context) => fromGeometry({ solid: fromPolygons({}, polygons) }, context);
  Shape.fromPolygonsToZ0Surface = (polygons, context) => fromGeometry({ z0Surface: polygons }, context);
  Shape.fromSurfaces = (surfaces, context) => fromGeometry({ solid: surfaces }, context);
  Shape.fromSolid = (solid, context) => fromGeometry({ solid: solid }, context);

  const fromGeometry = Shape.fromGeometry;
  const toGeometry = (shape) => shape.toGeometry();
  const toKeptGeometry$1 = (shape) => shape.toKeptGeometry();

  /**
   *
   * # As
   *
   * Produces a version of a shape with user defined tags.
   *
   * ::: illustration
   * ```
   * Circle(10).as('A')
   * ```
   * :::
   *
   **/

  const as = (shape, tags) =>
    Shape.fromGeometry(rewriteTags(tags.map(tag => `user/${tag}`), [], shape.toGeometry()));

  const notAs = (shape, tags) =>
    Shape.fromGeometry(rewriteTags([], tags.map(tag => `user/${tag}`), shape.toGeometry()));

  const asMethod = function (...tags) { return as(this, tags); };
  const notAsMethod = function (...tags) { return notAs(this, tags); };

  Shape.prototype.as = asMethod;
  Shape.prototype.notAs = notAsMethod;

  asMethod.signature = 'Shape -> as(...tags:string) -> Shape';
  notAsMethod.signature = 'Shape -> as(...tags:string) -> Shape';

  /**
   *
   * # Union
   *
   * Union produces a version of the first shape extended to cover the remaining shapes, as applicable.
   * Different kinds of shapes do not interact. e.g., you cannot union a surface and a solid.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * union(Sphere(5).left(),
   *       Sphere(5),
   *       Sphere(5).right())
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * union(Sphere(5).left(),
   *       Sphere(5),
   *       Sphere(5).right())
   *   .section()
   *   .outline()
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, 0, 5] } }
   * ```
   * union(Triangle(),
   *       Triangle().rotateZ(180))
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, 0, 5] } }
   * ```
   * union(Triangle(),
   *       Triangle().rotateZ(180))
   *   .outline()
   * ```
   * :::
   * ::: illustration { "view": { "position": [5, 5, 5] } }
   * ```
   * union(assemble(Cube().left(),
   *                Cube().right()),
   *       Cube().front())
   *   .section()
   *   .outline()
   * ```
   * :::
   *
   **/

  // NOTE: Perhaps we should make union(a, b, c) equivalent to emptyGeometry.union(a, b, c);
  // This would restore commutation.

  const union$5 = (...shapes) => {
    switch (shapes.length) {
      case 0: {
        return fromGeometry({ assembly: [] });
      }
      case 1: {
        return shapes[0];
      }
      default: {
        return fromGeometry(union$4(...shapes.map(toKeptGeometry$1)));
      }
    }
  };

  const unionMethod = function (...shapes) { return union$5(this, ...shapes); };
  Shape.prototype.union = unionMethod;

  union$5.signature = 'union(shape:Shape, ...shapes:Shape) -> Shape';
  unionMethod.signature = 'Shape -> union(...shapes:Shape) -> Shape';

  /**
   *
   * # shape.add(...shapes)
   *
   * Produces a version of shape with the regions overlapped by shapes added.
   *
   * shape.add(...shapes) is equivalent to union(shape, ...shapes).
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cube(10).below().add(Cube(5).moveX(5).below())
   * ```
   * :::
   *
   **/

  const addMethod = function (...shapes) { return union$5(this, ...shapes); };
  Shape.prototype.add = addMethod;

  addMethod.signature = 'Shape -> (...Shapes) -> Shape';

  // x.addTo(y) === y.add(x)

  const addToMethod = function (shape) { return union$5(shape, this); };
  Shape.prototype.addTo = addToMethod;

  addToMethod.signature = 'Shape -> (...Shapes) -> Shape';

  /**
   *
   * # Intersection
   *
   * Intersection produces a version of the first shape retaining only the parts included in the remaining shapes.
   *
   * Different kinds of shapes do not interact. e.g., you cannot intersect a surface and a solid.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * intersection(Cube(12),
   *              Sphere(8))
   * ```
   * :::
   * ::: illustration
   * ```
   * intersection(Circle(10).move(-5),
   *              Circle(10).move(5))
   * ```
   * :::
   * ::: illustration { "view": { "position": [5, 5, 5] } }
   * ```
   * intersection(assemble(Cube().below(),
   *                       Cube().above()),
   *              Sphere(1))
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(difference(Square(10),
   *                     Square(7))
   *            .translate(-2, -2),
   *          difference(Square(10),
   *                     Square(7))
   *            .move(2, 2));
   * ```
   * :::
   * ::: illustration
   * ```
   * intersection(difference(Square(10),
   *                         Square(7))
   *                .translate(-2, -2),
   *              difference(Square(10),
   *                         Square(7))
   *                .move(2, 2));
   * ```
   * :::
   **/

  const intersection$5 = (...shapes) => {
    switch (shapes.length) {
      case 0: {
        return fromGeometry({ assembly: [] });
      }
      case 1: {
        // We still want to produce a simple shape.
        return fromGeometry(toKeptGeometry$1(shapes[0]));
      }
      default: {
        return fromGeometry(intersection$4(...shapes.map(toKeptGeometry$1)));
      }
    }
  };

  intersection$5.signature = 'intersection(shape:Shape, ...to:Shape) -> Shape';

  const clipMethod = function (...shapes) { return intersection$5(this, ...shapes); };
  Shape.prototype.clip = clipMethod;

  clipMethod.signature = 'Shape -> clip(...to:Shape) -> Shape';

  const clipFromMethod = function (shape) { return intersection$5(shape, this); };
  Shape.prototype.clipFrom = clipFromMethod;

  clipFromMethod.signature = 'Shape -> clipFrom(...to:Shape) -> Shape';

  /**
   *
   * # Difference
   *
   * Difference produces a version of the first shape with the remaining shapes removed, where applicable.
   * Different kinds of shapes do not interact. e.g., you cannot subtract a surface from a solid.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * difference(Cube(10).below(),
   *            Cube(5).below())
   * ```
   * :::
   * ::: illustration
   * ```
   * difference(Circle(10),
   *            Circle(2.5))
   * ```
   * :::
   * ::: illustration { "view": { "position": [5, 5, 5] } }
   * ```
   * difference(assemble(Cube().below(),
   *                     Cube().above()),
   *            Cube().right())
   * ```
   * :::
   *
   **/

  const difference$5 = (...shapes) => {
    switch (shapes.length) {
      case 0: {
        return fromGeometry({ assembly: [] });
      }
      case 1: {
        // We still want to produce a simple shape.
        return fromGeometry(toKeptGeometry$1(shapes[0]));
      }
      default: {
        return fromGeometry(difference$4(...shapes.map(toKeptGeometry$1)));
      }
    }
  };

  difference$5.signature = 'difference(shape:Shape, ...shapes:Shape) -> Shape';

  /**
   *
   * # shape.cut(...shapes)
   *
   * Produces a version of shape with the regions overlapped by shapes removed.
   *
   * shape.cut(...shapes) is equivalent to difference(shape, ...shapes).
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cube(10).below().cut(Cube(5).below())
   * ```
   * :::
   *
   **/

  const cutMethod = function (...shapes) { return difference$5(this, ...shapes); };
  Shape.prototype.cut = cutMethod;

  cutMethod.signature = 'Shape -> cut(...shapes:Shape) -> Shape';

  // a.cut(b) === b.cutFrom(a)

  const cutFromMethod = function (shape) { return difference$5(shape, this); };
  Shape.prototype.cutFrom = cutFromMethod;

  cutFromMethod.signature = 'Shape -> cutFrom(...shapes:Shape) -> Shape';

  /**
   *
   * # Assemble
   *
   * Produces an assembly of shapes that can be manipulated as a single shape.
   * assemble(a, b) is equivalent to a.with(b).
   *
   * ::: illustration { "view": { "position": [80, 80, 80] } }
   * ```
   * assemble(Circle(20).moveZ(-12),
   *          Square(40).moveZ(16).outline(),
   *          Cylinder(10, 20));
   * ```
   * :::
   *
   * Components of the assembly can be extracted by tag filtering.
   *
   * Components later in the assembly project holes into components earlier in the
   * assembly so that the geometries are disjoint.
   *
   * ::: illustration { "view": { "position": [100, 100, 100] } }
   * ```
   * assemble(Cube(30).above().as('cube'),
   *          Cylinder(10, 40).above().as('cylinder'))
   * ```
   * :::
   * ::: illustration { "view": { "position": [100, 100, 100] } }
   * ```
   * assemble(Cube(30).above().as('cube'),
   *          Cylinder(10, 40).above().as('cylinder'))
   *   .keep('cube')
   * ```
   * :::
   * ::: illustration { "view": { "position": [100, 100, 100] } }
   * ```
   * assemble(Cube(30).above().as('cube'),
   *          assemble(Circle(40),
   *                   Circle(50).outline()).as('circles'))
   *   .keep('circles')
   * ```
   * :::
   * ::: illustration { "view": { "position": [100, 100, 100] } }
   * ```
   * assemble(Cube(30).above().as('cube'),
   *          assemble(Circle(40).as('circle'),
   *                   Circle(50).outline().as('outline')))
   *   .drop('outline')
   * ```
   * :::
   *
   **/

  const assemble$1 = (...shapes) => {
    shapes = shapes.filter(shape => shape !== undefined);
    switch (shapes.length) {
      case 0: {
        return Shape.fromGeometry({ assembly: [] });
      }
      case 1: {
        return shapes[0];
      }
      default: {
        return fromGeometry(assemble(...shapes.map(toGeometry)));
      }
    }
  };

  assemble$1.signature = 'assemble(...shapes:Shape) -> Shape';

  const faces = (shape, op = (x => x)) => {
    const faces = [];
    for (const { solid } of getSolids(shape.toKeptGeometry())) {
      for (const surface of solid) {
        faces.push(op(Shape.fromGeometry({ paths: outline$1(surface) }), faces.length));
      }
    }
    return assemble$1(...faces);
  };

  const facesMethod = function (...args) { return faces(this, ...args); };
  Shape.prototype.faces = facesMethod;

  const inSolids = (shape, op = (_ => _)) => {
    let nth = 0;
    const rewritten = rewrite(shape.toKeptGeometry(),
                              (geometry, descend) => {
                                if (geometry.solid) {
                                  // Operate on the solid.
                                  const solid = op(Shape.fromGeometry(geometry), nth++);
                                  // Replace the solid with the result (which might not be a solid).
                                  return solid.toGeometry();
                                } else {
                                  return descend();
                                }
                              });
    return Shape.fromGeometry(rewritten);
  };

  const inSolidsMethod = function (...args) { return inSolids(this, ...args); };
  Shape.prototype.inSolids = inSolidsMethod;

  inSolids.signature = 'inSolids(shape:Shape, op:function) -> Shapes';
  inSolidsMethod.signature = 'Shape -> inSolids(op:function) -> Shapes';

  /**
   *
   * # Measure Bounding Box
   *
   * Provides the corners of the smallest orthogonal box containing the shape.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Sphere(7)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * const [corner1, corner2] = Sphere(7).measureBoundingBox();
   * Cube.fromCorners(corner1, corner2)
   * ```
   * :::
   **/

  const measureBoundingBox$6 = (shape) => measureBoundingBox$5(shape.toGeometry());

  const measureBoundingBoxMethod = function () { return measureBoundingBox$6(this); };
  Shape.prototype.measureBoundingBox = measureBoundingBoxMethod;

  measureBoundingBox$6.signature = 'measureBoundingBox(shape:Shape) -> BoundingBox';
  measureBoundingBoxMethod.signature = 'Shape -> measureBoundingBox() -> BoundingBox';

  /**
   *
   * # Measure Center
   *
   * Provides the center of the smallest orthogonal box containing the shape.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Sphere(7)
   * ```
   * :::
   **/

  const measureCenter = (shape) => {
    // FIX: Produce a clearer definition of center.
    const geometry = shape.toKeptGeometry();
    if (geometry.plan && geometry.plan.connector) {
      // Return the center of the connector.
      return geometry.marks[0];
    }
    const [high, low] = measureBoundingBox$6(shape);
    return scale(0.5, add(high, low));
  };

  const measureCenterMethod = function () { return measureCenter(this); };
  Shape.prototype.measureCenter = measureCenterMethod;

  measureCenter.signature = 'measureCenter(shape:Shape) -> vector';
  measureCenterMethod.signature = 'Shape -> measureCenter() -> vector';

  const opMethod = function (op, ...args) { return op(this, ...args); };
  const withOpMethod = function (op, ...args) { return assemble$1(this, op(this, ...args)); };

  Shape.prototype.op = opMethod;
  Shape.prototype.withOp = withOpMethod;

  const openEdges = (shape, { isOpen = true } = {}) => {
    const r = (v) => v;
    const paths = [];
    for (const { solid } of getSolids(shape.toKeptGeometry())) {
      paths.push(...findOpenEdges(solid, isOpen));
    }
    return Shape.fromGeometry({ paths: paths.map(path => path.map(([x, y, z]) => [r(x), r(y), r(z)])) });
  };

  const openEdgesMethod = function (...args) { return openEdges(this, ...args); };
  Shape.prototype.openEdges = openEdgesMethod;

  const withOpenEdgesMethod = function (...args) { return assemble$1(this, openEdges(this, ...args)); };
  Shape.prototype.withOpenEdges = withOpenEdgesMethod;

  const solids = (shape, xform = (_ => _)) => {
    const solids = [];
    for (const solid of getSolids(shape.toKeptGeometry())) {
      solids.push(xform(Shape.fromGeometry(solid)));
    }
    return solids;
  };

  const solidsMethod = function (...args) { return solids(this, ...args); };
  Shape.prototype.solids = solidsMethod;

  const tags = (shape) =>
    [...allTags(shape.toGeometry())]
        .filter(tag => tag.startsWith('user/'))
        .map(tag => tag.substring(5));

  const method = function () { return tags(this); };

  Shape.prototype.tags = method;

  /**
   *
   * # Drop from assembly
   *
   * Generates an assembly from components in an assembly without a tag.
   *
   * If no tag is supplied, the whole shape is dropped.
   *
   * ::: illustration
   * ```
   * assemble(Circle(10).as('A'),
   *          Square(10).as('B'))
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Circle(10).as('A'),
   *          Square(10).as('B'))
   *   .drop('A')
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Circle(10).as('A'),
   *          Square(10).as('B'))
   *   .drop('B')
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Circle(10).as('A'),
   *          Square(10).as('B'))
   *   .drop('A', 'B')
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Cube(10).below(),
   *          Cube(8).below().drop())
   * ```
   * :::
   *
   **/

  const drop$1 = (shape, ...tags) => {
    if (tags.length === 0) {
      return fromGeometry(rewriteTags(['compose/non-positive'], [], toGeometry(shape)));
    } else {
      return fromGeometry(drop(tags.map(tag => `user/${tag}`), toGeometry(shape)));
    }
  };

  const dropMethod = function (...tags) { return drop$1(this, ...tags); };
  Shape.prototype.drop = dropMethod;

  drop$1.signature = '(shape:Shape ...tags:string) -> Shape';
  dropMethod.signature = 'Shape -> drop(...tags:string) -> Shape';

  /**
   *
   * # shape.void(...shapes)
   *
   **/

  const voidMethod = function (...shapes) { return assemble$1(this, ...shapes.map(drop$1)); };
  Shape.prototype.void = voidMethod;

  voidMethod.signature = 'Shape -> void(...shapes:Shape) -> Shape';

  const toWireframeFromSolid = (solid) => {
    const paths = [];
    for (const surface of solid) {
      paths.push(...surface);
    }
    return Shape.fromPaths(paths);
  };

  const toWireframeFromSurface = (surface) => {
    return Shape.fromPaths(surface);
  };

  /**
   *
   * # Wireframe
   *
   * Generates a set of paths outlining a solid.
   *
   * ::: illustration { "view": { "position": [-40, -40, 40] } }
   * ```
   * Cube(10).wireframe()
   * ```
   * :::
   * ::: illustration { "view": { "position": [-40, -40, 40] } }
   * ```
   * Sphere(10).wireframe()
   * ```
   * :::
   *
   **/

  const wireframe = (options = {}, shape) => {
    const pieces = [];
    for (const { solid } of getSolids(shape.toKeptGeometry())) {
      pieces.push(toWireframeFromSolid(solid));
    }
    for (const { surface } of getSurfaces(shape.toKeptGeometry())) {
      pieces.push(toWireframeFromSurface(surface));
    }
    for (const { z0Surface } of getZ0Surfaces(shape.toKeptGeometry())) {
      pieces.push(toWireframeFromSurface(z0Surface));
    }
    return assemble$1(...pieces);
  };

  const method$1 = function (options) { return wireframe(options, this); };

  Shape.prototype.wireframe = method$1;
  Shape.prototype.withWireframe = function (options) { return assemble$1(this, wireframe(options, this)); };

  const wireframeFaces = (shape, op = (x => x)) => {
    const faces = [];
    for (const { solid } of getSolids(shape.toKeptGeometry())) {
      for (const surface of solid) {
        for (const path of surface) {
          faces.push(op(Shape.fromGeometry({ paths: [path] }), faces.length));
        }
      }
    }
    return assemble$1(...faces);
  };

  const wireframeFacesMethod = function (...args) { return wireframeFaces(this, ...args); };
  Shape.prototype.wireframeFaces = wireframeFacesMethod;

  /**
   *
   * # With
   *
   * Assembles the current shape with those provided.
   *
   * The below example is equivalent to
   * ```
   * assemble(Circle(20), Square(40).moveX(10))
   * ```
   *
   * ::: illustration { "view": { "position": [80, 80, 80] } }
   * ```
   * Circle(20).with(Square(40).moveX(10))
   * ```
   * :::
   *
   **/

  const withMethod = function (...shapes) { return assemble$1(this, ...shapes); };
  Shape.prototype.with = withMethod;

  const canonicalize$a = (shape) => Shape.fromGeometry(canonicalize$9(shape.toGeometry()));

  const canonicalizeMethod = function () { return canonicalize$a(this); };
  Shape.prototype.canonicalize = canonicalizeMethod;

  /**
   *
   * # Center
   *
   * Moves the shape so that its bounding box is centered on the origin.
   *
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Circle(20).with(Cube(10).center())
   * ```
   * :::
   **/

  const X$e = 0;
  const Y$e = 1;
  const Z$a = 2;

  const center = (shape) => {
    const [minPoint, maxPoint] = measureBoundingBox$6(shape);
    let center = scale(0.5, add(minPoint, maxPoint));
    // FIX: Find a more principled way to handle centering empty shapes.
    if (isNaN(center[X$e]) || isNaN(center[Y$e]) || isNaN(center[Z$a])) {
      return shape;
    }
    const moved = shape.move(...negate(center));
    return moved;
  };

  const centerMethod = function (...params) { return center(this); };
  Shape.prototype.center = centerMethod;

  center.signature = 'center(shape:Shape) -> Shape';
  centerMethod.signature = 'Shape -> center() -> Shape';

  // Derived from npm color-namer due to issue with rollup and weak maps.

  var colors = [
    { name: 'black', rgb: 0x000000, origin: 'basic' },
    { name: 'blue', rgb: 0x0000FF, origin: 'basic' },
    { name: 'cyan', rgb: 0x00FFFF, origin: 'basic' },
    { name: 'green', rgb: 0x008000, origin: 'basic' },
    { name: 'teal', rgb: 0x008080, origin: 'basic' },
    { name: 'turquoise', rgb: 0x40E0D0, origin: 'basic' },
    { name: 'indigo', rgb: 0x4B0082, origin: 'basic' },
    { name: 'gray', rgb: 0x808080, origin: 'basic' },
    { name: 'purple', rgb: 0x800080, origin: 'basic' },
    { name: 'brown', rgb: 0xA52A2A, origin: 'basic' },
    { name: 'tan', rgb: 0xD2B48C, origin: 'basic' },
    { name: 'violet', rgb: 0xEE82EE, origin: 'basic' },
    { name: 'beige', rgb: 0xF5F5DC, origin: 'basic' },
    { name: 'fuchsia', rgb: 0xFF00FF, origin: 'basic' },
    { name: 'gold', rgb: 0xFFD700, origin: 'basic' },
    { name: 'magenta', rgb: 0xFF00FF, origin: 'basic' },
    { name: 'orange', rgb: 0xFFA500, origin: 'basic' },
    { name: 'pink', rgb: 0xFFC0CB, origin: 'basic' },
    { name: 'red', rgb: 0xFF0000, origin: 'basic' },
    { name: 'white', rgb: 0xFFFFFF, origin: 'basic' },
    { name: 'yellow', rgb: 0xFFFF00, origin: 'basic' },
    { name: 'aqua', rgb: 0x00FFFF, origin: 'html' },
    { name: 'aliceblue', rgb: 0xF0F8FF, origin: 'html' },
    { name: 'antiquewhite', rgb: 0xFAEBD7, origin: 'html' },
    { name: 'black', rgb: 0x000000, origin: 'html' },
    { name: 'blue', rgb: 0x0000FF, origin: 'html' },
    { name: 'cyan', rgb: 0x00FFFF, origin: 'html' },
    { name: 'darkblue', rgb: 0x00008B, origin: 'html' },
    { name: 'darkcyan', rgb: 0x008B8B, origin: 'html' },
    { name: 'darkgreen', rgb: 0x006400, origin: 'html' },
    { name: 'darkturquoise', rgb: 0x00CED1, origin: 'html' },
    { name: 'deepskyblue', rgb: 0x00BFFF, origin: 'html' },
    { name: 'green', rgb: 0x008000, origin: 'html' },
    { name: 'lime', rgb: 0x00FF00, origin: 'html' },
    { name: 'mediumblue', rgb: 0x0000CD, origin: 'html' },
    { name: 'mediumspringgreen', rgb: 0x00FA9A, origin: 'html' },
    { name: 'navy', rgb: 0x000080, origin: 'html' },
    { name: 'springgreen', rgb: 0x00FF7F, origin: 'html' },
    { name: 'teal', rgb: 0x008080, origin: 'html' },
    { name: 'midnightblue', rgb: 0x191970, origin: 'html' },
    { name: 'dodgerblue', rgb: 0x1E90FF, origin: 'html' },
    { name: 'lightseagreen', rgb: 0x20B2AA, origin: 'html' },
    { name: 'forestgreen', rgb: 0x228B22, origin: 'html' },
    { name: 'seagreen', rgb: 0x2E8B57, origin: 'html' },
    { name: 'darkslategray', rgb: 0x2F4F4F, origin: 'html' },
    { name: 'darkslategrey', rgb: 0x2F4F4F, origin: 'html' },
    { name: 'limegreen', rgb: 0x32CD32, origin: 'html' },
    { name: 'mediumseagreen', rgb: 0x3CB371, origin: 'html' },
    { name: 'turquoise', rgb: 0x40E0D0, origin: 'html' },
    { name: 'royalblue', rgb: 0x4169E1, origin: 'html' },
    { name: 'steelblue', rgb: 0x4682B4, origin: 'html' },
    { name: 'darkslateblue', rgb: 0x483D8B, origin: 'html' },
    { name: 'mediumturquoise', rgb: 0x48D1CC, origin: 'html' },
    { name: 'indigo', rgb: 0x4B0082, origin: 'html' },
    { name: 'darkolivegreen', rgb: 0x556B2F, origin: 'html' },
    { name: 'cadetblue', rgb: 0x5F9EA0, origin: 'html' },
    { name: 'cornflowerblue', rgb: 0x6495ED, origin: 'html' },
    { name: 'mediumaquamarine', rgb: 0x66CDAA, origin: 'html' },
    { name: 'dimgray', rgb: 0x696969, origin: 'html' },
    { name: 'dimgrey', rgb: 0x696969, origin: 'html' },
    { name: 'slateblue', rgb: 0x6A5ACD, origin: 'html' },
    { name: 'olivedrab', rgb: 0x6B8E23, origin: 'html' },
    { name: 'slategray', rgb: 0x708090, origin: 'html' },
    { name: 'slategrey', rgb: 0x708090, origin: 'html' },
    { name: 'lightslategray', rgb: 0x778899, origin: 'html' },
    { name: 'lightslategrey', rgb: 0x778899, origin: 'html' },
    { name: 'mediumslateblue', rgb: 0x7B68EE, origin: 'html' },
    { name: 'lawngreen', rgb: 0x7CFC00, origin: 'html' },
    { name: 'aquamarine', rgb: 0x7FFFD4, origin: 'html' },
    { name: 'chartreuse', rgb: 0x7FFF00, origin: 'html' },
    { name: 'gray', rgb: 0x808080, origin: 'html' },
    { name: 'grey', rgb: 0x808080, origin: 'html' },
    { name: 'maroon', rgb: 0x800000, origin: 'html' },
    { name: 'olive', rgb: 0x808000, origin: 'html' },
    { name: 'purple', rgb: 0x800080, origin: 'html' },
    { name: 'lightskyblue', rgb: 0x87CEFA, origin: 'html' },
    { name: 'skyblue', rgb: 0x87CEEB, origin: 'html' },
    { name: 'blueviolet', rgb: 0x8A2BE2, origin: 'html' },
    { name: 'darkmagenta', rgb: 0x8B008B, origin: 'html' },
    { name: 'darkred', rgb: 0x8B0000, origin: 'html' },
    { name: 'saddlebrown', rgb: 0x8B4513, origin: 'html' },
    { name: 'darkseagreen', rgb: 0x8FBC8F, origin: 'html' },
    { name: 'lightgreen', rgb: 0x90EE90, origin: 'html' },
    { name: 'mediumpurple', rgb: 0x9370DB, origin: 'html' },
    { name: 'darkviolet', rgb: 0x9400D3, origin: 'html' },
    { name: 'palegreen', rgb: 0x98FB98, origin: 'html' },
    { name: 'darkorchid', rgb: 0x9932CC, origin: 'html' },
    { name: 'yellowgreen', rgb: 0x9ACD32, origin: 'html' },
    { name: 'sienna', rgb: 0xA0522D, origin: 'html' },
    { name: 'brown', rgb: 0xA52A2A, origin: 'html' },
    { name: 'darkgray', rgb: 0xA9A9A9, origin: 'html' },
    { name: 'darkgrey', rgb: 0xA9A9A9, origin: 'html' },
    { name: 'greenyellow', rgb: 0xADFF2F, origin: 'html' },
    { name: 'lightblue', rgb: 0xADD8E6, origin: 'html' },
    { name: 'paleturquoise', rgb: 0xAFEEEE, origin: 'html' },
    { name: 'lightsteelblue', rgb: 0xB0C4DE, origin: 'html' },
    { name: 'powderblue', rgb: 0xB0E0E6, origin: 'html' },
    { name: 'firebrick', rgb: 0xB22222, origin: 'html' },
    { name: 'darkgoldenrod', rgb: 0xB8860B, origin: 'html' },
    { name: 'mediumorchid', rgb: 0xBA55D3, origin: 'html' },
    { name: 'rosybrown', rgb: 0xBC8F8F, origin: 'html' },
    { name: 'darkkhaki', rgb: 0xBDB76B, origin: 'html' },
    { name: 'silver', rgb: 0xC0C0C0, origin: 'html' },
    { name: 'mediumvioletred', rgb: 0xC71585, origin: 'html' },
    { name: 'indianred', rgb: 0xCD5C5C, origin: 'html' },
    { name: 'peru', rgb: 0xCD853F, origin: 'html' },
    { name: 'chocolate', rgb: 0xD2691E, origin: 'html' },
    { name: 'tan', rgb: 0xD2B48C, origin: 'html' },
    { name: 'lightgray', rgb: 0xD3D3D3, origin: 'html' },
    { name: 'lightgrey', rgb: 0xD3D3D3, origin: 'html' },
    { name: 'thistle', rgb: 0xD8BFD8, origin: 'html' },
    { name: 'goldenrod', rgb: 0xDAA520, origin: 'html' },
    { name: 'orchid', rgb: 0xDA70D6, origin: 'html' },
    { name: 'palevioletred', rgb: 0xDB7093, origin: 'html' },
    { name: 'crimson', rgb: 0xDC143C, origin: 'html' },
    { name: 'gainsboro', rgb: 0xDCDCDC, origin: 'html' },
    { name: 'plum', rgb: 0xDDA0DD, origin: 'html' },
    { name: 'burlywood', rgb: 0xDEB887, origin: 'html' },
    { name: 'lightcyan', rgb: 0xE0FFFF, origin: 'html' },
    { name: 'lavender', rgb: 0xE6E6FA, origin: 'html' },
    { name: 'darksalmon', rgb: 0xE9967A, origin: 'html' },
    { name: 'palegoldenrod', rgb: 0xEEE8AA, origin: 'html' },
    { name: 'violet', rgb: 0xEE82EE, origin: 'html' },
    { name: 'azure', rgb: 0xF0FFFF, origin: 'html' },
    { name: 'honeydew', rgb: 0xF0FFF0, origin: 'html' },
    { name: 'khaki', rgb: 0xF0E68C, origin: 'html' },
    { name: 'lightcoral', rgb: 0xF08080, origin: 'html' },
    { name: 'sandybrown', rgb: 0xF4A460, origin: 'html' },
    { name: 'beige', rgb: 0xF5F5DC, origin: 'html' },
    { name: 'mintcream', rgb: 0xF5FFFA, origin: 'html' },
    { name: 'wheat', rgb: 0xF5DEB3, origin: 'html' },
    { name: 'whitesmoke', rgb: 0xF5F5F5, origin: 'html' },
    { name: 'ghostwhite', rgb: 0xF8F8FF, origin: 'html' },
    { name: 'lightgoldenrodyellow', rgb: 0xFAFAD2, origin: 'html' },
    { name: 'linen', rgb: 0xFAF0E6, origin: 'html' },
    { name: 'salmon', rgb: 0xFA8072, origin: 'html' },
    { name: 'oldlace', rgb: 0xFDF5E6, origin: 'html' },
    { name: 'bisque', rgb: 0xFFE4C4, origin: 'html' },
    { name: 'blanchedalmond', rgb: 0xFFEBCD, origin: 'html' },
    { name: 'coral', rgb: 0xFF7F50, origin: 'html' },
    { name: 'cornsilk', rgb: 0xFFF8DC, origin: 'html' },
    { name: 'darkorange', rgb: 0xFF8C00, origin: 'html' },
    { name: 'deeppink', rgb: 0xFF1493, origin: 'html' },
    { name: 'floralwhite', rgb: 0xFFFAF0, origin: 'html' },
    { name: 'fuchsia', rgb: 0xFF00FF, origin: 'html' },
    { name: 'gold', rgb: 0xFFD700, origin: 'html' },
    { name: 'hotpink', rgb: 0xFF69B4, origin: 'html' },
    { name: 'ivory', rgb: 0xFFFFF0, origin: 'html' },
    { name: 'lavenderblush', rgb: 0xFFF0F5, origin: 'html' },
    { name: 'lemonchiffon', rgb: 0xFFFACD, origin: 'html' },
    { name: 'lightpink', rgb: 0xFFB6C1, origin: 'html' },
    { name: 'lightsalmon', rgb: 0xFFA07A, origin: 'html' },
    { name: 'lightyellow', rgb: 0xFFFFE0, origin: 'html' },
    { name: 'magenta', rgb: 0xFF00FF, origin: 'html' },
    { name: 'mistyrose', rgb: 0xFFE4E1, origin: 'html' },
    { name: 'moccasin', rgb: 0xFFE4B5, origin: 'html' },
    { name: 'navajowhite', rgb: 0xFFDEAD, origin: 'html' },
    { name: 'orange', rgb: 0xFFA500, origin: 'html' },
    { name: 'orangered', rgb: 0xFF4500, origin: 'html' },
    { name: 'papayawhip', rgb: 0xFFEFD5, origin: 'html' },
    { name: 'peachpuff', rgb: 0xFFDAB9, origin: 'html' },
    { name: 'pink', rgb: 0xFFC0CB, origin: 'html' },
    { name: 'red', rgb: 0xFF0000, origin: 'html' },
    { name: 'seashell', rgb: 0xFFF5EE, origin: 'html' },
    { name: 'snow', rgb: 0xFFFAFA, origin: 'html' },
    { name: 'tomato', rgb: 0xFF6347, origin: 'html' },
    { name: 'white', rgb: 0xFFFFFF, origin: 'html' },
    { name: 'yellow', rgb: 0xFFFF00, origin: 'html' },
    { name: 'black', rgb: 0x000000, origin: './ntc' },
    { name: 'navy blue', rgb: 0x000080, origin: './ntc' },
    { name: 'dark blue', rgb: 0x0000C8, origin: './ntc' },
    { name: 'blue', rgb: 0x0000FF, origin: './ntc' },
    { name: 'stratos', rgb: 0x000741, origin: './ntc' },
    { name: 'swamp', rgb: 0x001B1C, origin: './ntc' },
    { name: 'resolution blue', rgb: 0x002387, origin: './ntc' },
    { name: 'deep fir', rgb: 0x002900, origin: './ntc' },
    { name: 'burnham', rgb: 0x002E20, origin: './ntc' },
    { name: 'international klein blue', rgb: 0x002FA7, origin: './ntc' },
    { name: 'prussian blue', rgb: 0x003153, origin: './ntc' },
    { name: 'midnight blue', rgb: 0x003366, origin: './ntc' },
    { name: 'smalt', rgb: 0x003399, origin: './ntc' },
    { name: 'deep teal', rgb: 0x003532, origin: './ntc' },
    { name: 'cyprus', rgb: 0x003E40, origin: './ntc' },
    { name: 'kaitoke green', rgb: 0x004620, origin: './ntc' },
    { name: 'cobalt', rgb: 0x0047AB, origin: './ntc' },
    { name: 'crusoe', rgb: 0x004816, origin: './ntc' },
    { name: 'sherpa blue', rgb: 0x004950, origin: './ntc' },
    { name: 'endeavour', rgb: 0x0056A7, origin: './ntc' },
    { name: 'camarone', rgb: 0x00581A, origin: './ntc' },
    { name: 'science blue', rgb: 0x0066CC, origin: './ntc' },
    { name: 'blue ribbon', rgb: 0x0066FF, origin: './ntc' },
    { name: 'tropical rain forest', rgb: 0x00755E, origin: './ntc' },
    { name: 'allports', rgb: 0x0076A3, origin: './ntc' },
    { name: 'deep cerulean', rgb: 0x007BA7, origin: './ntc' },
    { name: 'lochmara', rgb: 0x007EC7, origin: './ntc' },
    { name: 'azure radiance', rgb: 0x007FFF, origin: './ntc' },
    { name: 'teal', rgb: 0x008080, origin: './ntc' },
    { name: 'bondi blue', rgb: 0x0095B6, origin: './ntc' },
    { name: 'pacific blue', rgb: 0x009DC4, origin: './ntc' },
    { name: 'persian green', rgb: 0x00A693, origin: './ntc' },
    { name: 'jade', rgb: 0x00A86B, origin: './ntc' },
    { name: 'caribbean green', rgb: 0x00CC99, origin: './ntc' },
    { name: "robin's egg blue", rgb: 0x00CCCC, origin: './ntc' },
    { name: 'green', rgb: 0x00FF00, origin: './ntc' },
    { name: 'spring green', rgb: 0x00FF7F, origin: './ntc' },
    { name: 'cyan / aqua', rgb: 0x00FFFF, origin: './ntc' },
    { name: 'blue charcoal', rgb: 0x010D1A, origin: './ntc' },
    { name: 'midnight', rgb: 0x011635, origin: './ntc' },
    { name: 'holly', rgb: 0x011D13, origin: './ntc' },
    { name: 'daintree', rgb: 0x012731, origin: './ntc' },
    { name: 'cardin green', rgb: 0x01361C, origin: './ntc' },
    { name: 'county green', rgb: 0x01371A, origin: './ntc' },
    { name: 'astronaut blue', rgb: 0x013E62, origin: './ntc' },
    { name: 'regal blue', rgb: 0x013F6A, origin: './ntc' },
    { name: 'aqua deep', rgb: 0x014B43, origin: './ntc' },
    { name: 'orient', rgb: 0x015E85, origin: './ntc' },
    { name: 'blue stone', rgb: 0x016162, origin: './ntc' },
    { name: 'fun green', rgb: 0x016D39, origin: './ntc' },
    { name: 'pine green', rgb: 0x01796F, origin: './ntc' },
    { name: 'blue lagoon', rgb: 0x017987, origin: './ntc' },
    { name: 'deep sea', rgb: 0x01826B, origin: './ntc' },
    { name: 'green haze', rgb: 0x01A368, origin: './ntc' },
    { name: 'english holly', rgb: 0x022D15, origin: './ntc' },
    { name: 'sherwood green', rgb: 0x02402C, origin: './ntc' },
    { name: 'congress blue', rgb: 0x02478E, origin: './ntc' },
    { name: 'evening sea', rgb: 0x024E46, origin: './ntc' },
    { name: 'bahama blue', rgb: 0x026395, origin: './ntc' },
    { name: 'observatory', rgb: 0x02866F, origin: './ntc' },
    { name: 'cerulean', rgb: 0x02A4D3, origin: './ntc' },
    { name: 'tangaroa', rgb: 0x03163C, origin: './ntc' },
    { name: 'green vogue', rgb: 0x032B52, origin: './ntc' },
    { name: 'mosque', rgb: 0x036A6E, origin: './ntc' },
    { name: 'midnight moss', rgb: 0x041004, origin: './ntc' },
    { name: 'black pearl', rgb: 0x041322, origin: './ntc' },
    { name: 'blue whale', rgb: 0x042E4C, origin: './ntc' },
    { name: 'zuccini', rgb: 0x044022, origin: './ntc' },
    { name: 'teal blue', rgb: 0x044259, origin: './ntc' },
    { name: 'deep cove', rgb: 0x051040, origin: './ntc' },
    { name: 'gulf blue', rgb: 0x051657, origin: './ntc' },
    { name: 'venice blue', rgb: 0x055989, origin: './ntc' },
    { name: 'watercourse', rgb: 0x056F57, origin: './ntc' },
    { name: 'catalina blue', rgb: 0x062A78, origin: './ntc' },
    { name: 'tiber', rgb: 0x063537, origin: './ntc' },
    { name: 'gossamer', rgb: 0x069B81, origin: './ntc' },
    { name: 'niagara', rgb: 0x06A189, origin: './ntc' },
    { name: 'tarawera', rgb: 0x073A50, origin: './ntc' },
    { name: 'jaguar', rgb: 0x080110, origin: './ntc' },
    { name: 'black bean', rgb: 0x081910, origin: './ntc' },
    { name: 'deep sapphire', rgb: 0x082567, origin: './ntc' },
    { name: 'elf green', rgb: 0x088370, origin: './ntc' },
    { name: 'bright turquoise', rgb: 0x08E8DE, origin: './ntc' },
    { name: 'downriver', rgb: 0x092256, origin: './ntc' },
    { name: 'palm green', rgb: 0x09230F, origin: './ntc' },
    { name: 'madison', rgb: 0x09255D, origin: './ntc' },
    { name: 'bottle green', rgb: 0x093624, origin: './ntc' },
    { name: 'deep sea green', rgb: 0x095859, origin: './ntc' },
    { name: 'salem', rgb: 0x097F4B, origin: './ntc' },
    { name: 'black russian', rgb: 0x0A001C, origin: './ntc' },
    { name: 'dark fern', rgb: 0x0A480D, origin: './ntc' },
    { name: 'japanese laurel', rgb: 0x0A6906, origin: './ntc' },
    { name: 'atoll', rgb: 0x0A6F75, origin: './ntc' },
    { name: 'cod gray', rgb: 0x0B0B0B, origin: './ntc' },
    { name: 'marshland', rgb: 0x0B0F08, origin: './ntc' },
    { name: 'gordons green', rgb: 0x0B1107, origin: './ntc' },
    { name: 'black forest', rgb: 0x0B1304, origin: './ntc' },
    { name: 'san felix', rgb: 0x0B6207, origin: './ntc' },
    { name: 'malachite', rgb: 0x0BDA51, origin: './ntc' },
    { name: 'ebony', rgb: 0x0C0B1D, origin: './ntc' },
    { name: 'woodsmoke', rgb: 0x0C0D0F, origin: './ntc' },
    { name: 'racing green', rgb: 0x0C1911, origin: './ntc' },
    { name: 'surfie green', rgb: 0x0C7A79, origin: './ntc' },
    { name: 'blue chill', rgb: 0x0C8990, origin: './ntc' },
    { name: 'black rock', rgb: 0x0D0332, origin: './ntc' },
    { name: 'bunker', rgb: 0x0D1117, origin: './ntc' },
    { name: 'aztec', rgb: 0x0D1C19, origin: './ntc' },
    { name: 'bush', rgb: 0x0D2E1C, origin: './ntc' },
    { name: 'cinder', rgb: 0x0E0E18, origin: './ntc' },
    { name: 'firefly', rgb: 0x0E2A30, origin: './ntc' },
    { name: 'torea bay', rgb: 0x0F2D9E, origin: './ntc' },
    { name: 'vulcan', rgb: 0x10121D, origin: './ntc' },
    { name: 'green waterloo', rgb: 0x101405, origin: './ntc' },
    { name: 'eden', rgb: 0x105852, origin: './ntc' },
    { name: 'arapawa', rgb: 0x110C6C, origin: './ntc' },
    { name: 'ultramarine', rgb: 0x120A8F, origin: './ntc' },
    { name: 'elephant', rgb: 0x123447, origin: './ntc' },
    { name: 'jewel', rgb: 0x126B40, origin: './ntc' },
    { name: 'diesel', rgb: 0x130000, origin: './ntc' },
    { name: 'asphalt', rgb: 0x130A06, origin: './ntc' },
    { name: 'blue zodiac', rgb: 0x13264D, origin: './ntc' },
    { name: 'parsley', rgb: 0x134F19, origin: './ntc' },
    { name: 'nero', rgb: 0x140600, origin: './ntc' },
    { name: 'tory blue', rgb: 0x1450AA, origin: './ntc' },
    { name: 'bunting', rgb: 0x151F4C, origin: './ntc' },
    { name: 'denim', rgb: 0x1560BD, origin: './ntc' },
    { name: 'genoa', rgb: 0x15736B, origin: './ntc' },
    { name: 'mirage', rgb: 0x161928, origin: './ntc' },
    { name: 'hunter green', rgb: 0x161D10, origin: './ntc' },
    { name: 'big stone', rgb: 0x162A40, origin: './ntc' },
    { name: 'celtic', rgb: 0x163222, origin: './ntc' },
    { name: 'timber green', rgb: 0x16322C, origin: './ntc' },
    { name: 'gable green', rgb: 0x163531, origin: './ntc' },
    { name: 'pine tree', rgb: 0x171F04, origin: './ntc' },
    { name: 'chathams blue', rgb: 0x175579, origin: './ntc' },
    { name: 'deep forest green', rgb: 0x182D09, origin: './ntc' },
    { name: 'blumine', rgb: 0x18587A, origin: './ntc' },
    { name: 'palm leaf', rgb: 0x19330E, origin: './ntc' },
    { name: 'nile blue', rgb: 0x193751, origin: './ntc' },
    { name: 'fun blue', rgb: 0x1959A8, origin: './ntc' },
    { name: 'lucky point', rgb: 0x1A1A68, origin: './ntc' },
    { name: 'mountain meadow', rgb: 0x1AB385, origin: './ntc' },
    { name: 'tolopea', rgb: 0x1B0245, origin: './ntc' },
    { name: 'haiti', rgb: 0x1B1035, origin: './ntc' },
    { name: 'deep koamaru', rgb: 0x1B127B, origin: './ntc' },
    { name: 'acadia', rgb: 0x1B1404, origin: './ntc' },
    { name: 'seaweed', rgb: 0x1B2F11, origin: './ntc' },
    { name: 'biscay', rgb: 0x1B3162, origin: './ntc' },
    { name: 'matisse', rgb: 0x1B659D, origin: './ntc' },
    { name: 'crowshead', rgb: 0x1C1208, origin: './ntc' },
    { name: 'rangoon green', rgb: 0x1C1E13, origin: './ntc' },
    { name: 'persian blue', rgb: 0x1C39BB, origin: './ntc' },
    { name: 'everglade', rgb: 0x1C402E, origin: './ntc' },
    { name: 'elm', rgb: 0x1C7C7D, origin: './ntc' },
    { name: 'green pea', rgb: 0x1D6142, origin: './ntc' },
    { name: 'creole', rgb: 0x1E0F04, origin: './ntc' },
    { name: 'karaka', rgb: 0x1E1609, origin: './ntc' },
    { name: 'el paso', rgb: 0x1E1708, origin: './ntc' },
    { name: 'cello', rgb: 0x1E385B, origin: './ntc' },
    { name: 'te papa green', rgb: 0x1E433C, origin: './ntc' },
    { name: 'dodger blue', rgb: 0x1E90FF, origin: './ntc' },
    { name: 'eastern blue', rgb: 0x1E9AB0, origin: './ntc' },
    { name: 'night rider', rgb: 0x1F120F, origin: './ntc' },
    { name: 'java', rgb: 0x1FC2C2, origin: './ntc' },
    { name: 'jacksons purple', rgb: 0x20208D, origin: './ntc' },
    { name: 'cloud burst', rgb: 0x202E54, origin: './ntc' },
    { name: 'blue dianne', rgb: 0x204852, origin: './ntc' },
    { name: 'eternity', rgb: 0x211A0E, origin: './ntc' },
    { name: 'deep blue', rgb: 0x220878, origin: './ntc' },
    { name: 'forest green', rgb: 0x228B22, origin: './ntc' },
    { name: 'mallard', rgb: 0x233418, origin: './ntc' },
    { name: 'violet', rgb: 0x240A40, origin: './ntc' },
    { name: 'kilamanjaro', rgb: 0x240C02, origin: './ntc' },
    { name: 'log cabin', rgb: 0x242A1D, origin: './ntc' },
    { name: 'black olive', rgb: 0x242E16, origin: './ntc' },
    { name: 'green house', rgb: 0x24500F, origin: './ntc' },
    { name: 'graphite', rgb: 0x251607, origin: './ntc' },
    { name: 'cannon black', rgb: 0x251706, origin: './ntc' },
    { name: 'port gore', rgb: 0x251F4F, origin: './ntc' },
    { name: 'shark', rgb: 0x25272C, origin: './ntc' },
    { name: 'green kelp', rgb: 0x25311C, origin: './ntc' },
    { name: 'curious blue', rgb: 0x2596D1, origin: './ntc' },
    { name: 'paua', rgb: 0x260368, origin: './ntc' },
    { name: 'paris m', rgb: 0x26056A, origin: './ntc' },
    { name: 'wood bark', rgb: 0x261105, origin: './ntc' },
    { name: 'gondola', rgb: 0x261414, origin: './ntc' },
    { name: 'steel gray', rgb: 0x262335, origin: './ntc' },
    { name: 'ebony clay', rgb: 0x26283B, origin: './ntc' },
    { name: 'bay of many', rgb: 0x273A81, origin: './ntc' },
    { name: 'plantation', rgb: 0x27504B, origin: './ntc' },
    { name: 'eucalyptus', rgb: 0x278A5B, origin: './ntc' },
    { name: 'oil', rgb: 0x281E15, origin: './ntc' },
    { name: 'astronaut', rgb: 0x283A77, origin: './ntc' },
    { name: 'mariner', rgb: 0x286ACD, origin: './ntc' },
    { name: 'violent violet', rgb: 0x290C5E, origin: './ntc' },
    { name: 'bastille', rgb: 0x292130, origin: './ntc' },
    { name: 'zeus', rgb: 0x292319, origin: './ntc' },
    { name: 'charade', rgb: 0x292937, origin: './ntc' },
    { name: 'jelly bean', rgb: 0x297B9A, origin: './ntc' },
    { name: 'jungle green', rgb: 0x29AB87, origin: './ntc' },
    { name: 'cherry pie', rgb: 0x2A0359, origin: './ntc' },
    { name: 'coffee bean', rgb: 0x2A140E, origin: './ntc' },
    { name: 'baltic sea', rgb: 0x2A2630, origin: './ntc' },
    { name: 'turtle green', rgb: 0x2A380B, origin: './ntc' },
    { name: 'cerulean blue', rgb: 0x2A52BE, origin: './ntc' },
    { name: 'sepia black', rgb: 0x2B0202, origin: './ntc' },
    { name: 'valhalla', rgb: 0x2B194F, origin: './ntc' },
    { name: 'heavy metal', rgb: 0x2B3228, origin: './ntc' },
    { name: 'blue gem', rgb: 0x2C0E8C, origin: './ntc' },
    { name: 'revolver', rgb: 0x2C1632, origin: './ntc' },
    { name: 'bleached cedar', rgb: 0x2C2133, origin: './ntc' },
    { name: 'lochinvar', rgb: 0x2C8C84, origin: './ntc' },
    { name: 'mikado', rgb: 0x2D2510, origin: './ntc' },
    { name: 'outer space', rgb: 0x2D383A, origin: './ntc' },
    { name: 'st tropaz', rgb: 0x2D569B, origin: './ntc' },
    { name: 'jacaranda', rgb: 0x2E0329, origin: './ntc' },
    { name: 'jacko bean', rgb: 0x2E1905, origin: './ntc' },
    { name: 'rangitoto', rgb: 0x2E3222, origin: './ntc' },
    { name: 'rhino', rgb: 0x2E3F62, origin: './ntc' },
    { name: 'sea green', rgb: 0x2E8B57, origin: './ntc' },
    { name: 'scooter', rgb: 0x2EBFD4, origin: './ntc' },
    { name: 'onion', rgb: 0x2F270E, origin: './ntc' },
    { name: 'governor bay', rgb: 0x2F3CB3, origin: './ntc' },
    { name: 'sapphire', rgb: 0x2F519E, origin: './ntc' },
    { name: 'spectra', rgb: 0x2F5A57, origin: './ntc' },
    { name: 'casal', rgb: 0x2F6168, origin: './ntc' },
    { name: 'melanzane', rgb: 0x300529, origin: './ntc' },
    { name: 'cocoa brown', rgb: 0x301F1E, origin: './ntc' },
    { name: 'woodrush', rgb: 0x302A0F, origin: './ntc' },
    { name: 'san juan', rgb: 0x304B6A, origin: './ntc' },
    { name: 'turquoise', rgb: 0x30D5C8, origin: './ntc' },
    { name: 'eclipse', rgb: 0x311C17, origin: './ntc' },
    { name: 'pickled bluewood', rgb: 0x314459, origin: './ntc' },
    { name: 'azure', rgb: 0x315BA1, origin: './ntc' },
    { name: 'calypso', rgb: 0x31728D, origin: './ntc' },
    { name: 'paradiso', rgb: 0x317D82, origin: './ntc' },
    { name: 'persian indigo', rgb: 0x32127A, origin: './ntc' },
    { name: 'blackcurrant', rgb: 0x32293A, origin: './ntc' },
    { name: 'mine shaft', rgb: 0x323232, origin: './ntc' },
    { name: 'stromboli', rgb: 0x325D52, origin: './ntc' },
    { name: 'bilbao', rgb: 0x327C14, origin: './ntc' },
    { name: 'astral', rgb: 0x327DA0, origin: './ntc' },
    { name: 'christalle', rgb: 0x33036B, origin: './ntc' },
    { name: 'thunder', rgb: 0x33292F, origin: './ntc' },
    { name: 'shamrock', rgb: 0x33CC99, origin: './ntc' },
    { name: 'tamarind', rgb: 0x341515, origin: './ntc' },
    { name: 'mardi gras', rgb: 0x350036, origin: './ntc' },
    { name: 'valentino', rgb: 0x350E42, origin: './ntc' },
    { name: 'jagger', rgb: 0x350E57, origin: './ntc' },
    { name: 'tuna', rgb: 0x353542, origin: './ntc' },
    { name: 'chambray', rgb: 0x354E8C, origin: './ntc' },
    { name: 'martinique', rgb: 0x363050, origin: './ntc' },
    { name: 'tuatara', rgb: 0x363534, origin: './ntc' },
    { name: 'waiouru', rgb: 0x363C0D, origin: './ntc' },
    { name: 'ming', rgb: 0x36747D, origin: './ntc' },
    { name: 'la palma', rgb: 0x368716, origin: './ntc' },
    { name: 'chocolate', rgb: 0x370202, origin: './ntc' },
    { name: 'clinker', rgb: 0x371D09, origin: './ntc' },
    { name: 'brown tumbleweed', rgb: 0x37290E, origin: './ntc' },
    { name: 'birch', rgb: 0x373021, origin: './ntc' },
    { name: 'oracle', rgb: 0x377475, origin: './ntc' },
    { name: 'blue diamond', rgb: 0x380474, origin: './ntc' },
    { name: 'grape', rgb: 0x381A51, origin: './ntc' },
    { name: 'dune', rgb: 0x383533, origin: './ntc' },
    { name: 'oxford blue', rgb: 0x384555, origin: './ntc' },
    { name: 'clover', rgb: 0x384910, origin: './ntc' },
    { name: 'limed spruce', rgb: 0x394851, origin: './ntc' },
    { name: 'dell', rgb: 0x396413, origin: './ntc' },
    { name: 'toledo', rgb: 0x3A0020, origin: './ntc' },
    { name: 'sambuca', rgb: 0x3A2010, origin: './ntc' },
    { name: 'jacarta', rgb: 0x3A2A6A, origin: './ntc' },
    { name: 'william', rgb: 0x3A686C, origin: './ntc' },
    { name: 'killarney', rgb: 0x3A6A47, origin: './ntc' },
    { name: 'keppel', rgb: 0x3AB09E, origin: './ntc' },
    { name: 'temptress', rgb: 0x3B000B, origin: './ntc' },
    { name: 'aubergine', rgb: 0x3B0910, origin: './ntc' },
    { name: 'jon', rgb: 0x3B1F1F, origin: './ntc' },
    { name: 'treehouse', rgb: 0x3B2820, origin: './ntc' },
    { name: 'amazon', rgb: 0x3B7A57, origin: './ntc' },
    { name: 'boston blue', rgb: 0x3B91B4, origin: './ntc' },
    { name: 'windsor', rgb: 0x3C0878, origin: './ntc' },
    { name: 'rebel', rgb: 0x3C1206, origin: './ntc' },
    { name: 'meteorite', rgb: 0x3C1F76, origin: './ntc' },
    { name: 'dark ebony', rgb: 0x3C2005, origin: './ntc' },
    { name: 'camouflage', rgb: 0x3C3910, origin: './ntc' },
    { name: 'bright gray', rgb: 0x3C4151, origin: './ntc' },
    { name: 'cape cod', rgb: 0x3C4443, origin: './ntc' },
    { name: 'lunar green', rgb: 0x3C493A, origin: './ntc' },
    { name: 'bean  ', rgb: 0x3D0C02, origin: './ntc' },
    { name: 'bistre', rgb: 0x3D2B1F, origin: './ntc' },
    { name: 'goblin', rgb: 0x3D7D52, origin: './ntc' },
    { name: 'kingfisher daisy', rgb: 0x3E0480, origin: './ntc' },
    { name: 'cedar', rgb: 0x3E1C14, origin: './ntc' },
    { name: 'english walnut', rgb: 0x3E2B23, origin: './ntc' },
    { name: 'black marlin', rgb: 0x3E2C1C, origin: './ntc' },
    { name: 'ship gray', rgb: 0x3E3A44, origin: './ntc' },
    { name: 'pelorous', rgb: 0x3EABBF, origin: './ntc' },
    { name: 'bronze', rgb: 0x3F2109, origin: './ntc' },
    { name: 'cola', rgb: 0x3F2500, origin: './ntc' },
    { name: 'madras', rgb: 0x3F3002, origin: './ntc' },
    { name: 'minsk', rgb: 0x3F307F, origin: './ntc' },
    { name: 'cabbage pont', rgb: 0x3F4C3A, origin: './ntc' },
    { name: 'tom thumb', rgb: 0x3F583B, origin: './ntc' },
    { name: 'mineral green', rgb: 0x3F5D53, origin: './ntc' },
    { name: 'puerto rico', rgb: 0x3FC1AA, origin: './ntc' },
    { name: 'harlequin', rgb: 0x3FFF00, origin: './ntc' },
    { name: 'brown pod', rgb: 0x401801, origin: './ntc' },
    { name: 'cork', rgb: 0x40291D, origin: './ntc' },
    { name: 'masala', rgb: 0x403B38, origin: './ntc' },
    { name: 'thatch green', rgb: 0x403D19, origin: './ntc' },
    { name: 'fiord', rgb: 0x405169, origin: './ntc' },
    { name: 'viridian', rgb: 0x40826D, origin: './ntc' },
    { name: 'chateau green', rgb: 0x40A860, origin: './ntc' },
    { name: 'ripe plum', rgb: 0x410056, origin: './ntc' },
    { name: 'paco', rgb: 0x411F10, origin: './ntc' },
    { name: 'deep oak', rgb: 0x412010, origin: './ntc' },
    { name: 'merlin', rgb: 0x413C37, origin: './ntc' },
    { name: 'gun powder', rgb: 0x414257, origin: './ntc' },
    { name: 'east bay', rgb: 0x414C7D, origin: './ntc' },
    { name: 'royal blue', rgb: 0x4169E1, origin: './ntc' },
    { name: 'ocean green', rgb: 0x41AA78, origin: './ntc' },
    { name: 'burnt maroon', rgb: 0x420303, origin: './ntc' },
    { name: 'lisbon brown', rgb: 0x423921, origin: './ntc' },
    { name: 'faded jade', rgb: 0x427977, origin: './ntc' },
    { name: 'scarlet gum', rgb: 0x431560, origin: './ntc' },
    { name: 'iroko', rgb: 0x433120, origin: './ntc' },
    { name: 'armadillo', rgb: 0x433E37, origin: './ntc' },
    { name: 'river bed', rgb: 0x434C59, origin: './ntc' },
    { name: 'green leaf', rgb: 0x436A0D, origin: './ntc' },
    { name: 'barossa', rgb: 0x44012D, origin: './ntc' },
    { name: 'morocco brown', rgb: 0x441D00, origin: './ntc' },
    { name: 'mako', rgb: 0x444954, origin: './ntc' },
    { name: 'kelp', rgb: 0x454936, origin: './ntc' },
    { name: 'san marino', rgb: 0x456CAC, origin: './ntc' },
    { name: 'picton blue', rgb: 0x45B1E8, origin: './ntc' },
    { name: 'loulou', rgb: 0x460B41, origin: './ntc' },
    { name: 'crater brown', rgb: 0x462425, origin: './ntc' },
    { name: 'gray asparagus', rgb: 0x465945, origin: './ntc' },
    { name: 'steel blue', rgb: 0x4682B4, origin: './ntc' },
    { name: 'rustic red', rgb: 0x480404, origin: './ntc' },
    { name: 'bulgarian rose', rgb: 0x480607, origin: './ntc' },
    { name: 'clairvoyant', rgb: 0x480656, origin: './ntc' },
    { name: 'cocoa bean', rgb: 0x481C1C, origin: './ntc' },
    { name: 'woody brown', rgb: 0x483131, origin: './ntc' },
    { name: 'taupe', rgb: 0x483C32, origin: './ntc' },
    { name: 'van cleef', rgb: 0x49170C, origin: './ntc' },
    { name: 'brown derby', rgb: 0x492615, origin: './ntc' },
    { name: 'metallic bronze', rgb: 0x49371B, origin: './ntc' },
    { name: 'verdun green', rgb: 0x495400, origin: './ntc' },
    { name: 'blue bayoux', rgb: 0x496679, origin: './ntc' },
    { name: 'bismark', rgb: 0x497183, origin: './ntc' },
    { name: 'bracken', rgb: 0x4A2A04, origin: './ntc' },
    { name: 'deep bronze', rgb: 0x4A3004, origin: './ntc' },
    { name: 'mondo', rgb: 0x4A3C30, origin: './ntc' },
    { name: 'tundora', rgb: 0x4A4244, origin: './ntc' },
    { name: 'gravel', rgb: 0x4A444B, origin: './ntc' },
    { name: 'trout', rgb: 0x4A4E5A, origin: './ntc' },
    { name: 'pigment indigo', rgb: 0x4B0082, origin: './ntc' },
    { name: 'nandor', rgb: 0x4B5D52, origin: './ntc' },
    { name: 'saddle', rgb: 0x4C3024, origin: './ntc' },
    { name: 'abbey', rgb: 0x4C4F56, origin: './ntc' },
    { name: 'blackberry', rgb: 0x4D0135, origin: './ntc' },
    { name: 'cab sav', rgb: 0x4D0A18, origin: './ntc' },
    { name: 'indian tan', rgb: 0x4D1E01, origin: './ntc' },
    { name: 'cowboy', rgb: 0x4D282D, origin: './ntc' },
    { name: 'livid brown', rgb: 0x4D282E, origin: './ntc' },
    { name: 'rock', rgb: 0x4D3833, origin: './ntc' },
    { name: 'punga', rgb: 0x4D3D14, origin: './ntc' },
    { name: 'bronzetone', rgb: 0x4D400F, origin: './ntc' },
    { name: 'woodland', rgb: 0x4D5328, origin: './ntc' },
    { name: 'mahogany', rgb: 0x4E0606, origin: './ntc' },
    { name: 'bossanova', rgb: 0x4E2A5A, origin: './ntc' },
    { name: 'matterhorn', rgb: 0x4E3B41, origin: './ntc' },
    { name: 'bronze olive', rgb: 0x4E420C, origin: './ntc' },
    { name: 'mulled wine', rgb: 0x4E4562, origin: './ntc' },
    { name: 'axolotl', rgb: 0x4E6649, origin: './ntc' },
    { name: 'wedgewood', rgb: 0x4E7F9E, origin: './ntc' },
    { name: 'shakespeare', rgb: 0x4EABD1, origin: './ntc' },
    { name: 'honey flower', rgb: 0x4F1C70, origin: './ntc' },
    { name: 'daisy bush', rgb: 0x4F2398, origin: './ntc' },
    { name: 'indigo', rgb: 0x4F69C6, origin: './ntc' },
    { name: 'fern green', rgb: 0x4F7942, origin: './ntc' },
    { name: 'fruit salad', rgb: 0x4F9D5D, origin: './ntc' },
    { name: 'apple', rgb: 0x4FA83D, origin: './ntc' },
    { name: 'mortar', rgb: 0x504351, origin: './ntc' },
    { name: 'kashmir blue', rgb: 0x507096, origin: './ntc' },
    { name: 'cutty sark', rgb: 0x507672, origin: './ntc' },
    { name: 'emerald', rgb: 0x50C878, origin: './ntc' },
    { name: 'emperor', rgb: 0x514649, origin: './ntc' },
    { name: 'chalet green', rgb: 0x516E3D, origin: './ntc' },
    { name: 'como', rgb: 0x517C66, origin: './ntc' },
    { name: 'smalt blue', rgb: 0x51808F, origin: './ntc' },
    { name: 'castro', rgb: 0x52001F, origin: './ntc' },
    { name: 'maroon oak', rgb: 0x520C17, origin: './ntc' },
    { name: 'gigas', rgb: 0x523C94, origin: './ntc' },
    { name: 'voodoo', rgb: 0x533455, origin: './ntc' },
    { name: 'victoria', rgb: 0x534491, origin: './ntc' },
    { name: 'hippie green', rgb: 0x53824B, origin: './ntc' },
    { name: 'heath', rgb: 0x541012, origin: './ntc' },
    { name: 'judge gray', rgb: 0x544333, origin: './ntc' },
    { name: 'fuscous gray', rgb: 0x54534D, origin: './ntc' },
    { name: 'vida loca', rgb: 0x549019, origin: './ntc' },
    { name: 'cioccolato', rgb: 0x55280C, origin: './ntc' },
    { name: 'saratoga', rgb: 0x555B10, origin: './ntc' },
    { name: 'finlandia', rgb: 0x556D56, origin: './ntc' },
    { name: 'havelock blue', rgb: 0x5590D9, origin: './ntc' },
    { name: 'fountain blue', rgb: 0x56B4BE, origin: './ntc' },
    { name: 'spring leaves', rgb: 0x578363, origin: './ntc' },
    { name: 'saddle brown', rgb: 0x583401, origin: './ntc' },
    { name: 'scarpa flow', rgb: 0x585562, origin: './ntc' },
    { name: 'cactus', rgb: 0x587156, origin: './ntc' },
    { name: 'hippie blue', rgb: 0x589AAF, origin: './ntc' },
    { name: 'wine berry', rgb: 0x591D35, origin: './ntc' },
    { name: 'brown bramble', rgb: 0x592804, origin: './ntc' },
    { name: 'congo brown', rgb: 0x593737, origin: './ntc' },
    { name: 'millbrook', rgb: 0x594433, origin: './ntc' },
    { name: 'waikawa gray', rgb: 0x5A6E9C, origin: './ntc' },
    { name: 'horizon', rgb: 0x5A87A0, origin: './ntc' },
    { name: 'jambalaya', rgb: 0x5B3013, origin: './ntc' },
    { name: 'bordeaux', rgb: 0x5C0120, origin: './ntc' },
    { name: 'mulberry wood', rgb: 0x5C0536, origin: './ntc' },
    { name: 'carnaby tan', rgb: 0x5C2E01, origin: './ntc' },
    { name: 'comet', rgb: 0x5C5D75, origin: './ntc' },
    { name: 'redwood', rgb: 0x5D1E0F, origin: './ntc' },
    { name: 'don juan', rgb: 0x5D4C51, origin: './ntc' },
    { name: 'chicago', rgb: 0x5D5C58, origin: './ntc' },
    { name: 'verdigris', rgb: 0x5D5E37, origin: './ntc' },
    { name: 'dingley', rgb: 0x5D7747, origin: './ntc' },
    { name: 'breaker bay', rgb: 0x5DA19F, origin: './ntc' },
    { name: 'kabul', rgb: 0x5E483E, origin: './ntc' },
    { name: 'hemlock', rgb: 0x5E5D3B, origin: './ntc' },
    { name: 'irish coffee', rgb: 0x5F3D26, origin: './ntc' },
    { name: 'mid gray', rgb: 0x5F5F6E, origin: './ntc' },
    { name: 'shuttle gray', rgb: 0x5F6672, origin: './ntc' },
    { name: 'aqua forest', rgb: 0x5FA777, origin: './ntc' },
    { name: 'tradewind', rgb: 0x5FB3AC, origin: './ntc' },
    { name: 'horses neck', rgb: 0x604913, origin: './ntc' },
    { name: 'smoky', rgb: 0x605B73, origin: './ntc' },
    { name: 'corduroy', rgb: 0x606E68, origin: './ntc' },
    { name: 'danube', rgb: 0x6093D1, origin: './ntc' },
    { name: 'espresso', rgb: 0x612718, origin: './ntc' },
    { name: 'eggplant', rgb: 0x614051, origin: './ntc' },
    { name: 'costa del sol', rgb: 0x615D30, origin: './ntc' },
    { name: 'glade green', rgb: 0x61845F, origin: './ntc' },
    { name: 'buccaneer', rgb: 0x622F30, origin: './ntc' },
    { name: 'quincy', rgb: 0x623F2D, origin: './ntc' },
    { name: 'butterfly bush', rgb: 0x624E9A, origin: './ntc' },
    { name: 'west coast', rgb: 0x625119, origin: './ntc' },
    { name: 'finch', rgb: 0x626649, origin: './ntc' },
    { name: 'patina', rgb: 0x639A8F, origin: './ntc' },
    { name: 'fern', rgb: 0x63B76C, origin: './ntc' },
    { name: 'blue violet', rgb: 0x6456B7, origin: './ntc' },
    { name: 'dolphin', rgb: 0x646077, origin: './ntc' },
    { name: 'storm dust', rgb: 0x646463, origin: './ntc' },
    { name: 'siam', rgb: 0x646A54, origin: './ntc' },
    { name: 'nevada', rgb: 0x646E75, origin: './ntc' },
    { name: 'cornflower blue', rgb: 0x6495ED, origin: './ntc' },
    { name: 'viking', rgb: 0x64CCDB, origin: './ntc' },
    { name: 'rosewood', rgb: 0x65000B, origin: './ntc' },
    { name: 'cherrywood', rgb: 0x651A14, origin: './ntc' },
    { name: 'purple heart', rgb: 0x652DC1, origin: './ntc' },
    { name: 'fern frond', rgb: 0x657220, origin: './ntc' },
    { name: 'willow grove', rgb: 0x65745D, origin: './ntc' },
    { name: 'hoki', rgb: 0x65869F, origin: './ntc' },
    { name: 'pompadour', rgb: 0x660045, origin: './ntc' },
    { name: 'purple', rgb: 0x660099, origin: './ntc' },
    { name: 'tyrian purple', rgb: 0x66023C, origin: './ntc' },
    { name: 'dark tan', rgb: 0x661010, origin: './ntc' },
    { name: 'silver tree', rgb: 0x66B58F, origin: './ntc' },
    { name: 'bright green', rgb: 0x66FF00, origin: './ntc' },
    { name: "screamin' green", rgb: 0x66FF66, origin: './ntc' },
    { name: 'black rose', rgb: 0x67032D, origin: './ntc' },
    { name: 'scampi', rgb: 0x675FA6, origin: './ntc' },
    { name: 'ironside gray', rgb: 0x676662, origin: './ntc' },
    { name: 'viridian green', rgb: 0x678975, origin: './ntc' },
    { name: 'christi', rgb: 0x67A712, origin: './ntc' },
    { name: 'nutmeg wood finish', rgb: 0x683600, origin: './ntc' },
    { name: 'zambezi', rgb: 0x685558, origin: './ntc' },
    { name: 'salt box', rgb: 0x685E6E, origin: './ntc' },
    { name: 'tawny port', rgb: 0x692545, origin: './ntc' },
    { name: 'finn', rgb: 0x692D54, origin: './ntc' },
    { name: 'scorpion', rgb: 0x695F62, origin: './ntc' },
    { name: 'lynch', rgb: 0x697E9A, origin: './ntc' },
    { name: 'spice', rgb: 0x6A442E, origin: './ntc' },
    { name: 'himalaya', rgb: 0x6A5D1B, origin: './ntc' },
    { name: 'soya bean', rgb: 0x6A6051, origin: './ntc' },
    { name: 'hairy heath', rgb: 0x6B2A14, origin: './ntc' },
    { name: 'royal purple', rgb: 0x6B3FA0, origin: './ntc' },
    { name: 'shingle fawn', rgb: 0x6B4E31, origin: './ntc' },
    { name: 'dorado', rgb: 0x6B5755, origin: './ntc' },
    { name: 'bermuda gray', rgb: 0x6B8BA2, origin: './ntc' },
    { name: 'olive drab', rgb: 0x6B8E23, origin: './ntc' },
    { name: 'eminence', rgb: 0x6C3082, origin: './ntc' },
    { name: 'turquoise blue', rgb: 0x6CDAE7, origin: './ntc' },
    { name: 'lonestar', rgb: 0x6D0101, origin: './ntc' },
    { name: 'pine cone', rgb: 0x6D5E54, origin: './ntc' },
    { name: 'dove gray', rgb: 0x6D6C6C, origin: './ntc' },
    { name: 'juniper', rgb: 0x6D9292, origin: './ntc' },
    { name: 'gothic', rgb: 0x6D92A1, origin: './ntc' },
    { name: 'red oxide', rgb: 0x6E0902, origin: './ntc' },
    { name: 'moccaccino', rgb: 0x6E1D14, origin: './ntc' },
    { name: 'pickled bean', rgb: 0x6E4826, origin: './ntc' },
    { name: 'dallas', rgb: 0x6E4B26, origin: './ntc' },
    { name: 'kokoda', rgb: 0x6E6D57, origin: './ntc' },
    { name: 'pale sky', rgb: 0x6E7783, origin: './ntc' },
    { name: 'cafe royale', rgb: 0x6F440C, origin: './ntc' },
    { name: 'flint', rgb: 0x6F6A61, origin: './ntc' },
    { name: 'highland', rgb: 0x6F8E63, origin: './ntc' },
    { name: 'limeade', rgb: 0x6F9D02, origin: './ntc' },
    { name: 'downy', rgb: 0x6FD0C5, origin: './ntc' },
    { name: 'persian plum', rgb: 0x701C1C, origin: './ntc' },
    { name: 'sepia', rgb: 0x704214, origin: './ntc' },
    { name: 'antique bronze', rgb: 0x704A07, origin: './ntc' },
    { name: 'ferra', rgb: 0x704F50, origin: './ntc' },
    { name: 'coffee', rgb: 0x706555, origin: './ntc' },
    { name: 'slate gray', rgb: 0x708090, origin: './ntc' },
    { name: 'cedar wood finish', rgb: 0x711A00, origin: './ntc' },
    { name: 'metallic copper', rgb: 0x71291D, origin: './ntc' },
    { name: 'affair', rgb: 0x714693, origin: './ntc' },
    { name: 'studio', rgb: 0x714AB2, origin: './ntc' },
    { name: 'tobacco brown', rgb: 0x715D47, origin: './ntc' },
    { name: 'yellow metal', rgb: 0x716338, origin: './ntc' },
    { name: 'peat', rgb: 0x716B56, origin: './ntc' },
    { name: 'olivetone', rgb: 0x716E10, origin: './ntc' },
    { name: 'storm gray', rgb: 0x717486, origin: './ntc' },
    { name: 'sirocco', rgb: 0x718080, origin: './ntc' },
    { name: 'aquamarine blue', rgb: 0x71D9E2, origin: './ntc' },
    { name: 'venetian red', rgb: 0x72010F, origin: './ntc' },
    { name: 'old copper', rgb: 0x724A2F, origin: './ntc' },
    { name: 'go ben', rgb: 0x726D4E, origin: './ntc' },
    { name: 'raven', rgb: 0x727B89, origin: './ntc' },
    { name: 'seance', rgb: 0x731E8F, origin: './ntc' },
    { name: 'raw umber', rgb: 0x734A12, origin: './ntc' },
    { name: 'kimberly', rgb: 0x736C9F, origin: './ntc' },
    { name: 'crocodile', rgb: 0x736D58, origin: './ntc' },
    { name: 'crete', rgb: 0x737829, origin: './ntc' },
    { name: 'xanadu', rgb: 0x738678, origin: './ntc' },
    { name: 'spicy mustard', rgb: 0x74640D, origin: './ntc' },
    { name: 'limed ash', rgb: 0x747D63, origin: './ntc' },
    { name: 'rolling stone', rgb: 0x747D83, origin: './ntc' },
    { name: 'blue smoke', rgb: 0x748881, origin: './ntc' },
    { name: 'laurel', rgb: 0x749378, origin: './ntc' },
    { name: 'mantis', rgb: 0x74C365, origin: './ntc' },
    { name: 'russett', rgb: 0x755A57, origin: './ntc' },
    { name: 'deluge', rgb: 0x7563A8, origin: './ntc' },
    { name: 'cosmic', rgb: 0x76395D, origin: './ntc' },
    { name: 'blue marguerite', rgb: 0x7666C6, origin: './ntc' },
    { name: 'lima', rgb: 0x76BD17, origin: './ntc' },
    { name: 'sky blue', rgb: 0x76D7EA, origin: './ntc' },
    { name: 'dark burgundy', rgb: 0x770F05, origin: './ntc' },
    { name: 'crown of thorns', rgb: 0x771F1F, origin: './ntc' },
    { name: 'walnut', rgb: 0x773F1A, origin: './ntc' },
    { name: 'pablo', rgb: 0x776F61, origin: './ntc' },
    { name: 'pacifika', rgb: 0x778120, origin: './ntc' },
    { name: 'oxley', rgb: 0x779E86, origin: './ntc' },
    { name: 'pastel green', rgb: 0x77DD77, origin: './ntc' },
    { name: 'japanese maple', rgb: 0x780109, origin: './ntc' },
    { name: 'mocha', rgb: 0x782D19, origin: './ntc' },
    { name: 'peanut', rgb: 0x782F16, origin: './ntc' },
    { name: 'camouflage green', rgb: 0x78866B, origin: './ntc' },
    { name: 'wasabi', rgb: 0x788A25, origin: './ntc' },
    { name: 'ship cove', rgb: 0x788BBA, origin: './ntc' },
    { name: 'sea nymph', rgb: 0x78A39C, origin: './ntc' },
    { name: 'roman coffee', rgb: 0x795D4C, origin: './ntc' },
    { name: 'old lavender', rgb: 0x796878, origin: './ntc' },
    { name: 'rum', rgb: 0x796989, origin: './ntc' },
    { name: 'fedora', rgb: 0x796A78, origin: './ntc' },
    { name: 'sandstone', rgb: 0x796D62, origin: './ntc' },
    { name: 'spray', rgb: 0x79DEEC, origin: './ntc' },
    { name: 'siren', rgb: 0x7A013A, origin: './ntc' },
    { name: 'fuchsia blue', rgb: 0x7A58C1, origin: './ntc' },
    { name: 'boulder', rgb: 0x7A7A7A, origin: './ntc' },
    { name: 'wild blue yonder', rgb: 0x7A89B8, origin: './ntc' },
    { name: 'de york', rgb: 0x7AC488, origin: './ntc' },
    { name: 'red beech', rgb: 0x7B3801, origin: './ntc' },
    { name: 'cinnamon', rgb: 0x7B3F00, origin: './ntc' },
    { name: 'yukon gold', rgb: 0x7B6608, origin: './ntc' },
    { name: 'tapa', rgb: 0x7B7874, origin: './ntc' },
    { name: 'waterloo ', rgb: 0x7B7C94, origin: './ntc' },
    { name: 'flax smoke', rgb: 0x7B8265, origin: './ntc' },
    { name: 'amulet', rgb: 0x7B9F80, origin: './ntc' },
    { name: 'asparagus', rgb: 0x7BA05B, origin: './ntc' },
    { name: 'kenyan copper', rgb: 0x7C1C05, origin: './ntc' },
    { name: 'pesto', rgb: 0x7C7631, origin: './ntc' },
    { name: 'topaz', rgb: 0x7C778A, origin: './ntc' },
    { name: 'concord', rgb: 0x7C7B7A, origin: './ntc' },
    { name: 'jumbo', rgb: 0x7C7B82, origin: './ntc' },
    { name: 'trendy green', rgb: 0x7C881A, origin: './ntc' },
    { name: 'gumbo', rgb: 0x7CA1A6, origin: './ntc' },
    { name: 'acapulco', rgb: 0x7CB0A1, origin: './ntc' },
    { name: 'neptune', rgb: 0x7CB7BB, origin: './ntc' },
    { name: 'pueblo', rgb: 0x7D2C14, origin: './ntc' },
    { name: 'bay leaf', rgb: 0x7DA98D, origin: './ntc' },
    { name: 'malibu', rgb: 0x7DC8F7, origin: './ntc' },
    { name: 'bermuda', rgb: 0x7DD8C6, origin: './ntc' },
    { name: 'copper canyon', rgb: 0x7E3A15, origin: './ntc' },
    { name: 'claret', rgb: 0x7F1734, origin: './ntc' },
    { name: 'peru tan', rgb: 0x7F3A02, origin: './ntc' },
    { name: 'falcon', rgb: 0x7F626D, origin: './ntc' },
    { name: 'mobster', rgb: 0x7F7589, origin: './ntc' },
    { name: 'moody blue', rgb: 0x7F76D3, origin: './ntc' },
    { name: 'chartreuse', rgb: 0x7FFF00, origin: './ntc' },
    { name: 'aquamarine', rgb: 0x7FFFD4, origin: './ntc' },
    { name: 'maroon', rgb: 0x800000, origin: './ntc' },
    { name: 'rose bud cherry', rgb: 0x800B47, origin: './ntc' },
    { name: 'falu red', rgb: 0x801818, origin: './ntc' },
    { name: 'red robin', rgb: 0x80341F, origin: './ntc' },
    { name: 'vivid violet', rgb: 0x803790, origin: './ntc' },
    { name: 'russet', rgb: 0x80461B, origin: './ntc' },
    { name: 'friar gray', rgb: 0x807E79, origin: './ntc' },
    { name: 'olive', rgb: 0x808000, origin: './ntc' },
    { name: 'gray', rgb: 0x808080, origin: './ntc' },
    { name: 'gulf stream', rgb: 0x80B3AE, origin: './ntc' },
    { name: 'glacier', rgb: 0x80B3C4, origin: './ntc' },
    { name: 'seagull', rgb: 0x80CCEA, origin: './ntc' },
    { name: 'nutmeg', rgb: 0x81422C, origin: './ntc' },
    { name: 'spicy pink', rgb: 0x816E71, origin: './ntc' },
    { name: 'empress', rgb: 0x817377, origin: './ntc' },
    { name: 'spanish green', rgb: 0x819885, origin: './ntc' },
    { name: 'sand dune', rgb: 0x826F65, origin: './ntc' },
    { name: 'gunsmoke', rgb: 0x828685, origin: './ntc' },
    { name: 'battleship gray', rgb: 0x828F72, origin: './ntc' },
    { name: 'merlot', rgb: 0x831923, origin: './ntc' },
    { name: 'shadow', rgb: 0x837050, origin: './ntc' },
    { name: 'chelsea cucumber', rgb: 0x83AA5D, origin: './ntc' },
    { name: 'monte carlo', rgb: 0x83D0C6, origin: './ntc' },
    { name: 'plum', rgb: 0x843179, origin: './ntc' },
    { name: 'granny smith', rgb: 0x84A0A0, origin: './ntc' },
    { name: 'chetwode blue', rgb: 0x8581D9, origin: './ntc' },
    { name: 'bandicoot', rgb: 0x858470, origin: './ntc' },
    { name: 'bali hai', rgb: 0x859FAF, origin: './ntc' },
    { name: 'half baked', rgb: 0x85C4CC, origin: './ntc' },
    { name: 'red devil', rgb: 0x860111, origin: './ntc' },
    { name: 'lotus', rgb: 0x863C3C, origin: './ntc' },
    { name: 'ironstone', rgb: 0x86483C, origin: './ntc' },
    { name: 'bull shot', rgb: 0x864D1E, origin: './ntc' },
    { name: 'rusty nail', rgb: 0x86560A, origin: './ntc' },
    { name: 'bitter', rgb: 0x868974, origin: './ntc' },
    { name: 'regent gray', rgb: 0x86949F, origin: './ntc' },
    { name: 'disco', rgb: 0x871550, origin: './ntc' },
    { name: 'americano', rgb: 0x87756E, origin: './ntc' },
    { name: 'hurricane', rgb: 0x877C7B, origin: './ntc' },
    { name: 'oslo gray', rgb: 0x878D91, origin: './ntc' },
    { name: 'sushi', rgb: 0x87AB39, origin: './ntc' },
    { name: 'spicy mix', rgb: 0x885342, origin: './ntc' },
    { name: 'kumera', rgb: 0x886221, origin: './ntc' },
    { name: 'suva gray', rgb: 0x888387, origin: './ntc' },
    { name: 'avocado', rgb: 0x888D65, origin: './ntc' },
    { name: 'camelot', rgb: 0x893456, origin: './ntc' },
    { name: 'solid pink', rgb: 0x893843, origin: './ntc' },
    { name: 'cannon pink', rgb: 0x894367, origin: './ntc' },
    { name: 'makara', rgb: 0x897D6D, origin: './ntc' },
    { name: 'burnt umber', rgb: 0x8A3324, origin: './ntc' },
    { name: 'true v', rgb: 0x8A73D6, origin: './ntc' },
    { name: 'clay creek', rgb: 0x8A8360, origin: './ntc' },
    { name: 'monsoon', rgb: 0x8A8389, origin: './ntc' },
    { name: 'stack', rgb: 0x8A8F8A, origin: './ntc' },
    { name: 'jordy blue', rgb: 0x8AB9F1, origin: './ntc' },
    { name: 'electric violet', rgb: 0x8B00FF, origin: './ntc' },
    { name: 'monarch', rgb: 0x8B0723, origin: './ntc' },
    { name: 'corn harvest', rgb: 0x8B6B0B, origin: './ntc' },
    { name: 'olive haze', rgb: 0x8B8470, origin: './ntc' },
    { name: 'schooner', rgb: 0x8B847E, origin: './ntc' },
    { name: 'natural gray', rgb: 0x8B8680, origin: './ntc' },
    { name: 'mantle', rgb: 0x8B9C90, origin: './ntc' },
    { name: 'portage', rgb: 0x8B9FEE, origin: './ntc' },
    { name: 'envy', rgb: 0x8BA690, origin: './ntc' },
    { name: 'cascade', rgb: 0x8BA9A5, origin: './ntc' },
    { name: 'riptide', rgb: 0x8BE6D8, origin: './ntc' },
    { name: 'cardinal pink', rgb: 0x8C055E, origin: './ntc' },
    { name: 'mule fawn', rgb: 0x8C472F, origin: './ntc' },
    { name: 'potters clay', rgb: 0x8C5738, origin: './ntc' },
    { name: 'trendy pink', rgb: 0x8C6495, origin: './ntc' },
    { name: 'paprika', rgb: 0x8D0226, origin: './ntc' },
    { name: 'sanguine brown', rgb: 0x8D3D38, origin: './ntc' },
    { name: 'tosca', rgb: 0x8D3F3F, origin: './ntc' },
    { name: 'cement', rgb: 0x8D7662, origin: './ntc' },
    { name: 'granite green', rgb: 0x8D8974, origin: './ntc' },
    { name: 'manatee', rgb: 0x8D90A1, origin: './ntc' },
    { name: 'polo blue', rgb: 0x8DA8CC, origin: './ntc' },
    { name: 'red berry', rgb: 0x8E0000, origin: './ntc' },
    { name: 'rope', rgb: 0x8E4D1E, origin: './ntc' },
    { name: 'opium', rgb: 0x8E6F70, origin: './ntc' },
    { name: 'domino', rgb: 0x8E775E, origin: './ntc' },
    { name: 'mamba', rgb: 0x8E8190, origin: './ntc' },
    { name: 'nepal', rgb: 0x8EABC1, origin: './ntc' },
    { name: 'pohutukawa', rgb: 0x8F021C, origin: './ntc' },
    { name: 'el salva', rgb: 0x8F3E33, origin: './ntc' },
    { name: 'korma', rgb: 0x8F4B0E, origin: './ntc' },
    { name: 'squirrel', rgb: 0x8F8176, origin: './ntc' },
    { name: 'vista blue', rgb: 0x8FD6B4, origin: './ntc' },
    { name: 'burgundy', rgb: 0x900020, origin: './ntc' },
    { name: 'old brick', rgb: 0x901E1E, origin: './ntc' },
    { name: 'hemp', rgb: 0x907874, origin: './ntc' },
    { name: 'almond frost', rgb: 0x907B71, origin: './ntc' },
    { name: 'sycamore', rgb: 0x908D39, origin: './ntc' },
    { name: 'sangria', rgb: 0x92000A, origin: './ntc' },
    { name: 'cumin', rgb: 0x924321, origin: './ntc' },
    { name: 'beaver', rgb: 0x926F5B, origin: './ntc' },
    { name: 'stonewall', rgb: 0x928573, origin: './ntc' },
    { name: 'venus', rgb: 0x928590, origin: './ntc' },
    { name: 'medium purple', rgb: 0x9370DB, origin: './ntc' },
    { name: 'cornflower', rgb: 0x93CCEA, origin: './ntc' },
    { name: 'algae green', rgb: 0x93DFB8, origin: './ntc' },
    { name: 'copper rust', rgb: 0x944747, origin: './ntc' },
    { name: 'arrowtown', rgb: 0x948771, origin: './ntc' },
    { name: 'scarlett', rgb: 0x950015, origin: './ntc' },
    { name: 'strikemaster', rgb: 0x956387, origin: './ntc' },
    { name: 'mountain mist', rgb: 0x959396, origin: './ntc' },
    { name: 'carmine', rgb: 0x960018, origin: './ntc' },
    { name: 'brown', rgb: 0x964B00, origin: './ntc' },
    { name: 'leather', rgb: 0x967059, origin: './ntc' },
    { name: "purple mountain's majesty", rgb: 0x9678B6, origin: './ntc' },
    { name: 'lavender purple', rgb: 0x967BB6, origin: './ntc' },
    { name: 'pewter', rgb: 0x96A8A1, origin: './ntc' },
    { name: 'summer green', rgb: 0x96BBAB, origin: './ntc' },
    { name: 'au chico', rgb: 0x97605D, origin: './ntc' },
    { name: 'wisteria', rgb: 0x9771B5, origin: './ntc' },
    { name: 'atlantis', rgb: 0x97CD2D, origin: './ntc' },
    { name: 'vin rouge', rgb: 0x983D61, origin: './ntc' },
    { name: 'lilac bush', rgb: 0x9874D3, origin: './ntc' },
    { name: 'bazaar', rgb: 0x98777B, origin: './ntc' },
    { name: 'hacienda', rgb: 0x98811B, origin: './ntc' },
    { name: 'pale oyster', rgb: 0x988D77, origin: './ntc' },
    { name: 'mint green', rgb: 0x98FF98, origin: './ntc' },
    { name: 'fresh eggplant', rgb: 0x990066, origin: './ntc' },
    { name: 'violet eggplant', rgb: 0x991199, origin: './ntc' },
    { name: 'tamarillo', rgb: 0x991613, origin: './ntc' },
    { name: 'totem pole', rgb: 0x991B07, origin: './ntc' },
    { name: 'copper rose', rgb: 0x996666, origin: './ntc' },
    { name: 'amethyst', rgb: 0x9966CC, origin: './ntc' },
    { name: 'mountbatten pink', rgb: 0x997A8D, origin: './ntc' },
    { name: 'blue bell', rgb: 0x9999CC, origin: './ntc' },
    { name: 'prairie sand', rgb: 0x9A3820, origin: './ntc' },
    { name: 'toast', rgb: 0x9A6E61, origin: './ntc' },
    { name: 'gurkha', rgb: 0x9A9577, origin: './ntc' },
    { name: 'olivine', rgb: 0x9AB973, origin: './ntc' },
    { name: 'shadow green', rgb: 0x9AC2B8, origin: './ntc' },
    { name: 'oregon', rgb: 0x9B4703, origin: './ntc' },
    { name: 'lemon grass', rgb: 0x9B9E8F, origin: './ntc' },
    { name: 'stiletto', rgb: 0x9C3336, origin: './ntc' },
    { name: 'hawaiian tan', rgb: 0x9D5616, origin: './ntc' },
    { name: 'gull gray', rgb: 0x9DACB7, origin: './ntc' },
    { name: 'pistachio', rgb: 0x9DC209, origin: './ntc' },
    { name: 'granny smith apple', rgb: 0x9DE093, origin: './ntc' },
    { name: 'anakiwa', rgb: 0x9DE5FF, origin: './ntc' },
    { name: 'chelsea gem', rgb: 0x9E5302, origin: './ntc' },
    { name: 'sepia skin', rgb: 0x9E5B40, origin: './ntc' },
    { name: 'sage', rgb: 0x9EA587, origin: './ntc' },
    { name: 'citron', rgb: 0x9EA91F, origin: './ntc' },
    { name: 'rock blue', rgb: 0x9EB1CD, origin: './ntc' },
    { name: 'morning glory', rgb: 0x9EDEE0, origin: './ntc' },
    { name: 'cognac', rgb: 0x9F381D, origin: './ntc' },
    { name: 'reef gold', rgb: 0x9F821C, origin: './ntc' },
    { name: 'star dust', rgb: 0x9F9F9C, origin: './ntc' },
    { name: 'santas gray', rgb: 0x9FA0B1, origin: './ntc' },
    { name: 'sinbad', rgb: 0x9FD7D3, origin: './ntc' },
    { name: 'feijoa', rgb: 0x9FDD8C, origin: './ntc' },
    { name: 'tabasco', rgb: 0xA02712, origin: './ntc' },
    { name: 'buttered rum', rgb: 0xA1750D, origin: './ntc' },
    { name: 'hit gray', rgb: 0xA1ADB5, origin: './ntc' },
    { name: 'citrus', rgb: 0xA1C50A, origin: './ntc' },
    { name: 'aqua island', rgb: 0xA1DAD7, origin: './ntc' },
    { name: 'water leaf', rgb: 0xA1E9DE, origin: './ntc' },
    { name: 'flirt', rgb: 0xA2006D, origin: './ntc' },
    { name: 'rouge', rgb: 0xA23B6C, origin: './ntc' },
    { name: 'cape palliser', rgb: 0xA26645, origin: './ntc' },
    { name: 'gray chateau', rgb: 0xA2AAB3, origin: './ntc' },
    { name: 'edward', rgb: 0xA2AEAB, origin: './ntc' },
    { name: 'pharlap', rgb: 0xA3807B, origin: './ntc' },
    { name: 'amethyst smoke', rgb: 0xA397B4, origin: './ntc' },
    { name: 'blizzard blue', rgb: 0xA3E3ED, origin: './ntc' },
    { name: 'delta', rgb: 0xA4A49D, origin: './ntc' },
    { name: 'wistful', rgb: 0xA4A6D3, origin: './ntc' },
    { name: 'green smoke', rgb: 0xA4AF6E, origin: './ntc' },
    { name: 'jazzberry jam', rgb: 0xA50B5E, origin: './ntc' },
    { name: 'zorba', rgb: 0xA59B91, origin: './ntc' },
    { name: 'bahia', rgb: 0xA5CB0C, origin: './ntc' },
    { name: 'roof terracotta', rgb: 0xA62F20, origin: './ntc' },
    { name: 'paarl', rgb: 0xA65529, origin: './ntc' },
    { name: 'barley corn', rgb: 0xA68B5B, origin: './ntc' },
    { name: 'donkey brown', rgb: 0xA69279, origin: './ntc' },
    { name: 'dawn', rgb: 0xA6A29A, origin: './ntc' },
    { name: 'mexican red', rgb: 0xA72525, origin: './ntc' },
    { name: 'luxor gold', rgb: 0xA7882C, origin: './ntc' },
    { name: 'rich gold', rgb: 0xA85307, origin: './ntc' },
    { name: 'reno sand', rgb: 0xA86515, origin: './ntc' },
    { name: 'coral tree', rgb: 0xA86B6B, origin: './ntc' },
    { name: 'dusty gray', rgb: 0xA8989B, origin: './ntc' },
    { name: 'dull lavender', rgb: 0xA899E6, origin: './ntc' },
    { name: 'tallow', rgb: 0xA8A589, origin: './ntc' },
    { name: 'bud', rgb: 0xA8AE9C, origin: './ntc' },
    { name: 'locust', rgb: 0xA8AF8E, origin: './ntc' },
    { name: 'norway', rgb: 0xA8BD9F, origin: './ntc' },
    { name: 'chinook', rgb: 0xA8E3BD, origin: './ntc' },
    { name: 'gray olive', rgb: 0xA9A491, origin: './ntc' },
    { name: 'aluminium', rgb: 0xA9ACB6, origin: './ntc' },
    { name: 'cadet blue', rgb: 0xA9B2C3, origin: './ntc' },
    { name: 'schist', rgb: 0xA9B497, origin: './ntc' },
    { name: 'tower gray', rgb: 0xA9BDBF, origin: './ntc' },
    { name: 'perano', rgb: 0xA9BEF2, origin: './ntc' },
    { name: 'opal', rgb: 0xA9C6C2, origin: './ntc' },
    { name: 'night shadz', rgb: 0xAA375A, origin: './ntc' },
    { name: 'fire', rgb: 0xAA4203, origin: './ntc' },
    { name: 'muesli', rgb: 0xAA8B5B, origin: './ntc' },
    { name: 'sandal', rgb: 0xAA8D6F, origin: './ntc' },
    { name: 'shady lady', rgb: 0xAAA5A9, origin: './ntc' },
    { name: 'logan', rgb: 0xAAA9CD, origin: './ntc' },
    { name: 'spun pearl', rgb: 0xAAABB7, origin: './ntc' },
    { name: 'regent st blue', rgb: 0xAAD6E6, origin: './ntc' },
    { name: 'magic mint', rgb: 0xAAF0D1, origin: './ntc' },
    { name: 'lipstick', rgb: 0xAB0563, origin: './ntc' },
    { name: 'royal heath', rgb: 0xAB3472, origin: './ntc' },
    { name: 'sandrift', rgb: 0xAB917A, origin: './ntc' },
    { name: 'cold purple', rgb: 0xABA0D9, origin: './ntc' },
    { name: 'bronco', rgb: 0xABA196, origin: './ntc' },
    { name: 'limed oak', rgb: 0xAC8A56, origin: './ntc' },
    { name: 'east side', rgb: 0xAC91CE, origin: './ntc' },
    { name: 'lemon ginger', rgb: 0xAC9E22, origin: './ntc' },
    { name: 'napa', rgb: 0xACA494, origin: './ntc' },
    { name: 'hillary', rgb: 0xACA586, origin: './ntc' },
    { name: 'cloudy', rgb: 0xACA59F, origin: './ntc' },
    { name: 'silver chalice', rgb: 0xACACAC, origin: './ntc' },
    { name: 'swamp green', rgb: 0xACB78E, origin: './ntc' },
    { name: 'spring rain', rgb: 0xACCBB1, origin: './ntc' },
    { name: 'conifer', rgb: 0xACDD4D, origin: './ntc' },
    { name: 'celadon', rgb: 0xACE1AF, origin: './ntc' },
    { name: 'mandalay', rgb: 0xAD781B, origin: './ntc' },
    { name: 'casper', rgb: 0xADBED1, origin: './ntc' },
    { name: 'moss green', rgb: 0xADDFAD, origin: './ntc' },
    { name: 'padua', rgb: 0xADE6C4, origin: './ntc' },
    { name: 'green yellow', rgb: 0xADFF2F, origin: './ntc' },
    { name: 'hippie pink', rgb: 0xAE4560, origin: './ntc' },
    { name: 'desert', rgb: 0xAE6020, origin: './ntc' },
    { name: 'bouquet', rgb: 0xAE809E, origin: './ntc' },
    { name: 'medium carmine', rgb: 0xAF4035, origin: './ntc' },
    { name: 'apple blossom', rgb: 0xAF4D43, origin: './ntc' },
    { name: 'brown rust', rgb: 0xAF593E, origin: './ntc' },
    { name: 'driftwood', rgb: 0xAF8751, origin: './ntc' },
    { name: 'alpine', rgb: 0xAF8F2C, origin: './ntc' },
    { name: 'lucky', rgb: 0xAF9F1C, origin: './ntc' },
    { name: 'martini', rgb: 0xAFA09E, origin: './ntc' },
    { name: 'bombay', rgb: 0xAFB1B8, origin: './ntc' },
    { name: 'pigeon post', rgb: 0xAFBDD9, origin: './ntc' },
    { name: 'cadillac', rgb: 0xB04C6A, origin: './ntc' },
    { name: 'matrix', rgb: 0xB05D54, origin: './ntc' },
    { name: 'tapestry', rgb: 0xB05E81, origin: './ntc' },
    { name: 'mai tai', rgb: 0xB06608, origin: './ntc' },
    { name: 'del rio', rgb: 0xB09A95, origin: './ntc' },
    { name: 'powder blue', rgb: 0xB0E0E6, origin: './ntc' },
    { name: 'inch worm', rgb: 0xB0E313, origin: './ntc' },
    { name: 'bright red', rgb: 0xB10000, origin: './ntc' },
    { name: 'vesuvius', rgb: 0xB14A0B, origin: './ntc' },
    { name: 'pumpkin skin', rgb: 0xB1610B, origin: './ntc' },
    { name: 'santa fe', rgb: 0xB16D52, origin: './ntc' },
    { name: 'teak', rgb: 0xB19461, origin: './ntc' },
    { name: 'fringy flower', rgb: 0xB1E2C1, origin: './ntc' },
    { name: 'ice cold', rgb: 0xB1F4E7, origin: './ntc' },
    { name: 'shiraz', rgb: 0xB20931, origin: './ntc' },
    { name: 'biloba flower', rgb: 0xB2A1EA, origin: './ntc' },
    { name: 'tall poppy', rgb: 0xB32D29, origin: './ntc' },
    { name: 'fiery orange', rgb: 0xB35213, origin: './ntc' },
    { name: 'hot toddy', rgb: 0xB38007, origin: './ntc' },
    { name: 'taupe gray', rgb: 0xB3AF95, origin: './ntc' },
    { name: 'la rioja', rgb: 0xB3C110, origin: './ntc' },
    { name: 'well read', rgb: 0xB43332, origin: './ntc' },
    { name: 'blush', rgb: 0xB44668, origin: './ntc' },
    { name: 'jungle mist', rgb: 0xB4CFD3, origin: './ntc' },
    { name: 'turkish rose', rgb: 0xB57281, origin: './ntc' },
    { name: 'lavender', rgb: 0xB57EDC, origin: './ntc' },
    { name: 'mongoose', rgb: 0xB5A27F, origin: './ntc' },
    { name: 'olive green', rgb: 0xB5B35C, origin: './ntc' },
    { name: 'jet stream', rgb: 0xB5D2CE, origin: './ntc' },
    { name: 'cruise', rgb: 0xB5ECDF, origin: './ntc' },
    { name: 'hibiscus', rgb: 0xB6316C, origin: './ntc' },
    { name: 'thatch', rgb: 0xB69D98, origin: './ntc' },
    { name: 'heathered gray', rgb: 0xB6B095, origin: './ntc' },
    { name: 'eagle', rgb: 0xB6BAA4, origin: './ntc' },
    { name: 'spindle', rgb: 0xB6D1EA, origin: './ntc' },
    { name: 'gum leaf', rgb: 0xB6D3BF, origin: './ntc' },
    { name: 'rust', rgb: 0xB7410E, origin: './ntc' },
    { name: 'muddy waters', rgb: 0xB78E5C, origin: './ntc' },
    { name: 'sahara', rgb: 0xB7A214, origin: './ntc' },
    { name: 'husk', rgb: 0xB7A458, origin: './ntc' },
    { name: 'nobel', rgb: 0xB7B1B1, origin: './ntc' },
    { name: 'heather', rgb: 0xB7C3D0, origin: './ntc' },
    { name: 'madang', rgb: 0xB7F0BE, origin: './ntc' },
    { name: 'milano red', rgb: 0xB81104, origin: './ntc' },
    { name: 'copper', rgb: 0xB87333, origin: './ntc' },
    { name: 'gimblet', rgb: 0xB8B56A, origin: './ntc' },
    { name: 'green spring', rgb: 0xB8C1B1, origin: './ntc' },
    { name: 'celery', rgb: 0xB8C25D, origin: './ntc' },
    { name: 'sail', rgb: 0xB8E0F9, origin: './ntc' },
    { name: 'chestnut', rgb: 0xB94E48, origin: './ntc' },
    { name: 'crail', rgb: 0xB95140, origin: './ntc' },
    { name: 'marigold', rgb: 0xB98D28, origin: './ntc' },
    { name: 'wild willow', rgb: 0xB9C46A, origin: './ntc' },
    { name: 'rainee', rgb: 0xB9C8AC, origin: './ntc' },
    { name: 'guardsman red', rgb: 0xBA0101, origin: './ntc' },
    { name: 'rock spray', rgb: 0xBA450C, origin: './ntc' },
    { name: 'bourbon', rgb: 0xBA6F1E, origin: './ntc' },
    { name: 'pirate gold', rgb: 0xBA7F03, origin: './ntc' },
    { name: 'nomad', rgb: 0xBAB1A2, origin: './ntc' },
    { name: 'submarine', rgb: 0xBAC7C9, origin: './ntc' },
    { name: 'charlotte', rgb: 0xBAEEF9, origin: './ntc' },
    { name: 'medium red violet', rgb: 0xBB3385, origin: './ntc' },
    { name: 'brandy rose', rgb: 0xBB8983, origin: './ntc' },
    { name: 'rio grande', rgb: 0xBBD009, origin: './ntc' },
    { name: 'surf', rgb: 0xBBD7C1, origin: './ntc' },
    { name: 'powder ash', rgb: 0xBCC9C2, origin: './ntc' },
    { name: 'tuscany', rgb: 0xBD5E2E, origin: './ntc' },
    { name: 'quicksand', rgb: 0xBD978E, origin: './ntc' },
    { name: 'silk', rgb: 0xBDB1A8, origin: './ntc' },
    { name: 'malta', rgb: 0xBDB2A1, origin: './ntc' },
    { name: 'chatelle', rgb: 0xBDB3C7, origin: './ntc' },
    { name: 'lavender gray', rgb: 0xBDBBD7, origin: './ntc' },
    { name: 'french gray', rgb: 0xBDBDC6, origin: './ntc' },
    { name: 'clay ash', rgb: 0xBDC8B3, origin: './ntc' },
    { name: 'loblolly', rgb: 0xBDC9CE, origin: './ntc' },
    { name: 'french pass', rgb: 0xBDEDFD, origin: './ntc' },
    { name: 'london hue', rgb: 0xBEA6C3, origin: './ntc' },
    { name: 'pink swan', rgb: 0xBEB5B7, origin: './ntc' },
    { name: 'fuego', rgb: 0xBEDE0D, origin: './ntc' },
    { name: 'rose of sharon', rgb: 0xBF5500, origin: './ntc' },
    { name: 'tide', rgb: 0xBFB8B0, origin: './ntc' },
    { name: 'blue haze', rgb: 0xBFBED8, origin: './ntc' },
    { name: 'silver sand', rgb: 0xBFC1C2, origin: './ntc' },
    { name: 'key lime pie', rgb: 0xBFC921, origin: './ntc' },
    { name: 'ziggurat', rgb: 0xBFDBE2, origin: './ntc' },
    { name: 'lime', rgb: 0xBFFF00, origin: './ntc' },
    { name: 'thunderbird', rgb: 0xC02B18, origin: './ntc' },
    { name: 'mojo', rgb: 0xC04737, origin: './ntc' },
    { name: 'old rose', rgb: 0xC08081, origin: './ntc' },
    { name: 'silver', rgb: 0xC0C0C0, origin: './ntc' },
    { name: 'pale leaf', rgb: 0xC0D3B9, origin: './ntc' },
    { name: 'pixie green', rgb: 0xC0D8B6, origin: './ntc' },
    { name: 'tia maria', rgb: 0xC1440E, origin: './ntc' },
    { name: 'fuchsia pink', rgb: 0xC154C1, origin: './ntc' },
    { name: 'buddha gold', rgb: 0xC1A004, origin: './ntc' },
    { name: 'bison hide', rgb: 0xC1B7A4, origin: './ntc' },
    { name: 'tea', rgb: 0xC1BAB0, origin: './ntc' },
    { name: 'gray suit', rgb: 0xC1BECD, origin: './ntc' },
    { name: 'sprout', rgb: 0xC1D7B0, origin: './ntc' },
    { name: 'sulu', rgb: 0xC1F07C, origin: './ntc' },
    { name: 'indochine', rgb: 0xC26B03, origin: './ntc' },
    { name: 'twine', rgb: 0xC2955D, origin: './ntc' },
    { name: 'cotton seed', rgb: 0xC2BDB6, origin: './ntc' },
    { name: 'pumice', rgb: 0xC2CAC4, origin: './ntc' },
    { name: 'jagged ice', rgb: 0xC2E8E5, origin: './ntc' },
    { name: 'maroon flush', rgb: 0xC32148, origin: './ntc' },
    { name: 'indian khaki', rgb: 0xC3B091, origin: './ntc' },
    { name: 'pale slate', rgb: 0xC3BFC1, origin: './ntc' },
    { name: 'gray nickel', rgb: 0xC3C3BD, origin: './ntc' },
    { name: 'periwinkle gray', rgb: 0xC3CDE6, origin: './ntc' },
    { name: 'tiara', rgb: 0xC3D1D1, origin: './ntc' },
    { name: 'tropical blue', rgb: 0xC3DDF9, origin: './ntc' },
    { name: 'cardinal', rgb: 0xC41E3A, origin: './ntc' },
    { name: 'fuzzy wuzzy brown', rgb: 0xC45655, origin: './ntc' },
    { name: 'orange roughy', rgb: 0xC45719, origin: './ntc' },
    { name: 'mist gray', rgb: 0xC4C4BC, origin: './ntc' },
    { name: 'coriander', rgb: 0xC4D0B0, origin: './ntc' },
    { name: 'mint tulip', rgb: 0xC4F4EB, origin: './ntc' },
    { name: 'mulberry', rgb: 0xC54B8C, origin: './ntc' },
    { name: 'nugget', rgb: 0xC59922, origin: './ntc' },
    { name: 'tussock', rgb: 0xC5994B, origin: './ntc' },
    { name: 'sea mist', rgb: 0xC5DBCA, origin: './ntc' },
    { name: 'yellow green', rgb: 0xC5E17A, origin: './ntc' },
    { name: 'brick red', rgb: 0xC62D42, origin: './ntc' },
    { name: 'contessa', rgb: 0xC6726B, origin: './ntc' },
    { name: 'oriental pink', rgb: 0xC69191, origin: './ntc' },
    { name: 'roti', rgb: 0xC6A84B, origin: './ntc' },
    { name: 'ash', rgb: 0xC6C3B5, origin: './ntc' },
    { name: 'kangaroo', rgb: 0xC6C8BD, origin: './ntc' },
    { name: 'las palmas', rgb: 0xC6E610, origin: './ntc' },
    { name: 'monza', rgb: 0xC7031E, origin: './ntc' },
    { name: 'red violet', rgb: 0xC71585, origin: './ntc' },
    { name: 'coral reef', rgb: 0xC7BCA2, origin: './ntc' },
    { name: 'melrose', rgb: 0xC7C1FF, origin: './ntc' },
    { name: 'cloud', rgb: 0xC7C4BF, origin: './ntc' },
    { name: 'ghost', rgb: 0xC7C9D5, origin: './ntc' },
    { name: 'pine glade', rgb: 0xC7CD90, origin: './ntc' },
    { name: 'botticelli', rgb: 0xC7DDE5, origin: './ntc' },
    { name: 'antique brass', rgb: 0xC88A65, origin: './ntc' },
    { name: 'lilac', rgb: 0xC8A2C8, origin: './ntc' },
    { name: 'hokey pokey', rgb: 0xC8A528, origin: './ntc' },
    { name: 'lily', rgb: 0xC8AABF, origin: './ntc' },
    { name: 'laser', rgb: 0xC8B568, origin: './ntc' },
    { name: 'edgewater', rgb: 0xC8E3D7, origin: './ntc' },
    { name: 'piper', rgb: 0xC96323, origin: './ntc' },
    { name: 'pizza', rgb: 0xC99415, origin: './ntc' },
    { name: 'light wisteria', rgb: 0xC9A0DC, origin: './ntc' },
    { name: 'rodeo dust', rgb: 0xC9B29B, origin: './ntc' },
    { name: 'sundance', rgb: 0xC9B35B, origin: './ntc' },
    { name: 'earls green', rgb: 0xC9B93B, origin: './ntc' },
    { name: 'silver rust', rgb: 0xC9C0BB, origin: './ntc' },
    { name: 'conch', rgb: 0xC9D9D2, origin: './ntc' },
    { name: 'reef', rgb: 0xC9FFA2, origin: './ntc' },
    { name: 'aero blue', rgb: 0xC9FFE5, origin: './ntc' },
    { name: 'flush mahogany', rgb: 0xCA3435, origin: './ntc' },
    { name: 'turmeric', rgb: 0xCABB48, origin: './ntc' },
    { name: 'paris white', rgb: 0xCADCD4, origin: './ntc' },
    { name: 'bitter lemon', rgb: 0xCAE00D, origin: './ntc' },
    { name: 'skeptic', rgb: 0xCAE6DA, origin: './ntc' },
    { name: 'viola', rgb: 0xCB8FA9, origin: './ntc' },
    { name: 'foggy gray', rgb: 0xCBCAB6, origin: './ntc' },
    { name: 'green mist', rgb: 0xCBD3B0, origin: './ntc' },
    { name: 'nebula', rgb: 0xCBDBD6, origin: './ntc' },
    { name: 'persian red', rgb: 0xCC3333, origin: './ntc' },
    { name: 'burnt orange', rgb: 0xCC5500, origin: './ntc' },
    { name: 'ochre', rgb: 0xCC7722, origin: './ntc' },
    { name: 'puce', rgb: 0xCC8899, origin: './ntc' },
    { name: 'thistle green', rgb: 0xCCCAA8, origin: './ntc' },
    { name: 'periwinkle', rgb: 0xCCCCFF, origin: './ntc' },
    { name: 'electric lime', rgb: 0xCCFF00, origin: './ntc' },
    { name: 'tenn', rgb: 0xCD5700, origin: './ntc' },
    { name: 'chestnut rose', rgb: 0xCD5C5C, origin: './ntc' },
    { name: 'brandy punch', rgb: 0xCD8429, origin: './ntc' },
    { name: 'onahau', rgb: 0xCDF4FF, origin: './ntc' },
    { name: 'sorrell brown', rgb: 0xCEB98F, origin: './ntc' },
    { name: 'cold turkey', rgb: 0xCEBABA, origin: './ntc' },
    { name: 'yuma', rgb: 0xCEC291, origin: './ntc' },
    { name: 'chino', rgb: 0xCEC7A7, origin: './ntc' },
    { name: 'eunry', rgb: 0xCFA39D, origin: './ntc' },
    { name: 'old gold', rgb: 0xCFB53B, origin: './ntc' },
    { name: 'tasman', rgb: 0xCFDCCF, origin: './ntc' },
    { name: 'surf crest', rgb: 0xCFE5D2, origin: './ntc' },
    { name: 'humming bird', rgb: 0xCFF9F3, origin: './ntc' },
    { name: 'scandal', rgb: 0xCFFAF4, origin: './ntc' },
    { name: 'red stage', rgb: 0xD05F04, origin: './ntc' },
    { name: 'hopbush', rgb: 0xD06DA1, origin: './ntc' },
    { name: 'meteor', rgb: 0xD07D12, origin: './ntc' },
    { name: 'perfume', rgb: 0xD0BEF8, origin: './ntc' },
    { name: 'prelude', rgb: 0xD0C0E5, origin: './ntc' },
    { name: 'tea green', rgb: 0xD0F0C0, origin: './ntc' },
    { name: 'geebung', rgb: 0xD18F1B, origin: './ntc' },
    { name: 'vanilla', rgb: 0xD1BEA8, origin: './ntc' },
    { name: 'soft amber', rgb: 0xD1C6B4, origin: './ntc' },
    { name: 'celeste', rgb: 0xD1D2CA, origin: './ntc' },
    { name: 'mischka', rgb: 0xD1D2DD, origin: './ntc' },
    { name: 'pear', rgb: 0xD1E231, origin: './ntc' },
    { name: 'hot cinnamon', rgb: 0xD2691E, origin: './ntc' },
    { name: 'raw sienna', rgb: 0xD27D46, origin: './ntc' },
    { name: 'careys pink', rgb: 0xD29EAA, origin: './ntc' },
    { name: 'tan', rgb: 0xD2B48C, origin: './ntc' },
    { name: 'deco', rgb: 0xD2DA97, origin: './ntc' },
    { name: 'blue romance', rgb: 0xD2F6DE, origin: './ntc' },
    { name: 'gossip', rgb: 0xD2F8B0, origin: './ntc' },
    { name: 'sisal', rgb: 0xD3CBBA, origin: './ntc' },
    { name: 'swirl', rgb: 0xD3CDC5, origin: './ntc' },
    { name: 'charm', rgb: 0xD47494, origin: './ntc' },
    { name: 'clam shell', rgb: 0xD4B6AF, origin: './ntc' },
    { name: 'straw', rgb: 0xD4BF8D, origin: './ntc' },
    { name: 'akaroa', rgb: 0xD4C4A8, origin: './ntc' },
    { name: 'bird flower', rgb: 0xD4CD16, origin: './ntc' },
    { name: 'iron', rgb: 0xD4D7D9, origin: './ntc' },
    { name: 'geyser', rgb: 0xD4DFE2, origin: './ntc' },
    { name: 'hawkes blue', rgb: 0xD4E2FC, origin: './ntc' },
    { name: 'grenadier', rgb: 0xD54600, origin: './ntc' },
    { name: 'can can', rgb: 0xD591A4, origin: './ntc' },
    { name: 'whiskey', rgb: 0xD59A6F, origin: './ntc' },
    { name: 'winter hazel', rgb: 0xD5D195, origin: './ntc' },
    { name: 'granny apple', rgb: 0xD5F6E3, origin: './ntc' },
    { name: 'my pink', rgb: 0xD69188, origin: './ntc' },
    { name: 'tacha', rgb: 0xD6C562, origin: './ntc' },
    { name: 'moon raker', rgb: 0xD6CEF6, origin: './ntc' },
    { name: 'quill gray', rgb: 0xD6D6D1, origin: './ntc' },
    { name: 'snowy mint', rgb: 0xD6FFDB, origin: './ntc' },
    { name: 'new york pink', rgb: 0xD7837F, origin: './ntc' },
    { name: 'pavlova', rgb: 0xD7C498, origin: './ntc' },
    { name: 'fog', rgb: 0xD7D0FF, origin: './ntc' },
    { name: 'valencia', rgb: 0xD84437, origin: './ntc' },
    { name: 'japonica', rgb: 0xD87C63, origin: './ntc' },
    { name: 'thistle', rgb: 0xD8BFD8, origin: './ntc' },
    { name: 'maverick', rgb: 0xD8C2D5, origin: './ntc' },
    { name: 'foam', rgb: 0xD8FCFA, origin: './ntc' },
    { name: 'cabaret', rgb: 0xD94972, origin: './ntc' },
    { name: 'burning sand', rgb: 0xD99376, origin: './ntc' },
    { name: 'cameo', rgb: 0xD9B99B, origin: './ntc' },
    { name: 'timberwolf', rgb: 0xD9D6CF, origin: './ntc' },
    { name: 'tana', rgb: 0xD9DCC1, origin: './ntc' },
    { name: 'link water', rgb: 0xD9E4F5, origin: './ntc' },
    { name: 'mabel', rgb: 0xD9F7FF, origin: './ntc' },
    { name: 'cerise', rgb: 0xDA3287, origin: './ntc' },
    { name: 'flame pea', rgb: 0xDA5B38, origin: './ntc' },
    { name: 'bamboo', rgb: 0xDA6304, origin: './ntc' },
    { name: 'red damask', rgb: 0xDA6A41, origin: './ntc' },
    { name: 'orchid', rgb: 0xDA70D6, origin: './ntc' },
    { name: 'copperfield', rgb: 0xDA8A67, origin: './ntc' },
    { name: 'golden grass', rgb: 0xDAA520, origin: './ntc' },
    { name: 'zanah', rgb: 0xDAECD6, origin: './ntc' },
    { name: 'iceberg', rgb: 0xDAF4F0, origin: './ntc' },
    { name: 'oyster bay', rgb: 0xDAFAFF, origin: './ntc' },
    { name: 'cranberry', rgb: 0xDB5079, origin: './ntc' },
    { name: 'petite orchid', rgb: 0xDB9690, origin: './ntc' },
    { name: 'di serria', rgb: 0xDB995E, origin: './ntc' },
    { name: 'alto', rgb: 0xDBDBDB, origin: './ntc' },
    { name: 'frosted mint', rgb: 0xDBFFF8, origin: './ntc' },
    { name: 'crimson', rgb: 0xDC143C, origin: './ntc' },
    { name: 'punch', rgb: 0xDC4333, origin: './ntc' },
    { name: 'galliano', rgb: 0xDCB20C, origin: './ntc' },
    { name: 'blossom', rgb: 0xDCB4BC, origin: './ntc' },
    { name: 'wattle', rgb: 0xDCD747, origin: './ntc' },
    { name: 'westar', rgb: 0xDCD9D2, origin: './ntc' },
    { name: 'moon mist', rgb: 0xDCDDCC, origin: './ntc' },
    { name: 'caper', rgb: 0xDCEDB4, origin: './ntc' },
    { name: 'swans down', rgb: 0xDCF0EA, origin: './ntc' },
    { name: 'swiss coffee', rgb: 0xDDD6D5, origin: './ntc' },
    { name: 'white ice', rgb: 0xDDF9F1, origin: './ntc' },
    { name: 'cerise red', rgb: 0xDE3163, origin: './ntc' },
    { name: 'roman', rgb: 0xDE6360, origin: './ntc' },
    { name: 'tumbleweed', rgb: 0xDEA681, origin: './ntc' },
    { name: 'gold tips', rgb: 0xDEBA13, origin: './ntc' },
    { name: 'brandy', rgb: 0xDEC196, origin: './ntc' },
    { name: 'wafer', rgb: 0xDECBC6, origin: './ntc' },
    { name: 'sapling', rgb: 0xDED4A4, origin: './ntc' },
    { name: 'barberry', rgb: 0xDED717, origin: './ntc' },
    { name: 'beryl green', rgb: 0xDEE5C0, origin: './ntc' },
    { name: 'pattens blue', rgb: 0xDEF5FF, origin: './ntc' },
    { name: 'heliotrope', rgb: 0xDF73FF, origin: './ntc' },
    { name: 'apache', rgb: 0xDFBE6F, origin: './ntc' },
    { name: 'chenin', rgb: 0xDFCD6F, origin: './ntc' },
    { name: 'lola', rgb: 0xDFCFDB, origin: './ntc' },
    { name: 'willow brook', rgb: 0xDFECDA, origin: './ntc' },
    { name: 'chartreuse yellow', rgb: 0xDFFF00, origin: './ntc' },
    { name: 'mauve', rgb: 0xE0B0FF, origin: './ntc' },
    { name: 'anzac', rgb: 0xE0B646, origin: './ntc' },
    { name: 'harvest gold', rgb: 0xE0B974, origin: './ntc' },
    { name: 'calico', rgb: 0xE0C095, origin: './ntc' },
    { name: 'baby blue', rgb: 0xE0FFFF, origin: './ntc' },
    { name: 'sunglo', rgb: 0xE16865, origin: './ntc' },
    { name: 'equator', rgb: 0xE1BC64, origin: './ntc' },
    { name: 'pink flare', rgb: 0xE1C0C8, origin: './ntc' },
    { name: 'periglacial blue', rgb: 0xE1E6D6, origin: './ntc' },
    { name: 'kidnapper', rgb: 0xE1EAD4, origin: './ntc' },
    { name: 'tara', rgb: 0xE1F6E8, origin: './ntc' },
    { name: 'mandy', rgb: 0xE25465, origin: './ntc' },
    { name: 'terracotta', rgb: 0xE2725B, origin: './ntc' },
    { name: 'golden bell', rgb: 0xE28913, origin: './ntc' },
    { name: 'shocking', rgb: 0xE292C0, origin: './ntc' },
    { name: 'dixie', rgb: 0xE29418, origin: './ntc' },
    { name: 'light orchid', rgb: 0xE29CD2, origin: './ntc' },
    { name: 'snuff', rgb: 0xE2D8ED, origin: './ntc' },
    { name: 'mystic', rgb: 0xE2EBED, origin: './ntc' },
    { name: 'apple green', rgb: 0xE2F3EC, origin: './ntc' },
    { name: 'razzmatazz', rgb: 0xE30B5C, origin: './ntc' },
    { name: 'alizarin crimson', rgb: 0xE32636, origin: './ntc' },
    { name: 'cinnabar', rgb: 0xE34234, origin: './ntc' },
    { name: 'cavern pink', rgb: 0xE3BEBE, origin: './ntc' },
    { name: 'peppermint', rgb: 0xE3F5E1, origin: './ntc' },
    { name: 'mindaro', rgb: 0xE3F988, origin: './ntc' },
    { name: 'deep blush', rgb: 0xE47698, origin: './ntc' },
    { name: 'gamboge', rgb: 0xE49B0F, origin: './ntc' },
    { name: 'melanie', rgb: 0xE4C2D5, origin: './ntc' },
    { name: 'twilight', rgb: 0xE4CFDE, origin: './ntc' },
    { name: 'bone', rgb: 0xE4D1C0, origin: './ntc' },
    { name: 'sunflower', rgb: 0xE4D422, origin: './ntc' },
    { name: 'grain brown', rgb: 0xE4D5B7, origin: './ntc' },
    { name: 'zombie', rgb: 0xE4D69B, origin: './ntc' },
    { name: 'frostee', rgb: 0xE4F6E7, origin: './ntc' },
    { name: 'snow flurry', rgb: 0xE4FFD1, origin: './ntc' },
    { name: 'amaranth', rgb: 0xE52B50, origin: './ntc' },
    { name: 'zest', rgb: 0xE5841B, origin: './ntc' },
    { name: 'dust storm', rgb: 0xE5CCC9, origin: './ntc' },
    { name: 'stark white', rgb: 0xE5D7BD, origin: './ntc' },
    { name: 'hampton', rgb: 0xE5D8AF, origin: './ntc' },
    { name: 'bon jour', rgb: 0xE5E0E1, origin: './ntc' },
    { name: 'mercury', rgb: 0xE5E5E5, origin: './ntc' },
    { name: 'polar', rgb: 0xE5F9F6, origin: './ntc' },
    { name: 'trinidad', rgb: 0xE64E03, origin: './ntc' },
    { name: 'gold sand', rgb: 0xE6BE8A, origin: './ntc' },
    { name: 'cashmere', rgb: 0xE6BEA5, origin: './ntc' },
    { name: 'double spanish white', rgb: 0xE6D7B9, origin: './ntc' },
    { name: 'satin linen', rgb: 0xE6E4D4, origin: './ntc' },
    { name: 'harp', rgb: 0xE6F2EA, origin: './ntc' },
    { name: 'off green', rgb: 0xE6F8F3, origin: './ntc' },
    { name: 'hint of green', rgb: 0xE6FFE9, origin: './ntc' },
    { name: 'tranquil', rgb: 0xE6FFFF, origin: './ntc' },
    { name: 'mango tango', rgb: 0xE77200, origin: './ntc' },
    { name: 'christine', rgb: 0xE7730A, origin: './ntc' },
    { name: 'tonys pink', rgb: 0xE79F8C, origin: './ntc' },
    { name: 'kobi', rgb: 0xE79FC4, origin: './ntc' },
    { name: 'rose fog', rgb: 0xE7BCB4, origin: './ntc' },
    { name: 'corn', rgb: 0xE7BF05, origin: './ntc' },
    { name: 'putty', rgb: 0xE7CD8C, origin: './ntc' },
    { name: 'gray nurse', rgb: 0xE7ECE6, origin: './ntc' },
    { name: 'lily white', rgb: 0xE7F8FF, origin: './ntc' },
    { name: 'bubbles', rgb: 0xE7FEFF, origin: './ntc' },
    { name: 'fire bush', rgb: 0xE89928, origin: './ntc' },
    { name: 'shilo', rgb: 0xE8B9B3, origin: './ntc' },
    { name: 'pearl bush', rgb: 0xE8E0D5, origin: './ntc' },
    { name: 'green white', rgb: 0xE8EBE0, origin: './ntc' },
    { name: 'chrome white', rgb: 0xE8F1D4, origin: './ntc' },
    { name: 'gin', rgb: 0xE8F2EB, origin: './ntc' },
    { name: 'aqua squeeze', rgb: 0xE8F5F2, origin: './ntc' },
    { name: 'clementine', rgb: 0xE96E00, origin: './ntc' },
    { name: 'burnt sienna', rgb: 0xE97451, origin: './ntc' },
    { name: 'tahiti gold', rgb: 0xE97C07, origin: './ntc' },
    { name: 'oyster pink', rgb: 0xE9CECD, origin: './ntc' },
    { name: 'confetti', rgb: 0xE9D75A, origin: './ntc' },
    { name: 'ebb', rgb: 0xE9E3E3, origin: './ntc' },
    { name: 'ottoman', rgb: 0xE9F8ED, origin: './ntc' },
    { name: 'clear day', rgb: 0xE9FFFD, origin: './ntc' },
    { name: 'carissma', rgb: 0xEA88A8, origin: './ntc' },
    { name: 'porsche', rgb: 0xEAAE69, origin: './ntc' },
    { name: 'tulip tree', rgb: 0xEAB33B, origin: './ntc' },
    { name: 'rob roy', rgb: 0xEAC674, origin: './ntc' },
    { name: 'raffia', rgb: 0xEADAB8, origin: './ntc' },
    { name: 'white rock', rgb: 0xEAE8D4, origin: './ntc' },
    { name: 'panache', rgb: 0xEAF6EE, origin: './ntc' },
    { name: 'solitude', rgb: 0xEAF6FF, origin: './ntc' },
    { name: 'aqua spring', rgb: 0xEAF9F5, origin: './ntc' },
    { name: 'dew', rgb: 0xEAFFFE, origin: './ntc' },
    { name: 'apricot', rgb: 0xEB9373, origin: './ntc' },
    { name: 'zinnwaldite', rgb: 0xEBC2AF, origin: './ntc' },
    { name: 'fuel yellow', rgb: 0xECA927, origin: './ntc' },
    { name: 'ronchi', rgb: 0xECC54E, origin: './ntc' },
    { name: 'french lilac', rgb: 0xECC7EE, origin: './ntc' },
    { name: 'just right', rgb: 0xECCDB9, origin: './ntc' },
    { name: 'wild rice', rgb: 0xECE090, origin: './ntc' },
    { name: 'fall green', rgb: 0xECEBBD, origin: './ntc' },
    { name: 'aths special', rgb: 0xECEBCE, origin: './ntc' },
    { name: 'starship', rgb: 0xECF245, origin: './ntc' },
    { name: 'red ribbon', rgb: 0xED0A3F, origin: './ntc' },
    { name: 'tango', rgb: 0xED7A1C, origin: './ntc' },
    { name: 'carrot orange', rgb: 0xED9121, origin: './ntc' },
    { name: 'sea pink', rgb: 0xED989E, origin: './ntc' },
    { name: 'tacao', rgb: 0xEDB381, origin: './ntc' },
    { name: 'desert sand', rgb: 0xEDC9AF, origin: './ntc' },
    { name: 'pancho', rgb: 0xEDCDAB, origin: './ntc' },
    { name: 'chamois', rgb: 0xEDDCB1, origin: './ntc' },
    { name: 'primrose', rgb: 0xEDEA99, origin: './ntc' },
    { name: 'frost', rgb: 0xEDF5DD, origin: './ntc' },
    { name: 'aqua haze', rgb: 0xEDF5F5, origin: './ntc' },
    { name: 'zumthor', rgb: 0xEDF6FF, origin: './ntc' },
    { name: 'narvik', rgb: 0xEDF9F1, origin: './ntc' },
    { name: 'honeysuckle', rgb: 0xEDFC84, origin: './ntc' },
    { name: 'lavender magenta', rgb: 0xEE82EE, origin: './ntc' },
    { name: 'beauty bush', rgb: 0xEEC1BE, origin: './ntc' },
    { name: 'chalky', rgb: 0xEED794, origin: './ntc' },
    { name: 'almond', rgb: 0xEED9C4, origin: './ntc' },
    { name: 'flax', rgb: 0xEEDC82, origin: './ntc' },
    { name: 'bizarre', rgb: 0xEEDEDA, origin: './ntc' },
    { name: 'double colonial white', rgb: 0xEEE3AD, origin: './ntc' },
    { name: 'cararra', rgb: 0xEEEEE8, origin: './ntc' },
    { name: 'manz', rgb: 0xEEEF78, origin: './ntc' },
    { name: 'tahuna sands', rgb: 0xEEF0C8, origin: './ntc' },
    { name: 'athens gray', rgb: 0xEEF0F3, origin: './ntc' },
    { name: 'tusk', rgb: 0xEEF3C3, origin: './ntc' },
    { name: 'loafer', rgb: 0xEEF4DE, origin: './ntc' },
    { name: 'catskill white', rgb: 0xEEF6F7, origin: './ntc' },
    { name: 'twilight blue', rgb: 0xEEFDFF, origin: './ntc' },
    { name: 'jonquil', rgb: 0xEEFF9A, origin: './ntc' },
    { name: 'rice flower', rgb: 0xEEFFE2, origin: './ntc' },
    { name: 'jaffa', rgb: 0xEF863F, origin: './ntc' },
    { name: 'gallery', rgb: 0xEFEFEF, origin: './ntc' },
    { name: 'porcelain', rgb: 0xEFF2F3, origin: './ntc' },
    { name: 'mauvelous', rgb: 0xF091A9, origin: './ntc' },
    { name: 'golden dream', rgb: 0xF0D52D, origin: './ntc' },
    { name: 'golden sand', rgb: 0xF0DB7D, origin: './ntc' },
    { name: 'buff', rgb: 0xF0DC82, origin: './ntc' },
    { name: 'prim', rgb: 0xF0E2EC, origin: './ntc' },
    { name: 'khaki', rgb: 0xF0E68C, origin: './ntc' },
    { name: 'selago', rgb: 0xF0EEFD, origin: './ntc' },
    { name: 'titan white', rgb: 0xF0EEFF, origin: './ntc' },
    { name: 'alice blue', rgb: 0xF0F8FF, origin: './ntc' },
    { name: 'feta', rgb: 0xF0FCEA, origin: './ntc' },
    { name: 'gold drop', rgb: 0xF18200, origin: './ntc' },
    { name: 'wewak', rgb: 0xF19BAB, origin: './ntc' },
    { name: 'sahara sand', rgb: 0xF1E788, origin: './ntc' },
    { name: 'parchment', rgb: 0xF1E9D2, origin: './ntc' },
    { name: 'blue chalk', rgb: 0xF1E9FF, origin: './ntc' },
    { name: 'mint julep', rgb: 0xF1EEC1, origin: './ntc' },
    { name: 'seashell', rgb: 0xF1F1F1, origin: './ntc' },
    { name: 'saltpan', rgb: 0xF1F7F2, origin: './ntc' },
    { name: 'tidal', rgb: 0xF1FFAD, origin: './ntc' },
    { name: 'chiffon', rgb: 0xF1FFC8, origin: './ntc' },
    { name: 'flamingo', rgb: 0xF2552A, origin: './ntc' },
    { name: 'tangerine', rgb: 0xF28500, origin: './ntc' },
    { name: 'mandys pink', rgb: 0xF2C3B2, origin: './ntc' },
    { name: 'concrete', rgb: 0xF2F2F2, origin: './ntc' },
    { name: 'black squeeze', rgb: 0xF2FAFA, origin: './ntc' },
    { name: 'pomegranate', rgb: 0xF34723, origin: './ntc' },
    { name: 'buttercup', rgb: 0xF3AD16, origin: './ntc' },
    { name: 'new orleans', rgb: 0xF3D69D, origin: './ntc' },
    { name: 'vanilla ice', rgb: 0xF3D9DF, origin: './ntc' },
    { name: 'sidecar', rgb: 0xF3E7BB, origin: './ntc' },
    { name: 'dawn pink', rgb: 0xF3E9E5, origin: './ntc' },
    { name: 'wheatfield', rgb: 0xF3EDCF, origin: './ntc' },
    { name: 'canary', rgb: 0xF3FB62, origin: './ntc' },
    { name: 'orinoco', rgb: 0xF3FBD4, origin: './ntc' },
    { name: 'carla', rgb: 0xF3FFD8, origin: './ntc' },
    { name: 'hollywood cerise', rgb: 0xF400A1, origin: './ntc' },
    { name: 'sandy brown', rgb: 0xF4A460, origin: './ntc' },
    { name: 'saffron', rgb: 0xF4C430, origin: './ntc' },
    { name: 'ripe lemon', rgb: 0xF4D81C, origin: './ntc' },
    { name: 'janna', rgb: 0xF4EBD3, origin: './ntc' },
    { name: 'pampas', rgb: 0xF4F2EE, origin: './ntc' },
    { name: 'wild sand', rgb: 0xF4F4F4, origin: './ntc' },
    { name: 'zircon', rgb: 0xF4F8FF, origin: './ntc' },
    { name: 'froly', rgb: 0xF57584, origin: './ntc' },
    { name: 'cream can', rgb: 0xF5C85C, origin: './ntc' },
    { name: 'manhattan', rgb: 0xF5C999, origin: './ntc' },
    { name: 'maize', rgb: 0xF5D5A0, origin: './ntc' },
    { name: 'wheat', rgb: 0xF5DEB3, origin: './ntc' },
    { name: 'sandwisp', rgb: 0xF5E7A2, origin: './ntc' },
    { name: 'pot pourri', rgb: 0xF5E7E2, origin: './ntc' },
    { name: 'albescent white', rgb: 0xF5E9D3, origin: './ntc' },
    { name: 'soft peach', rgb: 0xF5EDEF, origin: './ntc' },
    { name: 'ecru white', rgb: 0xF5F3E5, origin: './ntc' },
    { name: 'beige', rgb: 0xF5F5DC, origin: './ntc' },
    { name: 'golden fizz', rgb: 0xF5FB3D, origin: './ntc' },
    { name: 'australian mint', rgb: 0xF5FFBE, origin: './ntc' },
    { name: 'french rose', rgb: 0xF64A8A, origin: './ntc' },
    { name: 'brilliant rose', rgb: 0xF653A6, origin: './ntc' },
    { name: 'illusion', rgb: 0xF6A4C9, origin: './ntc' },
    { name: 'merino', rgb: 0xF6F0E6, origin: './ntc' },
    { name: 'black haze', rgb: 0xF6F7F7, origin: './ntc' },
    { name: 'spring sun', rgb: 0xF6FFDC, origin: './ntc' },
    { name: 'violet red', rgb: 0xF7468A, origin: './ntc' },
    { name: 'chilean fire', rgb: 0xF77703, origin: './ntc' },
    { name: 'persian pink', rgb: 0xF77FBE, origin: './ntc' },
    { name: 'rajah', rgb: 0xF7B668, origin: './ntc' },
    { name: 'azalea', rgb: 0xF7C8DA, origin: './ntc' },
    { name: 'we peep', rgb: 0xF7DBE6, origin: './ntc' },
    { name: 'quarter spanish white', rgb: 0xF7F2E1, origin: './ntc' },
    { name: 'whisper', rgb: 0xF7F5FA, origin: './ntc' },
    { name: 'snow drift', rgb: 0xF7FAF7, origin: './ntc' },
    { name: 'casablanca', rgb: 0xF8B853, origin: './ntc' },
    { name: 'chantilly', rgb: 0xF8C3DF, origin: './ntc' },
    { name: 'cherub', rgb: 0xF8D9E9, origin: './ntc' },
    { name: 'marzipan', rgb: 0xF8DB9D, origin: './ntc' },
    { name: 'energy yellow', rgb: 0xF8DD5C, origin: './ntc' },
    { name: 'givry', rgb: 0xF8E4BF, origin: './ntc' },
    { name: 'white linen', rgb: 0xF8F0E8, origin: './ntc' },
    { name: 'magnolia', rgb: 0xF8F4FF, origin: './ntc' },
    { name: 'spring wood', rgb: 0xF8F6F1, origin: './ntc' },
    { name: 'coconut cream', rgb: 0xF8F7DC, origin: './ntc' },
    { name: 'white lilac', rgb: 0xF8F7FC, origin: './ntc' },
    { name: 'desert storm', rgb: 0xF8F8F7, origin: './ntc' },
    { name: 'texas', rgb: 0xF8F99C, origin: './ntc' },
    { name: 'corn field', rgb: 0xF8FACD, origin: './ntc' },
    { name: 'mimosa', rgb: 0xF8FDD3, origin: './ntc' },
    { name: 'carnation', rgb: 0xF95A61, origin: './ntc' },
    { name: 'saffron mango', rgb: 0xF9BF58, origin: './ntc' },
    { name: 'carousel pink', rgb: 0xF9E0ED, origin: './ntc' },
    { name: 'dairy cream', rgb: 0xF9E4BC, origin: './ntc' },
    { name: 'portica', rgb: 0xF9E663, origin: './ntc' },
    { name: 'amour', rgb: 0xF9EAF3, origin: './ntc' },
    { name: 'rum swizzle', rgb: 0xF9F8E4, origin: './ntc' },
    { name: 'dolly', rgb: 0xF9FF8B, origin: './ntc' },
    { name: 'sugar cane', rgb: 0xF9FFF6, origin: './ntc' },
    { name: 'ecstasy', rgb: 0xFA7814, origin: './ntc' },
    { name: 'tan hide', rgb: 0xFA9D5A, origin: './ntc' },
    { name: 'corvette', rgb: 0xFAD3A2, origin: './ntc' },
    { name: 'peach yellow', rgb: 0xFADFAD, origin: './ntc' },
    { name: 'turbo', rgb: 0xFAE600, origin: './ntc' },
    { name: 'astra', rgb: 0xFAEAB9, origin: './ntc' },
    { name: 'champagne', rgb: 0xFAECCC, origin: './ntc' },
    { name: 'linen', rgb: 0xFAF0E6, origin: './ntc' },
    { name: 'fantasy', rgb: 0xFAF3F0, origin: './ntc' },
    { name: 'citrine white', rgb: 0xFAF7D6, origin: './ntc' },
    { name: 'alabaster', rgb: 0xFAFAFA, origin: './ntc' },
    { name: 'hint of yellow', rgb: 0xFAFDE4, origin: './ntc' },
    { name: 'milan', rgb: 0xFAFFA4, origin: './ntc' },
    { name: 'brink pink', rgb: 0xFB607F, origin: './ntc' },
    { name: 'geraldine', rgb: 0xFB8989, origin: './ntc' },
    { name: 'lavender rose', rgb: 0xFBA0E3, origin: './ntc' },
    { name: 'sea buckthorn', rgb: 0xFBA129, origin: './ntc' },
    { name: 'sun', rgb: 0xFBAC13, origin: './ntc' },
    { name: 'lavender pink', rgb: 0xFBAED2, origin: './ntc' },
    { name: 'rose bud', rgb: 0xFBB2A3, origin: './ntc' },
    { name: 'cupid', rgb: 0xFBBEDA, origin: './ntc' },
    { name: 'classic rose', rgb: 0xFBCCE7, origin: './ntc' },
    { name: 'apricot peach', rgb: 0xFBCEB1, origin: './ntc' },
    { name: 'banana mania', rgb: 0xFBE7B2, origin: './ntc' },
    { name: 'marigold yellow', rgb: 0xFBE870, origin: './ntc' },
    { name: 'festival', rgb: 0xFBE96C, origin: './ntc' },
    { name: 'sweet corn', rgb: 0xFBEA8C, origin: './ntc' },
    { name: 'candy corn', rgb: 0xFBEC5D, origin: './ntc' },
    { name: 'hint of red', rgb: 0xFBF9F9, origin: './ntc' },
    { name: 'shalimar', rgb: 0xFBFFBA, origin: './ntc' },
    { name: 'shocking pink', rgb: 0xFC0FC0, origin: './ntc' },
    { name: 'tickle me pink', rgb: 0xFC80A5, origin: './ntc' },
    { name: 'tree poppy', rgb: 0xFC9C1D, origin: './ntc' },
    { name: 'lightning yellow', rgb: 0xFCC01E, origin: './ntc' },
    { name: 'goldenrod', rgb: 0xFCD667, origin: './ntc' },
    { name: 'candlelight', rgb: 0xFCD917, origin: './ntc' },
    { name: 'cherokee', rgb: 0xFCDA98, origin: './ntc' },
    { name: 'double pearl lusta', rgb: 0xFCF4D0, origin: './ntc' },
    { name: 'pearl lusta', rgb: 0xFCF4DC, origin: './ntc' },
    { name: 'vista white', rgb: 0xFCF8F7, origin: './ntc' },
    { name: 'bianca', rgb: 0xFCFBF3, origin: './ntc' },
    { name: 'moon glow', rgb: 0xFCFEDA, origin: './ntc' },
    { name: 'china ivory', rgb: 0xFCFFE7, origin: './ntc' },
    { name: 'ceramic', rgb: 0xFCFFF9, origin: './ntc' },
    { name: 'torch red', rgb: 0xFD0E35, origin: './ntc' },
    { name: 'wild watermelon', rgb: 0xFD5B78, origin: './ntc' },
    { name: 'crusta', rgb: 0xFD7B33, origin: './ntc' },
    { name: 'sorbus', rgb: 0xFD7C07, origin: './ntc' },
    { name: 'sweet pink', rgb: 0xFD9FA2, origin: './ntc' },
    { name: 'light apricot', rgb: 0xFDD5B1, origin: './ntc' },
    { name: 'pig pink', rgb: 0xFDD7E4, origin: './ntc' },
    { name: 'cinderella', rgb: 0xFDE1DC, origin: './ntc' },
    { name: 'golden glow', rgb: 0xFDE295, origin: './ntc' },
    { name: 'lemon', rgb: 0xFDE910, origin: './ntc' },
    { name: 'old lace', rgb: 0xFDF5E6, origin: './ntc' },
    { name: 'half colonial white', rgb: 0xFDF6D3, origin: './ntc' },
    { name: 'drover', rgb: 0xFDF7AD, origin: './ntc' },
    { name: 'pale prim', rgb: 0xFDFEB8, origin: './ntc' },
    { name: 'cumulus', rgb: 0xFDFFD5, origin: './ntc' },
    { name: 'persian rose', rgb: 0xFE28A2, origin: './ntc' },
    { name: 'sunset orange', rgb: 0xFE4C40, origin: './ntc' },
    { name: 'bittersweet', rgb: 0xFE6F5E, origin: './ntc' },
    { name: 'california', rgb: 0xFE9D04, origin: './ntc' },
    { name: 'yellow sea', rgb: 0xFEA904, origin: './ntc' },
    { name: 'melon', rgb: 0xFEBAAD, origin: './ntc' },
    { name: 'bright sun', rgb: 0xFED33C, origin: './ntc' },
    { name: 'dandelion', rgb: 0xFED85D, origin: './ntc' },
    { name: 'salomie', rgb: 0xFEDB8D, origin: './ntc' },
    { name: 'cape honey', rgb: 0xFEE5AC, origin: './ntc' },
    { name: 'remy', rgb: 0xFEEBF3, origin: './ntc' },
    { name: 'oasis', rgb: 0xFEEFCE, origin: './ntc' },
    { name: 'bridesmaid', rgb: 0xFEF0EC, origin: './ntc' },
    { name: 'beeswax', rgb: 0xFEF2C7, origin: './ntc' },
    { name: 'bleach white', rgb: 0xFEF3D8, origin: './ntc' },
    { name: 'pipi', rgb: 0xFEF4CC, origin: './ntc' },
    { name: 'half spanish white', rgb: 0xFEF4DB, origin: './ntc' },
    { name: 'wisp pink', rgb: 0xFEF4F8, origin: './ntc' },
    { name: 'provincial pink', rgb: 0xFEF5F1, origin: './ntc' },
    { name: 'half dutch white', rgb: 0xFEF7DE, origin: './ntc' },
    { name: 'solitaire', rgb: 0xFEF8E2, origin: './ntc' },
    { name: 'white pointer', rgb: 0xFEF8FF, origin: './ntc' },
    { name: 'off yellow', rgb: 0xFEF9E3, origin: './ntc' },
    { name: 'orange white', rgb: 0xFEFCED, origin: './ntc' },
    { name: 'red', rgb: 0xFF0000, origin: './ntc' },
    { name: 'rose', rgb: 0xFF007F, origin: './ntc' },
    { name: 'purple pizzazz', rgb: 0xFF00CC, origin: './ntc' },
    { name: 'magenta / fuchsia', rgb: 0xFF00FF, origin: './ntc' },
    { name: 'scarlet', rgb: 0xFF2400, origin: './ntc' },
    { name: 'wild strawberry', rgb: 0xFF3399, origin: './ntc' },
    { name: 'razzle dazzle rose', rgb: 0xFF33CC, origin: './ntc' },
    { name: 'radical red', rgb: 0xFF355E, origin: './ntc' },
    { name: 'red orange', rgb: 0xFF3F34, origin: './ntc' },
    { name: 'coral red', rgb: 0xFF4040, origin: './ntc' },
    { name: 'vermilion', rgb: 0xFF4D00, origin: './ntc' },
    { name: 'international orange', rgb: 0xFF4F00, origin: './ntc' },
    { name: 'outrageous orange', rgb: 0xFF6037, origin: './ntc' },
    { name: 'blaze orange', rgb: 0xFF6600, origin: './ntc' },
    { name: 'pink flamingo', rgb: 0xFF66FF, origin: './ntc' },
    { name: 'orange', rgb: 0xFF681F, origin: './ntc' },
    { name: 'hot pink', rgb: 0xFF69B4, origin: './ntc' },
    { name: 'persimmon', rgb: 0xFF6B53, origin: './ntc' },
    { name: 'blush pink', rgb: 0xFF6FFF, origin: './ntc' },
    { name: 'burning orange', rgb: 0xFF7034, origin: './ntc' },
    { name: 'pumpkin', rgb: 0xFF7518, origin: './ntc' },
    { name: 'flamenco', rgb: 0xFF7D07, origin: './ntc' },
    { name: 'flush orange', rgb: 0xFF7F00, origin: './ntc' },
    { name: 'coral', rgb: 0xFF7F50, origin: './ntc' },
    { name: 'salmon', rgb: 0xFF8C69, origin: './ntc' },
    { name: 'pizazz', rgb: 0xFF9000, origin: './ntc' },
    { name: 'west side', rgb: 0xFF910F, origin: './ntc' },
    { name: 'pink salmon', rgb: 0xFF91A4, origin: './ntc' },
    { name: 'neon carrot', rgb: 0xFF9933, origin: './ntc' },
    { name: 'atomic tangerine', rgb: 0xFF9966, origin: './ntc' },
    { name: 'vivid tangerine', rgb: 0xFF9980, origin: './ntc' },
    { name: 'sunshade', rgb: 0xFF9E2C, origin: './ntc' },
    { name: 'orange peel', rgb: 0xFFA000, origin: './ntc' },
    { name: 'mona lisa', rgb: 0xFFA194, origin: './ntc' },
    { name: 'web orange', rgb: 0xFFA500, origin: './ntc' },
    { name: 'carnation pink', rgb: 0xFFA6C9, origin: './ntc' },
    { name: 'hit pink', rgb: 0xFFAB81, origin: './ntc' },
    { name: 'yellow orange', rgb: 0xFFAE42, origin: './ntc' },
    { name: 'cornflower lilac', rgb: 0xFFB0AC, origin: './ntc' },
    { name: 'sundown', rgb: 0xFFB1B3, origin: './ntc' },
    { name: 'my sin', rgb: 0xFFB31F, origin: './ntc' },
    { name: 'texas rose', rgb: 0xFFB555, origin: './ntc' },
    { name: 'cotton candy', rgb: 0xFFB7D5, origin: './ntc' },
    { name: 'macaroni and cheese', rgb: 0xFFB97B, origin: './ntc' },
    { name: 'selective yellow', rgb: 0xFFBA00, origin: './ntc' },
    { name: 'koromiko', rgb: 0xFFBD5F, origin: './ntc' },
    { name: 'amber', rgb: 0xFFBF00, origin: './ntc' },
    { name: 'wax flower', rgb: 0xFFC0A8, origin: './ntc' },
    { name: 'pink', rgb: 0xFFC0CB, origin: './ntc' },
    { name: 'your pink', rgb: 0xFFC3C0, origin: './ntc' },
    { name: 'supernova', rgb: 0xFFC901, origin: './ntc' },
    { name: 'flesh', rgb: 0xFFCBA4, origin: './ntc' },
    { name: 'sunglow', rgb: 0xFFCC33, origin: './ntc' },
    { name: 'golden tainoi', rgb: 0xFFCC5C, origin: './ntc' },
    { name: 'peach orange', rgb: 0xFFCC99, origin: './ntc' },
    { name: 'chardonnay', rgb: 0xFFCD8C, origin: './ntc' },
    { name: 'pastel pink', rgb: 0xFFD1DC, origin: './ntc' },
    { name: 'romantic', rgb: 0xFFD2B7, origin: './ntc' },
    { name: 'grandis', rgb: 0xFFD38C, origin: './ntc' },
    { name: 'gold', rgb: 0xFFD700, origin: './ntc' },
    { name: 'school bus yellow', rgb: 0xFFD800, origin: './ntc' },
    { name: 'cosmos', rgb: 0xFFD8D9, origin: './ntc' },
    { name: 'mustard', rgb: 0xFFDB58, origin: './ntc' },
    { name: 'peach schnapps', rgb: 0xFFDCD6, origin: './ntc' },
    { name: 'caramel', rgb: 0xFFDDAF, origin: './ntc' },
    { name: 'tuft bush', rgb: 0xFFDDCD, origin: './ntc' },
    { name: 'watusi', rgb: 0xFFDDCF, origin: './ntc' },
    { name: 'pink lace', rgb: 0xFFDDF4, origin: './ntc' },
    { name: 'navajo white', rgb: 0xFFDEAD, origin: './ntc' },
    { name: 'frangipani', rgb: 0xFFDEB3, origin: './ntc' },
    { name: 'pippin', rgb: 0xFFE1DF, origin: './ntc' },
    { name: 'pale rose', rgb: 0xFFE1F2, origin: './ntc' },
    { name: 'negroni', rgb: 0xFFE2C5, origin: './ntc' },
    { name: 'cream brulee', rgb: 0xFFE5A0, origin: './ntc' },
    { name: 'peach', rgb: 0xFFE5B4, origin: './ntc' },
    { name: 'tequila', rgb: 0xFFE6C7, origin: './ntc' },
    { name: 'kournikova', rgb: 0xFFE772, origin: './ntc' },
    { name: 'sandy beach', rgb: 0xFFEAC8, origin: './ntc' },
    { name: 'karry', rgb: 0xFFEAD4, origin: './ntc' },
    { name: 'broom', rgb: 0xFFEC13, origin: './ntc' },
    { name: 'colonial white', rgb: 0xFFEDBC, origin: './ntc' },
    { name: 'derby', rgb: 0xFFEED8, origin: './ntc' },
    { name: 'vis vis', rgb: 0xFFEFA1, origin: './ntc' },
    { name: 'egg white', rgb: 0xFFEFC1, origin: './ntc' },
    { name: 'papaya whip', rgb: 0xFFEFD5, origin: './ntc' },
    { name: 'fair pink', rgb: 0xFFEFEC, origin: './ntc' },
    { name: 'peach cream', rgb: 0xFFF0DB, origin: './ntc' },
    { name: 'lavender blush', rgb: 0xFFF0F5, origin: './ntc' },
    { name: 'gorse', rgb: 0xFFF14F, origin: './ntc' },
    { name: 'buttermilk', rgb: 0xFFF1B5, origin: './ntc' },
    { name: 'pink lady', rgb: 0xFFF1D8, origin: './ntc' },
    { name: 'forget me not', rgb: 0xFFF1EE, origin: './ntc' },
    { name: 'tutu', rgb: 0xFFF1F9, origin: './ntc' },
    { name: 'picasso', rgb: 0xFFF39D, origin: './ntc' },
    { name: 'chardon', rgb: 0xFFF3F1, origin: './ntc' },
    { name: 'paris daisy', rgb: 0xFFF46E, origin: './ntc' },
    { name: 'barley white', rgb: 0xFFF4CE, origin: './ntc' },
    { name: 'egg sour', rgb: 0xFFF4DD, origin: './ntc' },
    { name: 'sazerac', rgb: 0xFFF4E0, origin: './ntc' },
    { name: 'serenade', rgb: 0xFFF4E8, origin: './ntc' },
    { name: 'chablis', rgb: 0xFFF4F3, origin: './ntc' },
    { name: 'seashell peach', rgb: 0xFFF5EE, origin: './ntc' },
    { name: 'sauvignon', rgb: 0xFFF5F3, origin: './ntc' },
    { name: 'milk punch', rgb: 0xFFF6D4, origin: './ntc' },
    { name: 'varden', rgb: 0xFFF6DF, origin: './ntc' },
    { name: 'rose white', rgb: 0xFFF6F5, origin: './ntc' },
    { name: 'baja white', rgb: 0xFFF8D1, origin: './ntc' },
    { name: 'gin fizz', rgb: 0xFFF9E2, origin: './ntc' },
    { name: 'early dawn', rgb: 0xFFF9E6, origin: './ntc' },
    { name: 'lemon chiffon', rgb: 0xFFFACD, origin: './ntc' },
    { name: 'bridal heath', rgb: 0xFFFAF4, origin: './ntc' },
    { name: 'scotch mist', rgb: 0xFFFBDC, origin: './ntc' },
    { name: 'soapstone', rgb: 0xFFFBF9, origin: './ntc' },
    { name: 'witch haze', rgb: 0xFFFC99, origin: './ntc' },
    { name: 'buttery white', rgb: 0xFFFCEA, origin: './ntc' },
    { name: 'island spice', rgb: 0xFFFCEE, origin: './ntc' },
    { name: 'cream', rgb: 0xFFFDD0, origin: './ntc' },
    { name: 'chilean heath', rgb: 0xFFFDE6, origin: './ntc' },
    { name: 'travertine', rgb: 0xFFFDE8, origin: './ntc' },
    { name: 'orchid white', rgb: 0xFFFDF3, origin: './ntc' },
    { name: 'quarter pearl lusta', rgb: 0xFFFDF4, origin: './ntc' },
    { name: 'half and half', rgb: 0xFFFEE1, origin: './ntc' },
    { name: 'apricot white', rgb: 0xFFFEEC, origin: './ntc' },
    { name: 'rice cake', rgb: 0xFFFEF0, origin: './ntc' },
    { name: 'black white', rgb: 0xFFFEF6, origin: './ntc' },
    { name: 'romance', rgb: 0xFFFEFD, origin: './ntc' },
    { name: 'yellow', rgb: 0xFFFF00, origin: './ntc' },
    { name: 'laser lemon', rgb: 0xFFFF66, origin: './ntc' },
    { name: 'pale canary', rgb: 0xFFFF99, origin: './ntc' },
    { name: 'portafino', rgb: 0xFFFFB4, origin: './ntc' },
    { name: 'ivory', rgb: 0xFFFFF0, origin: './ntc' },
    { name: 'white', rgb: 0xFFFFFF, origin: './ntc' },
    { name: 'mahogany', rgb: 0xCD4A4A, origin: './pantone' },
    { name: 'fuzzy wuzzy brown', rgb: 0xCC6666, origin: './pantone' },
    { name: 'chestnut', rgb: 0xBC5D58, origin: './pantone' },
    { name: 'red orange', rgb: 0xFF5349, origin: './pantone' },
    { name: 'sunset orange', rgb: 0xFD5E53, origin: './pantone' },
    { name: 'bittersweet', rgb: 0xFD7C6E, origin: './pantone' },
    { name: 'melon', rgb: 0xFDBCB4, origin: './pantone' },
    { name: 'outrageous orange', rgb: 0xFF6E4A, origin: './pantone' },
    { name: 'vivid tangerine', rgb: 0xFFA089, origin: './pantone' },
    { name: 'burnt sienna', rgb: 0xEA7E5D, origin: './pantone' },
    { name: 'brown', rgb: 0xB4674D, origin: './pantone' },
    { name: 'sepia', rgb: 0xA5694F, origin: './pantone' },
    { name: 'orange', rgb: 0xFF7538, origin: './pantone' },
    { name: 'burnt orange', rgb: 0xFF7F49, origin: './pantone' },
    { name: 'copper', rgb: 0xDD9475, origin: './pantone' },
    { name: 'mango tango', rgb: 0xFF8243, origin: './pantone' },
    { name: 'atomic tangerine', rgb: 0xFFA474, origin: './pantone' },
    { name: 'beaver', rgb: 0x9F8170, origin: './pantone' },
    { name: 'antique brass', rgb: 0xCD9575, origin: './pantone' },
    { name: 'desert sand', rgb: 0xEFCDB8, origin: './pantone' },
    { name: 'raw sienna', rgb: 0xD68A59, origin: './pantone' },
    { name: 'tumbleweed', rgb: 0xDEAA88, origin: './pantone' },
    { name: 'tan', rgb: 0xFAA76C, origin: './pantone' },
    { name: 'peach', rgb: 0xFFCFAB, origin: './pantone' },
    { name: 'macaroni and cheese', rgb: 0xFFBD88, origin: './pantone' },
    { name: 'apricot', rgb: 0xFDD9B5, origin: './pantone' },
    { name: 'neon carrot', rgb: 0xFFA343, origin: './pantone' },
    { name: 'almond', rgb: 0xEFDBC5, origin: './pantone' },
    { name: 'yellow orange', rgb: 0xFFB653, origin: './pantone' },
    { name: 'gold', rgb: 0xE7C697, origin: './pantone' },
    { name: 'shadow', rgb: 0x8A795D, origin: './pantone' },
    { name: 'banana mania', rgb: 0xFAE7B5, origin: './pantone' },
    { name: 'sunglow', rgb: 0xFFCF48, origin: './pantone' },
    { name: 'goldenrod', rgb: 0xFCD975, origin: './pantone' },
    { name: 'dandelion', rgb: 0xFDDB6D, origin: './pantone' },
    { name: 'yellow', rgb: 0xFCE883, origin: './pantone' },
    { name: 'green yellow', rgb: 0xF0E891, origin: './pantone' },
    { name: 'spring green', rgb: 0xECEABE, origin: './pantone' },
    { name: 'olive green', rgb: 0xBAB86C, origin: './pantone' },
    { name: 'laser lemon', rgb: 0xFDFC74, origin: './pantone' },
    { name: 'unmellow yellow', rgb: 0xFDFC74, origin: './pantone' },
    { name: 'canary', rgb: 0xFFFF99, origin: './pantone' },
    { name: 'yellow green', rgb: 0xC5E384, origin: './pantone' },
    { name: 'inch worm', rgb: 0xB2EC5D, origin: './pantone' },
    { name: 'asparagus', rgb: 0x87A96B, origin: './pantone' },
    { name: 'granny smith apple', rgb: 0xA8E4A0, origin: './pantone' },
    { name: 'electric lime', rgb: 0x1DF914, origin: './pantone' },
    { name: 'screamin green', rgb: 0x76FF7A, origin: './pantone' },
    { name: 'fern', rgb: 0x71BC78, origin: './pantone' },
    { name: 'forest green', rgb: 0x6DAE81, origin: './pantone' },
    { name: 'sea green', rgb: 0x9FE2BF, origin: './pantone' },
    { name: 'green', rgb: 0x1CAC78, origin: './pantone' },
    { name: 'mountain meadow', rgb: 0x30BA8F, origin: './pantone' },
    { name: 'shamrock', rgb: 0x45CEA2, origin: './pantone' },
    { name: 'jungle green', rgb: 0x3BB08F, origin: './pantone' },
    { name: 'caribbean green', rgb: 0x1CD3A2, origin: './pantone' },
    { name: 'tropical rain forest', rgb: 0x17806D, origin: './pantone' },
    { name: 'pine green', rgb: 0x158078, origin: './pantone' },
    { name: 'robin egg blue', rgb: 0x1FCECB, origin: './pantone' },
    { name: 'aquamarine', rgb: 0x78DBE2, origin: './pantone' },
    { name: 'turquoise blue', rgb: 0x77DDE7, origin: './pantone' },
    { name: 'sky blue', rgb: 0x80DAEB, origin: './pantone' },
    { name: 'outer space', rgb: 0x414A4C, origin: './pantone' },
    { name: 'blue green', rgb: 0x199EBD, origin: './pantone' },
    { name: 'pacific blue', rgb: 0x1CA9C9, origin: './pantone' },
    { name: 'cerulean', rgb: 0x1DACD6, origin: './pantone' },
    { name: 'cornflower', rgb: 0x9ACEEB, origin: './pantone' },
    { name: 'midnight blue', rgb: 0x1A4876, origin: './pantone' },
    { name: 'navy blue', rgb: 0x1974D2, origin: './pantone' },
    { name: 'denim', rgb: 0x2B6CC4, origin: './pantone' },
    { name: 'blue', rgb: 0x1F75FE, origin: './pantone' },
    { name: 'periwinkle', rgb: 0xC5D0E6, origin: './pantone' },
    { name: 'cadet blue', rgb: 0xB0B7C6, origin: './pantone' },
    { name: 'indigo', rgb: 0x5D76CB, origin: './pantone' },
    { name: 'wild blue yonder', rgb: 0xA2ADD0, origin: './pantone' },
    { name: 'manatee', rgb: 0x979AAA, origin: './pantone' },
    { name: 'blue bell', rgb: 0xADADD6, origin: './pantone' },
    { name: 'blue violet', rgb: 0x7366BD, origin: './pantone' },
    { name: 'purple heart', rgb: 0x7442C8, origin: './pantone' },
    { name: 'royal purple', rgb: 0x7851A9, origin: './pantone' },
    { name: 'purple mountainsâ€™ majesty', rgb: 0x9D81BA, origin: './pantone' },
    { name: 'violet (purple)', rgb: 0x926EAE, origin: './pantone' },
    { name: 'wisteria', rgb: 0xCDA4DE, origin: './pantone' },
    { name: 'vivid violet', rgb: 0x8F509D, origin: './pantone' },
    { name: 'fuchsia', rgb: 0xC364C5, origin: './pantone' },
    { name: 'shocking pink', rgb: 0xFB7EFD, origin: './pantone' },
    { name: 'pink flamingo', rgb: 0xFC74FD, origin: './pantone' },
    { name: 'plum', rgb: 0x8E4585, origin: './pantone' },
    { name: 'hot magenta', rgb: 0xFF1DCE, origin: './pantone' },
    { name: 'purple pizzazz', rgb: 0xFF1DCE, origin: './pantone' },
    { name: 'razzle dazzle rose', rgb: 0xFF48D0, origin: './pantone' },
    { name: 'orchid', rgb: 0xE6A8D7, origin: './pantone' },
    { name: 'red violet', rgb: 0xC0448F, origin: './pantone' },
    { name: 'eggplant', rgb: 0x6E5160, origin: './pantone' },
    { name: 'cerise', rgb: 0xDD4492, origin: './pantone' },
    { name: 'wild strawberry', rgb: 0xFF43A4, origin: './pantone' },
    { name: 'magenta', rgb: 0xF664AF, origin: './pantone' },
    { name: 'lavender', rgb: 0xFCB4D5, origin: './pantone' },
    { name: 'cotton candy', rgb: 0xFFBCD9, origin: './pantone' },
    { name: 'violet red', rgb: 0xF75394, origin: './pantone' },
    { name: 'carnation pink', rgb: 0xFFAACC, origin: './pantone' },
    { name: 'razzmatazz', rgb: 0xE3256B, origin: './pantone' },
    { name: 'piggy pink', rgb: 0xFDD7E4, origin: './pantone' },
    { name: 'jazzberry jam', rgb: 0xCA3767, origin: './pantone' },
    { name: 'blush', rgb: 0xDE5D83, origin: './pantone' },
    { name: 'tickle me pink', rgb: 0xFC89AC, origin: './pantone' },
    { name: 'pink sherbet', rgb: 0xF780A1, origin: './pantone' },
    { name: 'maroon', rgb: 0xC8385A, origin: './pantone' },
    { name: 'red', rgb: 0xEE204D, origin: './pantone' },
    { name: 'radical red', rgb: 0xFF496C, origin: './pantone' },
    { name: 'mauvelous', rgb: 0xEF98AA, origin: './pantone' },
    { name: 'wild watermelon', rgb: 0xFC6C85, origin: './pantone' },
    { name: 'scarlet', rgb: 0xFC2847, origin: './pantone' },
    { name: 'salmon', rgb: 0xFF9BAA, origin: './pantone' },
    { name: 'brick red', rgb: 0xCB4154, origin: './pantone' },
    { name: 'white', rgb: 0xEDEDED, origin: './pantone' },
    { name: 'timberwolf', rgb: 0xDBD7D2, origin: './pantone' },
    { name: 'silver', rgb: 0xCDC5C2, origin: './pantone' },
    { name: 'gray', rgb: 0x95918C, origin: './pantone' },
    { name: 'black', rgb: 0x232323, origin: './pantone' },
    { name: 'red', rgb: 0xFF0000, origin: './roygbiv' },
    { name: 'orange', rgb: 0xFFA500, origin: './roygbiv' },
    { name: 'yellow', rgb: 0xFFFF00, origin: './roygbiv' },
    { name: 'green', rgb: 0x008000, origin: './roygbiv' },
    { name: 'blue', rgb: 0x0000FF, origin: './roygbiv' },
    { name: 'indigo', rgb: 0x4B0082, origin: './roygbiv' },
    { name: 'violet', rgb: 0xEE82EE, origin: './roygbiv' },
    { name: 'indigo', rgb: 0x4b0082, origin: './x11' },
    { name: 'gold', rgb: 0xffd700, origin: './x11' },
    { name: 'hotpink', rgb: 0xff69b4, origin: './x11' },
    { name: 'firebrick', rgb: 0xb22222, origin: './x11' },
    { name: 'indianred', rgb: 0xcd5c5c, origin: './x11' },
    { name: 'yellow', rgb: 0xffff00, origin: './x11' },
    { name: 'mistyrose', rgb: 0xffe4e1, origin: './x11' },
    { name: 'darkolivegreen', rgb: 0x556b2f, origin: './x11' },
    { name: 'olive', rgb: 0x808000, origin: './x11' },
    { name: 'darkseagreen', rgb: 0x8fbc8f, origin: './x11' },
    { name: 'pink', rgb: 0xffc0cb, origin: './x11' },
    { name: 'tomato', rgb: 0xff6347, origin: './x11' },
    { name: 'lightcoral', rgb: 0xf08080, origin: './x11' },
    { name: 'orangered', rgb: 0xff4500, origin: './x11' },
    { name: 'navajowhite', rgb: 0xffdead, origin: './x11' },
    { name: 'lime', rgb: 0x00ff00, origin: './x11' },
    { name: 'palegreen', rgb: 0x98fb98, origin: './x11' },
    { name: 'darkslategrey', rgb: 0x2f4f4f, origin: './x11' },
    { name: 'greenyellow', rgb: 0xadff2f, origin: './x11' },
    { name: 'burlywood', rgb: 0xdeb887, origin: './x11' },
    { name: 'seashell', rgb: 0xfff5ee, origin: './x11' },
    { name: 'mediumspringgreen', rgb: 0x00fa9a, origin: './x11' },
    { name: 'fuchsia', rgb: 0xff00ff, origin: './x11' },
    { name: 'papayawhip', rgb: 0xffefd5, origin: './x11' },
    { name: 'blanchedalmond', rgb: 0xffebcd, origin: './x11' },
    { name: 'chartreuse', rgb: 0x7fff00, origin: './x11' },
    { name: 'dimgray', rgb: 0x696969, origin: './x11' },
    { name: 'black', rgb: 0x000000, origin: './x11' },
    { name: 'peachpuff', rgb: 0xffdab9, origin: './x11' },
    { name: 'springgreen', rgb: 0x00ff7f, origin: './x11' },
    { name: 'aquamarine', rgb: 0x7fffd4, origin: './x11' },
    { name: 'white', rgb: 0xffffff, origin: './x11' },
    { name: 'orange', rgb: 0xffa500, origin: './x11' },
    { name: 'lightsalmon', rgb: 0xffa07a, origin: './x11' },
    { name: 'darkslategray', rgb: 0x2f4f4f, origin: './x11' },
    { name: 'brown', rgb: 0xa52a2a, origin: './x11' },
    { name: 'ivory', rgb: 0xfffff0, origin: './x11' },
    { name: 'dodgerblue', rgb: 0x1e90ff, origin: './x11' },
    { name: 'peru', rgb: 0xcd853f, origin: './x11' },
    { name: 'lawngreen', rgb: 0x7cfc00, origin: './x11' },
    { name: 'chocolate', rgb: 0xd2691e, origin: './x11' },
    { name: 'crimson', rgb: 0xdc143c, origin: './x11' },
    { name: 'forestgreen', rgb: 0x228b22, origin: './x11' },
    { name: 'darkgrey', rgb: 0xa9a9a9, origin: './x11' },
    { name: 'lightseagreen', rgb: 0x20b2aa, origin: './x11' },
    { name: 'cyan', rgb: 0x00ffff, origin: './x11' },
    { name: 'mintcream', rgb: 0xf5fffa, origin: './x11' },
    { name: 'silver', rgb: 0xc0c0c0, origin: './x11' },
    { name: 'antiquewhite', rgb: 0xfaebd7, origin: './x11' },
    { name: 'mediumorchid', rgb: 0xba55d3, origin: './x11' },
    { name: 'skyblue', rgb: 0x87ceeb, origin: './x11' },
    { name: 'gray', rgb: 0x808080, origin: './x11' },
    { name: 'darkturquoise', rgb: 0x00ced1, origin: './x11' },
    { name: 'goldenrod', rgb: 0xdaa520, origin: './x11' },
    { name: 'darkgreen', rgb: 0x006400, origin: './x11' },
    { name: 'floralwhite', rgb: 0xfffaf0, origin: './x11' },
    { name: 'darkviolet', rgb: 0x9400d3, origin: './x11' },
    { name: 'darkgray', rgb: 0xa9a9a9, origin: './x11' },
    { name: 'moccasin', rgb: 0xffe4b5, origin: './x11' },
    { name: 'saddlebrown', rgb: 0x8b4513, origin: './x11' },
    { name: 'grey', rgb: 0x808080, origin: './x11' },
    { name: 'darkslateblue', rgb: 0x483d8b, origin: './x11' },
    { name: 'lightskyblue', rgb: 0x87cefa, origin: './x11' },
    { name: 'lightpink', rgb: 0xffb6c1, origin: './x11' },
    { name: 'mediumvioletred', rgb: 0xc71585, origin: './x11' },
    { name: 'slategrey', rgb: 0x708090, origin: './x11' },
    { name: 'red', rgb: 0xff0000, origin: './x11' },
    { name: 'deeppink', rgb: 0xff1493, origin: './x11' },
    { name: 'limegreen', rgb: 0x32cd32, origin: './x11' },
    { name: 'darkmagenta', rgb: 0x8b008b, origin: './x11' },
    { name: 'palegoldenrod', rgb: 0xeee8aa, origin: './x11' },
    { name: 'plum', rgb: 0xdda0dd, origin: './x11' },
    { name: 'turquoise', rgb: 0x40e0d0, origin: './x11' },
    { name: 'lightgrey', rgb: 0xd3d3d3, origin: './x11' },
    { name: 'lightgoldenrodyellow', rgb: 0xfafad2, origin: './x11' },
    { name: 'darkgoldenrod', rgb: 0xb8860b, origin: './x11' },
    { name: 'lavender', rgb: 0xe6e6fa, origin: './x11' },
    { name: 'maroon', rgb: 0x800000, origin: './x11' },
    { name: 'yellowgreen', rgb: 0x9acd32, origin: './x11' },
    { name: 'sandybrown', rgb: 0xf4a460, origin: './x11' },
    { name: 'thistle', rgb: 0xd8bfd8, origin: './x11' },
    { name: 'violet', rgb: 0xee82ee, origin: './x11' },
    { name: 'navy', rgb: 0x000080, origin: './x11' },
    { name: 'magenta', rgb: 0xff00ff, origin: './x11' },
    { name: 'dimgrey', rgb: 0x696969, origin: './x11' },
    { name: 'tan', rgb: 0xd2b48c, origin: './x11' },
    { name: 'rosybrown', rgb: 0xbc8f8f, origin: './x11' },
    { name: 'olivedrab', rgb: 0x6b8e23, origin: './x11' },
    { name: 'blue', rgb: 0x0000ff, origin: './x11' },
    { name: 'lightblue', rgb: 0xadd8e6, origin: './x11' },
    { name: 'ghostwhite', rgb: 0xf8f8ff, origin: './x11' },
    { name: 'honeydew', rgb: 0xf0fff0, origin: './x11' },
    { name: 'cornflowerblue', rgb: 0x6495ed, origin: './x11' },
    { name: 'slateblue', rgb: 0x6a5acd, origin: './x11' },
    { name: 'linen', rgb: 0xfaf0e6, origin: './x11' },
    { name: 'darkblue', rgb: 0x00008b, origin: './x11' },
    { name: 'powderblue', rgb: 0xb0e0e6, origin: './x11' },
    { name: 'seagreen', rgb: 0x2e8b57, origin: './x11' },
    { name: 'darkkhaki', rgb: 0xbdb76b, origin: './x11' },
    { name: 'snow', rgb: 0xfffafa, origin: './x11' },
    { name: 'sienna', rgb: 0xa0522d, origin: './x11' },
    { name: 'mediumblue', rgb: 0x0000cd, origin: './x11' },
    { name: 'royalblue', rgb: 0x4169e1, origin: './x11' },
    { name: 'lightcyan', rgb: 0xe0ffff, origin: './x11' },
    { name: 'green', rgb: 0x008000, origin: './x11' },
    { name: 'mediumpurple', rgb: 0x9370db, origin: './x11' },
    { name: 'midnightblue', rgb: 0x191970, origin: './x11' },
    { name: 'cornsilk', rgb: 0xfff8dc, origin: './x11' },
    { name: 'paleturquoise', rgb: 0xafeeee, origin: './x11' },
    { name: 'bisque', rgb: 0xffe4c4, origin: './x11' },
    { name: 'slategray', rgb: 0x708090, origin: './x11' },
    { name: 'darkcyan', rgb: 0x008b8b, origin: './x11' },
    { name: 'khaki', rgb: 0xf0e68c, origin: './x11' },
    { name: 'wheat', rgb: 0xf5deb3, origin: './x11' },
    { name: 'teal', rgb: 0x008080, origin: './x11' },
    { name: 'darkorchid', rgb: 0x9932cc, origin: './x11' },
    { name: 'deepskyblue', rgb: 0x00bfff, origin: './x11' },
    { name: 'salmon', rgb: 0xfa8072, origin: './x11' },
    { name: 'darkred', rgb: 0x8b0000, origin: './x11' },
    { name: 'steelblue', rgb: 0x4682b4, origin: './x11' },
    { name: 'palevioletred', rgb: 0xdb7093, origin: './x11' },
    { name: 'lightslategray', rgb: 0x778899, origin: './x11' },
    { name: 'aliceblue', rgb: 0xf0f8ff, origin: './x11' },
    { name: 'lightslategrey', rgb: 0x778899, origin: './x11' },
    { name: 'lightgreen', rgb: 0x90ee90, origin: './x11' },
    { name: 'orchid', rgb: 0xda70d6, origin: './x11' },
    { name: 'gainsboro', rgb: 0xdcdcdc, origin: './x11' },
    { name: 'mediumseagreen', rgb: 0x3cb371, origin: './x11' },
    { name: 'lightgray', rgb: 0xd3d3d3, origin: './x11' },
    { name: 'mediumturquoise', rgb: 0x48d1cc, origin: './x11' },
    { name: 'lemonchiffon', rgb: 0xfffacd, origin: './x11' },
    { name: 'cadetblue', rgb: 0x5f9ea0, origin: './x11' },
    { name: 'lightyellow', rgb: 0xffffe0, origin: './x11' },
    { name: 'lavenderblush', rgb: 0xfff0f5, origin: './x11' },
    { name: 'coral', rgb: 0xff7f50, origin: './x11' },
    { name: 'purple', rgb: 0x800080, origin: './x11' },
    { name: 'aqua', rgb: 0x00ffff, origin: './x11' },
    { name: 'whitesmoke', rgb: 0xf5f5f5, origin: './x11' },
    { name: 'mediumslateblue', rgb: 0x7b68ee, origin: './x11' },
    { name: 'darkorange', rgb: 0xff8c00, origin: './x11' },
    { name: 'mediumaquamarine', rgb: 0x66cdaa, origin: './x11' },
    { name: 'darksalmon', rgb: 0xe9967a, origin: './x11' },
    { name: 'beige', rgb: 0xf5f5dc, origin: './x11' },
    { name: 'blueviolet', rgb: 0x8a2be2, origin: './x11' },
    { name: 'azure', rgb: 0xf0ffff, origin: './x11' },
    { name: 'lightsteelblue', rgb: 0xb0c4de, origin: './x11' },
    { name: 'oldlace', rgb: 0xfdf5e6, origin: './x11' }
  ];

  // From 'colour-proximity' and 'chroma-js' npm.

  const proximity = (s1, s2) => {
    const c1 = rgb2lab(...s1);
    const c2 = rgb2lab(...s2);
    return Math.sqrt(Math.pow(c1[0] - c2[0], 2) + Math.pow(c1[1] - c2[1], 2) + Math.pow(c1[2] - c2[2], 2));
  };

  const labConstants = {
    // Corresponds roughly to RGB brighter/darker
    Kn: 18,

    // D65 standard referent
    Xn: 0.950470,
    Yn: 1,
    Zn: 1.088830,

    t0: 0.137931034, // 4 / 29
    t1: 0.206896552, // 6 / 29
    t2: 0.12841855, // 3 * t1 * t1
    t3: 0.008856452 // t1 * t1 * t1
  };

  const rgbXyz = (r) => {
    if ((r /= 255) <= 0.04045) {
      return r / 12.92;
    }
    return Math.pow((r + 0.055) / 1.055, 2.4);
  };

  const xyzLab = function (t) {
    if (t > labConstants.t3) {
      return Math.pow(t, 1 / 3);
    }
    return t / labConstants.t2 + labConstants.t0;
  };

  const rgb2xyz = (r, g, b) => {
    r = rgbXyz(r);
    g = rgbXyz(g);
    b = rgbXyz(b);
    var x = xyzLab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / labConstants.Xn);
    var y = xyzLab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / labConstants.Yn);
    var z = xyzLab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / labConstants.Zn);
    return [x, y, z];
  };

  const rgb2lab = (r, g, b) => {
    const [x, y, z] = rgb2xyz(r, g, b);
    const l = 116 * y - 16;
    return [l < 0 ? 0 : l, 500 * (x - y), 200 * (y - z)];
  };

  const toEntryFromRgbInt = (rgbInt) => {
    const rgb = toArrayFromRgbInt(rgbInt);
    let bestDistance = Infinity;
    let best;
    for (const entry of colors) {
      const distance = proximity(rgb, toArrayFromRgbInt(entry.rgb));
      if (distance < bestDistance) {
        best = entry;
        bestDistance = distance;
      }
    }
    return best;
  };

  const toRgbIntFromName = (name, defaultRgbInt = 0) => {
    let rgbInt;
    // Handle '#00ffbb'.
    if (rgbInt === undefined) {
      if (name.startsWith('#')) {
        rgbInt = parseInt(name.substring(1), 16);
      }
    }
    // Handle 'blue'.
    if (rgbInt === undefined) {
      const normalizedName = name.toLowerCase();
      for (const { name, rgb } of colors) {
        if (normalizedName === name) {
          rgbInt = rgb;
        }
      }
    }
    // Handle defaulting.
    if (rgbInt === undefined) {
      rgbInt = defaultRgbInt;
    }
    return rgbInt;
  };

  const toArrayFromRgbInt = (rgbInt) =>
    [(rgbInt >> 16) & 0xFF, (rgbInt >> 8) & 0xFF, (rgbInt >> 0) & 0xFF];

  const toRgbIntFromTags = (tags = [], defaultRgb = [0, 0, 0]) => {
    let rgb = defaultRgb;
    for (const tag of tags) {
      if (tag.startsWith('color/')) {
        let entry = toRgbIntFromName(tag.substring(6));
        if (entry !== undefined) {
          return entry;
        }
      }
    }
    return rgb;
  };

  const toTagFromName = (name) => {
    const entry = toEntryFromRgbInt(toRgbIntFromName(name));
    if (entry !== undefined) {
      return `color/${entry.name.toLowerCase()}`;
    }
    return `color/unknown`;
  };

  const toRgbFromTags = (tags, defaultRgb) => {
    const rgbInt = toRgbIntFromTags(tags, null);
    if (rgbInt === null) {
      return defaultRgb;
    }
    return toArrayFromRgbInt(rgbInt);
  };

  /**
   *
   * # Color
   *
   * Produces a version of a shape the given color.
   * FIX: Support color in convert/threejs/toSvg.
   *
   * ::: illustration
   * ```
   * Circle(10).color('blue')
   * ```
   * :::
   * ::: illustration
   * ```
   * Triangle(10).color('chartreuse')
   * ```
   * :::
   *
   **/

  const fromName = (shape, name) =>
    Shape.fromGeometry(rewriteTags([toTagFromName(name)], [], shape.toGeometry()));

  const color = (...args) => fromName(...args);

  const colorMethod = function (...args) { return color(this, ...args); };
  Shape.prototype.color = colorMethod;

  color.signature = 'color(shape:Shape, color:string) -> Shape';
  colorMethod.signature = 'Shape -> color(color:string) -> Shape';

  const colors$1 = (shape) =>
    [...allTags(shape.toGeometry())]
        .filter(tag => tag.startsWith('color/'))
        .map(tag => tag.substring(6));

  const colorsMethod = function () { return colors$1(this); };
  Shape.prototype.colors = colorsMethod;

  colors$1.signature = 'colors(shape:Shape) -> strings';
  colorsMethod.signature = 'Shape -> colors() -> strings';

  /**
   *
   * # Keep in assembly
   *
   * Generates an assembly from components in an assembly with a tag.
   *
   * ::: illustration
   * ```
   * assemble(Circle(10).as('A'),
   *          Square(10).as('B'))
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Circle(10).as('A'),
   *          Square(10).as('B'))
   *   .keep('A')
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Circle(10).as('A'),
   *          Square(10).as('B'))
   *   .keep('B')
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Circle(10).as('A'),
   *          Square(10).as('B'))
   *   .keep('A', 'B')
   * ```
   * :::
   *
   **/

  const keep$1 = (shape, tags) => fromGeometry(keep(tags.map(tag => `user/${tag}`), toGeometry(shape)));

  const keepMethod = function (...tags) { return keep$1(this, tags); };
  Shape.prototype.keep = keepMethod;

  keep$1.signature = 'keep(shape:Shape, tags:strings) -> Shape';
  keepMethod.signature = 'Shape -> keep(tags:strings) -> Shape';

  /**
   *
   * # Kept
   *
   * Kept produces a geometry without dropped elements.
   *
   **/

  const kept = (shape) => Shape.fromGeometry(toKeptGeometry$1(shape));

  const keptMethod = function () { return kept(this); };
  Shape.prototype.kept = keptMethod;

  kept.signature = 'kept(shape:Shape) -> Shape';
  keptMethod.signature = 'Shape -> kept() -> Shape';

  const layer = (...shapes) => Shape.fromGeometry({ layers: shapes.map(shape => shape.toGeometry()) });

  const layerMethod = function (...shapes) { return layer(this, ...shapes); };
  Shape.prototype.layer = layerMethod;
  Shape.prototype.and = layerMethod;

  /**
   *
   * # Log
   *
   * Writes a string to the console.
   *
   * ```
   * log("Hello, World")
   * ```
   *
   **/

  const log$2 = (text, level) => log({ op: 'text', text: String(text), level });

  const logOp = (shape, op) => log({ op: 'text', text: String(op(shape)) });

  const logMethod = function (op = (shape => JSON.stringify(shape.toKeptGeometry()))) { logOp(this, op); return this; };
  Shape.prototype.log = logMethod;

  log$2.signature = 'log(op:function)';

  /**
   *
   * # Write Shape Geometry
   *
   * This writes a shape as a tagged geometry in json format.
   *
   * ::: illustration { "view": { "position": [5, 5, 5] } }
   * ```
   * await Cube().writeShape('cube.shape');
   * await readShape({ path: 'cube.shape' })
   * ```
   * :::
   *
   **/

  const cacheShape = async (shape, path) => {
    const geometry = shape.toGeometry();
    await writeFile({}, `cache/${path}`, geometry);
  };

  const writeShape = async (shape, path) => {
    const geometry = shape.toGeometry();
    await writeFile({ doSerialize: false }, `output/${path}`, JSON.stringify(geometry));
    await writeFile({}, `geometry/${path}`, geometry);
  };

  const writeShapeMethod = function (...args) { return writeShape(this, ...args); };
  Shape.prototype.writeShape = writeShapeMethod;

  const readShape = async (path, build, { ephemeral = false, src } = {}) => {
    let data = await readFile({ ephemeral }, `source/${path}`);
    if (data === undefined && src) {
      data = await readFile({ sources: [src], ephemeral }, `cache/${path}`);
    }
    if (data === undefined && build !== undefined) {
      data = await readFile({ ephemeral }, `cache/${path}`);
      if (data !== undefined) {
        return Shape.fromGeometry(data);
      }
      const shape = await build();
      if (!ephemeral) {
        await cacheShape(shape, path);
      }
      return shape;
    }
    return Shape.fromGeometry(data);
  };

  const make = (path, builder) => readShape(path, builder);

  /**
   *
   * # Material
   *
   * Produces a version of a shape with a given material.
   *
   * Materials supported include 'paper', 'metal', 'glass', etc.
   *
   * ::: illustration
   * ```
   * Cylinder(5, 10).material('copper')
   * ```
   * :::
   *
   **/

  const material = (shape, ...tags) =>
    Shape.fromGeometry(rewriteTags(tags.map(tag => `material/${tag}`), [], shape.toGeometry()));

  const materialMethod = function (...tags) { return material(this, ...tags); };
  Shape.prototype.material = materialMethod;

  material.signature = 'material(shape:Shape) -> Shape';
  materialMethod.signature = 'Shape -> material() -> Shape';

  /**
   *
   * # Translate
   *
   * Translation moves a shape.
   *
   * ::: illustration { "view": { "position": [10, 0, 10] } }
   * ```
   * assemble(Circle(),
   *          Sphere().above())
   * ```
   * :::
   * ::: illustration { "view": { "position": [10, 0, 10] } }
   * ```
   * assemble(Circle(),
   *          Sphere().above()
   *                  .translate(0, 0, 1))
   * ```
   * :::
   * ::: illustration { "view": { "position": [10, 0, 10] } }
   * ```
   * assemble(Circle(),
   *          Sphere().above()
   *                  .translate(0, 1, 0))
   * ```
   * :::
   * ::: illustration { "view": { "position": [10, 0, 10] } }
   * ```
   * assemble(Circle(),
   *          Sphere().above()
   *                  .translate([-1, -1, 1]))
   * ```
   * :::
   *
   **/

  const translate$5 = (shape, x = 0, y = 0, z = 0) => shape.transform(fromTranslation([x, y, z]));

  const method$2 = function (...args) { return translate$5(this, ...args); };
  Shape.prototype.translate = method$2;

  /**
   *
   * # Move
   *
   * A shorter way to write translate.
   *
   */

  const move = (...args) => translate$5(...args);

  const moveMethod = function (...params) { return translate$5(this, ...params); };
  Shape.prototype.move = moveMethod;

  move.signature = 'move(shape:Shape, x:number = 0, y:number = 0, z:number = 0) -> Shape';
  moveMethod.signature = 'Shape -> move(x:number = 0, y:number = 0, z:number = 0) -> Shape';

  /**
   *
   * # MoveX
   *
   * Move along the X axis.
   *
   */

  const moveX = (shape, x = 0) => move(shape, x);

  const moveXMethod = function (x) { return moveX(this, x); };
  Shape.prototype.moveX = moveXMethod;

  moveX.signature = 'moveX(shape:Shape, x:number = 0) -> Shape';
  moveXMethod.signature = 'Shape -> moveX(x:number = 0) -> Shape';

  /**
   *
   * # MoveY
   *
   * Move along the Y axis.
   *
   */

  const moveY = (shape, y = 0) => move(shape, 0, y);

  const moveYMethod = function (y) { return moveY(this, y); };
  Shape.prototype.moveY = moveYMethod;

  moveY.signature = 'moveY(shape:Shape, y:number = 0) -> Shape';
  moveYMethod.signature = 'Shape -> moveY(y:number = 0) -> Shape';

  /**
   *
   * # MoveZ
   *
   * Move along the Z axis.
   *
   */

  const moveZ = (shape, z = 0) => move(shape, 0, 0, z);

  const moveZMethod = function (z) { return moveZ(this, z); };
  Shape.prototype.moveZ = moveZMethod;

  moveZ.signature = 'moveZ(shape:Shape, z:number = 0) -> Shape';
  moveZMethod.signature = 'Shape -> moveZ(z:number = 0) -> Shape';

  /**
   *
   * # Mark an object as not to cut holes.
   *
   **/

  const nocut = (shape, ...tags) => fromGeometry(nonNegative(tags.map(tag => `user/${tag}`), toGeometry(shape)));

  const nocutMethod = function (...tags) { return nocut(this, tags); };
  Shape.prototype.nocut = nocutMethod;

  nocut.signature = 'nocut(shape:Shape, ...tag:string) -> Shape';
  nocutMethod.signature = 'Shape -> nocut(...tag:string) -> Shape';

  /**
   *
   * # Orient
   *
   * Orients a shape so that it moves from 'center' to 'from' and faces toward 'at', rather than 'facing'.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10).orient({ from: [3, 3, 3], at: [1, 1, 1] });
   * ```
   * :::
   **/

  const orient = (shape, { center = [0, 0, 0], facing = [0, 0, 1], at = [0, 0, 0], from = [0, 0, 0] }) => {
    const normalizedFacing = normalize(facing);
    const normalizedAt = normalize(subtract(at, from));

    const angle = Math.acos(dot(normalizedFacing, normalizedAt)) * 180 / Math.PI;
    const axis = normalize(cross(normalizedFacing, normalizedAt));

    return shape
        .move(negate(center))
        .rotate(angle, axis)
        .move(from);
  };

  const orientMethod = function (...args) { return orient(this, ...args); };
  Shape.prototype.orient = orientMethod;

  orient.signature = 'orient(Shape:shape, { center:Point, facing:Vector, at:Point, from:Point }) -> Shape';
  orientMethod.signature = 'Shape -> orient({ center:Point, facing:Vector, at:Point, from:Point }) -> Shape';

  /**
   *
   * # Rotate
   *
   * ```
   * rotate(shape, axis, angle)
   * shape.rotate(axis, angle)
   * ```
   *
   * Rotates the shape around the provided axis.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10).rotate([1, 1, 1], 90)
   * ```
   * :::
   **/

  const rotate$1 = (shape, angle = 0, axis = [0, 0, 1]) => shape.transform(fromRotation(angle * 0.017453292519943295, axis));

  const rotateMethod = function (...args) { return rotate$1(this, ...args); };
  Shape.prototype.rotate = rotateMethod;

  /**
   *
   * # Rotate X
   *
   * Rotates the shape around the X axis.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10).rotateX(90)
   * ```
   * :::
   **/

  const rotateX$2 = (shape, angle) => shape.transform(fromXRotation(angle * 0.017453292519943295));

  const rotateXMethod = function (angle) { return rotateX$2(this, angle); };
  Shape.prototype.rotateX = rotateXMethod;

  /**
   *
   * # Rotate Y
   *
   * Rotates the shape around the Y axis.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10).rotateY(90)
   * ```
   * :::
   **/

  const rotateY$1 = (shape, angle) => shape.transform(fromYRotation(angle * 0.017453292519943295));

  const rotateYMethod = function (angle) { return rotateY$1(this, angle); };
  Shape.prototype.rotateY = rotateYMethod;

  /**
   *
   * # Rotate Z
   *
   * Rotates the shape around the Z axis.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10).rotateZ(45)
   * ```
   * :::
   **/

  const rotateZ$2 = (shape, angle) => shape.transform(fromZRotation(angle * 0.017453292519943295));

  const rotateZMethod = function (angle) { return rotateZ$2(this, angle); };
  Shape.prototype.rotateZ = rotateZMethod;

  /**
   *
   * # Scale
   *
   * Scales an object uniformly or per axis.
   *
   * ::: illustration { "view": { "position": [10, 10, 10] } }
   * ```
   * Cube()
   * ```
   * :::
   * ::: illustration { "view": { "position": [10, 10, 10] } }
   * ```
   * Cube().scale(2)
   * ```
   * :::
   * ::: illustration { "view": { "position": [10, 10, 10] } }
   * ```
   * Cube().scale([1, 2, 3])
   * ```
   * :::
   **/

  const scale$4 = (factor, shape) => {
    if (factor.length) {
      const [x = 1, y = 1, z = 1] = factor;
      return shape.transform(fromScaling([x, y, z]));
    } else {
      return shape.transform(fromScaling([factor, factor, factor]));
    }
  };

  const scaleMethod = function (factor) { return scale$4(factor, this); };
  Shape.prototype.scale = scaleMethod;

  const X$f = 0;
  const Y$f = 1;
  const Z$b = 2;

  const size = (shape) => {
    const [min, max] = measureBoundingBox$6(shape);
    const width = max[X$f] - min[X$f];
    const length = max[Y$f] - min[Y$f];
    const height = max[Z$b] - min[Z$b];
    const center = scale(0.5, add(min, max));
    const radius = distance(center, max);
    return { length, width, height, max, min, center, radius };
  };

  const sizeMethod = function () { return size(this); };
  Shape.prototype.size = sizeMethod;

  size.signature = 'size(shape:Shape) -> Size';
  sizeMethod.signature = 'Shape -> size() -> Size';

  /**
   *
   * # Turn
   *
   * ```
   * turn(shape, axis, angle)
   * shape.turn(axis, angle)
   * ```
   *
   * Rotates the shape around its own axis.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Square(10).turn([1, 1, 1], 90)
   * ```
   * :::
   **/

  const turn = (shape, axis, angle) => {
    const center = shape.measureCenter();
    return shape.move(...negate(center))
        .rotate(axis, angle)
        .move(...center);
  };

  const turnMethod = function (angle, axis) { return turn(this, axis, angle); };
  Shape.prototype.turn = turnMethod;

  const turnX$1 = (shape, angle) => {
    const center = shape.measureCenter();
    return shape.move(...negate(center))
        .rotateX(angle)
        .move(...center);
  };

  const turnXMethod = function (angle) { return turnX$1(this, angle); };
  Shape.prototype.turnX = turnXMethod;

  const turnY$1 = (shape, angle) => {
    const center = shape.measureCenter();
    return shape.move(...negate(center))
        .rotateY(angle)
        .move(...center);
  };

  const turnYMethod = function (angle) { return turnY$1(this, angle); };
  Shape.prototype.turnY = turnYMethod;

  const turnZ$1 = (shape, angle) => {
    const center = shape.measureCenter();
    return shape.move(...negate(center))
        .rotateZ(angle)
        .move(...center);
  };

  const turnZMethod = function (angle) { return turnZ$1(this, angle); };
  Shape.prototype.turnZ = turnZMethod;

  const registry = [];

  // FIX: Need to clear out temporary registrations.

  const fromDesignator = (designator) => {
    for (const { parser, constructor } of registry) {
      const spec = parser(designator);
      if (spec !== undefined && spec !== null && spec !== false) {
        return constructor(spec);
      }
    }
    throw Error('die');
  };

  // Later definitions override earlier definitions.
  const registerDesignator = (parser, constructor) =>
    registry.unshift({ parser, constructor });

  /**
   *
   * # Item
   *
   * Encapsulates a geometry as a discrete item.
   *
   **/

  // Constructs an item from the designator.
  const Item$1 = (designator) => {
    if (typeof designator === 'string') {
      return fromDesignator(designator);
    } else if (designator instanceof Array) {
      return fromDesignator(...designator);
    }
  };

  // Turns the current shape into an item.
  const itemMethod = function (id) {
    const shape = Shape.fromGeometry(rewriteTags([`item/${id}`], [], { item: this.toGeometry() }));
    // Register the designator for re-use.
    registerDesignator(d => (d === id), () => shape);
    return shape;
  };

  Shape.prototype.Item = itemMethod;
  Shape.prototype.toItem = itemMethod;

  Item$1.signature = 'Item(shape:Shape, id:string) -> Shape';
  itemMethod.signature = 'Shape -> toItem(id:string) -> Shape';

  /**
   *
   * # Bill Of Materials
   *
   **/

  const bom = (shape) => {
    const bom = [];
    visit(shape.toKeptGeometry(),
          (geometry, descend) => {
            if (geometry.item) {
              bom.push(geometry.tags.filter(tag => tag.startsWith('item/'))
                  .map(tag => tag.substring(5)));
            }
            descend();
          });
    return bom;
  };

  const bomMethod = function (...args) { return bom(this); };
  Shape.prototype.bom = bomMethod;

  bomMethod.signature = 'Shape -> bom() -> string';

  const fuse = (shape, op = (_ => _)) =>
    Shape.fromGeometry(rewrite(shape.toKeptGeometry(),
                               (geometry, descend, walk) => {
                                 if (geometry.item) {
                                   return walk(geometry.item);
                                 } else {
                                   return descend();
                                 }
                               }));

  const fuseMethod = function (...args) { return fuse(this, ...args); };
  Shape.prototype.fuse = fuseMethod;

  fuse.signature = 'fuse(shape:Shape, op:function) -> Shapes';
  fuseMethod.signature = 'Shape -> fuse(op:function) -> Shapes';

  const inItems = (shape, op = (_ => _)) => {
    const rewritten = rewrite(shape.toKeptGeometry(),
                              (geometry, descend) => {
                                if (geometry.item) {
                                  // Operate on the interior of the items.
                                  const item = op(Shape.fromGeometry(geometry.item));
                                  // Reassemble as an item equivalent to the original.
                                  return update(geometry, { item: item.toGeometry() });
                                } else {
                                  return descend();
                                }
                              });
    return Shape.fromGeometry(rewritten);
  };

  const inItemsMethod = function (...args) { return inItems(this, ...args); };
  Shape.prototype.inItems = inItemsMethod;

  inItems.signature = 'inItems(shape:Shape, op:function) -> Shapes';
  inItemsMethod.signature = 'Shape -> inItems(op:function) -> Shapes';

  const items = (shape, op = (_ => _)) => {
    const items = [];
    for (const item of getItems(shape.toKeptGeometry())) {
      items.push(op(Shape.fromGeometry(item)));
    }
    return items;
  };

  const itemsMethod = function (...args) { return items(this, ...args); };
  Shape.prototype.items = itemsMethod;

  items.signature = 'items(shape:Shape, op:function) -> Shapes';
  itemsMethod.signature = 'Shape -> items(op:function) -> Shapes';

  const leafs = (shape, op = (_ => _)) => {
    const leafs = [];
    for (const leaf of getLeafs(shape.toKeptGeometry())) {
      leafs.push(op(Shape.fromGeometry(leaf)));
    }
    return leafs;
  };

  const leafsMethod = function (...args) { return leafs(this, ...args); };
  Shape.prototype.leafs = leafsMethod;

  leafs.signature = 'leafs(shape:Shape, op:function) -> Shapes';
  leafsMethod.signature = 'Shape -> leafs(op:function) -> Shapes';

  const toBillOfMaterial = (shape) => {
    const specifications = [];
    for (const { tags } of getItems(shape.toKeptGeometry())) {
      for (const tag of tags) {
        if (tag.startsWith('item/')) {
          const specification = tag.substring(5);
          specifications.push(specification);
        }
      }
    }
    return specifications;
  };

  const toBillOfMaterialMethod = function (options = {}) { return toBillOfMaterial(this); };

  Shape.prototype.toBillOfMaterial = toBillOfMaterialMethod;

  /**
   *
   * # Ease
   *
   * Produces a function for composing easing functions.
   * ```
   * ease(0.00, 0.25, t => sin(t * 25))(ease(0.25, 1.00, t => 5)())
   * ```
   *
   **/

  const ease = (start = 0.00, end = 1.00, op = t => 1) => {
    const compose = (next = t => 1) => {
      const fn = t => {
        if (t >= start && t <= end) {
          return op((t - start) / (end - start));
        } else {
          return next(t);
        }
      };
      return fn;
    };
    return compose;
  };

  const linear = (start, end) => t => start + t * (end - start);
  ease.linear = linear;

  ease.signature = 'ease(start:number = 0, end:number = 1, op:function) -> function';
  linear.signature = 'linear(start:number = 0, end:number = 1) -> function';

  var Prando_umd = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
  	 module.exports = factory() ;
  }(commonjsGlobal, (function () {
  	var Prando = /** @class */ (function () {
  	    // ================================================================================================================
  	    // CONSTRUCTOR ----------------------------------------------------------------------------------------------------
  	    /**
  	     * Generate a new Prando pseudo-random number generator.
  	     *
  	     * @param seed - A number or string seed that determines which pseudo-random number sequence will be created. Defaults to current time.
  	     */
  	    function Prando(seed) {
  	        this._value = NaN;
  	        if (typeof (seed) === "string") {
  	            // String seed
  	            this._seed = this.hashCode(seed);
  	        }
  	        else if (typeof (seed) === "number") {
  	            // Numeric seed
  	            this._seed = this.getSafeSeed(seed);
  	        }
  	        else {
  	            // Pseudo-random seed
  	            this._seed = this.getSafeSeed(Prando.MIN + Math.floor((Prando.MAX - Prando.MIN) * Math.random()));
  	        }
  	        this.reset();
  	    }
  	    // ================================================================================================================
  	    // PUBLIC INTERFACE -----------------------------------------------------------------------------------------------
  	    /**
  	     * Generates a pseudo-random number between a lower (inclusive) and a higher (exclusive) bounds.
  	     *
  	     * @param min - The minimum number that can be randomly generated.
  	     * @param pseudoMax - The maximum number that can be randomly generated (exclusive).
  	     * @return The generated pseudo-random number.
  	     */
  	    Prando.prototype.next = function (min, pseudoMax) {
  	        if (min === void 0) { min = 0; }
  	        if (pseudoMax === void 0) { pseudoMax = 1; }
  	        this.recalculate();
  	        return this.map(this._value, Prando.MIN, Prando.MAX, min, pseudoMax);
  	    };
  	    /**
  	     * Generates a pseudo-random integer number in a range (inclusive).
  	     *
  	     * @param min - The minimum number that can be randomly generated.
  	     * @param max - The maximum number that can be randomly generated.
  	     * @return The generated pseudo-random number.
  	     */
  	    Prando.prototype.nextInt = function (min, max) {
  	        if (min === void 0) { min = 10; }
  	        if (max === void 0) { max = 100; }
  	        this.recalculate();
  	        return Math.floor(this.map(this._value, Prando.MIN, Prando.MAX, min, max + 1));
  	    };
  	    /**
  	     * Generates a pseudo-random string sequence of a particular length from a specific character range.
  	     *
  	     * Note: keep in mind that creating a random string sequence does not guarantee uniqueness; there is always a
  	     * 1 in (char_length^string_length) chance of collision. For real unique string ids, always check for
  	     * pre-existing ids, or employ a robust GUID/UUID generator.
  	     *
  	     * @param length - Length of the strting to be generated.
  	     * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).
  	     * @return The generated string sequence.
  	     */
  	    Prando.prototype.nextString = function (length, chars) {
  	        if (length === void 0) { length = 16; }
  	        if (chars === void 0) { chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; }
  	        var str = "";
  	        while (str.length < length) {
  	            str += this.nextChar(chars);
  	        }
  	        return str;
  	    };
  	    /**
  	     * Generates a pseudo-random string of 1 character specific character range.
  	     *
  	     * @param chars - Characters that are used when creating the random string. Defaults to all alphanumeric chars (A-Z, a-z, 0-9).
  	     * @return The generated character.
  	     */
  	    Prando.prototype.nextChar = function (chars) {
  	        if (chars === void 0) { chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; }
  	        this.recalculate();
  	        return chars.substr(this.nextInt(0, chars.length - 1), 1);
  	    };
  	    /**
  	     * Picks a pseudo-random item from an array. The array is left unmodified.
  	     *
  	     * Note: keep in mind that while the returned item will be random enough, picking one item from the array at a time
  	     * does not guarantee nor imply that a sequence of random non-repeating items will be picked. If you want to
  	     * *pick items in a random order* from an array, instead of *pick one random item from an array*, it's best to
  	     * apply a *shuffle* transformation to the array instead, then read it linearly.
  	     *
  	     * @param array - Array of any type containing one or more candidates for random picking.
  	     * @return An item from the array.
  	     */
  	    Prando.prototype.nextArrayItem = function (array) {
  	        this.recalculate();
  	        return array[this.nextInt(0, array.length - 1)];
  	    };
  	    /**
  	     * Generates a pseudo-random boolean.
  	     *
  	     * @return A value of true or false.
  	     */
  	    Prando.prototype.nextBoolean = function () {
  	        this.recalculate();
  	        return this._value > 0.5;
  	    };
  	    /**
  	     * Skips ahead in the sequence of numbers that are being generated. This is equivalent to
  	     * calling next() a specified number of times, but faster since it doesn't need to map the
  	     * new random numbers to a range and return it.
  	     *
  	     * @param iterations - The number of items to skip ahead.
  	     */
  	    Prando.prototype.skip = function (iterations) {
  	        if (iterations === void 0) { iterations = 1; }
  	        while (iterations-- > 0) {
  	            this.recalculate();
  	        }
  	    };
  	    /**
  	     * Reset the pseudo-random number sequence back to its starting seed. Further calls to next()
  	     * will then produce the same sequence of numbers it had produced before. This is equivalent to
  	     * creating a new Prando instance with the same seed as another Prando instance.
  	     *
  	     * Example:
  	     * let rng = new Prando(12345678);
  	     * console.log(rng.next()); // 0.6177754114889017
  	     * console.log(rng.next()); // 0.5784605181725837
  	     * rng.reset();
  	     * console.log(rng.next()); // 0.6177754114889017 again
  	     * console.log(rng.next()); // 0.5784605181725837 again
  	     */
  	    Prando.prototype.reset = function () {
  	        this._value = this._seed;
  	    };
  	    // ================================================================================================================
  	    // PRIVATE INTERFACE ----------------------------------------------------------------------------------------------
  	    Prando.prototype.recalculate = function () {
  	        this._value = this.xorshift(this._value);
  	    };
  	    Prando.prototype.xorshift = function (value) {
  	        // Xorshift*32
  	        // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper
  	        value ^= value << 13;
  	        value ^= value >> 17;
  	        value ^= value << 5;
  	        return value;
  	    };
  	    Prando.prototype.map = function (val, minFrom, maxFrom, minTo, maxTo) {
  	        return ((val - minFrom) / (maxFrom - minFrom)) * (maxTo - minTo) + minTo;
  	    };
  	    Prando.prototype.hashCode = function (str) {
  	        var hash = 0;
  	        if (str) {
  	            var l = str.length;
  	            for (var i = 0; i < l; i++) {
  	                hash = ((hash << 5) - hash) + str.charCodeAt(i);
  	                hash |= 0;
  	                hash = this.xorshift(hash);
  	            }
  	        }
  	        return this.getSafeSeed(hash);
  	    };
  	    Prando.prototype.getSafeSeed = function (seed) {
  	        if (seed === 0)
  	            return 1;
  	        return seed;
  	    };
  	    Prando.MIN = -2147483648; // Int32 min
  	    Prando.MAX = 2147483647; // Int32 max
  	    return Prando;
  	}());

  	return Prando;

  })));
  module.exports.default = module.exports; // Terrible injection just so it works regardless of how it's required
  });

  const makeTo = (g) => (to) => g() * to;
  const makeIn = (g) => (from, to) => g() * (to - from) + from;
  const makeVary = (g) => (degree) => (g() - 0.5) * degree * 2;
  const makePick = (g) => (options) => options[Math.floor(g() * options.length)];

  const Random = (seed = 0) => {
    const rng = new Prando_umd(seed);
    const g = () => rng.next();
    g.in = makeIn(g);
    g.to = makeTo(g);
    g.vary = makeVary(g);
    g.pick = makePick(g);
    return g;
  };

  /**
   *
   * # Arc Cosine
   *
   * Gives the arc cosine converted to degrees.
   * ```
   * acos(a) => Math.acos(a) / (Math.PI * 2) * 360;
   *
   * acos(0) = 90
   * acos(0.5) = 60
   * acos(1) = 0
   * ```
   *
   **/

  const acos = (a) => Math.acos(a) / (Math.PI * 2) * 360;
  acos.signature = 'acos(angle:number) -> number';

  /**
   *
   * # Cosine
   *
   * Gives the cosine in degrees.
   * ```
   * cos(a) => Math.cos(a / 360 * Math.PI * 2);
   *
   * cos(0) = 1
   * cos(45) = 0.707
   * cos(90) = 0
   * ```
   *
   **/

  const cos = (a) => Math.cos(a / 360 * Math.PI * 2);

  cos.signature = 'cos(angle:number) -> number';

  /**
   *
   * # Max
   *
   * Produces the maximum of a series of numbers.
   *
   * ```
   * max(1, 2, 3, 4) == 4
   * ```
   *
   **/

  const max$1 = Math.max;

  max$1.signature = 'max(...values:number) -> number';

  /**
   *
   * # Min
   *
   * Produces the minimum of a series of numbers.
   *
   * ```
   * min(1, 2, 3, 4) == 1
   * ```
   *
   **/

  const min$1 = Math.min;

  min$1.signature = 'min(...values:number) -> number';

  /**
   *
   * # Numbers
   *
   * ```
   * numbers({ to: 10 }) is [0, 1, 2, 3, 4, 5, 6, 9].
   * numbers({ from: 3, to: 6 }) is [3, 4, 5, 6].
   * numbers({ from: 2, to: 8, by: 2 }) is [2, 4, 6].
   * numbers({ to: 2 }, { to: 3 }) is [[0, 0], [0, 1], [0, 2], [1, 0], ...];
   * ```
   *
   **/

  const EPSILON$3 = 1e-5;

  const numbers = (thunk = (n => n), { from = 0, to, upto, by, resolution } = {}) => {
    const numbers = [];
    if (by === undefined) {
      if (resolution !== undefined) {
        by = to / resolution;
      } else {
        by = 1;
      }
    }

    if (to === undefined && upto === undefined) {
      upto = 1;
    }

    if (upto !== undefined) {
      // Exclusive
      for (let number = from, nth = 0; number < to - EPSILON$3; number += by, nth++) {
        numbers.push(thunk(number, nth));
      }
    } else if (to !== undefined) {
      // Inclusive
      for (let number = from, nth = 0; number <= to + EPSILON$3; number += by, nth++) {
        numbers.push(thunk(number, nth));
      }
    }
    return numbers;
  };

  numbers.signature = 'numbers(spec) -> numbers';

  /**
   *
   * # Sine
   *
   * Gives the sine in degrees.
   * ```
   * sin(a) => Math.sin(a / 360 * Math.PI * 2);
   *
   * sin(0) = 0
   * sin(45) = 0.707
   * sin(90) = 1
   * ```
   *
   **/

  const sin = (a) => Math.sin(a / 360 * Math.PI * 2);

  /**
   *
   * # Square Root
   *
   * Gives the the square root of a number.
   * ```
   * sqrt(a) => Math.sqrt(a);
   *
   * sqrt(0) = 0
   * sqrt(4) = 2
   * sqrt(16) = 4
   * ```
   *
   **/

  const sqrt = Math.sqrt;

  /**
   *
   * # Spiral
   *
   * These take a function mapping angle to radius.
   *
   * ::: illustration { "view": { "position": [0, 0, 10] } }
   * ```
   * Spiral(angle => [angle],
   *        { to: 360 * 5 });
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, 0, 10] } }
   * ```
   * Spiral({ to: 360 },
   *        (angle) => [[2 + sin(angle * 20)]])
   *   .close()
   *   .interior()
   * ```
   * :::
   **/

  const Spiral = (toPathFromAngle = (angle => [[angle]]), { from = 0, to = 360, by, resolution } = {}) => {
    if (by === undefined && resolution === undefined) {
      by = 1;
    }
    let path = [null];
    for (const angle of numbers(angle => angle, { from, to, by, resolution })) {
      const radians = angle * Math.PI / 180;
      const subpath = toPathFromAngle(angle);
      path = concatenate(path, rotateZ$1(radians, subpath));
    }
    return Shape.fromPath(path);
  };

  const ofRadius = (radius, angle = 360, { start = 0, sides = 32 } = {}) =>
    Spiral(a => [[radius]], { from: start, to: start + angle, resolution: sides });

  const Arc = (...args) => ofRadius(...args);
  Arc.ofRadius = ofRadius;

  const Assembly = (...shapes) => Shape.fromGeometry({ assembly: shapes.map(shape => shape.toGeometry()) });

  function clone(point) { //TODO: use gl-vec2 for this
      return [point[0], point[1]]
  }

  function vec2(x, y) {
      return [x, y]
  }

  var _function = function createBezierBuilder(opt) {
      opt = opt||{};

      var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8;
      var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7;
      var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0;

      var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01;
      var m_angle_tolerance = opt.angleTolerance || 0;
      var m_cusp_limit = opt.cuspLimit || 0;

      return function bezierCurve(start, c1, c2, end, scale, points) {
          if (!points)
              points = [];

          scale = typeof scale === 'number' ? scale : 1.0;
          var distanceTolerance = PATH_DISTANCE_EPSILON / scale;
          distanceTolerance *= distanceTolerance;
          begin(start, c1, c2, end, points, distanceTolerance);
          return points
      }


      ////// Based on:
      ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

      function begin(start, c1, c2, end, points, distanceTolerance) {
          points.push(clone(start));
          var x1 = start[0],
              y1 = start[1],
              x2 = c1[0],
              y2 = c1[1],
              x3 = c2[0],
              y3 = c2[1],
              x4 = end[0],
              y4 = end[1];
          recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0);
          points.push(clone(end));
      }

      function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
          if(level > RECURSION_LIMIT) 
              return

          var pi = Math.PI;

          // Calculate all the mid-points of the line segments
          //----------------------
          var x12   = (x1 + x2) / 2;
          var y12   = (y1 + y2) / 2;
          var x23   = (x2 + x3) / 2;
          var y23   = (y2 + y3) / 2;
          var x34   = (x3 + x4) / 2;
          var y34   = (y3 + y4) / 2;
          var x123  = (x12 + x23) / 2;
          var y123  = (y12 + y23) / 2;
          var x234  = (x23 + x34) / 2;
          var y234  = (y23 + y34) / 2;
          var x1234 = (x123 + x234) / 2;
          var y1234 = (y123 + y234) / 2;

          if(level > 0) { // Enforce subdivision first time
              // Try to approximate the full cubic curve by a single straight line
              //------------------
              var dx = x4-x1;
              var dy = y4-y1;

              var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
              var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);

              var da1, da2;

              if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
                  // Regular care
                  //-----------------
                  if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
                      // If the curvature doesn't exceed the distanceTolerance value
                      // we tend to finish subdivisions.
                      //----------------------
                      if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                          points.push(vec2(x1234, y1234));
                          return
                      }

                      // Angle & Cusp Condition
                      //----------------------
                      var a23 = Math.atan2(y3 - y2, x3 - x2);
                      da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
                      da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
                      if(da1 >= pi) da1 = 2*pi - da1;
                      if(da2 >= pi) da2 = 2*pi - da2;

                      if(da1 + da2 < m_angle_tolerance) {
                          // Finally we can stop the recursion
                          //----------------------
                          points.push(vec2(x1234, y1234));
                          return
                      }

                      if(m_cusp_limit !== 0.0) {
                          if(da1 > m_cusp_limit) {
                              points.push(vec2(x2, y2));
                              return
                          }

                          if(da2 > m_cusp_limit) {
                              points.push(vec2(x3, y3));
                              return
                          }
                      }
                  }
              }
              else {
                  if(d2 > FLT_EPSILON) {
                      // p1,p3,p4 are collinear, p2 is considerable
                      //----------------------
                      if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
                          if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                              points.push(vec2(x1234, y1234));
                              return
                          }

                          // Angle Condition
                          //----------------------
                          da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
                          if(da1 >= pi) da1 = 2*pi - da1;

                          if(da1 < m_angle_tolerance) {
                              points.push(vec2(x2, y2));
                              points.push(vec2(x3, y3));
                              return
                          }

                          if(m_cusp_limit !== 0.0) {
                              if(da1 > m_cusp_limit) {
                                  points.push(vec2(x2, y2));
                                  return
                              }
                          }
                      }
                  }
                  else if(d3 > FLT_EPSILON) {
                      // p1,p2,p4 are collinear, p3 is considerable
                      //----------------------
                      if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
                          if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                              points.push(vec2(x1234, y1234));
                              return
                          }

                          // Angle Condition
                          //----------------------
                          da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
                          if(da1 >= pi) da1 = 2*pi - da1;

                          if(da1 < m_angle_tolerance) {
                              points.push(vec2(x2, y2));
                              points.push(vec2(x3, y3));
                              return
                          }

                          if(m_cusp_limit !== 0.0) {
                              if(da1 > m_cusp_limit)
                              {
                                  points.push(vec2(x3, y3));
                                  return
                              }
                          }
                      }
                  }
                  else {
                      // Collinear case
                      //-----------------
                      dx = x1234 - (x1 + x4) / 2;
                      dy = y1234 - (y1 + y4) / 2;
                      if(dx*dx + dy*dy <= distanceTolerance) {
                          points.push(vec2(x1234, y1234));
                          return
                      }
                  }
              }
          }

          // Continue subdivision
          //----------------------
          recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1); 
          recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1); 
      }
  };

  var adaptiveBezierCurve = _function();

  const buildAdaptiveCubicBezierCurve = ({ scale = 2 }, [start, c1, c2, end]) => adaptiveBezierCurve(start, c1, c2, end, scale);

  var subtract_1 = subtract$2;

  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  function subtract$2(out, a, b) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      out[2] = a[2] - b[2];
      return out
  }

  var cross_1 = cross$1;

  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  function cross$1(out, a, b) {
      var ax = a[0], ay = a[1], az = a[2],
          bx = b[0], by = b[1], bz = b[2];

      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out
  }

  var squaredLength_1 = squaredLength$1;

  /**
   * Calculates the squared length of a vec3
   *
   * @param {vec3} a vector to calculate squared length of
   * @returns {Number} squared length of a
   */
  function squaredLength$1(a) {
      var x = a[0],
          y = a[1],
          z = a[2];
      return x*x + y*y + z*z
  }

  var ab = [];
  var ap = [];
  var cr = [];

  var squared = function (p, a, b) {
    // // == vector solution
    // var normalize = require('gl-vec3/normalize')
    // var scaleAndAdd = require('gl-vec3/scaleAndAdd')
    // var dot = require('gl-vec3/dot')
    // var squaredDistance = require('gl-vec3/squaredDistance')
    // // n = vector `ab` normalized
    // var n = []
    // // projection = projection of `point` on `n`
    // var projection = []
    // normalize(n, subtract(n, a, b))
    // scaleAndAdd(projection, a, n, dot(n, p))
    // return squaredDistance(projection, p)

    // == parallelogram solution
    //
    //            s
    //      __a________b__
    //       /   |    /
    //      /   h|   /
    //     /_____|__/
    //    p
    //
    //  s = b - a
    //  area = s * h
    //  |ap x s| = s * h
    //  h = |ap x s| / s
    //
    subtract_1(ab, b, a);
    subtract_1(ap, p, a);
    var area = squaredLength_1(cross_1(cr, ap, ab));
    var s = squaredLength_1(ab);
    if (s === 0) {
      throw Error('a and b are the same point')
    }
    return area / s
  };

  var pointLineDistance = function (point, a, b) {
    return Math.sqrt(squared(point, a, b))
  };

  var normalize_1 = normalize$2;

  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to normalize
   * @returns {vec3} out
   */
  function normalize$2(out, a) {
      var x = a[0],
          y = a[1],
          z = a[2];
      var len = x*x + y*y + z*z;
      if (len > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          out[0] = a[0] * len;
          out[1] = a[1] * len;
          out[2] = a[2] * len;
      }
      return out
  }

  var tmp = [0, 0, 0];

  var getPlaneNormal = planeNormal;

  function planeNormal (out, point1, point2, point3) {
    subtract_1(out, point1, point2);
    subtract_1(tmp, point2, point3);
    cross_1(out, out, tmp);
    return normalize_1(out, out)
  }

  var dot_1 = dot$3;

  /**
   * Calculates the dot product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} dot product of a and b
   */
  function dot$3(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
  }

  var VertexList_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var VertexList = function () {
    function VertexList() {
      _classCallCheck(this, VertexList);

      this.head = null;
      this.tail = null;
    }

    _createClass(VertexList, [{
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
      }

      /**
       * Inserts a `node` before `target`, it's assumed that
       * `target` belongs to this doubly linked list
       *
       * @param {*} target
       * @param {*} node
       */

    }, {
      key: "insertBefore",
      value: function insertBefore(target, node) {
        node.prev = target.prev;
        node.next = target;
        if (!node.prev) {
          this.head = node;
        } else {
          node.prev.next = node;
        }
        target.prev = node;
      }

      /**
       * Inserts a `node` after `target`, it's assumed that
       * `target` belongs to this doubly linked list
       *
       * @param {Vertex} target
       * @param {Vertex} node
       */

    }, {
      key: "insertAfter",
      value: function insertAfter(target, node) {
        node.prev = target;
        node.next = target.next;
        if (!node.next) {
          this.tail = node;
        } else {
          node.next.prev = node;
        }
        target.next = node;
      }

      /**
       * Appends a `node` to the end of this doubly linked list
       * Note: `node.next` will be unlinked from `node`
       * Note: if `node` is part of another linked list call `addAll` instead
       *
       * @param {*} node
       */

    }, {
      key: "add",
      value: function add(node) {
        if (!this.head) {
          this.head = node;
        } else {
          this.tail.next = node;
        }
        node.prev = this.tail;
        // since node is the new end it doesn't have a next node
        node.next = null;
        this.tail = node;
      }

      /**
       * Appends a chain of nodes where `node` is the head,
       * the difference with `add` is that it correctly sets the position
       * of the node list `tail` property
       *
       * @param {*} node
       */

    }, {
      key: "addAll",
      value: function addAll(node) {
        if (!this.head) {
          this.head = node;
        } else {
          this.tail.next = node;
        }
        node.prev = this.tail;

        // find the end of the list
        while (node.next) {
          node = node.next;
        }
        this.tail = node;
      }

      /**
       * Deletes a `node` from this linked list, it's assumed that `node` is a
       * member of this linked list
       *
       * @param {*} node
       */

    }, {
      key: "remove",
      value: function remove(node) {
        if (!node.prev) {
          this.head = node.next;
        } else {
          node.prev.next = node.next;
        }

        if (!node.next) {
          this.tail = node.prev;
        } else {
          node.next.prev = node.prev;
        }
      }

      /**
       * Removes a chain of nodes whose head is `a` and whose tail is `b`,
       * it's assumed that `a` and `b` belong to this list and also that `a`
       * comes before `b` in the linked list
       *
       * @param {*} a
       * @param {*} b
       */

    }, {
      key: "removeChain",
      value: function removeChain(a, b) {
        if (!a.prev) {
          this.head = b.next;
        } else {
          a.prev.next = b.next;
        }

        if (!b.next) {
          this.tail = a.prev;
        } else {
          b.next.prev = a.prev;
        }
      }
    }, {
      key: "first",
      value: function first() {
        return this.head;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return !this.head;
      }
    }]);

    return VertexList;
  }();

  exports.default = VertexList;
  module.exports = exports["default"];
  });

  unwrapExports(VertexList_1);

  var Vertex_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var Vertex = function Vertex(point, index) {
    _classCallCheck(this, Vertex);

    this.point = point;
    // index in the input array
    this.index = index;
    // vertex is a double linked list node
    this.next = null;
    this.prev = null;
    // the face that is able to see this point
    this.face = null;
  };

  exports.default = Vertex;
  module.exports = exports["default"];
  });

  unwrapExports(Vertex_1);

  var add_1 = add$1;

  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */
  function add$1(out, a, b) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      out[2] = a[2] + b[2];
      return out
  }

  var copy_1 = copy;

  /**
   * Copy the values from one vec3 to another
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the source vector
   * @returns {vec3} out
   */
  function copy(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      return out
  }

  var length_1 = length$1;

  /**
   * Calculates the length of a vec3
   *
   * @param {vec3} a vector to calculate length of
   * @returns {Number} length of a
   */
  function length$1(a) {
      var x = a[0],
          y = a[1],
          z = a[2];
      return Math.sqrt(x*x + y*y + z*z)
  }

  var scale_1 = scale$5;

  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */
  function scale$5(out, a, b) {
      out[0] = a[0] * b;
      out[1] = a[1] * b;
      out[2] = a[2] * b;
      return out
  }

  var scaleAndAdd_1 = scaleAndAdd;

  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @param {Number} scale the amount to scale b by before adding
   * @returns {vec3} out
   */
  function scaleAndAdd(out, a, b, scale) {
      out[0] = a[0] + (b[0] * scale);
      out[1] = a[1] + (b[1] * scale);
      out[2] = a[2] + (b[2] * scale);
      return out
  }

  var distance_1 = distance$2;

  /**
   * Calculates the euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} distance between a and b
   */
  function distance$2(a, b) {
      var x = b[0] - a[0],
          y = b[1] - a[1],
          z = b[2] - a[2];
      return Math.sqrt(x*x + y*y + z*z)
  }

  var squaredDistance_1 = squaredDistance$1;

  /**
   * Calculates the squared euclidian distance between two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} squared distance between a and b
   */
  function squaredDistance$1(a, b) {
      var x = b[0] - a[0],
          y = b[1] - a[1],
          z = b[2] - a[2];
      return x*x + y*y + z*z
  }

  var browser$1 = true;

  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  var ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse$2(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val)
    );
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse$2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */
  function setup$1(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    /**
    * Active `debug` instances.
    */

    createDebug.instances = [];
    /**
    * The currently active debug mode names, and names to skip.
    */

    createDebug.names = [];
    createDebug.skips = [];
    /**
    * Map of special "%n" handling functions, for the debug "format" argument.
    *
    * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    */

    createDebug.formatters = {};
    /**
    * Selects a color for a debug namespace
    * @param {String} namespace The namespace string for the for the debug instance to be colored
    * @return {Number|String} An ANSI color code for the given namespace
    * @api private
    */

    function selectColor(namespace) {
      var hash = 0;

      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }

    createDebug.selectColor = selectColor;
    /**
    * Create a debugger with the given `namespace`.
    *
    * @param {String} namespace
    * @return {Function}
    * @api public
    */

    function createDebug(namespace) {
      var prevTime;

      function debug() {
        // Disabled?
        if (!debug.enabled) {
          return;
        }

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var self = debug; // Set `diff` timestamp

        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        } // Apply any `formatters` transformations


        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return match;
          }

          index++;
          var formatter = createDebug.formatters[format];

          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

            args.splice(index, 1);
            index--;
          }

          return match;
        }); // Apply env-specific formatting (colors, etc.)

        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend; // Debug.formatArgs = formatArgs;
      // debug.rawLog = rawLog;
      // env-specific initialization logic for debug instances

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }

      createDebug.instances.push(debug);
      return debug;
    }

    function destroy() {
      var index = createDebug.instances.indexOf(this);

      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }

      return false;
    }

    function extend(namespace, delimiter) {
      return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    }
    /**
    * Enables a debug mode by namespaces. This can include modes
    * separated by a colon and wildcards.
    *
    * @param {String} namespaces
    * @api public
    */


    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          // ignore empty strings
          continue;
        }

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }

      for (i = 0; i < createDebug.instances.length; i++) {
        var instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    /**
    * Disable debug output.
    *
    * @api public
    */


    function disable() {
      createDebug.enable('');
    }
    /**
    * Returns true if the given mode name is enabled, false otherwise.
    *
    * @param {String} name
    * @return {Boolean}
    * @api public
    */


    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }

      var i;
      var len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }
    /**
    * Coerce `val`.
    *
    * @param {Mixed} val
    * @return {Mixed}
    * @api private
    */


    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }

      return val;
    }

    createDebug.enable(createDebug.load());
    return createDebug;
  }

  var common = setup$1;

  var browser$2 = createCommonjsModule(function (module, exports) {

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  /* eslint-env browser */

  /**
   * This is the web browser implementation of `debug()`.
   */
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  /**
   * Colors.
   */

  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  // eslint-disable-next-line complexity

  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    } // Internet Explorer and Edge do not support colors.


    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    } // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into

    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function (match) {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  /**
   * Invokes `console.log()` when available.
   * No-op when `console.log` is not a "function".
   *
   * @api public
   */


  function log() {
    var _console;

    // This hackery is required for IE8/9, where
    // the `console.log` function doesn't have 'apply'
    return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    var r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {} // Swallow
    // XXX (@Qix-) should we be logging these?
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */


  function localstorage() {
    try {
      // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
      // The Browser also has localStorage in the global context.
      return localStorage;
    } catch (error) {// Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }

  module.exports = common(exports);
  var formatters = module.exports.formatters;
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
  });
  var browser_1 = browser$2.log;
  var browser_2 = browser$2.formatArgs;
  var browser_3 = browser$2.save;
  var browser_4 = browser$2.load;
  var browser_5 = browser$2.useColors;
  var browser_6 = browser$2.storage;
  var browser_7 = browser$2.colors;

  // MIT lisence
  // from https://github.com/substack/tty-browserify/blob/1ba769a6429d242f36226538835b4034bf6b7886/index.js

  function isatty() {
    return false;
  }

  function ReadStream() {
    throw new Error('tty.ReadStream is not implemented');
  }

  function WriteStream() {
    throw new Error('tty.ReadStream is not implemented');
  }

  var tty = {
    isatty: isatty,
    ReadStream: ReadStream,
    WriteStream: WriteStream
  };

  var hasFlag = (flag, argv = process.argv) => {
  	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
  	const position = argv.indexOf(prefix + flag);
  	const terminatorPosition = argv.indexOf('--');
  	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };

  const {env: env$1} = process;

  let forceColor;
  if (hasFlag('no-color') ||
  	hasFlag('no-colors') ||
  	hasFlag('color=false') ||
  	hasFlag('color=never')) {
  	forceColor = 0;
  } else if (hasFlag('color') ||
  	hasFlag('colors') ||
  	hasFlag('color=true') ||
  	hasFlag('color=always')) {
  	forceColor = 1;
  }

  if ('FORCE_COLOR' in env$1) {
  	if (env$1.FORCE_COLOR === 'true') {
  		forceColor = 1;
  	} else if (env$1.FORCE_COLOR === 'false') {
  		forceColor = 0;
  	} else {
  		forceColor = env$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env$1.FORCE_COLOR, 10), 3);
  	}
  }

  function translateLevel(level) {
  	if (level === 0) {
  		return false;
  	}

  	return {
  		level,
  		hasBasic: true,
  		has256: level >= 2,
  		has16m: level >= 3
  	};
  }

  function supportsColor(haveStream, streamIsTTY) {
  	if (forceColor === 0) {
  		return 0;
  	}

  	if (hasFlag('color=16m') ||
  		hasFlag('color=full') ||
  		hasFlag('color=truecolor')) {
  		return 3;
  	}

  	if (hasFlag('color=256')) {
  		return 2;
  	}

  	if (haveStream && !streamIsTTY && forceColor === undefined) {
  		return 0;
  	}

  	const min = forceColor || 0;

  	if (env$1.TERM === 'dumb') {
  		return min;
  	}

  	if ('CI' in env$1) {
  		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env$1) || env$1.CI_NAME === 'codeship') {
  			return 1;
  		}

  		return min;
  	}

  	if ('TEAMCITY_VERSION' in env$1) {
  		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;
  	}

  	if ('GITHUB_ACTIONS' in env$1) {
  		return 1;
  	}

  	if (env$1.COLORTERM === 'truecolor') {
  		return 3;
  	}

  	if ('TERM_PROGRAM' in env$1) {
  		const version = parseInt((env$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

  		switch (env$1.TERM_PROGRAM) {
  			case 'iTerm.app':
  				return version >= 3 ? 3 : 2;
  			case 'Apple_Terminal':
  				return 2;
  			// No default
  		}
  	}

  	if (/-256(color)?$/i.test(env$1.TERM)) {
  		return 2;
  	}

  	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {
  		return 1;
  	}

  	if ('COLORTERM' in env$1) {
  		return 1;
  	}

  	return min;
  }

  function getSupportLevel(stream) {
  	const level = supportsColor(stream, stream && stream.isTTY);
  	return translateLevel(level);
  }

  var supportsColor_1 = {
  	supportsColor: getSupportLevel,
  	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
  	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };

  var node = createCommonjsModule(function (module, exports) {

  /**
   * Module dependencies.
   */



  /**
   * This is the Node.js implementation of `debug()`.
   */


  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  /**
   * Colors.
   */

  exports.colors = [6, 2, 3, 4, 5, 1];

  try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    var supportsColor = supportsColor_1;

    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
    }
  } catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.

  /**
   * Build up the default `inspectOpts` object from the environment variables.
   *
   *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
   */


  exports.inspectOpts = Object.keys(process.env).filter(function (key) {
    return /^debug_/i.test(key);
  }).reduce(function (obj, key) {
    // Camel-case
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
      return k.toUpperCase();
    }); // Coerce string value into JS value

    var val = process.env[key];

    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === 'null') {
      val = null;
    } else {
      val = Number(val);
    }

    obj[prop] = val;
    return obj;
  }, {});
  /**
   * Is stdout a TTY? Colored output is enabled when `true`.
   */

  function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  /**
   * Adds ANSI color escape codes if enabled.
   *
   * @api public
   */


  function formatArgs(args) {
    var name = this.namespace,
        useColors = this.useColors;

    if (useColors) {
      var c = this.color;
      var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
      var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
      args[0] = prefix + args[0].split('\n').join('\n' + prefix);
      args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + ' ' + args[0];
    }
  }

  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return '';
    }

    return new Date().toISOString() + ' ';
  }
  /**
   * Invokes `util.format()` with the specified arguments and writes to stderr.
   */


  function log() {
    return process.stderr.write(util.format.apply(util, arguments) + '\n');
  }
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */


  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      // If you set a process.env field to null or undefined, it gets cast to the
      // string 'null' or 'undefined'. Just delete instead.
      delete process.env.DEBUG;
    }
  }
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */


  function load() {
    return process.env.DEBUG;
  }
  /**
   * Init logic for `debug` instances.
   *
   * Create a new `inspectOpts` object in case `useColors` is set
   * differently for a particular `debug` instance.
   */


  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);

    for (var i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }

  module.exports = common(exports);
  var formatters = module.exports.formatters;
  /**
   * Map %o to `util.inspect()`, all on a single line.
   */

  formatters.o = function (v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, ' ');
  };
  /**
   * Map %O to `util.inspect()`, allowing multiple lines if needed.
   */


  formatters.O = function (v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
  });
  var node_1 = node.init;
  var node_2 = node.log;
  var node_3 = node.formatArgs;
  var node_4 = node.save;
  var node_5 = node.load;
  var node_6 = node.useColors;
  var node_7 = node.colors;
  var node_8 = node.inspectOpts;

  var src = createCommonjsModule(function (module) {

  /**
   * Detect Electron renderer / nwjs process, which is node, but we should
   * treat as a browser.
   */
  if (typeof process === 'undefined' || process.type === 'renderer' || browser$1 === true || process.__nwjs) {
    module.exports = browser$2;
  } else {
    module.exports = node;
  }
  });

  var HalfEdge_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



  var _distance2 = _interopRequireDefault(distance_1);



  var _squaredDistance2 = _interopRequireDefault(squaredDistance_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var debug = src('halfedge');

  var HalfEdge = function () {
    function HalfEdge(vertex, face) {
      _classCallCheck(this, HalfEdge);

      this.vertex = vertex;
      this.face = face;
      this.next = null;
      this.prev = null;
      this.opposite = null;
    }

    _createClass(HalfEdge, [{
      key: 'head',
      value: function head() {
        return this.vertex;
      }
    }, {
      key: 'tail',
      value: function tail() {
        return this.prev ? this.prev.vertex : null;
      }
    }, {
      key: 'length',
      value: function length() {
        if (this.tail()) {
          return (0, _distance2.default)(this.tail().point, this.head().point);
        }
        return -1;
      }
    }, {
      key: 'lengthSquared',
      value: function lengthSquared() {
        if (this.tail()) {
          return (0, _squaredDistance2.default)(this.tail().point, this.head().point);
        }
        return -1;
      }
    }, {
      key: 'setOpposite',
      value: function setOpposite(edge) {
        var me = this;
        if (debug.enabled) {
          debug('opposite ' + me.tail().index + ' <--> ' + me.head().index + ' between ' + me.face.collectIndices() + ', ' + edge.face.collectIndices());
        }
        this.opposite = edge;
        edge.opposite = this;
      }
    }]);

    return HalfEdge;
  }();

  exports.default = HalfEdge;
  module.exports = exports['default'];
  });

  unwrapExports(HalfEdge_1);

  var Face_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DELETED = exports.NON_CONVEX = exports.VISIBLE = undefined;

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



  var _dot2 = _interopRequireDefault(dot_1);



  var _add2 = _interopRequireDefault(add_1);



  var _subtract2 = _interopRequireDefault(subtract_1);



  var _cross2 = _interopRequireDefault(cross_1);



  var _copy2 = _interopRequireDefault(copy_1);



  var _length2 = _interopRequireDefault(length_1);



  var _scale2 = _interopRequireDefault(scale_1);



  var _scaleAndAdd2 = _interopRequireDefault(scaleAndAdd_1);



  var _normalize2 = _interopRequireDefault(normalize_1);



  var _HalfEdge2 = _interopRequireDefault(HalfEdge_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var debug = src('face');

  var VISIBLE = exports.VISIBLE = 0;
  var NON_CONVEX = exports.NON_CONVEX = 1;
  var DELETED = exports.DELETED = 2;

  var Face = function () {
    function Face() {
      _classCallCheck(this, Face);

      this.normal = [];
      this.centroid = [];
      // signed distance from face to the origin
      this.offset = 0;
      // pointer to the a vertex in a double linked list this face can see
      this.outside = null;
      this.mark = VISIBLE;
      this.edge = null;
      this.nVertices = 0;
    }

    _createClass(Face, [{
      key: 'getEdge',
      value: function getEdge(i) {
        if (typeof i !== 'number') {
          throw Error('requires a number');
        }
        var it = this.edge;
        while (i > 0) {
          it = it.next;
          i -= 1;
        }
        while (i < 0) {
          it = it.prev;
          i += 1;
        }
        return it;
      }
    }, {
      key: 'computeNormal',
      value: function computeNormal() {
        var e0 = this.edge;
        var e1 = e0.next;
        var e2 = e1.next;
        var v2 = (0, _subtract2.default)([], e1.head().point, e0.head().point);
        var t = [];
        var v1 = [];

        this.nVertices = 2;
        this.normal = [0, 0, 0];
        while (e2 !== e0) {
          (0, _copy2.default)(v1, v2);
          (0, _subtract2.default)(v2, e2.head().point, e0.head().point);
          (0, _add2.default)(this.normal, this.normal, (0, _cross2.default)(t, v1, v2));
          e2 = e2.next;
          this.nVertices += 1;
        }
        this.area = (0, _length2.default)(this.normal);
        // normalize the vector, since we've already calculated the area
        // it's cheaper to scale the vector using this quantity instead of
        // doing the same operation again
        this.normal = (0, _scale2.default)(this.normal, this.normal, 1 / this.area);
      }
    }, {
      key: 'computeNormalMinArea',
      value: function computeNormalMinArea(minArea) {
        this.computeNormal();
        if (this.area < minArea) {
          // compute the normal without the longest edge
          var maxEdge = void 0;
          var maxSquaredLength = 0;
          var edge = this.edge;

          // find the longest edge (in length) in the chain of edges
          do {
            var lengthSquared = edge.lengthSquared();
            if (lengthSquared > maxSquaredLength) {
              maxEdge = edge;
              maxSquaredLength = lengthSquared;
            }
            edge = edge.next;
          } while (edge !== this.edge);

          var p1 = maxEdge.tail().point;
          var p2 = maxEdge.head().point;
          var maxVector = (0, _subtract2.default)([], p2, p1);
          var maxLength = Math.sqrt(maxSquaredLength);
          // maxVector is normalized after this operation
          (0, _scale2.default)(maxVector, maxVector, 1 / maxLength);
          // compute the projection of maxVector over this face normal
          var maxProjection = (0, _dot2.default)(this.normal, maxVector);
          // subtract the quantity maxEdge adds on the normal
          (0, _scaleAndAdd2.default)(this.normal, this.normal, maxVector, -maxProjection);
          // renormalize `this.normal`
          (0, _normalize2.default)(this.normal, this.normal);
        }
      }
    }, {
      key: 'computeCentroid',
      value: function computeCentroid() {
        this.centroid = [0, 0, 0];
        var edge = this.edge;
        do {
          (0, _add2.default)(this.centroid, this.centroid, edge.head().point);
          edge = edge.next;
        } while (edge !== this.edge);
        (0, _scale2.default)(this.centroid, this.centroid, 1 / this.nVertices);
      }
    }, {
      key: 'computeNormalAndCentroid',
      value: function computeNormalAndCentroid(minArea) {
        if (typeof minArea !== 'undefined') {
          this.computeNormalMinArea(minArea);
        } else {
          this.computeNormal();
        }
        this.computeCentroid();
        this.offset = (0, _dot2.default)(this.normal, this.centroid);
      }
    }, {
      key: 'distanceToPlane',
      value: function distanceToPlane(point) {
        return (0, _dot2.default)(this.normal, point) - this.offset;
      }

      /**
       * @private
       *
       * Connects two edges assuming that prev.head().point === next.tail().point
       *
       * @param {HalfEdge} prev
       * @param {HalfEdge} next
       */

    }, {
      key: 'connectHalfEdges',
      value: function connectHalfEdges(prev, next) {
        var discardedFace = void 0;
        if (prev.opposite.face === next.opposite.face) {
          // `prev` is remove a redundant edge
          var oppositeFace = next.opposite.face;
          var oppositeEdge = void 0;
          if (prev === this.edge) {
            this.edge = next;
          }
          if (oppositeFace.nVertices === 3) {
            // case:
            // remove the face on the right
            //
            //       /|\
            //      / | \ the face on the right
            //     /  |  \ --> opposite edge
            //    / a |   \
            //   *----*----*
            //  /     b  |  \
            //           â–¾
            //      redundant edge
            //
            // Note: the opposite edge is actually in the face to the right
            // of the face to be destroyed
            oppositeEdge = next.opposite.prev.opposite;
            oppositeFace.mark = DELETED;
            discardedFace = oppositeFace;
          } else {
            // case:
            //          t
            //        *----
            //       /| <- right face's redundant edge
            //      / | opposite edge
            //     /  |  â–´   /
            //    / a |  |  /
            //   *----*----*
            //  /     b  |  \
            //           â–¾
            //      redundant edge
            oppositeEdge = next.opposite.next;
            // make sure that the link `oppositeFace.edge` points correctly even
            // after the right face redundant edge is removed
            if (oppositeFace.edge === oppositeEdge.prev) {
              oppositeFace.edge = oppositeEdge;
            }

            //       /|   /
            //      / | t/opposite edge
            //     /  | / â–´  /
            //    / a |/  | /
            //   *----*----*
            //  /     b     \
            oppositeEdge.prev = oppositeEdge.prev.prev;
            oppositeEdge.prev.next = oppositeEdge;
          }
          //       /|
          //      / |
          //     /  |
          //    / a |
          //   *----*----*
          //  /     b  â–´  \
          //           |
          //     redundant edge
          next.prev = prev.prev;
          next.prev.next = next;

          //       / \  \
          //      /   \->\
          //     /     \<-\ opposite edge
          //    / a     \  \
          //   *----*----*
          //  /     b  ^  \
          next.setOpposite(oppositeEdge);

          oppositeFace.computeNormalAndCentroid();
        } else {
          // trivial case
          //        *
          //       /|\
          //      / | \
          //     /  |--> next
          //    / a |   \
          //   *----*----*
          //    \ b |   /
          //     \  |--> prev
          //      \ | /
          //       \|/
          //        *
          prev.next = next;
          next.prev = prev;
        }
        return discardedFace;
      }
    }, {
      key: 'mergeAdjacentFaces',
      value: function mergeAdjacentFaces(adjacentEdge, discardedFaces) {
        var oppositeEdge = adjacentEdge.opposite;
        var oppositeFace = oppositeEdge.face;

        discardedFaces.push(oppositeFace);
        oppositeFace.mark = DELETED;

        // find the chain of edges whose opposite face is `oppositeFace`
        //
        //                ===>
        //      \         face         /
        //       * ---- * ---- * ---- *
        //      /     opposite face    \
        //                <===
        //
        var adjacentEdgePrev = adjacentEdge.prev;
        var adjacentEdgeNext = adjacentEdge.next;
        var oppositeEdgePrev = oppositeEdge.prev;
        var oppositeEdgeNext = oppositeEdge.next;

        // left edge
        while (adjacentEdgePrev.opposite.face === oppositeFace) {
          adjacentEdgePrev = adjacentEdgePrev.prev;
          oppositeEdgeNext = oppositeEdgeNext.next;
        }
        // right edge
        while (adjacentEdgeNext.opposite.face === oppositeFace) {
          adjacentEdgeNext = adjacentEdgeNext.next;
          oppositeEdgePrev = oppositeEdgePrev.prev;
        }
        // adjacentEdgePrev  \         face         / adjacentEdgeNext
        //                    * ---- * ---- * ---- *
        // oppositeEdgeNext  /     opposite face    \ oppositeEdgePrev

        // fix the face reference of all the opposite edges that are not part of
        // the edges whose opposite face is not `face` i.e. all the edges that
        // `face` and `oppositeFace` do not have in common
        var edge = void 0;
        for (edge = oppositeEdgeNext; edge !== oppositeEdgePrev.next; edge = edge.next) {
          edge.face = this;
        }

        // make sure that `face.edge` is not one of the edges to be destroyed
        // Note: it's important for it to be a `next` edge since `prev` edges
        // might be destroyed on `connectHalfEdges`
        this.edge = adjacentEdgeNext;

        // connect the extremes
        // Note: it might be possible that after connecting the edges a triangular
        // face might be redundant
        var discardedFace = void 0;
        discardedFace = this.connectHalfEdges(oppositeEdgePrev, adjacentEdgeNext);
        if (discardedFace) {
          discardedFaces.push(discardedFace);
        }
        discardedFace = this.connectHalfEdges(adjacentEdgePrev, oppositeEdgeNext);
        if (discardedFace) {
          discardedFaces.push(discardedFace);
        }

        this.computeNormalAndCentroid();
        // TODO: additional consistency checks
        return discardedFaces;
      }
    }, {
      key: 'collectIndices',
      value: function collectIndices() {
        var indices = [];
        var edge = this.edge;
        do {
          indices.push(edge.head().index);
          edge = edge.next;
        } while (edge !== this.edge);
        return indices;
      }
    }], [{
      key: 'createTriangle',
      value: function createTriangle(v0, v1, v2) {
        var minArea = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        var face = new Face();
        var e0 = new _HalfEdge2.default(v0, face);
        var e1 = new _HalfEdge2.default(v1, face);
        var e2 = new _HalfEdge2.default(v2, face);

        // join edges
        e0.next = e2.prev = e1;
        e1.next = e0.prev = e2;
        e2.next = e1.prev = e0;

        // main half edge reference
        face.edge = e0;
        face.computeNormalAndCentroid(minArea);
        if (debug.enabled) {
          debug('face created %j', face.collectIndices());
        }
        return face;
      }
    }]);

    return Face;
  }();

  exports.default = Face;
  });

  unwrapExports(Face_1);
  var Face_2 = Face_1.DELETED;
  var Face_3 = Face_1.NON_CONVEX;
  var Face_4 = Face_1.VISIBLE;

  var QuickHull_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



  var _pointLineDistance2 = _interopRequireDefault(pointLineDistance);



  var _getPlaneNormal2 = _interopRequireDefault(getPlaneNormal);



  var _dot2 = _interopRequireDefault(dot_1);



  var _VertexList2 = _interopRequireDefault(VertexList_1);



  var _Vertex2 = _interopRequireDefault(Vertex_1);



  var _Face2 = _interopRequireDefault(Face_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var debug = src('quickhull');

  // merge types
  // non convex with respect to the large face
  var MERGE_NON_CONVEX_WRT_LARGER_FACE = 1;
  var MERGE_NON_CONVEX = 2;

  var QuickHull = function () {
    function QuickHull(points) {
      _classCallCheck(this, QuickHull);

      if (!Array.isArray(points)) {
        throw TypeError('input is not a valid array');
      }
      if (points.length < 4) {
        throw Error('cannot build a simplex out of <4 points');
      }

      this.tolerance = -1;

      // buffers
      this.nFaces = 0;
      this.nPoints = points.length;

      this.faces = [];
      this.newFaces = [];
      // helpers
      //
      // let `a`, `b` be `Face` instances
      // let `v` be points wrapped as instance of `Vertex`
      //
      //     [v, v, ..., v, v, v, ...]
      //      ^             ^
      //      |             |
      //  a.outside     b.outside
      //
      this.claimed = new _VertexList2.default();
      this.unclaimed = new _VertexList2.default();

      // vertices of the hull(internal representation of points)
      this.vertices = [];
      for (var i = 0; i < points.length; i += 1) {
        this.vertices.push(new _Vertex2.default(points[i], i));
      }
      this.discardedFaces = [];
      this.vertexPointIndices = [];
    }

    _createClass(QuickHull, [{
      key: 'addVertexToFace',
      value: function addVertexToFace(vertex, face) {
        vertex.face = face;
        if (!face.outside) {
          this.claimed.add(vertex);
        } else {
          this.claimed.insertBefore(face.outside, vertex);
        }
        face.outside = vertex;
      }

      /**
       * Removes `vertex` for the `claimed` list of vertices, it also makes sure
       * that the link from `face` to the first vertex it sees in `claimed` is
       * linked correctly after the removal
       *
       * @param {Vertex} vertex
       * @param {Face} face
       */

    }, {
      key: 'removeVertexFromFace',
      value: function removeVertexFromFace(vertex, face) {
        if (vertex === face.outside) {
          // fix face.outside link
          if (vertex.next && vertex.next.face === face) {
            // face has at least 2 outside vertices, move the `outside` reference
            face.outside = vertex.next;
          } else {
            // vertex was the only outside vertex that face had
            face.outside = null;
          }
        }
        this.claimed.remove(vertex);
      }

      /**
       * Removes all the visible vertices that `face` is able to see which are
       * stored in the `claimed` vertext list
       *
       * @param {Face} face
       * @return {Vertex|undefined} If face had visible vertices returns
       * `face.outside`, otherwise undefined
       */

    }, {
      key: 'removeAllVerticesFromFace',
      value: function removeAllVerticesFromFace(face) {
        if (face.outside) {
          // pointer to the last vertex of this face
          // [..., outside, ..., end, outside, ...]
          //          |           |      |
          //          a           a      b
          var end = face.outside;
          while (end.next && end.next.face === face) {
            end = end.next;
          }
          this.claimed.removeChain(face.outside, end);
          //                            b
          //                       [ outside, ...]
          //                            |  removes this link
          //     [ outside, ..., end ] -â”˜
          //          |           |
          //          a           a
          end.next = null;
          return face.outside;
        }
      }

      /**
       * Removes all the visible vertices that `face` is able to see, additionally
       * checking the following:
       *
       * If `absorbingFace` doesn't exist then all the removed vertices will be
       * added to the `unclaimed` vertex list
       *
       * If `absorbingFace` exists then this method will assign all the vertices of
       * `face` that can see `absorbingFace`, if a vertex cannot see `absorbingFace`
       * it's added to the `unclaimed` vertex list
       *
       * @param {Face} face
       * @param {Face} [absorbingFace]
       */

    }, {
      key: 'deleteFaceVertices',
      value: function deleteFaceVertices(face, absorbingFace) {
        var faceVertices = this.removeAllVerticesFromFace(face);
        if (faceVertices) {
          if (!absorbingFace) {
            // mark the vertices to be reassigned to some other face
            this.unclaimed.addAll(faceVertices);
          } else {
            // if there's an absorbing face try to assign as many vertices
            // as possible to it

            // the reference `vertex.next` might be destroyed on
            // `this.addVertexToFace` (see VertexList#add), nextVertex is a
            // reference to it
            var nextVertex = void 0;
            for (var vertex = faceVertices; vertex; vertex = nextVertex) {
              nextVertex = vertex.next;
              var distance = absorbingFace.distanceToPlane(vertex.point);

              // check if `vertex` is able to see `absorbingFace`
              if (distance > this.tolerance) {
                this.addVertexToFace(vertex, absorbingFace);
              } else {
                this.unclaimed.add(vertex);
              }
            }
          }
        }
      }

      /**
       * Reassigns as many vertices as possible from the unclaimed list to the new
       * faces
       *
       * @param {Faces[]} newFaces
       */

    }, {
      key: 'resolveUnclaimedPoints',
      value: function resolveUnclaimedPoints(newFaces) {
        // cache next vertex so that if `vertex.next` is destroyed it's still
        // recoverable
        var vertexNext = this.unclaimed.first();
        for (var vertex = vertexNext; vertex; vertex = vertexNext) {
          vertexNext = vertex.next;
          var maxDistance = this.tolerance;
          var maxFace = void 0;
          for (var i = 0; i < newFaces.length; i += 1) {
            var face = newFaces[i];
            if (face.mark === Face_1.VISIBLE) {
              var dist = face.distanceToPlane(vertex.point);
              if (dist > maxDistance) {
                maxDistance = dist;
                maxFace = face;
              }
              if (maxDistance > 1000 * this.tolerance) {
                break;
              }
            }
          }

          if (maxFace) {
            this.addVertexToFace(vertex, maxFace);
          }
        }
      }

      /**
       * Computes the extremes of a tetrahedron which will be the initial hull
       *
       * @return {number[]} The min/max vertices in the x,y,z directions
       */

    }, {
      key: 'computeExtremes',
      value: function computeExtremes() {
        var me = this;
        var min = [];
        var max = [];

        // min vertex on the x,y,z directions
        var minVertices = [];
        // max vertex on the x,y,z directions
        var maxVertices = [];

        var i = void 0,
            j = void 0;

        // initially assume that the first vertex is the min/max
        for (i = 0; i < 3; i += 1) {
          minVertices[i] = maxVertices[i] = this.vertices[0];
        }
        // copy the coordinates of the first vertex to min/max
        for (i = 0; i < 3; i += 1) {
          min[i] = max[i] = this.vertices[0].point[i];
        }

        // compute the min/max vertex on all 6 directions
        for (i = 1; i < this.vertices.length; i += 1) {
          var vertex = this.vertices[i];
          var point = vertex.point;
          // update the min coordinates
          for (j = 0; j < 3; j += 1) {
            if (point[j] < min[j]) {
              min[j] = point[j];
              minVertices[j] = vertex;
            }
          }
          // update the max coordinates
          for (j = 0; j < 3; j += 1) {
            if (point[j] > max[j]) {
              max[j] = point[j];
              maxVertices[j] = vertex;
            }
          }
        }

        // compute epsilon
        this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min[0]), Math.abs(max[0])) + Math.max(Math.abs(min[1]), Math.abs(max[1])) + Math.max(Math.abs(min[2]), Math.abs(max[2])));
        if (debug.enabled) {
          debug('tolerance %d', me.tolerance);
        }
        return [minVertices, maxVertices];
      }

      /**
       * Compues the initial tetrahedron assigning to its faces all the points that
       * are candidates to form part of the hull
       */

    }, {
      key: 'createInitialSimplex',
      value: function createInitialSimplex() {
        var vertices = this.vertices;

        var _computeExtremes = this.computeExtremes(),
            _computeExtremes2 = _slicedToArray(_computeExtremes, 2),
            min = _computeExtremes2[0],
            max = _computeExtremes2[1];

        var v0 = void 0,
            v1 = void 0,
            v2 = void 0,
            v3 = void 0;
        var i = void 0,
            j = void 0;

        // Find the two vertices with the greatest 1d separation
        // (max.x - min.x)
        // (max.y - min.y)
        // (max.z - min.z)
        var maxDistance = 0;
        var indexMax = 0;
        for (i = 0; i < 3; i += 1) {
          var distance = max[i].point[i] - min[i].point[i];
          if (distance > maxDistance) {
            maxDistance = distance;
            indexMax = i;
          }
        }
        v0 = min[indexMax];
        v1 = max[indexMax];

        // the next vertex is the one farthest to the line formed by `v0` and `v1`
        maxDistance = 0;
        for (i = 0; i < this.vertices.length; i += 1) {
          var vertex = this.vertices[i];
          if (vertex !== v0 && vertex !== v1) {
            var _distance = (0, _pointLineDistance2.default)(vertex.point, v0.point, v1.point);
            if (_distance > maxDistance) {
              maxDistance = _distance;
              v2 = vertex;
            }
          }
        }

        // the next vertes is the one farthest to the plane `v0`, `v1`, `v2`
        // normalize((v2 - v1) x (v0 - v1))
        var normal = (0, _getPlaneNormal2.default)([], v0.point, v1.point, v2.point);
        // distance from the origin to the plane
        var distPO = (0, _dot2.default)(v0.point, normal);
        maxDistance = -1;
        for (i = 0; i < this.vertices.length; i += 1) {
          var _vertex = this.vertices[i];
          if (_vertex !== v0 && _vertex !== v1 && _vertex !== v2) {
            var _distance2 = Math.abs((0, _dot2.default)(normal, _vertex.point) - distPO);
            if (_distance2 > maxDistance) {
              maxDistance = _distance2;
              v3 = _vertex;
            }
          }
        }

        // initial simplex
        // Taken from http://everything2.com/title/How+to+paint+a+tetrahedron
        //
        //                              v2
        //                             ,|,
        //                           ,7``\'VA,
        //                         ,7`   |, `'VA,
        //                       ,7`     `\    `'VA,
        //                     ,7`        |,      `'VA,
        //                   ,7`          `\         `'VA,
        //                 ,7`             |,           `'VA,
        //               ,7`               `\       ,..ooOOTK` v3
        //             ,7`                  |,.ooOOT''`    AV
        //           ,7`            ,..ooOOT`\`           /7
        //         ,7`      ,..ooOOT''`      |,          AV
        //        ,T,..ooOOT''`              `\         /7
        //     v0 `'TTs.,                     |,       AV
        //            `'TTs.,                 `\      /7
        //                 `'TTs.,             |,    AV
        //                      `'TTs.,        `\   /7
        //                           `'TTs.,    |, AV
        //                                `'TTs.,\/7
        //                                     `'T`
        //                                       v1
        //
        var faces = [];
        if ((0, _dot2.default)(v3.point, normal) - distPO < 0) {
          // the face is not able to see the point so `planeNormal`
          // is pointing outside the tetrahedron
          faces.push(_Face2.default.createTriangle(v0, v1, v2), _Face2.default.createTriangle(v3, v1, v0), _Face2.default.createTriangle(v3, v2, v1), _Face2.default.createTriangle(v3, v0, v2));

          // set the opposite edge
          for (i = 0; i < 3; i += 1) {
            var _j = (i + 1) % 3;
            // join face[i] i > 0, with the first face
            faces[i + 1].getEdge(2).setOpposite(faces[0].getEdge(_j));
            // join face[i] with face[i + 1], 1 <= i <= 3
            faces[i + 1].getEdge(1).setOpposite(faces[_j + 1].getEdge(0));
          }
        } else {
          // the face is able to see the point so `planeNormal`
          // is pointing inside the tetrahedron
          faces.push(_Face2.default.createTriangle(v0, v2, v1), _Face2.default.createTriangle(v3, v0, v1), _Face2.default.createTriangle(v3, v1, v2), _Face2.default.createTriangle(v3, v2, v0));

          // set the opposite edge
          for (i = 0; i < 3; i += 1) {
            var _j2 = (i + 1) % 3;
            // join face[i] i > 0, with the first face
            faces[i + 1].getEdge(2).setOpposite(faces[0].getEdge((3 - i) % 3));
            // join face[i] with face[i + 1]
            faces[i + 1].getEdge(0).setOpposite(faces[_j2 + 1].getEdge(1));
          }
        }

        // the initial hull is the tetrahedron
        for (i = 0; i < 4; i += 1) {
          this.faces.push(faces[i]);
        }

        // initial assignment of vertices to the faces of the tetrahedron
        for (i = 0; i < vertices.length; i += 1) {
          var _vertex2 = vertices[i];
          if (_vertex2 !== v0 && _vertex2 !== v1 && _vertex2 !== v2 && _vertex2 !== v3) {
            maxDistance = this.tolerance;
            var maxFace = void 0;
            for (j = 0; j < 4; j += 1) {
              var _distance3 = faces[j].distanceToPlane(_vertex2.point);
              if (_distance3 > maxDistance) {
                maxDistance = _distance3;
                maxFace = faces[j];
              }
            }

            if (maxFace) {
              this.addVertexToFace(_vertex2, maxFace);
            }
          }
        }
      }
    }, {
      key: 'reindexFaceAndVertices',
      value: function reindexFaceAndVertices() {
        // remove inactive faces
        var activeFaces = [];
        for (var i = 0; i < this.faces.length; i += 1) {
          var face = this.faces[i];
          if (face.mark === Face_1.VISIBLE) {
            activeFaces.push(face);
          }
        }
        this.faces = activeFaces;
      }
    }, {
      key: 'collectFaces',
      value: function collectFaces(skipTriangulation) {
        var faceIndices = [];
        for (var i = 0; i < this.faces.length; i += 1) {
          if (this.faces[i].mark !== Face_1.VISIBLE) {
            throw Error('attempt to include a destroyed face in the hull');
          }
          var indices = this.faces[i].collectIndices();
          if (skipTriangulation) {
            faceIndices.push(indices);
          } else {
            for (var j = 0; j < indices.length - 2; j += 1) {
              faceIndices.push([indices[0], indices[j + 1], indices[j + 2]]);
            }
          }
        }
        return faceIndices;
      }

      /**
       * Finds the next vertex to make faces with the current hull
       *
       * - let `face` be the first face existing in the `claimed` vertex list
       *  - if `face` doesn't exist then return since there're no vertices left
       *  - otherwise for each `vertex` that face sees find the one furthest away
       *  from `face`
       *
       * @return {Vertex|undefined} Returns undefined when there're no more
       * visible vertices
       */

    }, {
      key: 'nextVertexToAdd',
      value: function nextVertexToAdd() {
        if (!this.claimed.isEmpty()) {
          var eyeVertex = void 0,
              vertex = void 0;
          var maxDistance = 0;
          var eyeFace = this.claimed.first().face;
          for (vertex = eyeFace.outside; vertex && vertex.face === eyeFace; vertex = vertex.next) {
            var distance = eyeFace.distanceToPlane(vertex.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              eyeVertex = vertex;
            }
          }
          return eyeVertex;
        }
      }

      /**
       * Computes a chain of half edges in ccw order called the `horizon`, for an
       * edge to be part of the horizon it must join a face that can see
       * `eyePoint` and a face that cannot see `eyePoint`
       *
       * @param {number[]} eyePoint - The coordinates of a point
       * @param {HalfEdge} crossEdge - The edge used to jump to the current `face`
       * @param {Face} face - The current face being tested
       * @param {HalfEdge[]} horizon - The edges that form part of the horizon in
       * ccw order
       */

    }, {
      key: 'computeHorizon',
      value: function computeHorizon(eyePoint, crossEdge, face, horizon) {
        // moves face's vertices to the `unclaimed` vertex list
        this.deleteFaceVertices(face);

        face.mark = Face_1.DELETED;

        var edge = void 0;
        if (!crossEdge) {
          edge = crossEdge = face.getEdge(0);
        } else {
          // start from the next edge since `crossEdge` was already analyzed
          // (actually `crossEdge.opposite` was the face who called this method
          // recursively)
          edge = crossEdge.next;
        }

        // All the faces that are able to see `eyeVertex` are defined as follows
        //
        //       v    /
        //           / <== visible face
        //          /
        //         |
        //         | <== not visible face
        //
        //  dot(v, visible face normal) - visible face offset > this.tolerance
        //
        do {
          var oppositeEdge = edge.opposite;
          var oppositeFace = oppositeEdge.face;
          if (oppositeFace.mark === Face_1.VISIBLE) {
            if (oppositeFace.distanceToPlane(eyePoint) > this.tolerance) {
              this.computeHorizon(eyePoint, oppositeEdge, oppositeFace, horizon);
            } else {
              horizon.push(edge);
            }
          }
          edge = edge.next;
        } while (edge !== crossEdge);
      }

      /**
       * Creates a face with the points `eyeVertex.point`, `horizonEdge.tail` and
       * `horizonEdge.tail` in ccw order
       *
       * @param {Vertex} eyeVertex
       * @param {HalfEdge} horizonEdge
       * @return {HalfEdge} The half edge whose vertex is the eyeVertex
       */

    }, {
      key: 'addAdjoiningFace',
      value: function addAdjoiningFace(eyeVertex, horizonEdge) {
        // all the half edges are created in ccw order thus the face is always
        // pointing outside the hull
        // edges:
        //
        //                  eyeVertex.point
        //                       / \
        //                      /   \
        //                  1  /     \  0
        //                    /       \
        //                   /         \
        //                  /           \
        //          horizon.tail --- horizon.head
        //                        2
        //
        var face = _Face2.default.createTriangle(eyeVertex, horizonEdge.tail(), horizonEdge.head());
        this.faces.push(face);
        // join face.getEdge(-1) with the horizon's opposite edge
        // face.getEdge(-1) = face.getEdge(2)
        face.getEdge(-1).setOpposite(horizonEdge.opposite);
        return face.getEdge(0);
      }

      /**
       * Adds horizon.length faces to the hull, each face will be 'linked' with the
       * horizon opposite face and the face on the left/right
       *
       * @param {Vertex} eyeVertex
       * @param {HalfEdge[]} horizon - A chain of half edges in ccw order
       */

    }, {
      key: 'addNewFaces',
      value: function addNewFaces(eyeVertex, horizon) {
        this.newFaces = [];
        var firstSideEdge = void 0,
            previousSideEdge = void 0;
        for (var i = 0; i < horizon.length; i += 1) {
          var horizonEdge = horizon[i];
          // returns the right side edge
          var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
          if (!firstSideEdge) {
            firstSideEdge = sideEdge;
          } else {
            // joins face.getEdge(1) with previousFace.getEdge(0)
            sideEdge.next.setOpposite(previousSideEdge);
          }
          this.newFaces.push(sideEdge.face);
          previousSideEdge = sideEdge;
        }
        firstSideEdge.next.setOpposite(previousSideEdge);
      }

      /**
       * Computes the distance from `edge` opposite face's centroid to
       * `edge.face`
       *
       * @param {HalfEdge} edge
       * @return {number}
       * - A positive number when the centroid of the opposite face is above the
       *   face i.e. when the faces are concave
       * - A negative number when the centroid of the opposite face is below the
       *   face i.e. when the faces are convex
       */

    }, {
      key: 'oppositeFaceDistance',
      value: function oppositeFaceDistance(edge) {
        return edge.face.distanceToPlane(edge.opposite.face.centroid);
      }

      /**
       * Merges a face with none/any/all its neighbors according to the strategy
       * used
       *
       * if `mergeType` is MERGE_NON_CONVEX_WRT_LARGER_FACE then the merge will be
       * decided based on the face with the larger area, the centroid of the face
       * with the smaller area will be checked against the one with the larger area
       * to see if it's in the merge range [tolerance, -tolerance] i.e.
       *
       *    dot(centroid smaller face, larger face normal) - larger face offset > -tolerance
       *
       * Note that the first check (with +tolerance) was done on `computeHorizon`
       *
       * If the above is not true then the check is done with respect to the smaller
       * face i.e.
       *
       *    dot(centroid larger face, smaller face normal) - smaller face offset > -tolerance
       *
       * If true then it means that two faces are non convex (concave), even if the
       * dot(...) - offset value is > 0 (that's the point of doing the merge in the
       * first place)
       *
       * If two faces are concave then the check must also be done on the other face
       * but this is done in another merge pass, for this to happen the face is
       * marked in a temporal NON_CONVEX state
       *
       * if `mergeType` is MERGE_NON_CONVEX then two faces will be merged only if
       * they pass the following conditions
       *
       *    dot(centroid smaller face, larger face normal) - larger face offset > -tolerance
       *    dot(centroid larger face, smaller face normal) - smaller face offset > -tolerance
       *
       * @param {Face} face
       * @param {number} mergeType - Either MERGE_NON_CONVEX_WRT_LARGER_FACE or
       * MERGE_NON_CONVEX
       */

    }, {
      key: 'doAdjacentMerge',
      value: function doAdjacentMerge(face, mergeType) {
        var edge = face.edge;
        var convex = true;
        var it = 0;
        do {
          if (it >= face.nVertices) {
            throw Error('merge recursion limit exceeded');
          }
          var oppositeFace = edge.opposite.face;
          var merge = false;

          // Important notes about the algorithm to merge faces
          //
          // - Given a vertex `eyeVertex` that will be added to the hull
          //   all the faces that cannot see `eyeVertex` are defined as follows
          //
          //      dot(v, not visible face normal) - not visible offset < tolerance
          //
          // - Two faces can be merged when the centroid of one of these faces
          // projected to the normal of the other face minus the other face offset
          // is in the range [tolerance, -tolerance]
          // - Since `face` (given in the input for this method) has passed the
          // check above we only have to check the lower bound e.g.
          //
          //      dot(v, not visible face normal) - not visible offset > -tolerance
          //
          if (mergeType === MERGE_NON_CONVEX) {
            if (this.oppositeFaceDistance(edge) > -this.tolerance || this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
              merge = true;
            }
          } else {
            if (face.area > oppositeFace.area) {
              if (this.oppositeFaceDistance(edge) > -this.tolerance) {
                merge = true;
              } else if (this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
                convex = false;
              }
            } else {
              if (this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
                merge = true;
              } else if (this.oppositeFaceDistance(edge) > -this.tolerance) {
                convex = false;
              }
            }
          }

          if (merge) {
            debug('face merge');
            // when two faces are merged it might be possible that redundant faces
            // are destroyed, in that case move all the visible vertices from the
            // destroyed faces to the `unclaimed` vertex list
            var discardedFaces = face.mergeAdjacentFaces(edge, []);
            for (var i = 0; i < discardedFaces.length; i += 1) {
              this.deleteFaceVertices(discardedFaces[i], face);
            }
            return true;
          }

          edge = edge.next;
          it += 1;
        } while (edge !== face.edge);
        if (!convex) {
          face.mark = Face_1.NON_CONVEX;
        }
        return false;
      }

      /**
       * Adds a vertex to the hull with the following algorithm
       *
       * - Compute the `horizon` which is a chain of half edges, for an edge to
       *   belong to this group it must be the edge connecting a face that can
       *   see `eyeVertex` and a face which cannot see `eyeVertex`
       * - All the faces that can see `eyeVertex` have its visible vertices removed
       *   from the claimed VertexList
       * - A new set of faces is created with each edge of the `horizon` and
       *   `eyeVertex`, each face is connected with the opposite horizon face and
       *   the face on the left/right
       * - The new faces are merged if possible with the opposite horizon face first
       *   and then the faces on the right/left
       * - The vertices removed from all the visible faces are assigned to the new
       *   faces if possible
       *
       * @param {Vertex} eyeVertex
       */

    }, {
      key: 'addVertexToHull',
      value: function addVertexToHull(eyeVertex) {
        var horizon = [];

        this.unclaimed.clear();

        // remove `eyeVertex` from `eyeVertex.face` so that it can't be added to the
        // `unclaimed` vertex list
        this.removeVertexFromFace(eyeVertex, eyeVertex.face);
        this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
        if (debug.enabled) {
          debug('horizon %j', horizon.map(function (edge) {
            return edge.head().index;
          }));
        }
        this.addNewFaces(eyeVertex, horizon);

        debug('first merge');

        // first merge pass
        // Do the merge with respect to the larger face
        for (var i = 0; i < this.newFaces.length; i += 1) {
          var face = this.newFaces[i];
          if (face.mark === Face_1.VISIBLE) {
            while (this.doAdjacentMerge(face, MERGE_NON_CONVEX_WRT_LARGER_FACE)) {}
          }
        }

        debug('second merge');

        // second merge pass
        // Do the merge on non convex faces (a face is marked as non convex in the
        // first pass)
        for (var _i = 0; _i < this.newFaces.length; _i += 1) {
          var _face = this.newFaces[_i];
          if (_face.mark === Face_1.NON_CONVEX) {
            _face.mark = Face_1.VISIBLE;
            while (this.doAdjacentMerge(_face, MERGE_NON_CONVEX)) {}
          }
        }

        debug('reassigning points to newFaces');
        // reassign `unclaimed` vertices to the new faces
        this.resolveUnclaimedPoints(this.newFaces);
      }
    }, {
      key: 'build',
      value: function build() {
        var iterations = 0;
        var eyeVertex = void 0;
        this.createInitialSimplex();
        while (eyeVertex = this.nextVertexToAdd()) {
          iterations += 1;
          debug('== iteration %j ==', iterations);
          debug('next vertex to add = %d %j', eyeVertex.index, eyeVertex.point);
          this.addVertexToHull(eyeVertex);
          debug('end');
        }
        this.reindexFaceAndVertices();
      }
    }]);

    return QuickHull;
  }();

  exports.default = QuickHull;
  module.exports = exports['default'];
  });

  var QuickHull = unwrapExports(QuickHull_1);

  const buildConvexHullImpl = (points) => {
    const hull = new QuickHull(points, { skipTriangulation: true });
    hull.build();
    const polygons = hull.collectFaces().map(polygon => polygon.map(nthPoint => points[nthPoint]));
    polygons.isConvex = true;
    return { solid: fromPolygons({}, polygons) };
  };

  const buildConvexHull = cache(buildConvexHullImpl);

  const buildConvexMinkowskiSumImpl = (aPoints, bPoints) => {
    const summedPoints = [];
    for (const aPoint of aPoints) {
      for (const summedPoint of translate$3(aPoint, bPoints)) {
        summedPoints.push(summedPoint);
      }
    }
    return buildConvexHull(summedPoints);
  };

  const buildConvexMinkowskiSum = cache(buildConvexMinkowskiSumImpl);

  var twoProduct_1 = twoProduct;

  var SPLITTER = +(Math.pow(2, 27) + 1.0);

  function twoProduct(a, b, result) {
    var x = a * b;

    var c = SPLITTER * a;
    var abig = c - a;
    var ahi = c - abig;
    var alo = a - ahi;

    var d = SPLITTER * b;
    var bbig = d - b;
    var bhi = d - bbig;
    var blo = b - bhi;

    var err1 = x - (ahi * bhi);
    var err2 = err1 - (alo * bhi);
    var err3 = err2 - (ahi * blo);

    var y = alo * blo - err3;

    if(result) {
      result[0] = y;
      result[1] = x;
      return result
    }

    return [ y, x ]
  }

  var robustSum = linearExpansionSum;

  //Easy case: Add two scalars
  function scalarScalar(a, b) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    var y = ar + br;
    if(y) {
      return [y, x]
    }
    return [x]
  }

  function linearExpansionSum(e, f) {
    var ne = e.length|0;
    var nf = f.length|0;
    if(ne === 1 && nf === 1) {
      return scalarScalar(e[0], f[0])
    }
    var n = ne + nf;
    var g = new Array(n);
    var count = 0;
    var eptr = 0;
    var fptr = 0;
    var abs = Math.abs;
    var ei = e[eptr];
    var ea = abs(ei);
    var fi = f[fptr];
    var fa = abs(fi);
    var a, b;
    if(ea < fa) {
      b = ei;
      eptr += 1;
      if(eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      b = fi;
      fptr += 1;
      if(fptr < nf) {
        fi = f[fptr];
        fa = abs(fi);
      }
    }
    if((eptr < ne && ea < fa) || (fptr >= nf)) {
      a = ei;
      eptr += 1;
      if(eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      a = fi;
      fptr += 1;
      if(fptr < nf) {
        fi = f[fptr];
        fa = abs(fi);
      }
    }
    var x = a + b;
    var bv = x - a;
    var y = b - bv;
    var q0 = y;
    var q1 = x;
    var _x, _bv, _av, _br, _ar;
    while(eptr < ne && fptr < nf) {
      if(ea < fa) {
        a = ei;
        eptr += 1;
        if(eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if(fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if(y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
    }
    while(eptr < ne) {
      a = ei;
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if(y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      eptr += 1;
      if(eptr < ne) {
        ei = e[eptr];
      }
    }
    while(fptr < nf) {
      a = fi;
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if(y) {
        g[count++] = y;
      } 
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      fptr += 1;
      if(fptr < nf) {
        fi = f[fptr];
      }
    }
    if(q0) {
      g[count++] = q0;
    }
    if(q1) {
      g[count++] = q1;
    }
    if(!count) {
      g[count++] = 0.0;  
    }
    g.length = count;
    return g
  }

  var twoSum = fastTwoSum;

  function fastTwoSum(a, b, result) {
  	var x = a + b;
  	var bv = x - a;
  	var av = x - bv;
  	var br = b - bv;
  	var ar = a - av;
  	if(result) {
  		result[0] = ar + br;
  		result[1] = x;
  		return result
  	}
  	return [ar+br, x]
  }

  var robustScale = scaleLinearExpansion;

  function scaleLinearExpansion(e, scale) {
    var n = e.length;
    if(n === 1) {
      var ts = twoProduct_1(e[0], scale);
      if(ts[0]) {
        return ts
      }
      return [ ts[1] ]
    }
    var g = new Array(2 * n);
    var q = [0.1, 0.1];
    var t = [0.1, 0.1];
    var count = 0;
    twoProduct_1(e[0], scale, q);
    if(q[0]) {
      g[count++] = q[0];
    }
    for(var i=1; i<n; ++i) {
      twoProduct_1(e[i], scale, t);
      var pq = q[1];
      twoSum(pq, t[0], q);
      if(q[0]) {
        g[count++] = q[0];
      }
      var a = t[1];
      var b = q[1];
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      q[1] = x;
      if(y) {
        g[count++] = y;
      }
    }
    if(q[1]) {
      g[count++] = q[1];
    }
    if(count === 0) {
      g[count++] = 0.0;
    }
    g.length = count;
    return g
  }

  var robustDiff = robustSubtract;

  //Easy case: Add two scalars
  function scalarScalar$1(a, b) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    var y = ar + br;
    if(y) {
      return [y, x]
    }
    return [x]
  }

  function robustSubtract(e, f) {
    var ne = e.length|0;
    var nf = f.length|0;
    if(ne === 1 && nf === 1) {
      return scalarScalar$1(e[0], -f[0])
    }
    var n = ne + nf;
    var g = new Array(n);
    var count = 0;
    var eptr = 0;
    var fptr = 0;
    var abs = Math.abs;
    var ei = e[eptr];
    var ea = abs(ei);
    var fi = -f[fptr];
    var fa = abs(fi);
    var a, b;
    if(ea < fa) {
      b = ei;
      eptr += 1;
      if(eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      b = fi;
      fptr += 1;
      if(fptr < nf) {
        fi = -f[fptr];
        fa = abs(fi);
      }
    }
    if((eptr < ne && ea < fa) || (fptr >= nf)) {
      a = ei;
      eptr += 1;
      if(eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      a = fi;
      fptr += 1;
      if(fptr < nf) {
        fi = -f[fptr];
        fa = abs(fi);
      }
    }
    var x = a + b;
    var bv = x - a;
    var y = b - bv;
    var q0 = y;
    var q1 = x;
    var _x, _bv, _av, _br, _ar;
    while(eptr < ne && fptr < nf) {
      if(ea < fa) {
        a = ei;
        eptr += 1;
        if(eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if(fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if(y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
    }
    while(eptr < ne) {
      a = ei;
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if(y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      eptr += 1;
      if(eptr < ne) {
        ei = e[eptr];
      }
    }
    while(fptr < nf) {
      a = fi;
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if(y) {
        g[count++] = y;
      } 
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      fptr += 1;
      if(fptr < nf) {
        fi = -f[fptr];
      }
    }
    if(q0) {
      g[count++] = q0;
    }
    if(q1) {
      g[count++] = q1;
    }
    if(!count) {
      g[count++] = 0.0;  
    }
    g.length = count;
    return g
  }

  var orientation_1 = createCommonjsModule(function (module) {






  var NUM_EXPAND = 5;

  var EPSILON     = 1.1102230246251565e-16;
  var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON;
  var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON;

  function cofactor(m, c) {
    var result = new Array(m.length-1);
    for(var i=1; i<m.length; ++i) {
      var r = result[i-1] = new Array(m.length-1);
      for(var j=0,k=0; j<m.length; ++j) {
        if(j === c) {
          continue
        }
        r[k++] = m[i][j];
      }
    }
    return result
  }

  function matrix(n) {
    var result = new Array(n);
    for(var i=0; i<n; ++i) {
      result[i] = new Array(n);
      for(var j=0; j<n; ++j) {
        result[i][j] = ["m", j, "[", (n-i-1), "]"].join("");
      }
    }
    return result
  }

  function sign(n) {
    if(n & 1) {
      return "-"
    }
    return ""
  }

  function generateSum(expr) {
    if(expr.length === 1) {
      return expr[0]
    } else if(expr.length === 2) {
      return ["sum(", expr[0], ",", expr[1], ")"].join("")
    } else {
      var m = expr.length>>1;
      return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
    }
  }

  function determinant(m) {
    if(m.length === 2) {
      return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
    } else {
      var expr = [];
      for(var i=0; i<m.length; ++i) {
        expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""));
      }
      return expr
    }
  }

  function orientation(n) {
    var pos = [];
    var neg = [];
    var m = matrix(n);
    var args = [];
    for(var i=0; i<n; ++i) {
      if((i&1)===0) {
        pos.push.apply(pos, determinant(cofactor(m, i)));
      } else {
        neg.push.apply(neg, determinant(cofactor(m, i)));
      }
      args.push("m" + i);
    }
    var posExpr = generateSum(pos);
    var negExpr = generateSum(neg);
    var funcName = "orientation" + n + "Exact";
    var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("");
    var proc = new Function("sum", "prod", "scale", "sub", code);
    return proc(robustSum, twoProduct_1, robustScale, robustDiff)
  }

  var orientation3Exact = orientation(3);
  var orientation4Exact = orientation(4);

  var CACHED = [
    function orientation0() { return 0 },
    function orientation1() { return 0 },
    function orientation2(a, b) { 
      return b[0] - a[0]
    },
    function orientation3(a, b, c) {
      var l = (a[1] - c[1]) * (b[0] - c[0]);
      var r = (a[0] - c[0]) * (b[1] - c[1]);
      var det = l - r;
      var s;
      if(l > 0) {
        if(r <= 0) {
          return det
        } else {
          s = l + r;
        }
      } else if(l < 0) {
        if(r >= 0) {
          return det
        } else {
          s = -(l + r);
        }
      } else {
        return det
      }
      var tol = ERRBOUND3 * s;
      if(det >= tol || det <= -tol) {
        return det
      }
      return orientation3Exact(a, b, c)
    },
    function orientation4(a,b,c,d) {
      var adx = a[0] - d[0];
      var bdx = b[0] - d[0];
      var cdx = c[0] - d[0];
      var ady = a[1] - d[1];
      var bdy = b[1] - d[1];
      var cdy = c[1] - d[1];
      var adz = a[2] - d[2];
      var bdz = b[2] - d[2];
      var cdz = c[2] - d[2];
      var bdxcdy = bdx * cdy;
      var cdxbdy = cdx * bdy;
      var cdxady = cdx * ady;
      var adxcdy = adx * cdy;
      var adxbdy = adx * bdy;
      var bdxady = bdx * ady;
      var det = adz * (bdxcdy - cdxbdy) 
              + bdz * (cdxady - adxcdy)
              + cdz * (adxbdy - bdxady);
      var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                    + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                    + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
      var tol = ERRBOUND4 * permanent;
      if ((det > tol) || (-det > tol)) {
        return det
      }
      return orientation4Exact(a,b,c,d)
    }
  ];

  function slowOrient(args) {
    var proc = CACHED[args.length];
    if(!proc) {
      proc = CACHED[args.length] = orientation(args.length);
    }
    return proc.apply(undefined, args)
  }

  function generateOrientationProc() {
    while(CACHED.length <= NUM_EXPAND) {
      CACHED.push(orientation(CACHED.length));
    }
    var args = [];
    var procArgs = ["slow"];
    for(var i=0; i<=NUM_EXPAND; ++i) {
      args.push("a" + i);
      procArgs.push("o" + i);
    }
    var code = [
      "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
    ];
    for(var i=2; i<=NUM_EXPAND; ++i) {
      code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");");
    }
    code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation");
    procArgs.push(code.join(""));

    var proc = Function.apply(undefined, procArgs);
    module.exports = proc.apply(undefined, [slowOrient].concat(CACHED));
    for(var i=0; i<=NUM_EXPAND; ++i) {
      module.exports[i] = CACHED[i];
    }
  }

  generateOrientationProc();
  });

  var monotoneConvexHull2d = monotoneConvexHull2D;

  var orient$1 = orientation_1[3];

  function monotoneConvexHull2D(points) {
    var n = points.length;

    if(n < 3) {
      var result = new Array(n);
      for(var i=0; i<n; ++i) {
        result[i] = i;
      }

      if(n === 2 &&
         points[0][0] === points[1][0] &&
         points[0][1] === points[1][1]) {
        return [0]
      }

      return result
    }

    //Sort point indices along x-axis
    var sorted = new Array(n);
    for(var i=0; i<n; ++i) {
      sorted[i] = i;
    }
    sorted.sort(function(a,b) {
      var d = points[a][0]-points[b][0];
      if(d) {
        return d
      }
      return points[a][1] - points[b][1]
    });

    //Construct upper and lower hulls
    var lower = [sorted[0], sorted[1]];
    var upper = [sorted[0], sorted[1]];

    for(var i=2; i<n; ++i) {
      var idx = sorted[i];
      var p   = points[idx];

      //Insert into lower list
      var m = lower.length;
      while(m > 1 && orient$1(
          points[lower[m-2]], 
          points[lower[m-1]], 
          p) <= 0) {
        m -= 1;
        lower.pop();
      }
      lower.push(idx);

      //Insert into upper list
      m = upper.length;
      while(m > 1 && orient$1(
          points[upper[m-2]], 
          points[upper[m-1]], 
          p) >= 0) {
        m -= 1;
        upper.pop();
      }
      upper.push(idx);
    }

    //Merge lists together
    var result = new Array(upper.length + lower.length - 2);
    var ptr    = 0;
    for(var i=0, nl=lower.length; i<nl; ++i) {
      result[ptr++] = lower[i];
    }
    for(var j=upper.length-2; j>0; --j) {
      result[ptr++] = upper[j];
    }

    //Return result
    return result
  }

  const buildConvexSurfaceHullImpl = (points) => {
    const hull = [];
    for (const nth of monotoneConvexHull2d(points)) {
      hull.push(points[nth]);
    }
    return { z0Surface: [hull.reverse()] };
  };

  const buildConvexSurfaceHull = cache(buildConvexSurfaceHullImpl);

  const EPSILON$4 = 1e-5;

  const buildWalls = (polygons, floor, roof) => {
    for (let start = floor.length - 1, end = 0; end < floor.length; start = end++) {
      // Remember that we are walking CCW.
      const a = deduplicate([floor[start], floor[end], roof[start]]);
      const b = deduplicate([floor[end], roof[end], roof[start]]);

      // Some of these polygons may become degenerate -- skip those.
      if (fromPolygon(a)) {
        polygons.push(a);
      }

      if (fromPolygon(b)) {
        polygons.push(b);
      }
    }
  };

  const buildPath = (op, latitude, resolution, context) => {
    const points = [];
    const step = 1 / resolution;
    for (let longitude = 0; longitude <= 1; longitude += step) {
      points.push(op(latitude, longitude, context));
    }
    return points;
  };

  // Build a tube from generated path slices.
  // The paths are assumed to connect in a 1:1 vertical relationship before deduplication.
  const buildFromFunctionImpl = (op, resolution, cap = true, context) => {
    const polygons = [];
    const step = 1 / resolution;
    let lastPath;
    for (let latitude = 0; latitude <= 1 + EPSILON$4; latitude += step) {
      const path = buildPath(op, latitude, resolution, context);
      if (lastPath !== undefined) {
        buildWalls(polygons, path, lastPath);
      } else {
        if (cap) {
          const deduplicatedPath = deduplicate(path);
          if (deduplicatedPath.length > 0) {
            polygons.push(...makeConvex$1([deduplicatedPath]));
          }
        }
      }
      lastPath = path;
    }
    for (const polygon of polygons) {
      assertGood(polygon);
    }
    if (cap) {
      const deduplicatedPath = deduplicate(flip(lastPath));
      if (deduplicatedPath.length > 0) {
        polygons.push(...makeConvex$1([deduplicatedPath]));
      }
    }
    const solid = { solid: fromPolygons({}, polygons) };
    return solid;
  };

  const buildFromFunction = cache(buildFromFunctionImpl);

  const buildWalls$1 = (polygons, floor, roof) => {
    for (let start = floor.length - 1, end = 0; end < floor.length; start = end++) {
      // Remember that we are walking CCW.
      const a = deduplicate([floor[start], floor[end], roof[start]]);
      const b = deduplicate([floor[end], roof[end], roof[start]]);

      // Some of these polygons may become degenerate -- skip those.
      if (fromPolygon(a)) {
        polygons.push(a);
      }

      if (fromPolygon(b)) {
        polygons.push(b);
      }
    }
  };

  // Build a tube from generated path slices.
  // The paths are assumed to connect in a 1:1 vertical relationship before deduplication.
  const buildFromSlices = (buildPath, resolution, cap = true) => {
    const polygons = [];
    const step = 1 / resolution;
    let lastPath;
    for (let t = 0; t <= 1; t += step) {
      const path = buildPath(t);
      if (lastPath !== undefined) {
        buildWalls$1(polygons, path, lastPath);
      } else {
        if (cap) {
          const deduplicatedPath = deduplicate(path);
          if (deduplicatedPath.length > 0) {
            polygons.push(...makeConvex$1([deduplicatedPath]));
          }
        }
      }
      lastPath = path;
    }
    for (const polygon of polygons) {
      assertGood(polygon);
    }
    if (cap) {
      const deduplicatedPath = deduplicate(lastPath);
      if (deduplicatedPath.length > 0) {
        polygons.push(...flip$4(makeConvex$1([deduplicatedPath])));
      }
    }

    return { solid: fromPolygons({}, flip$4(polygons)) };
  };

  const fromPointsAndPaths = ({ points = [], paths = [] }) => {
    const polygons = [];
    for (const path of paths) {
      polygons.push(fromPoints(path.map(nth => points[nth])));
    }
    return polygons;
  };

  // Unit icosahedron vertices.
  const points = [[0.850651, 0.000000, -0.525731],
                  [0.850651, -0.000000, 0.525731],
                  [-0.850651, -0.000000, 0.525731],
                  [-0.850651, 0.000000, -0.525731],
                  [0.000000, -0.525731, 0.850651],
                  [0.000000, 0.525731, 0.850651],
                  [0.000000, 0.525731, -0.850651],
                  [0.000000, -0.525731, -0.850651],
                  [-0.525731, -0.850651, -0.000000],
                  [0.525731, -0.850651, -0.000000],
                  [0.525731, 0.850651, 0.000000],
                  [-0.525731, 0.850651, 0.000000]];

  // Triangular decomposition structure.
  const paths = [[1, 9, 0], [0, 10, 1], [0, 7, 6], [0, 6, 10],
                 [0, 9, 7], [4, 1, 5], [9, 1, 4], [1, 10, 5],
                 [3, 8, 2], [2, 11, 3], [4, 5, 2], [2, 8, 4],
                 [5, 11, 2], [6, 7, 3], [3, 11, 6], [3, 7, 8],
                 [4, 8, 9], [5, 10, 11], [6, 11, 10], [7, 9, 8]];

  // FIX: Why aren't we computing the convex hull?
  const buildRegularIcosahedron = (options = {}) => {
    return fromPointsAndPaths({ points: points, paths: paths });
  };

  const buildPolygonFromPointsImpl = (points) => ({ surface: [points.map(([x = 0, y = 0, z = 0]) => [x, y, z])] });

  const buildPolygonFromPoints = cachePoints(buildPolygonFromPointsImpl);

  /**
   * Construct a regular unit polygon of a given edge count.
   * Note: radius and length must not conflict.
   *
   * @param {Object} [options] - options for construction
   * @param {Integer} [options.sides=32] - how many sides the polygon has.
   * @returns {PointArray} Array of points along the path of the circle in CCW winding.
   *
   * @example
   * const circlePoints = regularPolygon(32)
   *
   * @example
   * const squarePoints = regularPolygon(4)
   * })
   */
  const buildRegularPolygonImpl = (sides = 32) => {
    let points = [];
    for (let i = 0; i < sides; i++) {
      let radians = 2 * Math.PI * i / sides;
      let [x, y] = fromAngleRadians(radians);
      points.push([x, y, 0]);
    }
    points.isConvex = true;
    // FIX: Clean up the consumers of this result.
    const z0Surface = { z0Surface: [points] };
    return z0Surface;
  };

  const buildRegularPolygon = cache(buildRegularPolygonImpl);

  const extrudeImpl = (z0Surface, height = 1, depth = 0, cap = true) => {
    const normalize = createNormalize2();
    const surfaceOutline = outline(z0Surface, normalize);
    const polygons = [];
    const stepHeight = height - depth;

    // Build the walls.
    for (const polygon of surfaceOutline) {
      const wall = flip(polygon);
      const floor = translate([0, 0, depth + stepHeight * 0], wall);
      const roof = translate([0, 0, depth + stepHeight * 1], wall);
      // Walk around the floor to build the walls.
      for (let i = 0; i < floor.length; i++) {
        const floorStart = floor[i];
        const floorEnd = floor[(i + 1) % floor.length];
        const roofStart = roof[i];
        const roofEnd = roof[(i + 1) % roof.length];
        polygons.push([floorStart, roofStart, roofEnd, floorEnd]);
      }
    }

    if (cap) {
      // FIX: This is already Z0.
      // FIX: This is bringing the vertices out of alignment?
      const surface = makeConvex(surfaceOutline, normalize);

      // Roof goes up.
      const roof = translate$1([0, 0, height], surface);
      polygons.push(...roof);

      // floor faces down.
      const floor = translate$1([0, 0, depth], flip$4(surface));
      polygons.push(...floor);
    }

    const solid = fromPolygons({}, polygons);
    return solid;
  };

  const extrude = cache(extrudeImpl);

  /**
   * Construct a regular unit prism of a given edge count.
   * Note: radius and length must not conflict.
   *
   * @param {Object} [options] - options for construction
   * @param {Integer} [options.edges=32] - how many edges the polygon has.
   * @returns {PointArray} Array of points along the path of the circle in CCW winding.
   *
   * @example
   * const circlePoints = regularPolygon({ edges: 32 })
   */

  const buildRegularPrismImpl = (edges = 32) => {
    const surface = buildRegularPolygon(edges);
    surface.isConvex = true;
    return translate$4([0, 0, -0.5], { solid: extrude(surface.z0Surface, 1) });
  };

  const buildRegularPrism = cache(buildRegularPrismImpl);

  // Unit tetrahedron vertices.
  const points$1 = [[1, 1, 1], [-1, 1, -1], [1, -1, -1],
                  [-1, 1, -1], [-1, -1, 1], [1, -1, -1],
                  [1, 1, 1], [1, -1, -1], [-1, -1, 1],
                  [1, 1, 1], [-1, -1, 1], [-1, 1, -1]];

  const buildRegularTetrahedron = (options = {}) => buildConvexHull(points$1);

  const buildWalls$2 = (polygons, floor, roof) => {
    for (let start = floor.length - 1, end = 0; end < floor.length; start = end++) {
      // Remember that we are walking CCW.
      polygons.push(deduplicate([floor[start], floor[end], roof[end], roof[start]]));
    }
  };

  // Approximates a UV sphere.
  const buildRingSphereImpl = (resolution = 20) => {
    const polygons = [];
    let lastPath;

    const latitudinalResolution = 2 + resolution;
    const longitudinalResolution = 2 * latitudinalResolution;

    // Trace out latitudinal rings.
    const ring = buildRegularPolygon(longitudinalResolution);
    for (let slice = 0; slice <= latitudinalResolution; slice++) {
      let angle = Math.PI * 1.0 * slice / latitudinalResolution;
      let height = Math.cos(angle);
      let radius = Math.sin(angle);
      const points = ring.z0Surface[0]; // FIX: Make this less fragile.
      const scaledPath = scale$2([radius, radius, radius], points);
      const translatedPath = translate([0, 0, height], scaledPath);
      const path = translatedPath;
      if (lastPath !== undefined) {
        buildWalls$2(polygons, path, lastPath);
      }
      lastPath = path;
    }
    polygons.isConvex = true;
    for (const polygon of polygons) {
      assertGood(polygon);
    }
    const solid = { solid: fromPolygons({}, polygons) };
    return solid;
  };

  const buildRingSphere = cache(buildRingSphereImpl);

  var cache$1 = {
      '1': bezier1
    , '2': bezier2
    , '3': bezier3
    , '4': bezier4
  };

  var bezier = neat;
  var prepare_1 = prepare;

  function neat(arr, t) {
    return prepare(arr.length)(arr, t)
  }

  function prepare(pieces) {
    pieces = +pieces|0;
    if (!pieces) throw new Error('Cannot create a interpolator with no elements')
    if (cache$1[pieces]) return cache$1[pieces]

    var fn = ['var ut = 1 - t', ''];

    var n = pieces;
    while (n--) {
      for (var j = 0; j < n; j += 1) {
        if (n+1 === pieces) {
          fn.push('var p'+j+' = arr['+j+'] * ut + arr['+(j+1)+'] * t');
        } else
        if (n > 1) {
          fn.push('p'+j+' = p'+j+' * ut + p'+(j+1)+' * t');
        } else {
          fn.push('return p'+j+' * ut + p'+(j+1)+' * t');
        }
      }
      if (n > 1) fn.push('');
    }

    fn = [
      'return function bezier'+pieces+'(arr, t) {'
      , fn.map(function(s) { return '  ' + s }).join('\n')
      , '}'
    ].join('\n');

    return Function(fn)()
  }

  //
  // Including the first four degrees
  // manually - there's a slight performance penalty
  // to generated code. It's outweighed by
  // the gains of the optimisations, but always
  // helps to cover the most common cases :)
  //

  function bezier1(arr) {
    return arr[0]
  }

  function bezier2(arr, t) {
    return arr[0] + (arr[1] - arr[0]) * t
  }

  function bezier3(arr, t) {
    var ut = 1 - t;
    return (arr[0] * ut + arr[1] * t) * ut + (arr[1] * ut + arr[2] * t) * t
  }

  function bezier4(arr, t) {
    var ut = 1 - t;
    var a1 = arr[1] * ut + arr[2] * t;
    return ((arr[0] * ut + arr[1] * t) * ut + a1 * t) * ut + (a1 * ut + (arr[2] * ut + arr[3] * t) * t) * t
  }
  bezier.prepare = prepare_1;

  const interpolateCubicBezier = bezier.prepare(4);

  const buildWalls$3 = (polygons, floor, roof) => {
    for (let start = floor.length - 1, end = 0; end < floor.length; start = end++) {
      if (floor[start] === null || floor[end] === null) {
        continue;
      }
      // Remember that we are walking CCW.
      polygons.push([roof[start], roof[end], floor[start]]);
      polygons.push([roof[end], floor[end], floor[start]]);
    }
  };

  // Rotate a path around the X axis to produce the polygons of a solid.
  const loopImpl = (path, endRadians = Math.PI * 2, resolution = 16, pitch = 0) => {
    const stepRadians = (Math.PI * 2) / resolution;
    const pitchPerRadian = pitch / (Math.PI * 2);
    let lastPath;
    const polygons = [];
    if (endRadians !== Math.PI * 2 || pitch !== 0) {
      // Cap the loop.
      polygons.push(flip(path), translate([pitchPerRadian * endRadians, 0, 0], rotateX$1(endRadians, path)));
    }
    for (let radians = 0; radians < endRadians; radians += stepRadians) {
      const rotatedPath = translate([pitchPerRadian * radians, 0, 0], rotateX$1(radians, path));
      if (lastPath !== undefined) {
        buildWalls$3(polygons, rotatedPath, lastPath);
      }
      lastPath = rotatedPath;
    }
    if (lastPath !== undefined) {
      buildWalls$3(polygons, translate([pitchPerRadian * endRadians, 0, 0], rotateX$1(endRadians, path)), lastPath);
    }
    return { solid: fromPolygons({}, polygons) };
  };

  const loop = cache(loopImpl);

  const sin$1 = (a) => Math.sin(a / 360 * Math.PI * 2);

  const regularPolygonEdgeLengthToRadius = (length, edges) => length / (2 * sin$1(180 / edges));

  function getSqDist(p1, p2) {
      var dx = p1[0] - p2[0],
          dy = p1[1] - p2[1];

      return dx * dx + dy * dy;
  }

  // basic distance-based simplification
  var radialDistance = function simplifyRadialDist(points, tolerance) {
      if (points.length<=1)
          return points;
      tolerance = typeof tolerance === 'number' ? tolerance : 1;
      var sqTolerance = tolerance * tolerance;
      
      var prevPoint = points[0],
          newPoints = [prevPoint],
          point;

      for (var i = 1, len = points.length; i < len; i++) {
          point = points[i];

          if (getSqDist(point, prevPoint) > sqTolerance) {
              newPoints.push(point);
              prevPoint = point;
          }
      }

      if (prevPoint !== point) newPoints.push(point);

      return newPoints;
  };

  // square distance from a point to a segment
  function getSqSegDist(p, p1, p2) {
      var x = p1[0],
          y = p1[1],
          dx = p2[0] - x,
          dy = p2[1] - y;

      if (dx !== 0 || dy !== 0) {

          var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

          if (t > 1) {
              x = p2[0];
              y = p2[1];

          } else if (t > 0) {
              x += dx * t;
              y += dy * t;
          }
      }

      dx = p[0] - x;
      dy = p[1] - y;

      return dx * dx + dy * dy;
  }

  function simplifyDPStep(points, first, last, sqTolerance, simplified) {
      var maxSqDist = sqTolerance,
          index;

      for (var i = first + 1; i < last; i++) {
          var sqDist = getSqSegDist(points[i], points[first], points[last]);

          if (sqDist > maxSqDist) {
              index = i;
              maxSqDist = sqDist;
          }
      }

      if (maxSqDist > sqTolerance) {
          if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
          simplified.push(points[index]);
          if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
      }
  }

  // simplification using Ramer-Douglas-Peucker algorithm
  var douglasPeucker = function simplifyDouglasPeucker(points, tolerance) {
      if (points.length<=1)
          return points;
      tolerance = typeof tolerance === 'number' ? tolerance : 1;
      var sqTolerance = tolerance * tolerance;
      
      var last = points.length - 1;

      var simplified = [points[0]];
      simplifyDPStep(points, 0, last, sqTolerance, simplified);
      simplified.push(points[last]);

      return simplified;
  };

  //simplifies using both algorithms
  var simplifyPath = function simplify(points, tolerance) {
      points = radialDistance(points, tolerance);
      points = douglasPeucker(points, tolerance);
      return points;
  };

  var radialDistance$1 = radialDistance;
  var douglasPeucker$1 = douglasPeucker;
  simplifyPath.radialDistance = radialDistance$1;
  simplifyPath.douglasPeucker = douglasPeucker$1;

  const toRadiusFromApothem = (apothem, sides) => apothem / Math.cos(Math.PI / sides);

  const unitPolygon = (sides = 16) => Shape.fromGeometry(buildRegularPolygon(sides));

  // Note: radius here is circumradius.
  const toRadiusFromEdge = (edge, sides) => edge * regularPolygonEdgeLengthToRadius(1, sides);

  const ofRadius$1 = (radius, { sides = 16 } = {}) => unitPolygon(sides).scale(radius);
  const ofEdge = (edge, { sides = 16 }) => ofRadius$1(toRadiusFromEdge(edge, sides), { sides });
  const ofApothem = (apothem, { sides = 16 }) => ofRadius$1(toRadiusFromApothem(apothem, sides), { sides });
  const ofDiameter = (diameter, ...args) => ofRadius$1(diameter / 2, ...args);
  const ofPoints = (points) => Shape.fromGeometry(buildPolygonFromPoints(points));

  /**
   *
   * # Polygon
   *
   * ::: illustration { "view": { "position": [0, 0, 5] } }
   * ```
   * Polygon([0, 1],
   *         [1, 1],
   *         [1, 0],
   *         [0.2, 0.2])
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, -1, 50] } }
   * ```
   * Polygon({ edge: 10, sides: 6 })
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, -1, 50] } }
   * ```
   * assemble(
   *   Polygon({ apothem: 10, sides: 5 }),
   *   Circle(10).drop())
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, -1, 50] } }
   * ```
   * assemble(
   *   Circle(10),
   *   Polygon({ radius: 10, sides: 5 }).drop())
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, -1, 50] } }
   * ```
   * Polygon({ diameter: 20, sides: 3 })
   * ```
   * :::
   *
   **/

  const Polygon = (...args) => ofRadius$1(...args);

  Polygon.ofEdge = ofEdge;
  Polygon.ofApothem = ofApothem;
  Polygon.ofRadius = ofRadius$1;
  Polygon.ofDiameter = ofDiameter;
  Polygon.ofPoints = ofPoints;
  Polygon.toRadiusFromApothem = toRadiusFromApothem;

  /**
   *
   * # Circle (disc)
   *
   * Circles are approximated as surfaces delimeted by regular polygons.
   *
   * Properly speaking what is produced here are discs.
   * The circle perimeter can be extracted via outline().
   *
   * ::: illustration { "view": { "position": [0, 0, 10] } }
   * ```
   * Circle()
   * ```
   * :::
   * ::: illustration
   * ```
   * Circle(10)
   * ```
   * :::
   * ::: illustration
   * ```
   * Circle.ofRadius(10, { sides: 8 })
   * ```
   * :::
   * ::: illustration
   * ```
   * Circle.ofApothem(10, { sides: 8 })
   * ```
   * :::
   * ::: illustration
   * ```
   * Circle.ofApothem(10, { sides: 5 })
   *       .with(Circle.ofRadius(10, { sides: 5 }).drop(),
   *             Circle.ofRadius(10).outline().moveZ(0.01))
   * ```
   * :::
   * ::: illustration
   * ```
   * Circle.ofDiameter(20, { sides: 16 })
   * ```
   * :::
   * ::: illustration
   * ```
   * Circle.ofEdge(5, { sides: 5 })
   * ```
   * :::
   **/

  const ofEdge$1 = (edge = 1, { sides = 32 } = {}) => Polygon.ofEdge(edge, { sides });

  const ofRadius$2 = (radius = 1, { sides = 32 } = {}) => Polygon.ofRadius(radius, { sides });

  const ofApothem$1 = (apothem = 1, { sides = 32 } = {}) => Polygon.ofApothem(apothem, { sides });

  const ofDiameter$1 = (diameter = 1, { sides = 32 } = {}) => Polygon.ofDiameter(diameter, { sides });

  const Circle = (...args) => ofRadius$2(...args);

  Circle.ofEdge = ofEdge$1;
  Circle.ofApothem = ofApothem$1;
  Circle.ofRadius = ofRadius$2;
  Circle.ofDiameter = ofDiameter$1;
  Circle.toRadiusFromApothem = (radius = 1, sides = 32) => Polygon.toRadiusFromApothem(radius, sides);

  Circle.signature = 'Circle(radius:number = 1, { sides:number = 32 }) -> Shape';
  ofEdge$1.signature = 'Circle.ofEdge(edge:number = 1, { sides:number = 32 }) -> Shape';
  ofRadius$2.signature = 'Circle.ofRadius(radius:number = 1, { sides:number = 32 }) -> Shape';
  ofApothem$1.signature = 'Circle.ofApothem(apothem:number = 1, { sides:number = 32 }) -> Shape';
  ofDiameter$1.signature = 'Circle.ofDiameter(diameter:number = 1, { sides:number = 32 }) -> Shape';

  const buildPrism = (radius = 1, height = 1, sides = 32) =>
    Shape.fromGeometry(buildRegularPrism(sides)).scale([radius, radius, height]);

  /**
   *
   * # Prism
   *
   * Generates prisms.
   *
   * ::: illustration { "view": { "position": [10, 10, 10] } }
   * ```
   * Prism()
   * ```
   * :::
   *
   **/

  const ofRadius$3 = (radius = 1, height = 1, { sides = 3 } = {}) => buildPrism(radius, height, sides);
  const ofDiameter$2 = (diameter = 1, ...args) => ofRadius$3(diameter / 2, ...args);

  const toPathFromSurface = (shape) => {
    for (const { surface, z0Surface } of getAnySurfaces(shape.toKeptGeometry())) {
      const anySurface = surface || z0Surface;
      for (const path of anySurface) {
        return path;
      }
    }
    return [];
  };

  const ofFunction = (op, { resolution, cap = true, context } = {}) =>
    Shape.fromGeometry(buildFromFunction(op, resolution, cap, context));

  const ofSlices = (op, { slices = 2, cap = true } = {}) =>
    Shape.fromGeometry(buildFromSlices(t => toPathFromSurface(op(t)), slices, cap));

  const Prism = (...args) => ofRadius$3(...args);

  Prism.ofRadius = ofRadius$3;
  Prism.ofDiameter = ofDiameter$2;
  Prism.ofFunction = ofFunction;
  Prism.ofSlices = ofSlices;

  const ofRadius$4 = (radius = 1, height = 1, { sides = 32 } = {}) => {
    const fn = linear(radius, 0);
    return Prism.ofSlices(t => Circle(fn(t) * radius, { sides }).moveZ(t * height));
  };

  const ofDiameter$3 = (diameter, ...args) => ofRadius$4(diameter / 2, ...args);
  const ofApothem$2 = (apothem, ...args) => ofRadius$4(toRadiusFromApothem(apothem), ...args);

  const Cone = (...args) => ofRadius$4(...args);

  Cone.ofRadius = ofRadius$4;
  Cone.ofDiameter = ofDiameter$3;
  Cone.ofApothem = ofApothem$2;

  Cone.signature = 'Cone(radius:number, height:number, { sides:number = 32 }) -> Shape';
  Cone.ofRadius.signature = 'Cone.ofRadius(radius:number, height:number, { sides:number = 32 }) -> Shape';
  Cone.ofDiameter.signature = 'Cone.ofDiameter(diameter:number, height:number, { sides:number = 32 }) -> Shape';
  Cone.ofApothem.signature = 'Cone.ofApothem(apothem:number, height:number, { sides:number = 32 }) -> Shape';

  /**
   *
   * # Cube (cuboid)
   *
   * Generates cuboids.
   *
   * ::: illustration { "view": { "position": [10, 10, 10] } }
   * ```
   * Cube()
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cube(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [80, 80, 80] } }
   * ```
   * Cube(10, 20, 30)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cube.ofRadius(8)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cube.ofDiameter(16)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cube.ofApothem(8)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cube.fromCorners([0, 0, 0], [10, 10, 10])
   * ```
   * :::
   *
   **/

  // Geometry construction.

  const edgeScale = regularPolygonEdgeLengthToRadius(1, 4);

  const unitCube = () => Shape.fromGeometry(buildRegularPrism(4))
      .rotateZ(45)
      .scale([edgeScale, edgeScale, 1]);

  // Cube Interfaces.

  const ofSize = (width = 1, length, height) =>
    unitCube().scale([width,
                      length === undefined ? width : length,
                      height === undefined ? width : height]);

  const ofRadius$5 = (radius) => Shape.fromGeometry(buildRegularPrism(4))
      .rotateZ(45)
      .scale([radius, radius, radius / edgeScale]);

  const ofApothem$3 = (apothem) => ofRadius$5(toRadiusFromApothem(apothem, 4));

  const ofDiameter$4 = (diameter) => ofRadius$5(diameter / 2);

  const fromCorners = (corner1, corner2) => {
    const [c1x, c1y, c1z] = corner1;
    const [c2x, c2y, c2z] = corner2;
    const length = c2x - c1x;
    const width = c2y - c1y;
    const height = c2z - c1z;
    const center = [(c1x + c2x) / 2, (c1y + c2y) / 2, (c1z + c2z) / 2];
    return unitCube().scale([length, width, height]).move(...center);
  };

  const Cube = (...args) => ofSize(...args);

  Cube.ofSize = ofSize;
  Cube.ofRadius = ofRadius$5;
  Cube.ofApothem = ofApothem$3;
  Cube.ofDiameter = ofDiameter$4;
  Cube.fromCorners = fromCorners;

  Cube.signature = 'Cube(size:number = 1) -> Shape';
  Cube.ofSize.signature = 'Cube.ofSize(width:number = 1, length:number = 1, height:number = 1) -> Shape';
  Cube.ofRadius.signature = 'Cube.ofRadius(radius:number = 1) -> Shape';
  Cube.ofApothem.signature = 'Cube.ofApothem(apothem:number = 1) -> Shape';
  Cube.ofDiameter.signature = 'Cube.ofDiameter(diameter:number = 1) -> Shape';
  Cube.fromCorners.signature = 'Cube.fromCorners(corner1:point, corner2:point) -> Shape';

  const buildPrism$1 = (radius = 1, height = 1, sides = 32) =>
    Shape.fromGeometry(buildRegularPrism(sides)).scale([radius, radius, height]);

  /**
   *
   * # Cylinder
   *
   * Generates cylinders.
   *
   * ::: illustration { "view": { "position": [10, 10, 10] } }
   * ```
   * Cylinder()
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cylinder(10, 5)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cylinder.ofRadius(6, 10, { sides: 8 })
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cylinder.ofApothem(6, 10, { sides: 8 })
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Cylinder.ofDiameter(6, 8, { sides: 16 })
   * ```
   * :::
   *
   **/

  const ofRadius$6 = (radius = 1, height = 1, { sides = 32 } = {}) => buildPrism$1(radius, height, sides);
  const ofApothem$4 = (apothem = 1, height = 1, { sides = 32 } = {}) => ofRadius$6(toRadiusFromApothem(apothem, sides), height, { sides });
  const ofDiameter$5 = (diameter = 1, ...args) => ofRadius$6(diameter / 2, ...args);

  const toPathFromShape = (shape) => {
    for (const { paths } of getPaths(shape.toKeptGeometry())) {
      for (const path of paths) {
        return path;
      }
    }
    return [];
  };

  const ofFunction$1 = (op, { resolution, cap = true, context } = {}) =>
    Shape.fromGeometry(buildFromFunction(op, resolution, cap, context));

  const ofSlices$1 = (op, { slices = 2, cap = true } = {}) =>
    Shape.fromGeometry(buildFromSlices(slice => toPathFromShape(op(slice)), slices, cap));

  const Cylinder = (...args) => ofRadius$6(...args);

  Cylinder.ofRadius = ofRadius$6;
  Cylinder.ofApothem = ofApothem$4;
  Cylinder.ofDiameter = ofDiameter$5;
  Cylinder.ofFunction = ofFunction$1;
  Cylinder.ofSlices = ofSlices$1;

  Cylinder.signature = 'Cylinder(radius:number = 1, height:number = 1, { sides:number = 32 }) -> Shape';
  Cylinder.ofRadius.signature = 'Cylinder.ofRadius(radius:number = 1, height:number = 1, { sides:number = 32 }) -> Shape';
  Cylinder.ofDiameter.signature = 'Cylinder.ofDiameter(radius:number = 1, height:number = 1, { sides:number = 32 }) -> Shape';
  Cylinder.ofApothem.signature = 'Cylinder.ofApothem(radius:number = 1, height:number = 1, { sides:number = 32 }) -> Shape';
  Cylinder.ofSlices.signature = 'Cylinder.ofSlices(op:function, { slices:number = 2, cap:boolean = true }) -> Shape';
  Cylinder.ofFunction.signature = 'Cylinder.ofFunction(op:function, { resolution:number, cap:boolean = true, context:Object }) -> Shape';

  const Difference = (...args) => difference$5(...args);

  const Empty = (...shapes) => Shape.fromGeometry({ disjointAssembly: [{ solid: [] }, { surface: [] }, { paths: [] }] });

  /**
   *
   * # Hexagon
   *
   * ::: illustration { "view": { "position": [0, 0, 5] } }
   * ```
   * Hexagon()
   * ```
   * :::
   * ::: illustration
   * ```
   * Hexagon(20)
   * ```
   * :::
   **/

  const ofEdge$2 = (edge = 1) => Polygon.ofEdge(edge, { sides: 6 });
  const ofApothem$5 = (apothem = 1) => Polygon.ofApothem(apothem, { sides: 6 });
  const ofRadius$7 = (radius = 1) => Polygon.ofRadius(radius, { sides: 6 });
  const ofDiameter$6 = (diameter = 1) => Polygon.ofDiameter(diameter, { sides: 6 });

  const Hexagon = (...args) => ofRadius$7(...args);

  Hexagon.ofRadius = ofRadius$7;
  Hexagon.ofEdge = ofEdge$2;
  Hexagon.ofApothem = ofApothem$5;
  Hexagon.ofRadius = ofRadius$7;
  Hexagon.ofDiameter = ofDiameter$6;

  Hexagon.signature = 'Hexagon(radius:number = 1) -> Shape';
  Hexagon.ofRadius.signature = 'Hexagon.ofRadius(radius:number = 1) -> Shape';
  Hexagon.ofDiameter.signature = 'Hexagon.ofDiameter(diameter:number = 1) -> Shape';
  Hexagon.ofApothem.signature = 'Hexagon.ofApothem(apothem:number = 1) -> Shape';
  Hexagon.ofEdge.signature = 'Hexagon.ofEdge(edge:number = 1) -> Shape';

  /**
   *
   * # Icosahedron
   *
   * Generates tetrahedrons.
   *
   * ::: illustration { "view": { "position": [8, 8, 8] } }
   * ```
   * Icosahedron()
   * ```
   * :::
   * ::: illustration { "view": { "position": [80, 80, 80] } }
   * ```
   * Icosahedron(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [60, 60, 60] } }
   * ```
   * Icosahedron({ radius: 8 })
   * ```
   * :::
   * ::: illustration { "view": { "position": [60, 60, 60] } }
   * ```
   * Icosahedron({ diameter: 16 })
   * ```
   * :::
   *
   **/

  const unitIcosahedron = () => Shape.fromPolygonsToSolid(buildRegularIcosahedron({}));

  const ofRadius$8 = (radius = 1) => unitIcosahedron().scale(radius);
  const ofDiameter$7 = (diameter = 1) => unitIcosahedron().scale(diameter / 2);
  const Icosahedron = (...args) => ofRadius$8(...args);

  Icosahedron.ofRadius = ofRadius$8;
  Icosahedron.ofDiameter = ofDiameter$7;

  Icosahedron.signature = 'Icosahedron(radius:number = 1) -> Shape';
  Icosahedron.ofRadius.signature = 'Icosahedron.ofRadius(radius:number = 1) -> Shape';
  Icosahedron.ofDiameter.signature = 'Icosahedron.ofDiameter(diameter:number = 1) -> Shape';

  const Intersection = (...args) => intersection$5(...args);

  const Layers = (...shapes) => Shape.fromGeometry({ layers: shapes.map(shape => shape.toGeometry()) });

  const fromPoints$3 = (...points) => Shape.fromOpenPath(points.map(([x = 0, y = 0, z = 0]) => [x, y, z]));

  /**
   *
   * # Path
   *
   * ::: illustration { "view": { "position": [0, 0, 5] } }
   * ```
   * Path([0, 1],
   *      [1, 1],
   *      [1, 0],
   *      [0.2, 0.2])
   * ```
   * :::
   *
   **/

  const Path = (...points) => fromPoints$3(...points);
  Path.fromPoints = fromPoints$3;

  Path.signature = 'Path(...points:Point) -> Shape';
  Path.fromPoints.signature = 'Path.fromPoints(...points:Point) -> Shape';

  const Line = (length) => Path([0, 0, length / -2], [0, 0, length / 2]);

  Line.signature = 'Line(length:number) -> Shape';

  const fromPoint$1 = (x = 0, y = 0, z = 0) => Shape.fromPoint([x, y, z]);
  const Point = (...args) => fromPoint$1(...args);
  Point.fromPoint = fromPoint$1;

  Point.signature = 'Point(point:Point) -> Shape';

  const fromPoints$4 = (points) => Shape.fromPoints(points);

  /**
   *
   * # Points
   *
   * Generates point cloud.
   *
   * Note: The points are not visible in the illustrations below.
   *
   * ::: illustration
   * ```
   * Points([ -0.5, -0.5, -0.5 ],
   *        [ -0.5, -0.5, 0.5 ],
   *        [ -0.5, 0.5, -0.5 ],
   *        [ -0.5, 0.5, 0.5 ],
   *        [ 0.5, -0.5, -0.5 ],
   *        [ 0.5, -0.5, 0.5 ],
   *        [ 0.5, 0.5, -0.5 ],
   *        [ 0.5, 0.5, 0.5 ])
   * ```
   * :::
   * ::: illustration { "view": { "position": [5, 5, 5] } }
   * ```
   * hull(Points([ -0.5, -0.5, -0.5 ],
   *             [ -0.5, -0.5, 0.5 ],
   *             [ -0.5, 0.5, -0.5 ],
   *             [ -0.5, 0.5, 0.5 ],
   *             [ 0.5, -0.5, -0.5 ],
   *             [ 0.5, -0.5, 0.5 ],
   *             [ 0.5, 0.5, -0.5 ],
   *             [ 0.5, 0.5, 0.5 ]))
   * ```
   * :::
   *
   **/

  const Points = (...args) => fromPoints$4(...args);
  Points.fromPoints = fromPoints$4;

  /**
   *
   * # Polyhedron
   *
   * ::: illustration { "view": { "position": [80, 20, 20] } }
   * ```
   * Polyhedron([[10, 10, 0], [10, -10, 0], [-10, -10, 0], [-10, 10, 0], [0, 0, 10]],
   *            [[4, 1, 0], [4, 2, 1], [4, 3, 2], [4, 0, 3], [3, 0, 1], [3, 1, 2]] })
   * ```
   * :::
   *
   **/

  const ofPointPaths = (points = [], paths = []) => {
    const polygons = [];
    for (const path of paths) {
      polygons.push(path.map(point => points[point]));
    }
    return Shape.fromPolygonsToSolid(polygons);
  };

  const Polyhedron = (...args) => ofPointPaths(...args);

  Polyhedron.ofPointPaths = ofPointPaths;

  /**
   *
   * # Sphere
   *
   * Generates spheres.
   *
   * ::: illustration { "view": { "position": [5, 5, 5] } }
   * ```
   * Sphere()
   * ```
   * :::
   * ::: illustration { "view": { "position": [60, 60, 60] } }
   * ```
   * Sphere(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Sphere({ radius: 8, resolution: 5 })
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * Sphere({ diameter: 16, resolution: 64 })
   * ```
   * :::
   *
   **/

  const unitSphere = (resolution = 16) => {
    const shape = Shape.fromGeometry(buildRingSphere(resolution));
    // Make convex.
    shape.toGeometry().solid.isConvex = true;
    return shape;
  };

  const ofRadius$9 = (radius = 1, { resolution = 16 } = {}) => unitSphere(resolution).scale(radius);
  const ofApothem$6 = (apothem = 1, { resolution = 16 } = {}) => ofRadius$9(toRadiusFromApothem(apothem), { resolution });
  const ofDiameter$8 = (diameter = 1, { resolution = 16 } = {}) => ofRadius$9(diameter / 2, { resolution });

  const Sphere = (...args) => ofRadius$9(...args);

  Sphere.ofApothem = ofApothem$6;
  Sphere.ofRadius = ofRadius$9;
  Sphere.ofDiameter = ofDiameter$8;

  /**
   *
   * # Square (rectangle)
   *
   * Properly speaking what is produced here are rectangles.
   *
   * ::: illustration { "view": { "position": [0, 0, 10] } }
   * ```
   * Square()
   * ```
   * :::
   * ::: illustration
   * ```
   * Square(10)
   * ```
   * :::
   * ::: illustration
   * ```
   * Square(6, 12)
   * ```
   * :::
   * ::: illustration
   * ```
   * Square({ edge: 10 })
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Circle(10),
   *          Square({ radius: 10 })
   *            .drop())
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Square({ apothem: 10 }),
   *          Circle(10).drop())
   * ```
   * :::
   * ::: illustration
   * ```
   * Square({ diameter: 20 })
   * ```
   * :::
   **/

  const toRadiusFromApothem$1 = (apothem) => apothem / Math.cos(Math.PI / 4);

  const edgeScale$1 = regularPolygonEdgeLengthToRadius(1, 4);
  const unitSquare = () => Shape.fromGeometry(buildRegularPolygon(4)).rotateZ(45).scale(edgeScale$1);

  const ofSize$1 = (width = 1, length) => unitSquare().scale([width, length === undefined ? width : length, 1]);
  const ofRadius$a = (radius) => Shape.fromGeometry(buildRegularPolygon(4)).rotateZ(45).scale(radius);
  const ofApothem$7 = (apothem) => ofRadius$a(toRadiusFromApothem$1(apothem));
  const ofDiameter$9 = (diameter) => ofRadius$a(diameter / 2);

  const fromCorners$1 = (corner1, corner2) => {
    const [c1x, c1y] = corner1;
    const [c2x, c2y] = corner2;
    const length = c2x - c1x;
    const width = c2y - c1y;
    const center = [(c1x + c2x) / 2, (c1y + c2y) / 2];
    return unitSquare().scale([length, width]).translate(center);
  };

  const Square = (...args) => ofSize$1(...args);

  Square.ofSize = ofSize$1;
  Square.ofRadius = ofRadius$a;
  Square.ofApothem = ofApothem$7;
  Square.ofDiameter = ofDiameter$9;
  Square.fromCorners = fromCorners$1;

  Square.signature = 'Square(edge:number) -> Surface';
  Square.ofApothem.signature = 'Square(apothem:number) -> Surface';
  Square.ofDiameter.signature = 'Square(diameter:number) -> Surface';
  Square.ofRadius.signature = 'Square(radius:number) -> Surface';
  Square.ofSize.signature = 'Square(edge:number) -> Surface';
  Square.fromCorners.signature = 'Square(corner1:Point, corner2:Point) -> Surface';

  /**
   *
   * # Tetrahedron
   *
   * Generates tetrahedrons.
   *
   * ::: illustration { "view": { "position": [8, 8, 8] } }
   * ```
   * Tetrahedron()
   * ```
   * :::
   * ::: illustration { "view": { "position": [80, 80, 80] } }
   * ```
   * Tetrahedron(10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [60, 60, 60] } }
   * ```
   * Tetrahedron({ radius: 8 })
   * ```
   * :::
   * ::: illustration { "view": { "position": [60, 60, 60] } }
   * ```
   * Tetrahedron({ diameter: 16 })
   * ```
   * :::
   *
   **/

  const unitTetrahedron = () => Shape.fromGeometry(buildRegularTetrahedron({}));

  const ofRadius$b = (radius = 1) => unitTetrahedron().scale(radius);
  const ofDiameter$a = (diameter = 1) => unitTetrahedron().scale(diameter / 2);

  const Tetrahedron = (...args) => ofRadius$b(...args);

  Tetrahedron.ofRadius = ofRadius$b;
  Tetrahedron.ofDiameter = ofDiameter$a;

  /**
   *
   * # Torus
   *
   * ::: illustration { "view": { "position": [-80, -80, 80] } }
   * ```
   * Torus({ thickness: 5,
   *         radius: 20 })
   * ```
   * :::
   * ::: illustration { "view": { "position": [-80, -80, 80] } }
   * ```
   * Torus({ thickness: 5,
   *         radius: 20,
   *         sides: 4 })
   * ```
   * :::
   * ::: illustration { "view": { "position": [-80, -80, 80] } }
   * ```
   * Torus({ thickness: 5,
   *         radius: 20,
   *         sides: 4,
   *         rotation: 45 })
   * ```
   * :::
   *
   **/

  const Torus = (radius = 1, height = 1, { segments = 32, sides = 32, rotation = 0 } = {}) =>
    Circle(height / 2, { sides })
        .rotateZ(rotation)
        .moveY(radius)
        .Loop(360, { sides: segments })
        .rotateY(90);

  /**
   *
   * # Triangle
   *
   * ::: illustration { "view": { "position": [0, 0, 5] } }
   * ```
   * Triangle()
   * ```
   * :::
   * ::: illustration
   * ```
   * Triangle(20)
   * ```
   * :::
   * ::: illustration
   * ```
   * Triangle({ radius: 10 })
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Circle(10),
   *          Triangle({ radius: 10 })
   *            .drop())
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Triangle({ apothem: 5 }),
   *          Circle(5).drop())
   * ```
   * :::
   * ::: illustration
   * ```
   * assemble(Triangle({ radius: 10 })
   *            .rotateZ(180),
   *          Triangle({ diameter: 10 })
   *            .drop())
   * ```
   * :::
   **/

  const ofEdge$3 = (edge = 1) => Polygon.ofEdge(edge, { sides: 3 });
  const ofApothem$8 = (apothem = 1) => Polygon.ofApothem(apothem, { sides: 3 });
  const ofRadius$c = (radius = 1) => Polygon.ofRadius(radius, { sides: 3 });
  const ofDiameter$b = (diameter = 1) => Polygon.ofDiameter(diameter, { sides: 3 });

  const Triangle = (...args) => ofEdge$3(...args);

  Triangle.ofEdge = ofEdge$3;
  Triangle.ofApothem = ofApothem$8;
  Triangle.ofRadius = ofRadius$c;
  Triangle.ofDiameter = ofDiameter$b;

  const Union = (...args) => Empty().add(...args);

  const UnionMethod = function (...args) { return Union(this, ...args); };
  Shape.prototype.Union = UnionMethod;

  const Void = (shape) => Shape.fromGeometry(rewriteTags(['compose/non-positive'], [], shape.toGeometry()));

  const VoidMethod = function () { return Void(this); };
  Shape.prototype.Void = VoidMethod;

  /**
   *
   * # Wave
   *
   * These take a function mapping X distance to Y distance.
   *
   * ::: illustration { "view": { "position": [0, 0, 10] } }
   * ```
   * Wave(angle => [[sin(angle) * 100]],
   *      { to: 360 });
   * ```
   * :::
   **/

  const Wave = (toPathFromXDistance = (xDistance) => [[0]], { from = 0, to = 360, by, resolution } = {}) => {
    if (by === undefined && resolution === undefined) {
      by = 1;
    }
    let path = [null];
    for (const xDistance of numbers(distance => distance, { from, to, by })) {
      const subpath = toPathFromXDistance(xDistance);
      path = concatenate(path, translate([xDistance, 0, 0], subpath));
    }
    return Shape.fromPath(path);
  };

  // Hershey simplex one line font.
  // See: http://paulbourke.net/dataformats/hershey/

  const hersheyPaths = { '32': [[null]], '33': [[null, [5, 21, 0], [5, 7, 0]], [null, [5, 2, 0], [4, 1, 0], [5, 0, 0], [6, 1, 0], [5, 2, 0]], [null]], '34': [[null, [4, 21, 0], [4, 14, 0]], [null, [12, 21, 0], [12, 14, 0]], [null]], '35': [[null, [11, 25, 0], [4, -7, 0]], [null, [17, 25, 0], [10, -7, 0]], [null, [4, 12, 0], [18, 12, 0]], [null, [3, 6, 0], [17, 6, 0]], [null]], '36': [[null, [8, 25, 0], [8, -4, 0]], [null, [12, 25, 0], [12, -4, 0]], [null, [17, 18, 0], [15, 20, 0], [12, 21, 0], [8, 21, 0], [5, 20, 0], [3, 18, 0], [3, 16, 0], [4, 14, 0], [5, 13, 0], [7, 12, 0], [13, 10, 0], [15, 9, 0], [16, 8, 0], [17, 6, 0], [17, 3, 0], [15, 1, 0], [12, 0, 0], [8, 0, 0], [5, 1, 0], [3, 3, 0]], [null]], '37': [[null, [21, 21, 0], [3, 0, 0]], [null, [8, 21, 0], [10, 19, 0], [10, 17, 0], [9, 15, 0], [7, 14, 0], [5, 14, 0], [3, 16, 0], [3, 18, 0], [4, 20, 0], [6, 21, 0], [8, 21, 0], [10, 20, 0], [13, 19, 0], [16, 19, 0], [19, 20, 0], [21, 21, 0]], [null, [17, 7, 0], [15, 6, 0], [14, 4, 0], [14, 2, 0], [16, 0, 0], [18, 0, 0], [20, 1, 0], [21, 3, 0], [21, 5, 0], [19, 7, 0], [17, 7, 0]], [null]], '38': [[null, [23, 12, 0], [23, 13, 0], [22, 14, 0], [21, 14, 0], [20, 13, 0], [19, 11, 0], [17, 6, 0], [15, 3, 0], [13, 1, 0], [11, 0, 0], [7, 0, 0], [5, 1, 0], [4, 2, 0], [3, 4, 0], [3, 6, 0], [4, 8, 0], [5, 9, 0], [12, 13, 0], [13, 14, 0], [14, 16, 0], [14, 18, 0], [13, 20, 0], [11, 21, 0], [9, 20, 0], [8, 18, 0], [8, 16, 0], [9, 13, 0], [11, 10, 0], [16, 3, 0], [18, 1, 0], [20, 0, 0], [22, 0, 0], [23, 1, 0], [23, 2, 0]], [null]], '39': [[null, [5, 19, 0], [4, 20, 0], [5, 21, 0], [6, 20, 0], [6, 18, 0], [5, 16, 0], [4, 15, 0]], [null]], '40': [[null, [11, 25, 0], [9, 23, 0], [7, 20, 0], [5, 16, 0], [4, 11, 0], [4, 7, 0], [5, 2, 0], [7, -2, 0], [9, -5, 0], [11, -7, 0]], [null]], '41': [[null, [3, 25, 0], [5, 23, 0], [7, 20, 0], [9, 16, 0], [10, 11, 0], [10, 7, 0], [9, 2, 0], [7, -2, 0], [5, -5, 0], [3, -7, 0]], [null]], '42': [[null, [8, 21, 0], [8, 9, 0]], [null, [3, 18, 0], [13, 12, 0]], [null, [13, 18, 0], [3, 12, 0]], [null]], '43': [[null, [13, 18, 0], [13, 0, 0]], [null, [4, 9, 0], [22, 9, 0]], [null]], '44': [[null, [6, 1, 0], [5, 0, 0], [4, 1, 0], [5, 2, 0], [6, 1, 0], [6, -1, 0], [5, -3, 0], [4, -4, 0]], [null]], '45': [[null, [4, 9, 0], [22, 9, 0]], [null]], '46': [[null, [5, 2, 0], [4, 1, 0], [5, 0, 0], [6, 1, 0], [5, 2, 0]], [null]], '47': [[null, [20, 25, 0], [2, -7, 0]], [null]], '48': [[null, [9, 21, 0], [6, 20, 0], [4, 17, 0], [3, 12, 0], [3, 9, 0], [4, 4, 0], [6, 1, 0], [9, 0, 0], [11, 0, 0], [14, 1, 0], [16, 4, 0], [17, 9, 0], [17, 12, 0], [16, 17, 0], [14, 20, 0], [11, 21, 0], [9, 21, 0]], [null]], '49': [[null, [6, 17, 0], [8, 18, 0], [11, 21, 0], [11, 0, 0]], [null]], '50': [[null, [4, 16, 0], [4, 17, 0], [5, 19, 0], [6, 20, 0], [8, 21, 0], [12, 21, 0], [14, 20, 0], [15, 19, 0], [16, 17, 0], [16, 15, 0], [15, 13, 0], [13, 10, 0], [3, 0, 0], [17, 0, 0]], [null]], '51': [[null, [5, 21, 0], [16, 21, 0], [10, 13, 0], [13, 13, 0], [15, 12, 0], [16, 11, 0], [17, 8, 0], [17, 6, 0], [16, 3, 0], [14, 1, 0], [11, 0, 0], [8, 0, 0], [5, 1, 0], [4, 2, 0], [3, 4, 0]], [null]], '52': [[null, [13, 21, 0], [3, 7, 0], [18, 7, 0]], [null, [13, 21, 0], [13, 0, 0]], [null]], '53': [[null, [15, 21, 0], [5, 21, 0], [4, 12, 0], [5, 13, 0], [8, 14, 0], [11, 14, 0], [14, 13, 0], [16, 11, 0], [17, 8, 0], [17, 6, 0], [16, 3, 0], [14, 1, 0], [11, 0, 0], [8, 0, 0], [5, 1, 0], [4, 2, 0], [3, 4, 0]], [null]], '54': [[null, [16, 18, 0], [15, 20, 0], [12, 21, 0], [10, 21, 0], [7, 20, 0], [5, 17, 0], [4, 12, 0], [4, 7, 0], [5, 3, 0], [7, 1, 0], [10, 0, 0], [11, 0, 0], [14, 1, 0], [16, 3, 0], [17, 6, 0], [17, 7, 0], [16, 10, 0], [14, 12, 0], [11, 13, 0], [10, 13, 0], [7, 12, 0], [5, 10, 0], [4, 7, 0]], [null]], '55': [[null, [17, 21, 0], [7, 0, 0]], [null, [3, 21, 0], [17, 21, 0]], [null]], '56': [[null, [8, 21, 0], [5, 20, 0], [4, 18, 0], [4, 16, 0], [5, 14, 0], [7, 13, 0], [11, 12, 0], [14, 11, 0], [16, 9, 0], [17, 7, 0], [17, 4, 0], [16, 2, 0], [15, 1, 0], [12, 0, 0], [8, 0, 0], [5, 1, 0], [4, 2, 0], [3, 4, 0], [3, 7, 0], [4, 9, 0], [6, 11, 0], [9, 12, 0], [13, 13, 0], [15, 14, 0], [16, 16, 0], [16, 18, 0], [15, 20, 0], [12, 21, 0], [8, 21, 0]], [null]], '57': [[null, [16, 14, 0], [15, 11, 0], [13, 9, 0], [10, 8, 0], [9, 8, 0], [6, 9, 0], [4, 11, 0], [3, 14, 0], [3, 15, 0], [4, 18, 0], [6, 20, 0], [9, 21, 0], [10, 21, 0], [13, 20, 0], [15, 18, 0], [16, 14, 0], [16, 9, 0], [15, 4, 0], [13, 1, 0], [10, 0, 0], [8, 0, 0], [5, 1, 0], [4, 3, 0]], [null]], '58': [[null, [5, 14, 0], [4, 13, 0], [5, 12, 0], [6, 13, 0], [5, 14, 0]], [null, [5, 2, 0], [4, 1, 0], [5, 0, 0], [6, 1, 0], [5, 2, 0]], [null]], '59': [[null, [5, 14, 0], [4, 13, 0], [5, 12, 0], [6, 13, 0], [5, 14, 0]], [null, [6, 1, 0], [5, 0, 0], [4, 1, 0], [5, 2, 0], [6, 1, 0], [6, -1, 0], [5, -3, 0], [4, -4, 0]], [null]], '60': [[null, [20, 18, 0], [4, 9, 0], [20, 0, 0]], [null]], '61': [[null, [4, 12, 0], [22, 12, 0]], [null, [4, 6, 0], [22, 6, 0]], [null]], '62': [[null, [4, 18, 0], [20, 9, 0], [4, 0, 0]], [null]], '63': [[null, [3, 16, 0], [3, 17, 0], [4, 19, 0], [5, 20, 0], [7, 21, 0], [11, 21, 0], [13, 20, 0], [14, 19, 0], [15, 17, 0], [15, 15, 0], [14, 13, 0], [13, 12, 0], [9, 10, 0], [9, 7, 0]], [null, [9, 2, 0], [8, 1, 0], [9, 0, 0], [10, 1, 0], [9, 2, 0]], [null]], '64': [[null, [18, 13, 0], [17, 15, 0], [15, 16, 0], [12, 16, 0], [10, 15, 0], [9, 14, 0], [8, 11, 0], [8, 8, 0], [9, 6, 0], [11, 5, 0], [14, 5, 0], [16, 6, 0], [17, 8, 0]], [null, [12, 16, 0], [10, 14, 0], [9, 11, 0], [9, 8, 0], [10, 6, 0], [11, 5, 0]], [null, [18, 16, 0], [17, 8, 0], [17, 6, 0], [19, 5, 0], [21, 5, 0], [23, 7, 0], [24, 10, 0], [24, 12, 0], [23, 15, 0], [22, 17, 0], [20, 19, 0], [18, 20, 0], [15, 21, 0], [12, 21, 0], [9, 20, 0], [7, 19, 0], [5, 17, 0], [4, 15, 0], [3, 12, 0], [3, 9, 0], [4, 6, 0], [5, 4, 0], [7, 2, 0], [9, 1, 0], [12, 0, 0], [15, 0, 0], [18, 1, 0], [20, 2, 0], [21, 3, 0]], [null, [19, 16, 0], [18, 8, 0], [18, 6, 0], [19, 5, 0]]], '65': [[null, [9, 21, 0], [1, 0, 0]], [null, [9, 21, 0], [17, 0, 0]], [null, [4, 7, 0], [14, 7, 0]], [null]], '66': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 21, 0], [13, 21, 0], [16, 20, 0], [17, 19, 0], [18, 17, 0], [18, 15, 0], [17, 13, 0], [16, 12, 0], [13, 11, 0]], [null, [4, 11, 0], [13, 11, 0], [16, 10, 0], [17, 9, 0], [18, 7, 0], [18, 4, 0], [17, 2, 0], [16, 1, 0], [13, 0, 0], [4, 0, 0]], [null]], '67': [[null, [18, 16, 0], [17, 18, 0], [15, 20, 0], [13, 21, 0], [9, 21, 0], [7, 20, 0], [5, 18, 0], [4, 16, 0], [3, 13, 0], [3, 8, 0], [4, 5, 0], [5, 3, 0], [7, 1, 0], [9, 0, 0], [13, 0, 0], [15, 1, 0], [17, 3, 0], [18, 5, 0]], [null]], '68': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 21, 0], [11, 21, 0], [14, 20, 0], [16, 18, 0], [17, 16, 0], [18, 13, 0], [18, 8, 0], [17, 5, 0], [16, 3, 0], [14, 1, 0], [11, 0, 0], [4, 0, 0]], [null]], '69': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 21, 0], [17, 21, 0]], [null, [4, 11, 0], [12, 11, 0]], [null, [4, 0, 0], [17, 0, 0]], [null]], '70': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 21, 0], [17, 21, 0]], [null, [4, 11, 0], [12, 11, 0]], [null]], '71': [[null, [18, 16, 0], [17, 18, 0], [15, 20, 0], [13, 21, 0], [9, 21, 0], [7, 20, 0], [5, 18, 0], [4, 16, 0], [3, 13, 0], [3, 8, 0], [4, 5, 0], [5, 3, 0], [7, 1, 0], [9, 0, 0], [13, 0, 0], [15, 1, 0], [17, 3, 0], [18, 5, 0], [18, 8, 0]], [null, [13, 8, 0], [18, 8, 0]], [null]], '72': [[null, [4, 21, 0], [4, 0, 0]], [null, [18, 21, 0], [18, 0, 0]], [null, [4, 11, 0], [18, 11, 0]], [null]], '73': [[null, [4, 21, 0], [4, 0, 0]], [null]], '74': [[null, [12, 21, 0], [12, 5, 0], [11, 2, 0], [10, 1, 0], [8, 0, 0], [6, 0, 0], [4, 1, 0], [3, 2, 0], [2, 5, 0], [2, 7, 0]], [null]], '75': [[null, [4, 21, 0], [4, 0, 0]], [null, [18, 21, 0], [4, 7, 0]], [null, [9, 12, 0], [18, 0, 0]], [null]], '76': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 0, 0], [16, 0, 0]], [null]], '77': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 21, 0], [12, 0, 0]], [null, [20, 21, 0], [12, 0, 0]], [null, [20, 21, 0], [20, 0, 0]], [null]], '78': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 21, 0], [18, 0, 0]], [null, [18, 21, 0], [18, 0, 0]], [null]], '79': [[null, [9, 21, 0], [7, 20, 0], [5, 18, 0], [4, 16, 0], [3, 13, 0], [3, 8, 0], [4, 5, 0], [5, 3, 0], [7, 1, 0], [9, 0, 0], [13, 0, 0], [15, 1, 0], [17, 3, 0], [18, 5, 0], [19, 8, 0], [19, 13, 0], [18, 16, 0], [17, 18, 0], [15, 20, 0], [13, 21, 0], [9, 21, 0]], [null]], '80': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 21, 0], [13, 21, 0], [16, 20, 0], [17, 19, 0], [18, 17, 0], [18, 14, 0], [17, 12, 0], [16, 11, 0], [13, 10, 0], [4, 10, 0]], [null]], '81': [[null, [9, 21, 0], [7, 20, 0], [5, 18, 0], [4, 16, 0], [3, 13, 0], [3, 8, 0], [4, 5, 0], [5, 3, 0], [7, 1, 0], [9, 0, 0], [13, 0, 0], [15, 1, 0], [17, 3, 0], [18, 5, 0], [19, 8, 0], [19, 13, 0], [18, 16, 0], [17, 18, 0], [15, 20, 0], [13, 21, 0], [9, 21, 0]], [null, [12, 4, 0], [18, -2, 0]], [null]], '82': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 21, 0], [13, 21, 0], [16, 20, 0], [17, 19, 0], [18, 17, 0], [18, 15, 0], [17, 13, 0], [16, 12, 0], [13, 11, 0], [4, 11, 0]], [null, [11, 11, 0], [18, 0, 0]], [null]], '83': [[null, [17, 18, 0], [15, 20, 0], [12, 21, 0], [8, 21, 0], [5, 20, 0], [3, 18, 0], [3, 16, 0], [4, 14, 0], [5, 13, 0], [7, 12, 0], [13, 10, 0], [15, 9, 0], [16, 8, 0], [17, 6, 0], [17, 3, 0], [15, 1, 0], [12, 0, 0], [8, 0, 0], [5, 1, 0], [3, 3, 0]], [null]], '84': [[null, [8, 21, 0], [8, 0, 0]], [null, [1, 21, 0], [15, 21, 0]], [null]], '85': [[null, [4, 21, 0], [4, 6, 0], [5, 3, 0], [7, 1, 0], [10, 0, 0], [12, 0, 0], [15, 1, 0], [17, 3, 0], [18, 6, 0], [18, 21, 0]], [null]], '86': [[null, [1, 21, 0], [9, 0, 0]], [null, [17, 21, 0], [9, 0, 0]], [null]], '87': [[null, [2, 21, 0], [7, 0, 0]], [null, [12, 21, 0], [7, 0, 0]], [null, [12, 21, 0], [17, 0, 0]], [null, [22, 21, 0], [17, 0, 0]], [null]], '88': [[null, [3, 21, 0], [17, 0, 0]], [null, [17, 21, 0], [3, 0, 0]], [null]], '89': [[null, [1, 21, 0], [9, 11, 0], [9, 0, 0]], [null, [17, 21, 0], [9, 11, 0]], [null]], '90': [[null, [17, 21, 0], [3, 0, 0]], [null, [3, 21, 0], [17, 21, 0]], [null, [3, 0, 0], [17, 0, 0]], [null]], '91': [[null, [4, 25, 0], [4, -7, 0]], [null, [5, 25, 0], [5, -7, 0]], [null, [4, 25, 0], [11, 25, 0]], [null, [4, -7, 0], [11, -7, 0]], [null]], '92': [[null, [0, 21, 0], [14, -3, 0]], [null]], '93': [[null, [9, 25, 0], [9, -7, 0]], [null, [10, 25, 0], [10, -7, 0]], [null, [3, 25, 0], [10, 25, 0]], [null, [3, -7, 0], [10, -7, 0]], [null]], '94': [[null, [6, 15, 0], [8, 18, 0], [10, 15, 0]], [null, [3, 12, 0], [8, 17, 0], [13, 12, 0]], [null, [8, 17, 0], [8, 0, 0]], [null]], '95': [[null, [0, -2, 0], [16, -2, 0]], [null]], '96': [[null, [6, 21, 0], [5, 20, 0], [4, 18, 0], [4, 16, 0], [5, 15, 0], [6, 16, 0], [5, 17, 0]], [null]], '97': [[null, [15, 14, 0], [15, 0, 0]], [null, [15, 11, 0], [13, 13, 0], [11, 14, 0], [8, 14, 0], [6, 13, 0], [4, 11, 0], [3, 8, 0], [3, 6, 0], [4, 3, 0], [6, 1, 0], [8, 0, 0], [11, 0, 0], [13, 1, 0], [15, 3, 0]], [null]], '98': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 11, 0], [6, 13, 0], [8, 14, 0], [11, 14, 0], [13, 13, 0], [15, 11, 0], [16, 8, 0], [16, 6, 0], [15, 3, 0], [13, 1, 0], [11, 0, 0], [8, 0, 0], [6, 1, 0], [4, 3, 0]], [null]], '99': [[null, [15, 11, 0], [13, 13, 0], [11, 14, 0], [8, 14, 0], [6, 13, 0], [4, 11, 0], [3, 8, 0], [3, 6, 0], [4, 3, 0], [6, 1, 0], [8, 0, 0], [11, 0, 0], [13, 1, 0], [15, 3, 0]], [null]], '100': [[null, [15, 21, 0], [15, 0, 0]], [null, [15, 11, 0], [13, 13, 0], [11, 14, 0], [8, 14, 0], [6, 13, 0], [4, 11, 0], [3, 8, 0], [3, 6, 0], [4, 3, 0], [6, 1, 0], [8, 0, 0], [11, 0, 0], [13, 1, 0], [15, 3, 0]], [null]], '101': [[null, [3, 8, 0], [15, 8, 0], [15, 10, 0], [14, 12, 0], [13, 13, 0], [11, 14, 0], [8, 14, 0], [6, 13, 0], [4, 11, 0], [3, 8, 0], [3, 6, 0], [4, 3, 0], [6, 1, 0], [8, 0, 0], [11, 0, 0], [13, 1, 0], [15, 3, 0]], [null]], '102': [[null, [10, 21, 0], [8, 21, 0], [6, 20, 0], [5, 17, 0], [5, 0, 0]], [null, [2, 14, 0], [9, 14, 0]], [null]], '103': [[null, [15, 14, 0], [15, -2, 0], [14, -5, 0], [13, -6, 0], [11, -7, 0], [8, -7, 0], [6, -6, 0]], [null, [15, 11, 0], [13, 13, 0], [11, 14, 0], [8, 14, 0], [6, 13, 0], [4, 11, 0], [3, 8, 0], [3, 6, 0], [4, 3, 0], [6, 1, 0], [8, 0, 0], [11, 0, 0], [13, 1, 0], [15, 3, 0]], [null]], '104': [[null, [4, 21, 0], [4, 0, 0]], [null, [4, 10, 0], [7, 13, 0], [9, 14, 0], [12, 14, 0], [14, 13, 0], [15, 10, 0], [15, 0, 0]], [null]], '105': [[null, [3, 21, 0], [4, 20, 0], [5, 21, 0], [4, 22, 0], [3, 21, 0]], [null, [4, 14, 0], [4, 0, 0]], [null]], '106': [[null, [5, 21, 0], [6, 20, 0], [7, 21, 0], [6, 22, 0], [5, 21, 0]], [null, [6, 14, 0], [6, -3, 0], [5, -6, 0], [3, -7, 0], [1, -7, 0]], [null]], '107': [[null, [4, 21, 0], [4, 0, 0]], [null, [14, 14, 0], [4, 4, 0]], [null, [8, 8, 0], [15, 0, 0]], [null]], '108': [[null, [4, 21, 0], [4, 0, 0]], [null]], '109': [[null, [4, 14, 0], [4, 0, 0]], [null, [4, 10, 0], [7, 13, 0], [9, 14, 0], [12, 14, 0], [14, 13, 0], [15, 10, 0], [15, 0, 0]], [null, [15, 10, 0], [18, 13, 0], [20, 14, 0], [23, 14, 0], [25, 13, 0], [26, 10, 0], [26, 0, 0]], [null]], '110': [[null, [4, 14, 0], [4, 0, 0]], [null, [4, 10, 0], [7, 13, 0], [9, 14, 0], [12, 14, 0], [14, 13, 0], [15, 10, 0], [15, 0, 0]], [null]], '111': [[null, [8, 14, 0], [6, 13, 0], [4, 11, 0], [3, 8, 0], [3, 6, 0], [4, 3, 0], [6, 1, 0], [8, 0, 0], [11, 0, 0], [13, 1, 0], [15, 3, 0], [16, 6, 0], [16, 8, 0], [15, 11, 0], [13, 13, 0], [11, 14, 0], [8, 14, 0]], [null]], '112': [[null, [4, 14, 0], [4, -7, 0]], [null, [4, 11, 0], [6, 13, 0], [8, 14, 0], [11, 14, 0], [13, 13, 0], [15, 11, 0], [16, 8, 0], [16, 6, 0], [15, 3, 0], [13, 1, 0], [11, 0, 0], [8, 0, 0], [6, 1, 0], [4, 3, 0]], [null]], '113': [[null, [15, 14, 0], [15, -7, 0]], [null, [15, 11, 0], [13, 13, 0], [11, 14, 0], [8, 14, 0], [6, 13, 0], [4, 11, 0], [3, 8, 0], [3, 6, 0], [4, 3, 0], [6, 1, 0], [8, 0, 0], [11, 0, 0], [13, 1, 0], [15, 3, 0]], [null]], '114': [[null, [4, 14, 0], [4, 0, 0]], [null, [4, 8, 0], [5, 11, 0], [7, 13, 0], [9, 14, 0], [12, 14, 0]], [null]], '115': [[null, [14, 11, 0], [13, 13, 0], [10, 14, 0], [7, 14, 0], [4, 13, 0], [3, 11, 0], [4, 9, 0], [6, 8, 0], [11, 7, 0], [13, 6, 0], [14, 4, 0], [14, 3, 0], [13, 1, 0], [10, 0, 0], [7, 0, 0], [4, 1, 0], [3, 3, 0]], [null]], '116': [[null, [5, 21, 0], [5, 4, 0], [6, 1, 0], [8, 0, 0], [10, 0, 0]], [null, [2, 14, 0], [9, 14, 0]], [null]], '117': [[null, [4, 14, 0], [4, 4, 0], [5, 1, 0], [7, 0, 0], [10, 0, 0], [12, 1, 0], [15, 4, 0]], [null, [15, 14, 0], [15, 0, 0]], [null]], '118': [[null, [2, 14, 0], [8, 0, 0]], [null, [14, 14, 0], [8, 0, 0]], [null]], '119': [[null, [3, 14, 0], [7, 0, 0]], [null, [11, 14, 0], [7, 0, 0]], [null, [11, 14, 0], [15, 0, 0]], [null, [19, 14, 0], [15, 0, 0]], [null]], '120': [[null, [3, 14, 0], [14, 0, 0]], [null, [14, 14, 0], [3, 0, 0]], [null]], '121': [[null, [2, 14, 0], [8, 0, 0]], [null, [14, 14, 0], [8, 0, 0], [6, -4, 0], [4, -6, 0], [2, -7, 0], [1, -7, 0]], [null]], '122': [[null, [14, 14, 0], [3, 0, 0]], [null, [3, 14, 0], [14, 14, 0]], [null, [3, 0, 0], [14, 0, 0]], [null]], '123': [[null, [9, 25, 0], [7, 24, 0], [6, 23, 0], [5, 21, 0], [5, 19, 0], [6, 17, 0], [7, 16, 0], [8, 14, 0], [8, 12, 0], [6, 10, 0]], [null, [7, 24, 0], [6, 22, 0], [6, 20, 0], [7, 18, 0], [8, 17, 0], [9, 15, 0], [9, 13, 0], [8, 11, 0], [4, 9, 0], [8, 7, 0], [9, 5, 0], [9, 3, 0], [8, 1, 0], [7, 0, 0], [6, -2, 0], [6, -4, 0], [7, -6, 0]], [null, [6, 8, 0], [8, 6, 0], [8, 4, 0], [7, 2, 0], [6, 1, 0], [5, -1, 0], [5, -3, 0], [6, -5, 0], [7, -6, 0], [9, -7, 0]], [null]], '124': [[null, [4, 25, 0], [4, -7, 0]], [null]], '125': [[null, [5, 25, 0], [7, 24, 0], [8, 23, 0], [9, 21, 0], [9, 19, 0], [8, 17, 0], [7, 16, 0], [6, 14, 0], [6, 12, 0], [8, 10, 0]], [null, [7, 24, 0], [8, 22, 0], [8, 20, 0], [7, 18, 0], [6, 17, 0], [5, 15, 0], [5, 13, 0], [6, 11, 0], [10, 9, 0], [6, 7, 0], [5, 5, 0], [5, 3, 0], [6, 1, 0], [7, 0, 0], [8, -2, 0], [8, -4, 0], [7, -6, 0]], [null, [8, 8, 0], [6, 6, 0], [6, 4, 0], [7, 2, 0], [8, 1, 0], [9, -1, 0], [9, -3, 0], [8, -5, 0], [7, -6, 0], [5, -7, 0]], [null]], '126': [[null, [3, 6, 0], [3, 8, 0], [4, 11, 0], [6, 12, 0], [8, 12, 0], [10, 11, 0], [14, 8, 0], [16, 7, 0], [18, 7, 0], [20, 8, 0], [21, 10, 0]], [null, [3, 8, 0], [4, 10, 0], [6, 11, 0], [8, 11, 0], [10, 10, 0], [14, 7, 0], [16, 6, 0], [18, 6, 0], [20, 7, 0], [21, 10, 0], [21, 12, 0]], [null]] };

  const hersheyWidth = { '32': 16, '33': 10, '34': 16, '35': 21, '36': 20, '37': 24, '38': 26, '39': 10, '40': 14, '41': 14, '42': 16, '43': 26, '44': 10, '45': 26, '46': 10, '47': 22, '48': 20, '49': 20, '50': 20, '51': 20, '52': 20, '53': 20, '54': 20, '55': 20, '56': 20, '57': 20, '58': 10, '59': 10, '60': 24, '61': 26, '62': 24, '63': 18, '64': 27, '65': 18, '66': 21, '67': 21, '68': 21, '69': 19, '70': 18, '71': 21, '72': 22, '73': 8, '74': 16, '75': 21, '76': 17, '77': 24, '78': 22, '79': 22, '80': 21, '81': 22, '82': 21, '83': 20, '84': 16, '85': 22, '86': 18, '87': 24, '88': 20, '89': 18, '90': 20, '91': 14, '92': 14, '93': 14, '94': 16, '95': 16, '96': 10, '97': 19, '98': 19, '99': 18, '100': 19, '101': 18, '102': 12, '103': 19, '104': 19, '105': 8, '106': 10, '107': 17, '108': 8, '109': 30, '110': 19, '111': 19, '112': 19, '113': 19, '114': 13, '115': 17, '116': 12, '117': 19, '118': 16, '119': 22, '120': 17, '121': 16, '122': 17, '123': 14, '124': 8, '125': 14, '126': 24 };

  const toPaths$1 = (letters) => {
    let xOffset = 0;
    const mergedPaths = [];
    for (const letter of letters) {
      const code = letter.charCodeAt(0);
      const paths = hersheyPaths[code] || [];
      mergedPaths.push(...translate$2([xOffset, 0, 0], paths));
      xOffset += hersheyWidth[code] || 0;
    }
    return Shape.fromGeometry({ paths: mergedPaths }).scale(1 / 28);
  };

  const ofSize$2 = (size) => (text) => toPaths$1(text).scale(size);

  const Hershey = (size) => ofSize$2(size);
  Hershey.ofSize = ofSize$2;
  Hershey.toPaths = toPaths$1;

  //[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
  //[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
  //[5]   	Name	   ::=   	NameStartChar (NameChar)*
  var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;//\u10000-\uEFFFF
  var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
  //var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
  //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

  //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
  //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
  var S_TAG = 0;//tag name offerring
  var S_ATTR = 1;//attr name offerring 
  var S_ATTR_SPACE=2;//attr name end and space offer
  var S_EQ = 3;//=space?
  var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
  var S_ATTR_END = 5;//attr value end and no space(quot end)
  var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
  var S_TAG_CLOSE = 7;//closed el<el />

  function XMLReader(){
  	
  }

  XMLReader.prototype = {
  	parse:function(source,defaultNSMap,entityMap){
  		var domBuilder = this.domBuilder;
  		domBuilder.startDocument();
  		_copy(defaultNSMap ,defaultNSMap = {});
  		parse$3(source,defaultNSMap,entityMap,
  				domBuilder,this.errorHandler);
  		domBuilder.endDocument();
  	}
  };
  function parse$3(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
  	function fixedFromCharCode(code) {
  		// String.prototype.fromCharCode does not supports
  		// > 2 bytes unicode chars directly
  		if (code > 0xffff) {
  			code -= 0x10000;
  			var surrogate1 = 0xd800 + (code >> 10)
  				, surrogate2 = 0xdc00 + (code & 0x3ff);

  			return String.fromCharCode(surrogate1, surrogate2);
  		} else {
  			return String.fromCharCode(code);
  		}
  	}
  	function entityReplacer(a){
  		var k = a.slice(1,-1);
  		if(k in entityMap){
  			return entityMap[k]; 
  		}else if(k.charAt(0) === '#'){
  			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
  		}else{
  			errorHandler.error('entity not found:'+a);
  			return a;
  		}
  	}
  	function appendText(end){//has some bugs
  		if(end>start){
  			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
  			locator&&position(start);
  			domBuilder.characters(xt,0,end-start);
  			start = end;
  		}
  	}
  	function position(p,m){
  		while(p>=lineEnd && (m = linePattern.exec(source))){
  			lineStart = m.index;
  			lineEnd = lineStart + m[0].length;
  			locator.lineNumber++;
  			//console.log('line++:',locator,startPos,endPos)
  		}
  		locator.columnNumber = p-lineStart+1;
  	}
  	var lineStart = 0;
  	var lineEnd = 0;
  	var linePattern = /.*(?:\r\n?|\n)|.*$/g;
  	var locator = domBuilder.locator;
  	
  	var parseStack = [{currentNSMap:defaultNSMapCopy}];
  	var closeMap = {};
  	var start = 0;
  	while(true){
  		try{
  			var tagStart = source.indexOf('<',start);
  			if(tagStart<0){
  				if(!source.substr(start).match(/^\s*$/)){
  					var doc = domBuilder.doc;
  	    			var text = doc.createTextNode(source.substr(start));
  	    			doc.appendChild(text);
  	    			domBuilder.currentElement = text;
  				}
  				return;
  			}
  			if(tagStart>start){
  				appendText(tagStart);
  			}
  			switch(source.charAt(tagStart+1)){
  			case '/':
  				var end = source.indexOf('>',tagStart+3);
  				var tagName = source.substring(tagStart+2,end);
  				var config = parseStack.pop();
  				if(end<0){
  					
  	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
  	        		//console.error('#@@@@@@'+tagName)
  	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
  	        		end = tagStart+1+tagName.length;
  	        	}else if(tagName.match(/\s</)){
  	        		tagName = tagName.replace(/[\s<].*/,'');
  	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
  	        		end = tagStart+1+tagName.length;
  				}
  				//console.error(parseStack.length,parseStack)
  				//console.error(config);
  				var localNSMap = config.localNSMap;
  				var endMatch = config.tagName == tagName;
  				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase();
  		        if(endIgnoreCaseMach){
  		        	domBuilder.endElement(config.uri,config.localName,tagName);
  					if(localNSMap){
  						for(var prefix in localNSMap){
  							domBuilder.endPrefixMapping(prefix) ;
  						}
  					}
  					if(!endMatch){
  		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
  					}
  		        }else{
  		        	parseStack.push(config);
  		        }
  				
  				end++;
  				break;
  				// end elment
  			case '?':// <?...?>
  				locator&&position(tagStart);
  				end = parseInstruction(source,tagStart,domBuilder);
  				break;
  			case '!':// <!doctype,<![CDATA,<!--
  				locator&&position(tagStart);
  				end = parseDCC(source,tagStart,domBuilder,errorHandler);
  				break;
  			default:
  				locator&&position(tagStart);
  				var el = new ElementAttributes();
  				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
  				//elStartEnd
  				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
  				var len = el.length;
  				
  				
  				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
  					el.closed = true;
  					if(!entityMap.nbsp){
  						errorHandler.warning('unclosed xml attribute');
  					}
  				}
  				if(locator && len){
  					var locator2 = copyLocator(locator,{});
  					//try{//attribute position fixed
  					for(var i = 0;i<len;i++){
  						var a = el[i];
  						position(a.offset);
  						a.locator = copyLocator(locator,{});
  					}
  					//}catch(e){console.error('@@@@@'+e)}
  					domBuilder.locator = locator2;
  					if(appendElement(el,domBuilder,currentNSMap)){
  						parseStack.push(el);
  					}
  					domBuilder.locator = locator;
  				}else{
  					if(appendElement(el,domBuilder,currentNSMap)){
  						parseStack.push(el);
  					}
  				}
  				
  				
  				
  				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
  					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder);
  				}else{
  					end++;
  				}
  			}
  		}catch(e){
  			errorHandler.error('element parse error: '+e);
  			//errorHandler.error('element parse error: '+e);
  			end = -1;
  			//throw e;
  		}
  		if(end>start){
  			start = end;
  		}else{
  			//TODO: è¿™é‡Œæœ‰å¯èƒ½saxå›žé€€ï¼Œæœ‰ä½ç½®é”™è¯¯é£Žé™©
  			appendText(Math.max(tagStart,start)+1);
  		}
  	}
  }
  function copyLocator(f,t){
  	t.lineNumber = f.lineNumber;
  	t.columnNumber = f.columnNumber;
  	return t;
  }

  /**
   * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
   * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
   */
  function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){
  	var attrName;
  	var value;
  	var p = ++start;
  	var s = S_TAG;//status
  	while(true){
  		var c = source.charAt(p);
  		switch(c){
  		case '=':
  			if(s === S_ATTR){//attrName
  				attrName = source.slice(start,p);
  				s = S_EQ;
  			}else if(s === S_ATTR_SPACE){
  				s = S_EQ;
  			}else{
  				//fatalError: equal must after attrName or space after attrName
  				throw new Error('attribute equal must after attrName');
  			}
  			break;
  		case '\'':
  		case '"':
  			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
  				){//equal
  				if(s === S_ATTR){
  					errorHandler.warning('attribute value must after "="');
  					attrName = source.slice(start,p);
  				}
  				start = p+1;
  				p = source.indexOf(c,start);
  				if(p>0){
  					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
  					el.add(attrName,value,start-1);
  					s = S_ATTR_END;
  				}else{
  					//fatalError: no end quot match
  					throw new Error('attribute value no end \''+c+'\' match');
  				}
  			}else if(s == S_ATTR_NOQUOT_VALUE){
  				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
  				//console.log(attrName,value,start,p)
  				el.add(attrName,value,start);
  				//console.dir(el)
  				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
  				start = p+1;
  				s = S_ATTR_END;
  			}else{
  				//fatalError: no equal before
  				throw new Error('attribute value must after "="');
  			}
  			break;
  		case '/':
  			switch(s){
  			case S_TAG:
  				el.setTagName(source.slice(start,p));
  			case S_ATTR_END:
  			case S_TAG_SPACE:
  			case S_TAG_CLOSE:
  				s =S_TAG_CLOSE;
  				el.closed = true;
  			case S_ATTR_NOQUOT_VALUE:
  			case S_ATTR:
  			case S_ATTR_SPACE:
  				break;
  			//case S_EQ:
  			default:
  				throw new Error("attribute invalid close char('/')")
  			}
  			break;
  		case ''://end document
  			//throw new Error('unexpected end of input')
  			errorHandler.error('unexpected end of input');
  			if(s == S_TAG){
  				el.setTagName(source.slice(start,p));
  			}
  			return p;
  		case '>':
  			switch(s){
  			case S_TAG:
  				el.setTagName(source.slice(start,p));
  			case S_ATTR_END:
  			case S_TAG_SPACE:
  			case S_TAG_CLOSE:
  				break;//normal
  			case S_ATTR_NOQUOT_VALUE://Compatible state
  			case S_ATTR:
  				value = source.slice(start,p);
  				if(value.slice(-1) === '/'){
  					el.closed  = true;
  					value = value.slice(0,-1);
  				}
  			case S_ATTR_SPACE:
  				if(s === S_ATTR_SPACE){
  					value = attrName;
  				}
  				if(s == S_ATTR_NOQUOT_VALUE){
  					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
  					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start);
  				}else{
  					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
  						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!');
  					}
  					el.add(value,value,start);
  				}
  				break;
  			case S_EQ:
  				throw new Error('attribute value missed!!');
  			}
  //			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
  			return p;
  		/*xml space '\x20' | #x9 | #xD | #xA; */
  		case '\u0080':
  			c = ' ';
  		default:
  			if(c<= ' '){//space
  				switch(s){
  				case S_TAG:
  					el.setTagName(source.slice(start,p));//tagName
  					s = S_TAG_SPACE;
  					break;
  				case S_ATTR:
  					attrName = source.slice(start,p);
  					s = S_ATTR_SPACE;
  					break;
  				case S_ATTR_NOQUOT_VALUE:
  					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
  					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
  					el.add(attrName,value,start);
  				case S_ATTR_END:
  					s = S_TAG_SPACE;
  					break;
  				//case S_TAG_SPACE:
  				//case S_EQ:
  				//case S_ATTR_SPACE:
  				//	void();break;
  				//case S_TAG_CLOSE:
  					//ignore warning
  				}
  			}else{//not space
  //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
  //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
  				switch(s){
  				//case S_TAG:void();break;
  				//case S_ATTR:void();break;
  				//case S_ATTR_NOQUOT_VALUE:void();break;
  				case S_ATTR_SPACE:
  					var tagName =  el.tagName;
  					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
  						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!');
  					}
  					el.add(attrName,attrName,start);
  					start = p;
  					s = S_ATTR;
  					break;
  				case S_ATTR_END:
  					errorHandler.warning('attribute space is required"'+attrName+'"!!');
  				case S_TAG_SPACE:
  					s = S_ATTR;
  					start = p;
  					break;
  				case S_EQ:
  					s = S_ATTR_NOQUOT_VALUE;
  					start = p;
  					break;
  				case S_TAG_CLOSE:
  					throw new Error("elements closed character '/' and '>' must be connected to");
  				}
  			}
  		}//end outer switch
  		//console.log('p++',p)
  		p++;
  	}
  }
  /**
   * @return true if has new namespace define
   */
  function appendElement(el,domBuilder,currentNSMap){
  	var tagName = el.tagName;
  	var localNSMap = null;
  	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
  	var i = el.length;
  	while(i--){
  		var a = el[i];
  		var qName = a.qName;
  		var value = a.value;
  		var nsp = qName.indexOf(':');
  		if(nsp>0){
  			var prefix = a.prefix = qName.slice(0,nsp);
  			var localName = qName.slice(nsp+1);
  			var nsPrefix = prefix === 'xmlns' && localName;
  		}else{
  			localName = qName;
  			prefix = null;
  			nsPrefix = qName === 'xmlns' && '';
  		}
  		//can not set prefix,because prefix !== ''
  		a.localName = localName ;
  		//prefix == null for no ns prefix attribute 
  		if(nsPrefix !== false){//hack!!
  			if(localNSMap == null){
  				localNSMap = {};
  				//console.log(currentNSMap,0)
  				_copy(currentNSMap,currentNSMap={});
  				//console.log(currentNSMap,1)
  			}
  			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
  			a.uri = 'http://www.w3.org/2000/xmlns/';
  			domBuilder.startPrefixMapping(nsPrefix, value); 
  		}
  	}
  	var i = el.length;
  	while(i--){
  		a = el[i];
  		var prefix = a.prefix;
  		if(prefix){//no prefix attribute has no namespace
  			if(prefix === 'xml'){
  				a.uri = 'http://www.w3.org/XML/1998/namespace';
  			}if(prefix !== 'xmlns'){
  				a.uri = currentNSMap[prefix || ''];
  				
  				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
  			}
  		}
  	}
  	var nsp = tagName.indexOf(':');
  	if(nsp>0){
  		prefix = el.prefix = tagName.slice(0,nsp);
  		localName = el.localName = tagName.slice(nsp+1);
  	}else{
  		prefix = null;//important!!
  		localName = el.localName = tagName;
  	}
  	//no prefix element has default namespace
  	var ns = el.uri = currentNSMap[prefix || ''];
  	domBuilder.startElement(ns,localName,tagName,el);
  	//endPrefixMapping and startPrefixMapping have not any help for dom builder
  	//localNSMap = null
  	if(el.closed){
  		domBuilder.endElement(ns,localName,tagName);
  		if(localNSMap){
  			for(prefix in localNSMap){
  				domBuilder.endPrefixMapping(prefix); 
  			}
  		}
  	}else{
  		el.currentNSMap = currentNSMap;
  		el.localNSMap = localNSMap;
  		//parseStack.push(el);
  		return true;
  	}
  }
  function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
  	if(/^(?:script|textarea)$/i.test(tagName)){
  		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
  		var text = source.substring(elStartEnd+1,elEndStart);
  		if(/[&<]/.test(text)){
  			if(/^script$/i.test(tagName)){
  				//if(!/\]\]>/.test(text)){
  					//lexHandler.startCDATA();
  					domBuilder.characters(text,0,text.length);
  					//lexHandler.endCDATA();
  					return elEndStart;
  				//}
  			}//}else{//text area
  				text = text.replace(/&#?\w+;/g,entityReplacer);
  				domBuilder.characters(text,0,text.length);
  				return elEndStart;
  			//}
  			
  		}
  	}
  	return elStartEnd+1;
  }
  function fixSelfClosed(source,elStartEnd,tagName,closeMap){
  	//if(tagName in closeMap){
  	var pos = closeMap[tagName];
  	if(pos == null){
  		//console.log(tagName)
  		pos =  source.lastIndexOf('</'+tagName+'>');
  		if(pos<elStartEnd){//å¿˜è®°é—­åˆ
  			pos = source.lastIndexOf('</'+tagName);
  		}
  		closeMap[tagName] =pos;
  	}
  	return pos<elStartEnd;
  	//} 
  }
  function _copy(source,target){
  	for(var n in source){target[n] = source[n];}
  }
  function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
  	var next= source.charAt(start+2);
  	switch(next){
  	case '-':
  		if(source.charAt(start + 3) === '-'){
  			var end = source.indexOf('-->',start+4);
  			//append comment source.substring(4,end)//<!--
  			if(end>start){
  				domBuilder.comment(source,start+4,end-start-4);
  				return end+3;
  			}else{
  				errorHandler.error("Unclosed comment");
  				return -1;
  			}
  		}else{
  			//error
  			return -1;
  		}
  	default:
  		if(source.substr(start+3,6) == 'CDATA['){
  			var end = source.indexOf(']]>',start+9);
  			domBuilder.startCDATA();
  			domBuilder.characters(source,start+9,end-start-9);
  			domBuilder.endCDATA(); 
  			return end+3;
  		}
  		//<!DOCTYPE
  		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
  		var matchs = split(source,start);
  		var len = matchs.length;
  		if(len>1 && /!doctype/i.test(matchs[0][0])){
  			var name = matchs[1][0];
  			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0];
  			var sysid = len>4 && matchs[4][0];
  			var lastMatch = matchs[len-1];
  			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
  					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
  			domBuilder.endDTD();
  			
  			return lastMatch.index+lastMatch[0].length
  		}
  	}
  	return -1;
  }



  function parseInstruction(source,start,domBuilder){
  	var end = source.indexOf('?>',start);
  	if(end){
  		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
  		if(match){
  			var len = match[0].length;
  			domBuilder.processingInstruction(match[1], match[2]) ;
  			return end+2;
  		}else{//error
  			return -1;
  		}
  	}
  	return -1;
  }

  /**
   * @param source
   */
  function ElementAttributes(source){
  	
  }
  ElementAttributes.prototype = {
  	setTagName:function(tagName){
  		if(!tagNamePattern.test(tagName)){
  			throw new Error('invalid tagName:'+tagName)
  		}
  		this.tagName = tagName;
  	},
  	add:function(qName,value,offset){
  		if(!tagNamePattern.test(qName)){
  			throw new Error('invalid attribute:'+qName)
  		}
  		this[this.length++] = {qName:qName,value:value,offset:offset};
  	},
  	length:0,
  	getLocalName:function(i){return this[i].localName},
  	getLocator:function(i){return this[i].locator},
  	getQName:function(i){return this[i].qName},
  	getURI:function(i){return this[i].uri},
  	getValue:function(i){return this[i].value}
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //			
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
  };




  function _set_proto_(thiz,parent){
  	thiz.__proto__ = parent;
  	return thiz;
  }
  if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
  	_set_proto_ = function(thiz,parent){
  		function p(){}		p.prototype = parent;
  		p = new p();
  		for(parent in thiz){
  			p[parent] = thiz[parent];
  		}
  		return p;
  	};
  }

  function split(source,start){
  	var match;
  	var buf = [];
  	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  	reg.lastIndex = start;
  	reg.exec(source);//skip <
  	while(match = reg.exec(source)){
  		buf.push(match);
  		if(match[1])return buf;
  	}
  }

  var XMLReader_1 = XMLReader;

  var sax = {
  	XMLReader: XMLReader_1
  };

  /*
   * DOM Level 2
   * Object DOMException
   * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
   */

  function copy$1(src,dest){
  	for(var p in src){
  		dest[p] = src[p];
  	}
  }
  /**
  ^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
  ^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
   */
  function _extends(Class,Super){
  	var pt = Class.prototype;
  	if(Object.create){
  		var ppt = Object.create(Super.prototype);
  		pt.__proto__ = ppt;
  	}
  	if(!(pt instanceof Super)){
  		function t(){}		t.prototype = Super.prototype;
  		t = new t();
  		copy$1(pt,t);
  		Class.prototype = pt = t;
  	}
  	if(pt.constructor != Class){
  		if(typeof Class != 'function'){
  			console.error("unknow Class:"+Class);
  		}
  		pt.constructor = Class;
  	}
  }
  var htmlns = 'http://www.w3.org/1999/xhtml' ;
  // Node Types
  var NodeType = {};
  var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
  var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
  var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
  var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
  var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
  var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
  var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
  var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
  var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
  var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

  // ExceptionCode
  var ExceptionCode = {};
  var ExceptionMessage = {};
  var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
  var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
  var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
  var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
  var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
  var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
  var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
  var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
  var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
  var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
  //level2
  var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
  var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
  var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
  var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
  var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


  function DOMException(code, message) {
  	if(message instanceof Error){
  		var error = message;
  	}else{
  		error = this;
  		Error.call(this, ExceptionMessage[code]);
  		this.message = ExceptionMessage[code];
  		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
  	}
  	error.code = code;
  	if(message) this.message = this.message + ": " + message;
  	return error;
  }DOMException.prototype = Error.prototype;
  copy$1(ExceptionCode,DOMException);
  /**
   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
   * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
   * The items in the NodeList are accessible via an integral index, starting from 0.
   */
  function NodeList() {
  }NodeList.prototype = {
  	/**
  	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
  	 * @standard level1
  	 */
  	length:0, 
  	/**
  	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
  	 * @standard level1
  	 * @param index  unsigned long 
  	 *   Index into the collection.
  	 * @return Node
  	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
  	 */
  	item: function(index) {
  		return this[index] || null;
  	},
  	toString:function(isHTML,nodeFilter){
  		for(var buf = [], i = 0;i<this.length;i++){
  			serializeToString(this[i],buf,isHTML,nodeFilter);
  		}
  		return buf.join('');
  	}
  };
  function LiveNodeList(node,refresh){
  	this._node = node;
  	this._refresh = refresh;
  	_updateLiveList(this);
  }
  function _updateLiveList(list){
  	var inc = list._node._inc || list._node.ownerDocument._inc;
  	if(list._inc != inc){
  		var ls = list._refresh(list._node);
  		//console.log(ls.length)
  		__set__(list,'length',ls.length);
  		copy$1(ls,list);
  		list._inc = inc;
  	}
  }
  LiveNodeList.prototype.item = function(i){
  	_updateLiveList(this);
  	return this[i];
  };

  _extends(LiveNodeList,NodeList);
  /**
   * 
   * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
   * NamedNodeMap objects in the DOM are live.
   * used for attributes or DocumentType entities 
   */
  function NamedNodeMap() {
  }
  function _findNodeIndex(list,node){
  	var i = list.length;
  	while(i--){
  		if(list[i] === node){return i}
  	}
  }

  function _addNamedNode(el,list,newAttr,oldAttr){
  	if(oldAttr){
  		list[_findNodeIndex(list,oldAttr)] = newAttr;
  	}else{
  		list[list.length++] = newAttr;
  	}
  	if(el){
  		newAttr.ownerElement = el;
  		var doc = el.ownerDocument;
  		if(doc){
  			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
  			_onAddAttribute(doc,el,newAttr);
  		}
  	}
  }
  function _removeNamedNode(el,list,attr){
  	//console.log('remove attr:'+attr)
  	var i = _findNodeIndex(list,attr);
  	if(i>=0){
  		var lastIndex = list.length-1;
  		while(i<lastIndex){
  			list[i] = list[++i];
  		}
  		list.length = lastIndex;
  		if(el){
  			var doc = el.ownerDocument;
  			if(doc){
  				_onRemoveAttribute(doc,el,attr);
  				attr.ownerElement = null;
  			}
  		}
  	}else{
  		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
  	}
  }
  NamedNodeMap.prototype = {
  	length:0,
  	item:NodeList.prototype.item,
  	getNamedItem: function(key) {
  //		if(key.indexOf(':')>0 || key == 'xmlns'){
  //			return null;
  //		}
  		//console.log()
  		var i = this.length;
  		while(i--){
  			var attr = this[i];
  			//console.log(attr.nodeName,key)
  			if(attr.nodeName == key){
  				return attr;
  			}
  		}
  	},
  	setNamedItem: function(attr) {
  		var el = attr.ownerElement;
  		if(el && el!=this._ownerElement){
  			throw new DOMException(INUSE_ATTRIBUTE_ERR);
  		}
  		var oldAttr = this.getNamedItem(attr.nodeName);
  		_addNamedNode(this._ownerElement,this,attr,oldAttr);
  		return oldAttr;
  	},
  	/* returns Node */
  	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
  		var el = attr.ownerElement, oldAttr;
  		if(el && el!=this._ownerElement){
  			throw new DOMException(INUSE_ATTRIBUTE_ERR);
  		}
  		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
  		_addNamedNode(this._ownerElement,this,attr,oldAttr);
  		return oldAttr;
  	},

  	/* returns Node */
  	removeNamedItem: function(key) {
  		var attr = this.getNamedItem(key);
  		_removeNamedNode(this._ownerElement,this,attr);
  		return attr;
  		
  		
  	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  	
  	//for level2
  	removeNamedItemNS:function(namespaceURI,localName){
  		var attr = this.getNamedItemNS(namespaceURI,localName);
  		_removeNamedNode(this._ownerElement,this,attr);
  		return attr;
  	},
  	getNamedItemNS: function(namespaceURI, localName) {
  		var i = this.length;
  		while(i--){
  			var node = this[i];
  			if(node.localName == localName && node.namespaceURI == namespaceURI){
  				return node;
  			}
  		}
  		return null;
  	}
  };
  /**
   * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
   */
  function DOMImplementation(/* Object */ features) {
  	this._features = {};
  	if (features) {
  		for (var feature in features) {
  			 this._features = features[feature];
  		}
  	}
  }
  DOMImplementation.prototype = {
  	hasFeature: function(/* string */ feature, /* string */ version) {
  		var versions = this._features[feature.toLowerCase()];
  		if (versions && (!version || version in versions)) {
  			return true;
  		} else {
  			return false;
  		}
  	},
  	// Introduced in DOM Level 2:
  	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
  		var doc = new Document();
  		doc.implementation = this;
  		doc.childNodes = new NodeList();
  		doc.doctype = doctype;
  		if(doctype){
  			doc.appendChild(doctype);
  		}
  		if(qualifiedName){
  			var root = doc.createElementNS(namespaceURI,qualifiedName);
  			doc.appendChild(root);
  		}
  		return doc;
  	},
  	// Introduced in DOM Level 2:
  	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
  		var node = new DocumentType();
  		node.name = qualifiedName;
  		node.nodeName = qualifiedName;
  		node.publicId = publicId;
  		node.systemId = systemId;
  		// Introduced in DOM Level 2:
  		//readonly attribute DOMString        internalSubset;
  		
  		//TODO:..
  		//  readonly attribute NamedNodeMap     entities;
  		//  readonly attribute NamedNodeMap     notations;
  		return node;
  	}
  };


  /**
   * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
   */

  function Node$1() {
  }
  Node$1.prototype = {
  	firstChild : null,
  	lastChild : null,
  	previousSibling : null,
  	nextSibling : null,
  	attributes : null,
  	parentNode : null,
  	childNodes : null,
  	ownerDocument : null,
  	nodeValue : null,
  	namespaceURI : null,
  	prefix : null,
  	localName : null,
  	// Modified in DOM Level 2:
  	insertBefore:function(newChild, refChild){//raises 
  		return _insertBefore(this,newChild,refChild);
  	},
  	replaceChild:function(newChild, oldChild){//raises 
  		this.insertBefore(newChild,oldChild);
  		if(oldChild){
  			this.removeChild(oldChild);
  		}
  	},
  	removeChild:function(oldChild){
  		return _removeChild(this,oldChild);
  	},
  	appendChild:function(newChild){
  		return this.insertBefore(newChild,null);
  	},
  	hasChildNodes:function(){
  		return this.firstChild != null;
  	},
  	cloneNode:function(deep){
  		return cloneNode(this.ownerDocument||this,this,deep);
  	},
  	// Modified in DOM Level 2:
  	normalize:function(){
  		var child = this.firstChild;
  		while(child){
  			var next = child.nextSibling;
  			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
  				this.removeChild(next);
  				child.appendData(next.data);
  			}else{
  				child.normalize();
  				child = next;
  			}
  		}
  	},
    	// Introduced in DOM Level 2:
  	isSupported:function(feature, version){
  		return this.ownerDocument.implementation.hasFeature(feature,version);
  	},
      // Introduced in DOM Level 2:
      hasAttributes:function(){
      	return this.attributes.length>0;
      },
      lookupPrefix:function(namespaceURI){
      	var el = this;
      	while(el){
      		var map = el._nsMap;
      		//console.dir(map)
      		if(map){
      			for(var n in map){
      				if(map[n] == namespaceURI){
      					return n;
      				}
      			}
      		}
      		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
      	}
      	return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI:function(prefix){
      	var el = this;
      	while(el){
      		var map = el._nsMap;
      		//console.dir(map)
      		if(map){
      			if(prefix in map){
      				return map[prefix] ;
      			}
      		}
      		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
      	}
      	return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace:function(namespaceURI){
      	var prefix = this.lookupPrefix(namespaceURI);
      	return prefix == null;
      }
  };


  function _xmlEncoder(c){
  	return c == '<' && '&lt;' ||
           c == '>' && '&gt;' ||
           c == '&' && '&amp;' ||
           c == '"' && '&quot;' ||
           '&#'+c.charCodeAt()+';'
  }


  copy$1(NodeType,Node$1);
  copy$1(NodeType,Node$1.prototype);

  /**
   * @param callback return true for continue,false for break
   * @return boolean true: break visit;
   */
  function _visitNode(node,callback){
  	if(callback(node)){
  		return true;
  	}
  	if(node = node.firstChild){
  		do{
  			if(_visitNode(node,callback)){return true}
          }while(node=node.nextSibling)
      }
  }



  function Document(){
  }
  function _onAddAttribute(doc,el,newAttr){
  	doc && doc._inc++;
  	var ns = newAttr.namespaceURI ;
  	if(ns == 'http://www.w3.org/2000/xmlns/'){
  		//update namespace
  		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value;
  	}
  }
  function _onRemoveAttribute(doc,el,newAttr,remove){
  	doc && doc._inc++;
  	var ns = newAttr.namespaceURI ;
  	if(ns == 'http://www.w3.org/2000/xmlns/'){
  		//update namespace
  		delete el._nsMap[newAttr.prefix?newAttr.localName:''];
  	}
  }
  function _onUpdateChild(doc,el,newChild){
  	if(doc && doc._inc){
  		doc._inc++;
  		//update childNodes
  		var cs = el.childNodes;
  		if(newChild){
  			cs[cs.length++] = newChild;
  		}else{
  			//console.log(1)
  			var child = el.firstChild;
  			var i = 0;
  			while(child){
  				cs[i++] = child;
  				child =child.nextSibling;
  			}
  			cs.length = i;
  		}
  	}
  }

  /**
   * attributes;
   * children;
   * 
   * writeable properties:
   * nodeValue,Attr:value,CharacterData:data
   * prefix
   */
  function _removeChild(parentNode,child){
  	var previous = child.previousSibling;
  	var next = child.nextSibling;
  	if(previous){
  		previous.nextSibling = next;
  	}else{
  		parentNode.firstChild = next;
  	}
  	if(next){
  		next.previousSibling = previous;
  	}else{
  		parentNode.lastChild = previous;
  	}
  	_onUpdateChild(parentNode.ownerDocument,parentNode);
  	return child;
  }
  /**
   * preformance key(refChild == null)
   */
  function _insertBefore(parentNode,newChild,nextChild){
  	var cp = newChild.parentNode;
  	if(cp){
  		cp.removeChild(newChild);//remove and update
  	}
  	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
  		var newFirst = newChild.firstChild;
  		if (newFirst == null) {
  			return newChild;
  		}
  		var newLast = newChild.lastChild;
  	}else{
  		newFirst = newLast = newChild;
  	}
  	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

  	newFirst.previousSibling = pre;
  	newLast.nextSibling = nextChild;
  	
  	
  	if(pre){
  		pre.nextSibling = newFirst;
  	}else{
  		parentNode.firstChild = newFirst;
  	}
  	if(nextChild == null){
  		parentNode.lastChild = newLast;
  	}else{
  		nextChild.previousSibling = newLast;
  	}
  	do{
  		newFirst.parentNode = parentNode;
  	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
  	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
  	//console.log(parentNode.lastChild.nextSibling == null)
  	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
  		newChild.firstChild = newChild.lastChild = null;
  	}
  	return newChild;
  }
  function _appendSingleChild(parentNode,newChild){
  	var cp = newChild.parentNode;
  	if(cp){
  		var pre = parentNode.lastChild;
  		cp.removeChild(newChild);//remove and update
  		var pre = parentNode.lastChild;
  	}
  	var pre = parentNode.lastChild;
  	newChild.parentNode = parentNode;
  	newChild.previousSibling = pre;
  	newChild.nextSibling = null;
  	if(pre){
  		pre.nextSibling = newChild;
  	}else{
  		parentNode.firstChild = newChild;
  	}
  	parentNode.lastChild = newChild;
  	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
  	return newChild;
  	//console.log("__aa",parentNode.lastChild.nextSibling == null)
  }
  Document.prototype = {
  	//implementation : null,
  	nodeName :  '#document',
  	nodeType :  DOCUMENT_NODE,
  	doctype :  null,
  	documentElement :  null,
  	_inc : 1,
  	
  	insertBefore :  function(newChild, refChild){//raises 
  		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
  			var child = newChild.firstChild;
  			while(child){
  				var next = child.nextSibling;
  				this.insertBefore(child,refChild);
  				child = next;
  			}
  			return newChild;
  		}
  		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
  			this.documentElement = newChild;
  		}
  		
  		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
  	},
  	removeChild :  function(oldChild){
  		if(this.documentElement == oldChild){
  			this.documentElement = null;
  		}
  		return _removeChild(this,oldChild);
  	},
  	// Introduced in DOM Level 2:
  	importNode : function(importedNode,deep){
  		return importNode(this,importedNode,deep);
  	},
  	// Introduced in DOM Level 2:
  	getElementById :	function(id){
  		var rtv = null;
  		_visitNode(this.documentElement,function(node){
  			if(node.nodeType == ELEMENT_NODE){
  				if(node.getAttribute('id') == id){
  					rtv = node;
  					return true;
  				}
  			}
  		});
  		return rtv;
  	},
  	
  	//document factory method:
  	createElement :	function(tagName){
  		var node = new Element();
  		node.ownerDocument = this;
  		node.nodeName = tagName;
  		node.tagName = tagName;
  		node.childNodes = new NodeList();
  		var attrs	= node.attributes = new NamedNodeMap();
  		attrs._ownerElement = node;
  		return node;
  	},
  	createDocumentFragment :	function(){
  		var node = new DocumentFragment();
  		node.ownerDocument = this;
  		node.childNodes = new NodeList();
  		return node;
  	},
  	createTextNode :	function(data){
  		var node = new Text();
  		node.ownerDocument = this;
  		node.appendData(data);
  		return node;
  	},
  	createComment :	function(data){
  		var node = new Comment();
  		node.ownerDocument = this;
  		node.appendData(data);
  		return node;
  	},
  	createCDATASection :	function(data){
  		var node = new CDATASection();
  		node.ownerDocument = this;
  		node.appendData(data);
  		return node;
  	},
  	createProcessingInstruction :	function(target,data){
  		var node = new ProcessingInstruction();
  		node.ownerDocument = this;
  		node.tagName = node.target = target;
  		node.nodeValue= node.data = data;
  		return node;
  	},
  	createAttribute :	function(name){
  		var node = new Attr();
  		node.ownerDocument	= this;
  		node.name = name;
  		node.nodeName	= name;
  		node.localName = name;
  		node.specified = true;
  		return node;
  	},
  	createEntityReference :	function(name){
  		var node = new EntityReference();
  		node.ownerDocument	= this;
  		node.nodeName	= name;
  		return node;
  	},
  	// Introduced in DOM Level 2:
  	createElementNS :	function(namespaceURI,qualifiedName){
  		var node = new Element();
  		var pl = qualifiedName.split(':');
  		var attrs	= node.attributes = new NamedNodeMap();
  		node.childNodes = new NodeList();
  		node.ownerDocument = this;
  		node.nodeName = qualifiedName;
  		node.tagName = qualifiedName;
  		node.namespaceURI = namespaceURI;
  		if(pl.length == 2){
  			node.prefix = pl[0];
  			node.localName = pl[1];
  		}else{
  			//el.prefix = null;
  			node.localName = qualifiedName;
  		}
  		attrs._ownerElement = node;
  		return node;
  	},
  	// Introduced in DOM Level 2:
  	createAttributeNS :	function(namespaceURI,qualifiedName){
  		var node = new Attr();
  		var pl = qualifiedName.split(':');
  		node.ownerDocument = this;
  		node.nodeName = qualifiedName;
  		node.name = qualifiedName;
  		node.namespaceURI = namespaceURI;
  		node.specified = true;
  		if(pl.length == 2){
  			node.prefix = pl[0];
  			node.localName = pl[1];
  		}else{
  			//el.prefix = null;
  			node.localName = qualifiedName;
  		}
  		return node;
  	}
  };
  _extends(Document,Node$1);


  function Element() {
  	this._nsMap = {};
  }Element.prototype = {
  	nodeType : ELEMENT_NODE,
  	hasAttribute : function(name){
  		return this.getAttributeNode(name)!=null;
  	},
  	getAttribute : function(name){
  		var attr = this.getAttributeNode(name);
  		return attr && attr.value || '';
  	},
  	getAttributeNode : function(name){
  		return this.attributes.getNamedItem(name);
  	},
  	setAttribute : function(name, value){
  		var attr = this.ownerDocument.createAttribute(name);
  		attr.value = attr.nodeValue = "" + value;
  		this.setAttributeNode(attr);
  	},
  	removeAttribute : function(name){
  		var attr = this.getAttributeNode(name);
  		attr && this.removeAttributeNode(attr);
  	},
  	
  	//four real opeartion method
  	appendChild:function(newChild){
  		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
  			return this.insertBefore(newChild,null);
  		}else{
  			return _appendSingleChild(this,newChild);
  		}
  	},
  	setAttributeNode : function(newAttr){
  		return this.attributes.setNamedItem(newAttr);
  	},
  	setAttributeNodeNS : function(newAttr){
  		return this.attributes.setNamedItemNS(newAttr);
  	},
  	removeAttributeNode : function(oldAttr){
  		//console.log(this == oldAttr.ownerElement)
  		return this.attributes.removeNamedItem(oldAttr.nodeName);
  	},
  	//get real attribute name,and remove it by removeAttributeNode
  	removeAttributeNS : function(namespaceURI, localName){
  		var old = this.getAttributeNodeNS(namespaceURI, localName);
  		old && this.removeAttributeNode(old);
  	},
  	
  	hasAttributeNS : function(namespaceURI, localName){
  		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
  	},
  	getAttributeNS : function(namespaceURI, localName){
  		var attr = this.getAttributeNodeNS(namespaceURI, localName);
  		return attr && attr.value || '';
  	},
  	setAttributeNS : function(namespaceURI, qualifiedName, value){
  		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
  		attr.value = attr.nodeValue = "" + value;
  		this.setAttributeNode(attr);
  	},
  	getAttributeNodeNS : function(namespaceURI, localName){
  		return this.attributes.getNamedItemNS(namespaceURI, localName);
  	},
  	
  	getElementsByTagName : function(tagName){
  		return new LiveNodeList(this,function(base){
  			var ls = [];
  			_visitNode(base,function(node){
  				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
  					ls.push(node);
  				}
  			});
  			return ls;
  		});
  	},
  	getElementsByTagNameNS : function(namespaceURI, localName){
  		return new LiveNodeList(this,function(base){
  			var ls = [];
  			_visitNode(base,function(node){
  				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
  					ls.push(node);
  				}
  			});
  			return ls;
  			
  		});
  	}
  };
  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


  _extends(Element,Node$1);
  function Attr() {
  }Attr.prototype.nodeType = ATTRIBUTE_NODE;
  _extends(Attr,Node$1);


  function CharacterData() {
  }CharacterData.prototype = {
  	data : '',
  	substringData : function(offset, count) {
  		return this.data.substring(offset, offset+count);
  	},
  	appendData: function(text) {
  		text = this.data+text;
  		this.nodeValue = this.data = text;
  		this.length = text.length;
  	},
  	insertData: function(offset,text) {
  		this.replaceData(offset,0,text);
  	
  	},
  	appendChild:function(newChild){
  		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
  	},
  	deleteData: function(offset, count) {
  		this.replaceData(offset,count,"");
  	},
  	replaceData: function(offset, count, text) {
  		var start = this.data.substring(0,offset);
  		var end = this.data.substring(offset+count);
  		text = start + text + end;
  		this.nodeValue = this.data = text;
  		this.length = text.length;
  	}
  };
  _extends(CharacterData,Node$1);
  function Text() {
  }Text.prototype = {
  	nodeName : "#text",
  	nodeType : TEXT_NODE,
  	splitText : function(offset) {
  		var text = this.data;
  		var newText = text.substring(offset);
  		text = text.substring(0, offset);
  		this.data = this.nodeValue = text;
  		this.length = text.length;
  		var newNode = this.ownerDocument.createTextNode(newText);
  		if(this.parentNode){
  			this.parentNode.insertBefore(newNode, this.nextSibling);
  		}
  		return newNode;
  	}
  };
  _extends(Text,CharacterData);
  function Comment() {
  }Comment.prototype = {
  	nodeName : "#comment",
  	nodeType : COMMENT_NODE
  };
  _extends(Comment,CharacterData);

  function CDATASection() {
  }CDATASection.prototype = {
  	nodeName : "#cdata-section",
  	nodeType : CDATA_SECTION_NODE
  };
  _extends(CDATASection,CharacterData);


  function DocumentType() {
  }DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  _extends(DocumentType,Node$1);

  function Notation() {
  }Notation.prototype.nodeType = NOTATION_NODE;
  _extends(Notation,Node$1);

  function Entity() {
  }Entity.prototype.nodeType = ENTITY_NODE;
  _extends(Entity,Node$1);

  function EntityReference() {
  }EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  _extends(EntityReference,Node$1);

  function DocumentFragment() {
  }DocumentFragment.prototype.nodeName =	"#document-fragment";
  DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
  _extends(DocumentFragment,Node$1);


  function ProcessingInstruction() {
  }
  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  _extends(ProcessingInstruction,Node$1);
  function XMLSerializer(){}
  XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
  	return nodeSerializeToString.call(node,isHtml,nodeFilter);
  };
  Node$1.prototype.toString = nodeSerializeToString;
  function nodeSerializeToString(isHtml,nodeFilter){
  	var buf = [];
  	var refNode = this.nodeType == 9?this.documentElement:this;
  	var prefix = refNode.prefix;
  	var uri = refNode.namespaceURI;
  	
  	if(uri && prefix == null){
  		//console.log(prefix)
  		var prefix = refNode.lookupPrefix(uri);
  		if(prefix == null){
  			//isHTML = true;
  			var visibleNamespaces=[
  			{namespace:uri,prefix:null}
  			//{namespace:uri,prefix:''}
  			];
  		}
  	}
  	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
  	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
  	return buf.join('');
  }
  function needNamespaceDefine(node,isHTML, visibleNamespaces) {
  	var prefix = node.prefix||'';
  	var uri = node.namespaceURI;
  	if (!prefix && !uri){
  		return false;
  	}
  	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
  		|| uri == 'http://www.w3.org/2000/xmlns/'){
  		return false;
  	}
  	
  	var i = visibleNamespaces.length; 
  	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
  	while (i--) {
  		var ns = visibleNamespaces[i];
  		// get namespace prefix
  		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
  		if (ns.prefix == prefix){
  			return ns.namespace != uri;
  		}
  	}
  	//console.log(isHTML,uri,prefix=='')
  	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
  	//	return false;
  	//}
  	//node.flag = '11111'
  	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
  	return true;
  }
  function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
  	if(nodeFilter){
  		node = nodeFilter(node);
  		if(node){
  			if(typeof node == 'string'){
  				buf.push(node);
  				return;
  			}
  		}else{
  			return;
  		}
  		//buf.sort.apply(attrs, attributeSorter);
  	}
  	switch(node.nodeType){
  	case ELEMENT_NODE:
  		if (!visibleNamespaces) visibleNamespaces = [];
  		var startVisibleNamespaces = visibleNamespaces.length;
  		var attrs = node.attributes;
  		var len = attrs.length;
  		var child = node.firstChild;
  		var nodeName = node.tagName;
  		
  		isHTML =  (htmlns === node.namespaceURI) ||isHTML; 
  		buf.push('<',nodeName);
  		
  		
  		
  		for(var i=0;i<len;i++){
  			// add namespaces for attributes
  			var attr = attrs.item(i);
  			if (attr.prefix == 'xmlns') {
  				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
  			}else if(attr.nodeName == 'xmlns'){
  				visibleNamespaces.push({ prefix: '', namespace: attr.value });
  			}
  		}
  		for(var i=0;i<len;i++){
  			var attr = attrs.item(i);
  			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
  				var prefix = attr.prefix||'';
  				var uri = attr.namespaceURI;
  				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
  				buf.push(ns, '="' , uri , '"');
  				visibleNamespaces.push({ prefix: prefix, namespace:uri });
  			}
  			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
  		}
  		// add namespace for current node		
  		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
  			var prefix = node.prefix||'';
  			var uri = node.namespaceURI;
  			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
  			buf.push(ns, '="' , uri , '"');
  			visibleNamespaces.push({ prefix: prefix, namespace:uri });
  		}
  		
  		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
  			buf.push('>');
  			//if is cdata child node
  			if(isHTML && /^script$/i.test(nodeName)){
  				while(child){
  					if(child.data){
  						buf.push(child.data);
  					}else{
  						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
  					}
  					child = child.nextSibling;
  				}
  			}else
  			{
  				while(child){
  					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
  					child = child.nextSibling;
  				}
  			}
  			buf.push('</',nodeName,'>');
  		}else{
  			buf.push('/>');
  		}
  		// remove added visible namespaces
  		//visibleNamespaces.length = startVisibleNamespaces;
  		return;
  	case DOCUMENT_NODE:
  	case DOCUMENT_FRAGMENT_NODE:
  		var child = node.firstChild;
  		while(child){
  			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
  			child = child.nextSibling;
  		}
  		return;
  	case ATTRIBUTE_NODE:
  		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
  	case TEXT_NODE:
  		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
  	case CDATA_SECTION_NODE:
  		return buf.push( '<![CDATA[',node.data,']]>');
  	case COMMENT_NODE:
  		return buf.push( "<!--",node.data,"-->");
  	case DOCUMENT_TYPE_NODE:
  		var pubid = node.publicId;
  		var sysid = node.systemId;
  		buf.push('<!DOCTYPE ',node.name);
  		if(pubid){
  			buf.push(' PUBLIC "',pubid);
  			if (sysid && sysid!='.') {
  				buf.push( '" "',sysid);
  			}
  			buf.push('">');
  		}else if(sysid && sysid!='.'){
  			buf.push(' SYSTEM "',sysid,'">');
  		}else{
  			var sub = node.internalSubset;
  			if(sub){
  				buf.push(" [",sub,"]");
  			}
  			buf.push(">");
  		}
  		return;
  	case PROCESSING_INSTRUCTION_NODE:
  		return buf.push( "<?",node.target," ",node.data,"?>");
  	case ENTITY_REFERENCE_NODE:
  		return buf.push( '&',node.nodeName,';');
  	//case ENTITY_NODE:
  	//case NOTATION_NODE:
  	default:
  		buf.push('??',node.nodeName);
  	}
  }
  function importNode(doc,node,deep){
  	var node2;
  	switch (node.nodeType) {
  	case ELEMENT_NODE:
  		node2 = node.cloneNode(false);
  		node2.ownerDocument = doc;
  		//var attrs = node2.attributes;
  		//var len = attrs.length;
  		//for(var i=0;i<len;i++){
  			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
  		//}
  	case DOCUMENT_FRAGMENT_NODE:
  		break;
  	case ATTRIBUTE_NODE:
  		deep = true;
  		break;
  	//case ENTITY_REFERENCE_NODE:
  	//case PROCESSING_INSTRUCTION_NODE:
  	////case TEXT_NODE:
  	//case CDATA_SECTION_NODE:
  	//case COMMENT_NODE:
  	//	deep = false;
  	//	break;
  	//case DOCUMENT_NODE:
  	//case DOCUMENT_TYPE_NODE:
  	//cannot be imported.
  	//case ENTITY_NODE:
  	//case NOTATION_NODEï¼š
  	//can not hit in level3
  	//default:throw e;
  	}
  	if(!node2){
  		node2 = node.cloneNode(false);//false
  	}
  	node2.ownerDocument = doc;
  	node2.parentNode = null;
  	if(deep){
  		var child = node.firstChild;
  		while(child){
  			node2.appendChild(importNode(doc,child,deep));
  			child = child.nextSibling;
  		}
  	}
  	return node2;
  }
  //
  //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
  //					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
  function cloneNode(doc,node,deep){
  	var node2 = new node.constructor();
  	for(var n in node){
  		var v = node[n];
  		if(typeof v != 'object' ){
  			if(v != node2[n]){
  				node2[n] = v;
  			}
  		}
  	}
  	if(node.childNodes){
  		node2.childNodes = new NodeList();
  	}
  	node2.ownerDocument = doc;
  	switch (node2.nodeType) {
  	case ELEMENT_NODE:
  		var attrs	= node.attributes;
  		var attrs2	= node2.attributes = new NamedNodeMap();
  		var len = attrs.length;
  		attrs2._ownerElement = node2;
  		for(var i=0;i<len;i++){
  			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
  		}
  		break;	case ATTRIBUTE_NODE:
  		deep = true;
  	}
  	if(deep){
  		var child = node.firstChild;
  		while(child){
  			node2.appendChild(cloneNode(doc,child,deep));
  			child = child.nextSibling;
  		}
  	}
  	return node2;
  }

  function __set__(object,key,value){
  	object[key] = value;
  }
  //do dynamic
  try{
  	if(Object.defineProperty){
  		Object.defineProperty(LiveNodeList.prototype,'length',{
  			get:function(){
  				_updateLiveList(this);
  				return this.$$length;
  			}
  		});
  		Object.defineProperty(Node$1.prototype,'textContent',{
  			get:function(){
  				return getTextContent(this);
  			},
  			set:function(data){
  				switch(this.nodeType){
  				case ELEMENT_NODE:
  				case DOCUMENT_FRAGMENT_NODE:
  					while(this.firstChild){
  						this.removeChild(this.firstChild);
  					}
  					if(data || String(data)){
  						this.appendChild(this.ownerDocument.createTextNode(data));
  					}
  					break;
  				default:
  					//TODO:
  					this.data = data;
  					this.value = data;
  					this.nodeValue = data;
  				}
  			}
  		});
  		
  		function getTextContent(node){
  			switch(node.nodeType){
  			case ELEMENT_NODE:
  			case DOCUMENT_FRAGMENT_NODE:
  				var buf = [];
  				node = node.firstChild;
  				while(node){
  					if(node.nodeType!==7 && node.nodeType !==8){
  						buf.push(getTextContent(node));
  					}
  					node = node.nextSibling;
  				}
  				return buf.join('');
  			default:
  				return node.nodeValue;
  			}
  		}
  		__set__ = function(object,key,value){
  			//console.log(value)
  			object['$$'+key] = value;
  		};
  	}
  }catch(e){//ie8
  }

  //if(typeof require == 'function'){
  	var DOMImplementation_1 = DOMImplementation;
  	var XMLSerializer_1 = XMLSerializer;
  //}

  var dom = {
  	DOMImplementation: DOMImplementation_1,
  	XMLSerializer: XMLSerializer_1
  };

  var domParser = createCommonjsModule(function (module, exports) {
  function DOMParser(options){
  	this.options = options ||{locator:{}};
  	
  }
  DOMParser.prototype.parseFromString = function(source,mimeType){
  	var options = this.options;
  	var sax =  new XMLReader();
  	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
  	var errorHandler = options.errorHandler;
  	var locator = options.locator;
  	var defaultNSMap = options.xmlns||{};
  	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"};
  	if(locator){
  		domBuilder.setDocumentLocator(locator);
  	}
  	
  	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
  	sax.domBuilder = options.domBuilder || domBuilder;
  	if(/\/x?html?$/.test(mimeType)){
  		entityMap.nbsp = '\xa0';
  		entityMap.copy = '\xa9';
  		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
  	}
  	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
  	if(source){
  		sax.parse(source,defaultNSMap,entityMap);
  	}else{
  		sax.errorHandler.error("invalid doc source");
  	}
  	return domBuilder.doc;
  };
  function buildErrorHandler(errorImpl,domBuilder,locator){
  	if(!errorImpl){
  		if(domBuilder instanceof DOMHandler){
  			return domBuilder;
  		}
  		errorImpl = domBuilder ;
  	}
  	var errorHandler = {};
  	var isCallback = errorImpl instanceof Function;
  	locator = locator||{};
  	function build(key){
  		var fn = errorImpl[key];
  		if(!fn && isCallback){
  			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg);}:errorImpl;
  		}
  		errorHandler[key] = fn && function(msg){
  			fn('[xmldom '+key+']\t'+msg+_locator(locator));
  		}||function(){};
  	}
  	build('warning');
  	build('error');
  	build('fatalError');
  	return errorHandler;
  }

  //console.log('#\n\n\n\n\n\n\n####')
  /**
   * +ContentHandler+ErrorHandler
   * +LexicalHandler+EntityResolver2
   * -DeclHandler-DTDHandler 
   * 
   * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
   * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
   * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
   */
  function DOMHandler() {
      this.cdata = false;
  }
  function position(locator,node){
  	node.lineNumber = locator.lineNumber;
  	node.columnNumber = locator.columnNumber;
  }
  /**
   * @see org.xml.sax.ContentHandler#startDocument
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
   */ 
  DOMHandler.prototype = {
  	startDocument : function() {
      	this.doc = new DOMImplementation().createDocument(null, null, null);
      	if (this.locator) {
          	this.doc.documentURI = this.locator.systemId;
      	}
  	},
  	startElement:function(namespaceURI, localName, qName, attrs) {
  		var doc = this.doc;
  	    var el = doc.createElementNS(namespaceURI, qName||localName);
  	    var len = attrs.length;
  	    appendElement(this, el);
  	    this.currentElement = el;
  	    
  		this.locator && position(this.locator,el);
  	    for (var i = 0 ; i < len; i++) {
  	        var namespaceURI = attrs.getURI(i);
  	        var value = attrs.getValue(i);
  	        var qName = attrs.getQName(i);
  			var attr = doc.createAttributeNS(namespaceURI, qName);
  			this.locator &&position(attrs.getLocator(i),attr);
  			attr.value = attr.nodeValue = value;
  			el.setAttributeNode(attr);
  	    }
  	},
  	endElement:function(namespaceURI, localName, qName) {
  		var current = this.currentElement;
  		var tagName = current.tagName;
  		this.currentElement = current.parentNode;
  	},
  	startPrefixMapping:function(prefix, uri) {
  	},
  	endPrefixMapping:function(prefix) {
  	},
  	processingInstruction:function(target, data) {
  	    var ins = this.doc.createProcessingInstruction(target, data);
  	    this.locator && position(this.locator,ins);
  	    appendElement(this, ins);
  	},
  	ignorableWhitespace:function(ch, start, length) {
  	},
  	characters:function(chars, start, length) {
  		chars = _toString.apply(this,arguments);
  		//console.log(chars)
  		if(chars){
  			if (this.cdata) {
  				var charNode = this.doc.createCDATASection(chars);
  			} else {
  				var charNode = this.doc.createTextNode(chars);
  			}
  			if(this.currentElement){
  				this.currentElement.appendChild(charNode);
  			}else if(/^\s*$/.test(chars)){
  				this.doc.appendChild(charNode);
  				//process xml
  			}
  			this.locator && position(this.locator,charNode);
  		}
  	},
  	skippedEntity:function(name) {
  	},
  	endDocument:function() {
  		this.doc.normalize();
  	},
  	setDocumentLocator:function (locator) {
  	    if(this.locator = locator){// && !('lineNumber' in locator)){
  	    	locator.lineNumber = 0;
  	    }
  	},
  	//LexicalHandler
  	comment:function(chars, start, length) {
  		chars = _toString.apply(this,arguments);
  	    var comm = this.doc.createComment(chars);
  	    this.locator && position(this.locator,comm);
  	    appendElement(this, comm);
  	},
  	
  	startCDATA:function() {
  	    //used in characters() methods
  	    this.cdata = true;
  	},
  	endCDATA:function() {
  	    this.cdata = false;
  	},
  	
  	startDTD:function(name, publicId, systemId) {
  		var impl = this.doc.implementation;
  	    if (impl && impl.createDocumentType) {
  	        var dt = impl.createDocumentType(name, publicId, systemId);
  	        this.locator && position(this.locator,dt);
  	        appendElement(this, dt);
  	    }
  	},
  	/**
  	 * @see org.xml.sax.ErrorHandler
  	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
  	 */
  	warning:function(error) {
  		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
  	},
  	error:function(error) {
  		console.error('[xmldom error]\t'+error,_locator(this.locator));
  	},
  	fatalError:function(error) {
  		console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
  	    throw error;
  	}
  };
  function _locator(l){
  	if(l){
  		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
  	}
  }
  function _toString(chars,start,length){
  	if(typeof chars == 'string'){
  		return chars.substr(start,length)
  	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
  		if(chars.length >= start+length || start){
  			return new java.lang.String(chars,start,length)+'';
  		}
  		return chars;
  	}
  }

  /*
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
   * used method of org.xml.sax.ext.LexicalHandler:
   *  #comment(chars, start, length)
   *  #startCDATA()
   *  #endCDATA()
   *  #startDTD(name, publicId, systemId)
   *
   *
   * IGNORED method of org.xml.sax.ext.LexicalHandler:
   *  #endDTD()
   *  #startEntity(name)
   *  #endEntity(name)
   *
   *
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
   * IGNORED method of org.xml.sax.ext.DeclHandler
   * 	#attributeDecl(eName, aName, type, mode, value)
   *  #elementDecl(name, model)
   *  #externalEntityDecl(name, publicId, systemId)
   *  #internalEntityDecl(name, value)
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
   * IGNORED method of org.xml.sax.EntityResolver2
   *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
   *  #resolveEntity(publicId, systemId)
   *  #getExternalSubset(name, baseURI)
   * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
   * IGNORED method of org.xml.sax.DTDHandler
   *  #notationDecl(name, publicId, systemId) {};
   *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
   */
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
  	DOMHandler.prototype[key] = function(){return null};
  });

  /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
  function appendElement (hander,node) {
      if (!hander.currentElement) {
          hander.doc.appendChild(node);
      } else {
          hander.currentElement.appendChild(node);
      }
  }//appendChild and setAttributeNS are preformance key

  //if(typeof require == 'function'){
  	var XMLReader = sax.XMLReader;
  	var DOMImplementation = exports.DOMImplementation = dom.DOMImplementation;
  	exports.XMLSerializer = dom.XMLSerializer ;
  	exports.DOMParser = DOMParser;
  //}
  });
  var domParser_1 = domParser.DOMImplementation;
  var domParser_2 = domParser.XMLSerializer;
  var domParser_3 = domParser.DOMParser;

  var absSvgPath = absolutize;

  /**
   * redefine `path` with absolute coordinates
   *
   * @param {Array} path
   * @return {Array}
   */

  function absolutize(path){
  	var startX = 0;
  	var startY = 0;
  	var x = 0;
  	var y = 0;

  	return path.map(function(seg){
  		seg = seg.slice();
  		var type = seg[0];
  		var command = type.toUpperCase();

  		// is relative
  		if (type != command) {
  			seg[0] = command;
  			switch (type) {
  				case 'a':
  					seg[6] += x;
  					seg[7] += y;
  					break
  				case 'v':
  					seg[1] += y;
  					break
  				case 'h':
  					seg[1] += x;
  					break
  				default:
  					for (var i = 1; i < seg.length;) {
  						seg[i++] += x;
  						seg[i++] += y;
  					}
  			}
  		}

  		// update cursor state
  		switch (command) {
  			case 'Z':
  				x = startX;
  				y = startY;
  				break
  			case 'H':
  				x = seg[1];
  				break
  			case 'V':
  				y = seg[1];
  				break
  			case 'M':
  				x = startX = seg[1];
  				y = startY = seg[2];
  				break
  			default:
  				x = seg[seg.length - 2];
  				y = seg[seg.length - 1];
  		}

  		return seg
  	})
  }

  var max$2 = Math.max;
  var abs$1 = Math.abs;
  var pow = Math.pow;
  var sin$2 = Math.sin;
  var cos$1 = Math.cos;
  var tan = Math.tan;
  var acos$1 = Math.acos;
  var sqrt$1 = Math.sqrt;
  var ceil = Math.ceil;
  var Ï„ = Math.PI * 2;

  var arcToCurves = curves;

  function curves (px, py, cx, cy, rx, ry, xrot, large, sweep) {
    if (rx === 0 || ry === 0) return []

    xrot = xrot || 0;
    large = large || 0;
    sweep = sweep || 0;

    var sinphi = sin$2(xrot * Ï„ / 360);
    var cosphi = cos$1(xrot * Ï„ / 360);

    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) return []

    rx = abs$1(rx);
    ry = abs$1(ry);

    var lambda = (
      pow(pxp, 2) / pow(rx, 2) +
      pow(pyp, 2) / pow(ry, 2)
    );

    if (lambda > 1) {
      rx *= sqrt$1(lambda);
      ry *= sqrt$1(lambda);
    }

    var centre = getArcCentre(px, py, cx, cy, rx, ry, large, sweep, sinphi, cosphi, pxp, pyp);
    var centrex = centre[0];
    var centrey = centre[1];
    var ang1 = centre[2];
    var ang2 = centre[3];

    var segments = max$2(ceil(abs$1(ang2) / (Ï„ / 4)), 1);
    if (!segments) return []

    var curves = [];
    ang2 /= segments;
    while (segments--) {
      curves.push(approxUnitArc(ang1, ang2));
      ang1 += ang2;
    }

    var result = [];
    var curve, a, b, c;
    var i = 0, l = curves.length;

    while (i < l) {
      curve = curves[i++];
      a = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centrex, centrey);
      b = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centrex, centrey);
      c = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centrex, centrey);
      result[result.length] = [a[0], a[1], b[0], b[1], c[0], c[1]];
    }

    return result
  }

  function mapToEllipse (curve, rx, ry, cosphi, sinphi, centrex, centrey) {
    var x = curve[0] * rx;
    var y = curve[1] * ry;

    var xp = cosphi * x - sinphi * y;
    var yp = sinphi * x + cosphi * y;

    return [xp + centrex, yp + centrey]
  }

  function approxUnitArc (ang1, ang2) {
    var a = 4 / 3 * tan(ang2 / 4);

    var x1 = cos$1(ang1);
    var y1 = sin$2(ang1);
    var x2 = cos$1(ang1 + ang2);
    var y2 = sin$2(ang1 + ang2);

    return [
      [x1 - y1 * a, y1 + x1 * a ],
      [x2 + y2 * a, y2 - x2 * a],
      [x2, y2]
    ]
  }

  function getArcCentre (px, py, cx, cy, rx, ry, large, sweep, sinphi, cosphi, pxp, pyp) {
    var rxsq = pow(rx, 2);
    var rysq = pow(ry, 2);
    var pxpsq = pow(pxp, 2);
    var pypsq = pow(pyp, 2);

    var radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq);

    if (radicant < 0) radicant = 0;
    radicant /= (rxsq * pypsq) + (rysq * pxpsq);
    radicant = sqrt$1(radicant) * (large === sweep ? -1 : 1);

    var centrexp = radicant * rx / ry * pyp;
    var centreyp = radicant * -ry / rx * pxp;
    var centrex = cosphi * centrexp - sinphi * centreyp + (px + cx) / 2;
    var centrey = sinphi * centrexp + cosphi * centreyp + (py + cy) / 2;

    var vx1 = (pxp - centrexp) / rx;
    var vy1 = (pyp - centreyp) / ry;
    var vx2 = (-pxp - centrexp) / rx;
    var vy2 = (-pyp - centreyp) / ry;

    var ang1 = vectorAngle(1, 0, vx1, vy1);
    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

    if (sweep === 0 && ang2 > 0) ang2 -= Ï„;
    if (sweep === 1 && ang2 < 0) ang2 += Ï„;

    return [centrex, centrey, ang1, ang2]
  }

  function vectorAngle (ux, uy, vx, vy) {
    var sign = (ux * vy - uy * vx < 0) ? -1 : 1;
    var umag = sqrt$1(ux * ux + uy * uy);
    var vmag = sqrt$1(ux * ux + uy * uy);
    var dot = ux * vx + uy * vy;

    var div = dot / (umag * vmag);
    if (div > 1) div = 1;
    if (div < -1) div = -1;

    return sign * acos$1(div)
  }

  var curvifySvgPath = curvify;

  function curvify (path) {
    var result = [];
    var cmd, prev, curves;
    var x = 0, y = 0;
    var bx = 0, by = 0;
    var sx = 0, sy = 0;
    var qx, qy, cx, cy;
    var i = 0, j, m, sl;
    var l = path.length;
    var c, seg;

    while (i < l) {
      seg = path[i++], cmd = seg[0];

      if (cmd == 'M') sx = seg[1], sy = seg[2];
      else if (cmd == 'L') seg = line(x, y, seg[1], seg[2]);
      else if (cmd == 'H') seg = line(x, y, seg[1], y);
      else if (cmd == 'V') seg = line(x, y, x, seg[1]);
      else if (cmd == 'Z') seg = line(x, y, sx, sy);

      else if (cmd == 'A') {
        curves = arcToCurves(
          x, y, seg[6], seg[7],
          seg[1], seg[2], seg[3],
          seg[4], seg[5]
        );

        m = curves.length;
        if (!m) continue
        j = 0;

        while (j < m) {
          c = curves[j++];
          seg = ['C', c[0], c[1], c[2], c[3], c[4], c[5]];
          if (j < m) result[result.length] = seg;
        }
      }

      else if (cmd == 'S') {
        cx = x, cy = y;
        if (prev == 'C' || prev == 'S') {
          cx += cx - bx,
          cy += cy - by;
        }
        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];
      }

      else if (cmd == 'T') {
        if (prev == 'Q' || prev == 'T') {
          qx = x * 2 - qx, qy = y * 2 - qy;
        }
        else qx = x, qy = y;
        seg = quadratic(x, y, qx, qy, seg[1], seg[2]);
      }

      else if (cmd == 'Q') {
        qx = seg[1], qy = seg[2];
        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);
      }

      sl = seg.length;
      x = seg[sl - 2], y = seg[sl - 1];
      if (sl > 4) bx = seg[sl - 4], by = seg[sl - 3];
      else bx = x, by = y;
      prev = cmd;

      result[result.length] = seg;
    }

    return result
  }

  function line (x1, y1, x2, y2) {
    return ['C', x1, y1, x2, y2, x2, y2]
  }

  function quadratic (x1, y1, cx, cy, x2, y2) {
    return ['C',
      x1 / 3 + (2 / 3) * cx, y1 / 3 + (2 / 3) * cy,
      x2 / 3 + (2 / 3) * cx, y2 / 3 + (2 / 3) * cy,
      x2, y2
    ]
  }

  var parseSvgPath = parse$4;

  /**
   * expected argument lengths
   * @type {Object}
   */

  var length$2 = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0};

  /**
   * segment pattern
   * @type {RegExp}
   */

  var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;

  /**
   * parse an svg path data string. Generates an Array
   * of commands where each command is an Array of the
   * form `[command, arg1, arg2, ...]`
   *
   * @param {String} path
   * @return {Array}
   */

  function parse$4(path) {
  	var data = [];
  	path.replace(segment, function(_, command, args){
  		var type = command.toLowerCase();
  		args = parseValues(args);

  		// overloaded moveTo
  		if (type == 'm' && args.length > 2) {
  			data.push([command].concat(args.splice(0, 2)));
  			type = 'l';
  			command = command == 'm' ? 'l' : 'L';
  		}

  		while (true) {
  			if (args.length == length$2[type]) {
  				args.unshift(command);
  				return data.push(args)
  			}
  			if (args.length < length$2[type]) throw new Error('malformed path data')
  			data.push([command].concat(args.splice(0, length$2[type])));
  		}
  	});
  	return data
  }

  var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

  function parseValues(args) {
  	var numbers = args.match(number);
  	return numbers ? numbers.map(Number) : []
  }

  const simplify = (path, tolerance) => {
    if (isClosed(path)) {
      return simplifyPath(path, tolerance);
    } else {
      return [null, ...simplifyPath(path.slice(1), tolerance)];
    }
  };

  const removeRepeatedPoints = (path) => {
    const unrepeated = [path[0]];
    for (let nth = 1; nth < path.length; nth++) {
      const last = path[nth - 1];
      const current = path[nth];
      if (last === null || !equals$1(last, current)) {
        unrepeated.push(current);
      }
    }
    return unrepeated;
  };

  const toPaths$2 = ({ curveSegments, normalizeCoordinateSystem = true, tolerance = 0.01 }, svgPath) => {
    const paths = [];
    let path = [null];

    const newPath = () => {
      if (path[0] === null) {
        maybeClosePath();
      }
      if (path.length < 2) {
        // An empty path.
        return;
      }
      paths.push(path);
      path = [null];
    };

    const maybeClosePath = () => {
      path = removeRepeatedPoints(canonicalize$1(path));
      if (path.length > 3) {
        if (path[0] === null && equals$1(path[1], path[path.length - 1])) {
          // The path is closed, remove the leading null, and the duplicate point at the end.
          path = path.slice(1, path.length - 1);
          newPath();
        }
      }
    };

    for (const segment of svgPath) {
      const [directive, ...args] = segment;
      switch (directive) {
        case 'M': {
          maybeClosePath();
          newPath();
          const [x, y] = args;
          path.push([x, y]);
          break;
        }
        case 'C': {
          const [x1, y1, x2, y2, x, y] = args;
          const start = path[path.length - 1];
          const [xStart, yStart] = (start === null) ? [0, 0] : start;
          path = path.concat(buildAdaptiveCubicBezierCurve({ segments: curveSegments }, [[xStart, yStart], [x1, y1], [x2, y2], [x, y]]));
          break;
        }
        default: {
          throw Error(`Unexpected segment: ${JSON.stringify(segment)}`);
        }
      }
    }

    maybeClosePath();
    newPath();

    const simplifiedPaths = paths.map(path => simplify(path, tolerance));

    if (normalizeCoordinateSystem) {
      // Turn it upside down.
      return transform$7(fromScaling([1, -1, 0]), simplifiedPaths);
    } else {
      return simplifiedPaths;
    }
  };

  const fromSvgPath = (svgPath, options = {}) => {
    const paths = toPaths$2(options, curvifySvgPath(absSvgPath(parseSvgPath(new TextDecoder('utf8').decode(svgPath)))));
    for (const path of paths) {
      assertGood(path);
    }
    const geometry = { paths };
    return geometry;
  };

  var toPoints_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

  var toPoints = function toPoints(_ref) {
    var type = _ref.type,
        props = _objectWithoutProperties(_ref, ['type']);

    switch (type) {
      case 'circle':
        return getPointsFromCircle(props);
      case 'ellipse':
        return getPointsFromEllipse(props);
      case 'line':
        return getPointsFromLine(props);
      case 'path':
        return getPointsFromPath(props);
      case 'polygon':
        return getPointsFromPolygon(props);
      case 'polyline':
        return getPointsFromPolyline(props);
      case 'rect':
        return getPointsFromRect(props);
      case 'g':
        return getPointsFromG(props);
      default:
        throw new Error('Not a valid shape type');
    }
  };

  var getPointsFromCircle = function getPointsFromCircle(_ref2) {
    var cx = _ref2.cx,
        cy = _ref2.cy,
        r = _ref2.r;

    return [{ x: cx, y: cy - r, moveTo: true }, { x: cx, y: cy + r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }, { x: cx, y: cy - r, curve: { type: 'arc', rx: r, ry: r, sweepFlag: 1 } }];
  };

  var getPointsFromEllipse = function getPointsFromEllipse(_ref3) {
    var cx = _ref3.cx,
        cy = _ref3.cy,
        rx = _ref3.rx,
        ry = _ref3.ry;

    return [{ x: cx, y: cy - ry, moveTo: true }, { x: cx, y: cy + ry, curve: { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 } }, { x: cx, y: cy - ry, curve: { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 } }];
  };

  var getPointsFromLine = function getPointsFromLine(_ref4) {
    var x1 = _ref4.x1,
        x2 = _ref4.x2,
        y1 = _ref4.y1,
        y2 = _ref4.y2;

    return [{ x: x1, y: y1, moveTo: true }, { x: x2, y: y2 }];
  };

  var validCommands = /[MmLlHhVvCcSsQqTtAaZz]/g;

  var commandLengths = {
    A: 7,
    C: 6,
    H: 1,
    L: 2,
    M: 2,
    Q: 4,
    S: 4,
    T: 2,
    V: 1,
    Z: 0
  };

  var relativeCommands = ['a', 'c', 'h', 'l', 'm', 'q', 's', 't', 'v'];

  var isRelative = function isRelative(command) {
    return relativeCommands.indexOf(command) !== -1;
  };

  var optionalArcKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];

  var getCommands = function getCommands(d) {
    return d.match(validCommands);
  };

  var getParams = function getParams(d) {
    return d.split(validCommands).map(function (v) {
      return v.replace(/[0-9]+-/g, function (m) {
        return m.slice(0, -1) + ' -';
      });
    }).map(function (v) {
      return v.replace(/\.[0-9]+/g, function (m) {
        return m + ' ';
      });
    }).map(function (v) {
      return v.trim();
    }).filter(function (v) {
      return v.length > 0;
    }).map(function (v) {
      return v.split(/[ ,]+/).map(parseFloat).filter(function (n) {
        return !isNaN(n);
      });
    });
  };

  var getPointsFromPath = function getPointsFromPath(_ref5) {
    var d = _ref5.d;

    var commands = getCommands(d);
    var params = getParams(d);

    var points = [];

    var moveTo = void 0;

    for (var i = 0, l = commands.length; i < l; i++) {
      var command = commands[i];
      var upperCaseCommand = command.toUpperCase();
      var commandLength = commandLengths[upperCaseCommand];
      var relative = isRelative(command);

      if (commandLength > 0) {
        var commandParams = params.shift();
        var iterations = commandParams.length / commandLength;

        for (var j = 0; j < iterations; j++) {
          var prevPoint = points[points.length - 1] || { x: 0, y: 0 };

          switch (upperCaseCommand) {
            case 'M':
              var x = (relative ? prevPoint.x : 0) + commandParams.shift();
              var y = (relative ? prevPoint.y : 0) + commandParams.shift();

              if (j === 0) {
                moveTo = { x: x, y: y };
                points.push({ x: x, y: y, moveTo: true });
              } else {
                points.push({ x: x, y: y });
              }

              break;

            case 'L':
              points.push({
                x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                y: (relative ? prevPoint.y : 0) + commandParams.shift()
              });

              break;

            case 'H':
              points.push({
                x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                y: prevPoint.y
              });

              break;

            case 'V':
              points.push({
                x: prevPoint.x,
                y: (relative ? prevPoint.y : 0) + commandParams.shift()
              });

              break;

            case 'A':
              points.push({
                curve: {
                  type: 'arc',
                  rx: commandParams.shift(),
                  ry: commandParams.shift(),
                  xAxisRotation: commandParams.shift(),
                  largeArcFlag: commandParams.shift(),
                  sweepFlag: commandParams.shift()
                },
                x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                y: (relative ? prevPoint.y : 0) + commandParams.shift()
              });

              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = optionalArcKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var k = _step.value;

                  if (points[points.length - 1]['curve'][k] === 0) {
                    delete points[points.length - 1]['curve'][k];
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              break;

            case 'C':
              points.push({
                curve: {
                  type: 'cubic',
                  x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y1: (relative ? prevPoint.y : 0) + commandParams.shift(),
                  x2: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y2: (relative ? prevPoint.y : 0) + commandParams.shift()
                },
                x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                y: (relative ? prevPoint.y : 0) + commandParams.shift()
              });

              break;

            case 'S':
              var sx2 = (relative ? prevPoint.x : 0) + commandParams.shift();
              var sy2 = (relative ? prevPoint.y : 0) + commandParams.shift();
              var sx = (relative ? prevPoint.x : 0) + commandParams.shift();
              var sy = (relative ? prevPoint.y : 0) + commandParams.shift();

              var diff = {};

              var sx1 = void 0;
              var sy1 = void 0;

              if (prevPoint.curve && prevPoint.curve.type === 'cubic') {
                diff.x = Math.abs(prevPoint.x - prevPoint.curve.x2);
                diff.y = Math.abs(prevPoint.y - prevPoint.curve.y2);
                sx1 = prevPoint.x < prevPoint.curve.x2 ? prevPoint.x - diff.x : prevPoint.x + diff.x;
                sy1 = prevPoint.y < prevPoint.curve.y2 ? prevPoint.y - diff.y : prevPoint.y + diff.y;
              } else {
                diff.x = Math.abs(sx - sx2);
                diff.y = Math.abs(sy - sy2);
                sx1 = prevPoint.x;
                sy1 = prevPoint.y;
              }

              points.push({ curve: { type: 'cubic', x1: sx1, y1: sy1, x2: sx2, y2: sy2 }, x: sx, y: sy });

              break;

            case 'Q':
              points.push({
                curve: {
                  type: 'quadratic',
                  x1: (relative ? prevPoint.x : 0) + commandParams.shift(),
                  y1: (relative ? prevPoint.y : 0) + commandParams.shift()
                },
                x: (relative ? prevPoint.x : 0) + commandParams.shift(),
                y: (relative ? prevPoint.y : 0) + commandParams.shift()
              });

              break;

            case 'T':
              var tx = (relative ? prevPoint.x : 0) + commandParams.shift();
              var ty = (relative ? prevPoint.y : 0) + commandParams.shift();

              var tx1 = void 0;
              var ty1 = void 0;

              if (prevPoint.curve && prevPoint.curve.type === 'quadratic') {
                var _diff = {
                  x: Math.abs(prevPoint.x - prevPoint.curve.x1),
                  y: Math.abs(prevPoint.y - prevPoint.curve.y1)
                };

                tx1 = prevPoint.x < prevPoint.curve.x1 ? prevPoint.x - _diff.x : prevPoint.x + _diff.x;
                ty1 = prevPoint.y < prevPoint.curve.y1 ? prevPoint.y - _diff.y : prevPoint.y + _diff.y;
              } else {
                tx1 = prevPoint.x;
                ty1 = prevPoint.y;
              }

              points.push({ curve: { type: 'quadratic', x1: tx1, y1: ty1 }, x: tx, y: ty });

              break;
          }
        }
      } else {
        var _prevPoint = points[points.length - 1] || { x: 0, y: 0 };

        if (_prevPoint.x !== moveTo.x || _prevPoint.y !== moveTo.y) {
          points.push({ x: moveTo.x, y: moveTo.y });
        }
      }
    }

    return points;
  };

  var getPointsFromPolygon = function getPointsFromPolygon(_ref6) {
    var points = _ref6.points;

    return getPointsFromPoints({ closed: true, points: points });
  };

  var getPointsFromPolyline = function getPointsFromPolyline(_ref7) {
    var points = _ref7.points;

    return getPointsFromPoints({ closed: false, points: points });
  };

  var getPointsFromPoints = function getPointsFromPoints(_ref8) {
    var closed = _ref8.closed,
        points = _ref8.points;

    var numbers = points.split(/[\s,]+/).map(function (n) {
      return parseFloat(n);
    });

    var p = numbers.reduce(function (arr, point, i) {
      if (i % 2 === 0) {
        arr.push({ x: point });
      } else {
        arr[(i - 1) / 2].y = point;
      }

      return arr;
    }, []);

    if (closed) {
      p.push(_extends({}, p[0]));
    }

    p[0].moveTo = true;

    return p;
  };

  var getPointsFromRect = function getPointsFromRect(_ref9) {
    var height = _ref9.height,
        rx = _ref9.rx,
        ry = _ref9.ry,
        width = _ref9.width,
        x = _ref9.x,
        y = _ref9.y;

    if (rx || ry) {
      return getPointsFromRectWithCornerRadius({
        height: height,
        rx: rx || ry,
        ry: ry || rx,
        width: width,
        x: x,
        y: y
      });
    }

    return getPointsFromBasicRect({ height: height, width: width, x: x, y: y });
  };

  var getPointsFromBasicRect = function getPointsFromBasicRect(_ref10) {
    var height = _ref10.height,
        width = _ref10.width,
        x = _ref10.x,
        y = _ref10.y;

    return [{ x: x, y: y, moveTo: true }, { x: x + width, y: y }, { x: x + width, y: y + height }, { x: x, y: y + height }, { x: x, y: y }];
  };

  var getPointsFromRectWithCornerRadius = function getPointsFromRectWithCornerRadius(_ref11) {
    var height = _ref11.height,
        rx = _ref11.rx,
        ry = _ref11.ry,
        width = _ref11.width,
        x = _ref11.x,
        y = _ref11.y;

    var curve = { type: 'arc', rx: rx, ry: ry, sweepFlag: 1 };

    return [{ x: x + rx, y: y, moveTo: true }, { x: x + width - rx, y: y }, { x: x + width, y: y + ry, curve: curve }, { x: x + width, y: y + height - ry }, { x: x + width - rx, y: y + height, curve: curve }, { x: x + rx, y: y + height }, { x: x, y: y + height - ry, curve: curve }, { x: x, y: y + ry }, { x: x + rx, y: y, curve: curve }];
  };

  var getPointsFromG = function getPointsFromG(_ref12) {
    var shapes = _ref12.shapes;
    return shapes.map(function (s) {
      return toPoints(s);
    });
  };

  exports.default = toPoints;
  });

  unwrapExports(toPoints_1);

  var toPath_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _toPoints2 = _interopRequireDefault(toPoints_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var pointsToD = function pointsToD(p) {
    var d = '';
    var i = 0;
    var firstPoint = void 0;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = p[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var point = _step.value;
        var _point$curve = point.curve,
            curve = _point$curve === undefined ? false : _point$curve,
            moveTo = point.moveTo,
            x = point.x,
            y = point.y;

        var isFirstPoint = i === 0 || moveTo;
        var isLastPoint = i === p.length - 1 || p[i + 1].moveTo;
        var prevPoint = i === 0 ? null : p[i - 1];

        if (isFirstPoint) {
          firstPoint = point;

          if (!isLastPoint) {
            d += 'M' + x + ',' + y;
          }
        } else if (curve) {
          switch (curve.type) {
            case 'arc':
              var _point$curve2 = point.curve,
                  _point$curve2$largeAr = _point$curve2.largeArcFlag,
                  largeArcFlag = _point$curve2$largeAr === undefined ? 0 : _point$curve2$largeAr,
                  rx = _point$curve2.rx,
                  ry = _point$curve2.ry,
                  _point$curve2$sweepFl = _point$curve2.sweepFlag,
                  sweepFlag = _point$curve2$sweepFl === undefined ? 0 : _point$curve2$sweepFl,
                  _point$curve2$xAxisRo = _point$curve2.xAxisRotation,
                  xAxisRotation = _point$curve2$xAxisRo === undefined ? 0 : _point$curve2$xAxisRo;

              d += 'A' + rx + ',' + ry + ',' + xAxisRotation + ',' + largeArcFlag + ',' + sweepFlag + ',' + x + ',' + y;
              break;
            case 'cubic':
              var _point$curve3 = point.curve,
                  cx1 = _point$curve3.x1,
                  cy1 = _point$curve3.y1,
                  cx2 = _point$curve3.x2,
                  cy2 = _point$curve3.y2;

              d += 'C' + cx1 + ',' + cy1 + ',' + cx2 + ',' + cy2 + ',' + x + ',' + y;
              break;
            case 'quadratic':
              var _point$curve4 = point.curve,
                  qx1 = _point$curve4.x1,
                  qy1 = _point$curve4.y1;

              d += 'Q' + qx1 + ',' + qy1 + ',' + x + ',' + y;
              break;
          }

          if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
            d += 'Z';
          }
        } else if (isLastPoint && x === firstPoint.x && y === firstPoint.y) {
          d += 'Z';
        } else if (x !== prevPoint.x && y !== prevPoint.y) {
          d += 'L' + x + ',' + y;
        } else if (x !== prevPoint.x) {
          d += 'H' + x;
        } else if (y !== prevPoint.y) {
          d += 'V' + y;
        }

        i++;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return d;
  };

  var toPath = function toPath(s) {
    var isPoints = Array.isArray(s);
    var isGroup = isPoints ? Array.isArray(s[0]) : s.type === 'g';
    var points = isPoints ? s : isGroup ? s.shapes.map(function (shp) {
      return (0, _toPoints2.default)(shp);
    }) : (0, _toPoints2.default)(s);

    if (isGroup) {
      return points.map(function (p) {
        return pointsToD(p);
      });
    }

    return pointsToD(points);
  };

  exports.default = toPath;
  });

  unwrapExports(toPath_1);

  var valid_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var getErrors = function getErrors(shape) {
    var rules = getRules(shape);
    var errors = [];

    rules.map(function (_ref) {
      var match = _ref.match,
          prop = _ref.prop,
          required = _ref.required,
          type = _ref.type;

      if (typeof shape[prop] === 'undefined') {
        if (required) {
          errors.push(prop + ' prop is required' + (prop === 'type' ? '' : ' on a ' + shape.type));
        }
      } else {
        if (typeof type !== 'undefined') {
          if (type === 'array') {
            if (!Array.isArray(shape[prop])) {
              errors.push(prop + ' prop must be of type array');
            }
          } else if (_typeof(shape[prop]) !== type) {
            // eslint-disable-line valid-typeof
            errors.push(prop + ' prop must be of type ' + type);
          }
        }

        if (Array.isArray(match)) {
          if (match.indexOf(shape[prop]) === -1) {
            errors.push(prop + ' prop must be one of ' + match.join(', '));
          }
        }
      }
    });

    if (shape.type === 'g' && Array.isArray(shape.shapes)) {
      var childErrors = shape.shapes.map(function (s) {
        return getErrors(s);
      });
      return [].concat.apply(errors, childErrors);
    }

    return errors;
  };

  var getRules = function getRules(shape) {
    var rules = [{
      match: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect', 'g'],
      prop: 'type',
      required: true,
      type: 'string'
    }];

    switch (shape.type) {
      case 'circle':
        rules.push({ prop: 'cx', required: true, type: 'number' });
        rules.push({ prop: 'cy', required: true, type: 'number' });
        rules.push({ prop: 'r', required: true, type: 'number' });
        break;

      case 'ellipse':
        rules.push({ prop: 'cx', required: true, type: 'number' });
        rules.push({ prop: 'cy', required: true, type: 'number' });
        rules.push({ prop: 'rx', required: true, type: 'number' });
        rules.push({ prop: 'ry', required: true, type: 'number' });
        break;

      case 'line':
        rules.push({ prop: 'x1', required: true, type: 'number' });
        rules.push({ prop: 'x2', required: true, type: 'number' });
        rules.push({ prop: 'y1', required: true, type: 'number' });
        rules.push({ prop: 'y2', required: true, type: 'number' });
        break;

      case 'path':
        rules.push({ prop: 'd', required: true, type: 'string' });
        break;

      case 'polygon':
      case 'polyline':
        rules.push({ prop: 'points', required: true, type: 'string' });
        break;

      case 'rect':
        rules.push({ prop: 'height', required: true, type: 'number' });
        rules.push({ prop: 'rx', type: 'number' });
        rules.push({ prop: 'ry', type: 'number' });
        rules.push({ prop: 'width', required: true, type: 'number' });
        rules.push({ prop: 'x', required: true, type: 'number' });
        rules.push({ prop: 'y', required: true, type: 'number' });
        break;

      case 'g':
        rules.push({ prop: 'shapes', required: true, type: 'array' });
        break;
    }

    return rules;
  };

  var valid = function valid(shape) {
    var errors = getErrors(shape);

    return {
      errors: errors,
      valid: errors.length === 0
    };
  };

  exports.default = valid;
  });

  unwrapExports(valid_1);

  var cjs = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.valid = exports.toPoints = exports.toPath = undefined;



  var _toPath2 = _interopRequireDefault(toPath_1);



  var _toPoints2 = _interopRequireDefault(toPoints_1);



  var _valid2 = _interopRequireDefault(valid_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.toPath = _toPath2.default;
  exports.toPoints = _toPoints2.default;
  exports.valid = _valid2.default;
  });

  unwrapExports(cjs);
  var cjs_1 = cjs.valid;
  var cjs_2 = cjs.toPoints;
  var cjs_3 = cjs.toPath;

  const X$g = 0;
  const Y$g = 1;

  const toColorFromTags = (tags, otherwise = 'black') => {
    if (tags !== undefined) {
      for (const tag of tags) {
        if (tag.startsWith('color/')) {
          return tag.substring(6);
        }
      }
    }
    return otherwise;
  };

  const toSvg = async (baseGeometry, { padding = 0 } = {}) => {
    const [min, max] = measureBoundingBox$5(baseGeometry);
    const width = max[X$g] - min[X$g];
    const height = max[Y$g] - min[Y$g];
    const translated = translate$4([width / 2, height / 2, 0], baseGeometry);
    const geometry = canonicalize$9(toKeptGeometry(translated));

    const svg = [
      `<?xml version="1.0" encoding="UTF-8"?>`,
      `<!-- Generated by jsxcad -->`,
      `<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">`,
      `<svg baseProfile="tiny" height="${height}mm" width="${width}mm" viewBox="${-padding} ${-padding} ${width + 2 * padding} ${height + 2 * padding}" version="1.1" stroke="black" stroke-width=".1" fill="none" xmlns="http://www.w3.org/2000/svg">`
    ];

    for (const { surface, z0Surface, tags } of getAnySurfaces(geometry)) {
      const anySurface = surface || z0Surface;
      if (anySurface === undefined) throw Error('die');
      const color = toColorFromTags(tags);
      const paths = [];
      for (const polygon of outline$1(anySurface)) {
        paths.push(`${polygon.map((point, index) => `${index === 0 ? 'M' : 'L'}${point[0]} ${point[1]}`).join(' ')} z`);
      }
      svg.push(`<path fill="${color}" stroke="none" d="${paths.join(' ')}"/>`);
    }
    for (const { paths, tags } of getPaths(geometry)) {
      const color = toColorFromTags(tags);
      for (const path of paths) {
        if (path[0] === null) {
          svg.push(`<path stroke="${color}" fill="none" d="${path.slice(1).map((point, index) => `${index === 0 ? 'M' : 'L'}${point[0]} ${point[1]}`).join(' ')}"/>`);
        } else {
          svg.push(`<path stroke="${color}" fill="none" d="${path.map((point, index) => `${index === 0 ? 'M' : 'L'}${point[0]} ${point[1]}`).join(' ')} z"/>`);
        }
      }
    }
    svg.push('</svg>');
    const output = svg.join('\n');
    return new TextEncoder('utf8').encode(output);
  };

  var opentype = createCommonjsModule(function (module, exports) {
  /**
   * https://opentype.js.org v0.11.0 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens
   */

  (function (global, factory) {
  	 factory(exports) ;
  }(commonjsGlobal, (function (exports) {
  	/*! https://mths.be/codepointat v0.2.0 by @mathias */
  	if (!String.prototype.codePointAt) {
  		(function() {
  			var defineProperty = (function() {
  				// IE 8 only supports `Object.defineProperty` on DOM elements
  				try {
  					var object = {};
  					var $defineProperty = Object.defineProperty;
  					var result = $defineProperty(object, object, object) && $defineProperty;
  				} catch(error) {}
  				return result;
  			}());
  			var codePointAt = function(position) {
  				if (this == null) {
  					throw TypeError();
  				}
  				var string = String(this);
  				var size = string.length;
  				// `ToInteger`
  				var index = position ? Number(position) : 0;
  				if (index != index) { // better `isNaN`
  					index = 0;
  				}
  				// Account for out-of-bounds indices:
  				if (index < 0 || index >= size) {
  					return undefined;
  				}
  				// Get the first code unit
  				var first = string.charCodeAt(index);
  				var second;
  				if ( // check if itâ€™s the start of a surrogate pair
  					first >= 0xD800 && first <= 0xDBFF && // high surrogate
  					size > index + 1 // there is a next code unit
  				) {
  					second = string.charCodeAt(index + 1);
  					if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
  						// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
  						return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
  					}
  				}
  				return first;
  			};
  			if (defineProperty) {
  				defineProperty(String.prototype, 'codePointAt', {
  					'value': codePointAt,
  					'configurable': true,
  					'writable': true
  				});
  			} else {
  				String.prototype.codePointAt = codePointAt;
  			}
  		}());
  	}

  	var TINF_OK = 0;
  	var TINF_DATA_ERROR = -3;

  	function Tree() {
  	  this.table = new Uint16Array(16);   /* table of code length counts */
  	  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
  	}

  	function Data(source, dest) {
  	  this.source = source;
  	  this.sourceIndex = 0;
  	  this.tag = 0;
  	  this.bitcount = 0;
  	  
  	  this.dest = dest;
  	  this.destLen = 0;
  	  
  	  this.ltree = new Tree();  /* dynamic length/symbol tree */
  	  this.dtree = new Tree();  /* dynamic distance tree */
  	}

  	/* --------------------------------------------------- *
  	 * -- uninitialized global data (static structures) -- *
  	 * --------------------------------------------------- */

  	var sltree = new Tree();
  	var sdtree = new Tree();

  	/* extra bits and base tables for length codes */
  	var length_bits = new Uint8Array(30);
  	var length_base = new Uint16Array(30);

  	/* extra bits and base tables for distance codes */
  	var dist_bits = new Uint8Array(30);
  	var dist_base = new Uint16Array(30);

  	/* special ordering of code length codes */
  	var clcidx = new Uint8Array([
  	  16, 17, 18, 0, 8, 7, 9, 6,
  	  10, 5, 11, 4, 12, 3, 13, 2,
  	  14, 1, 15
  	]);

  	/* used by tinf_decode_trees, avoids allocations every call */
  	var code_tree = new Tree();
  	var lengths = new Uint8Array(288 + 32);

  	/* ----------------------- *
  	 * -- utility functions -- *
  	 * ----------------------- */

  	/* build extra bits and base tables */
  	function tinf_build_bits_base(bits, base, delta, first) {
  	  var i, sum;

  	  /* build bits table */
  	  for (i = 0; i < delta; ++i) { bits[i] = 0; }
  	  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

  	  /* build base table */
  	  for (sum = first, i = 0; i < 30; ++i) {
  	    base[i] = sum;
  	    sum += 1 << bits[i];
  	  }
  	}

  	/* build the fixed huffman trees */
  	function tinf_build_fixed_trees(lt, dt) {
  	  var i;

  	  /* build fixed length tree */
  	  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

  	  lt.table[7] = 24;
  	  lt.table[8] = 152;
  	  lt.table[9] = 112;

  	  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
  	  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
  	  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
  	  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

  	  /* build fixed distance tree */
  	  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

  	  dt.table[5] = 32;

  	  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
  	}

  	/* given an array of code lengths, build a tree */
  	var offs = new Uint16Array(16);

  	function tinf_build_tree(t, lengths, off, num) {
  	  var i, sum;

  	  /* clear code length count table */
  	  for (i = 0; i < 16; ++i) { t.table[i] = 0; }

  	  /* scan symbol lengths, and sum code length counts */
  	  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

  	  t.table[0] = 0;

  	  /* compute offset table for distribution sort */
  	  for (sum = 0, i = 0; i < 16; ++i) {
  	    offs[i] = sum;
  	    sum += t.table[i];
  	  }

  	  /* create code->symbol translation table (symbols sorted by code) */
  	  for (i = 0; i < num; ++i) {
  	    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
  	  }
  	}

  	/* ---------------------- *
  	 * -- decode functions -- *
  	 * ---------------------- */

  	/* get one bit from source stream */
  	function tinf_getbit(d) {
  	  /* check if tag is empty */
  	  if (!d.bitcount--) {
  	    /* load next tag */
  	    d.tag = d.source[d.sourceIndex++];
  	    d.bitcount = 7;
  	  }

  	  /* shift bit out of tag */
  	  var bit = d.tag & 1;
  	  d.tag >>>= 1;

  	  return bit;
  	}

  	/* read a num bit value from a stream and add base */
  	function tinf_read_bits(d, num, base) {
  	  if (!num)
  	    { return base; }

  	  while (d.bitcount < 24) {
  	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
  	    d.bitcount += 8;
  	  }

  	  var val = d.tag & (0xffff >>> (16 - num));
  	  d.tag >>>= num;
  	  d.bitcount -= num;
  	  return val + base;
  	}

  	/* given a data stream and a tree, decode a symbol */
  	function tinf_decode_symbol(d, t) {
  	  while (d.bitcount < 24) {
  	    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
  	    d.bitcount += 8;
  	  }
  	  
  	  var sum = 0, cur = 0, len = 0;
  	  var tag = d.tag;

  	  /* get more bits while code value is above sum */
  	  do {
  	    cur = 2 * cur + (tag & 1);
  	    tag >>>= 1;
  	    ++len;

  	    sum += t.table[len];
  	    cur -= t.table[len];
  	  } while (cur >= 0);
  	  
  	  d.tag = tag;
  	  d.bitcount -= len;

  	  return t.trans[sum + cur];
  	}

  	/* given a data stream, decode dynamic trees from it */
  	function tinf_decode_trees(d, lt, dt) {
  	  var hlit, hdist, hclen;
  	  var i, num, length;

  	  /* get 5 bits HLIT (257-286) */
  	  hlit = tinf_read_bits(d, 5, 257);

  	  /* get 5 bits HDIST (1-32) */
  	  hdist = tinf_read_bits(d, 5, 1);

  	  /* get 4 bits HCLEN (4-19) */
  	  hclen = tinf_read_bits(d, 4, 4);

  	  for (i = 0; i < 19; ++i) { lengths[i] = 0; }

  	  /* read code lengths for code length alphabet */
  	  for (i = 0; i < hclen; ++i) {
  	    /* get 3 bits code length (0-7) */
  	    var clen = tinf_read_bits(d, 3, 0);
  	    lengths[clcidx[i]] = clen;
  	  }

  	  /* build code length tree */
  	  tinf_build_tree(code_tree, lengths, 0, 19);

  	  /* decode code lengths for the dynamic trees */
  	  for (num = 0; num < hlit + hdist;) {
  	    var sym = tinf_decode_symbol(d, code_tree);

  	    switch (sym) {
  	      case 16:
  	        /* copy previous code length 3-6 times (read 2 bits) */
  	        var prev = lengths[num - 1];
  	        for (length = tinf_read_bits(d, 2, 3); length; --length) {
  	          lengths[num++] = prev;
  	        }
  	        break;
  	      case 17:
  	        /* repeat code length 0 for 3-10 times (read 3 bits) */
  	        for (length = tinf_read_bits(d, 3, 3); length; --length) {
  	          lengths[num++] = 0;
  	        }
  	        break;
  	      case 18:
  	        /* repeat code length 0 for 11-138 times (read 7 bits) */
  	        for (length = tinf_read_bits(d, 7, 11); length; --length) {
  	          lengths[num++] = 0;
  	        }
  	        break;
  	      default:
  	        /* values 0-15 represent the actual code lengths */
  	        lengths[num++] = sym;
  	        break;
  	    }
  	  }

  	  /* build dynamic trees */
  	  tinf_build_tree(lt, lengths, 0, hlit);
  	  tinf_build_tree(dt, lengths, hlit, hdist);
  	}

  	/* ----------------------------- *
  	 * -- block inflate functions -- *
  	 * ----------------------------- */

  	/* given a stream and two trees, inflate a block of data */
  	function tinf_inflate_block_data(d, lt, dt) {
  	  while (1) {
  	    var sym = tinf_decode_symbol(d, lt);

  	    /* check for end of block */
  	    if (sym === 256) {
  	      return TINF_OK;
  	    }

  	    if (sym < 256) {
  	      d.dest[d.destLen++] = sym;
  	    } else {
  	      var length, dist, offs;
  	      var i;

  	      sym -= 257;

  	      /* possibly get more bits from length code */
  	      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

  	      dist = tinf_decode_symbol(d, dt);

  	      /* possibly get more bits from distance code */
  	      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

  	      /* copy match */
  	      for (i = offs; i < offs + length; ++i) {
  	        d.dest[d.destLen++] = d.dest[i];
  	      }
  	    }
  	  }
  	}

  	/* inflate an uncompressed block of data */
  	function tinf_inflate_uncompressed_block(d) {
  	  var length, invlength;
  	  var i;
  	  
  	  /* unread from bitbuffer */
  	  while (d.bitcount > 8) {
  	    d.sourceIndex--;
  	    d.bitcount -= 8;
  	  }

  	  /* get length */
  	  length = d.source[d.sourceIndex + 1];
  	  length = 256 * length + d.source[d.sourceIndex];

  	  /* get one's complement of length */
  	  invlength = d.source[d.sourceIndex + 3];
  	  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  	  /* check length */
  	  if (length !== (~invlength & 0x0000ffff))
  	    { return TINF_DATA_ERROR; }

  	  d.sourceIndex += 4;

  	  /* copy block */
  	  for (i = length; i; --i)
  	    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

  	  /* make sure we start next block on a byte boundary */
  	  d.bitcount = 0;

  	  return TINF_OK;
  	}

  	/* inflate stream from source to dest */
  	function tinf_uncompress(source, dest) {
  	  var d = new Data(source, dest);
  	  var bfinal, btype, res;

  	  do {
  	    /* read final block flag */
  	    bfinal = tinf_getbit(d);

  	    /* read block type (2 bits) */
  	    btype = tinf_read_bits(d, 2, 0);

  	    /* decompress block */
  	    switch (btype) {
  	      case 0:
  	        /* decompress uncompressed block */
  	        res = tinf_inflate_uncompressed_block(d);
  	        break;
  	      case 1:
  	        /* decompress block with fixed huffman trees */
  	        res = tinf_inflate_block_data(d, sltree, sdtree);
  	        break;
  	      case 2:
  	        /* decompress block with dynamic huffman trees */
  	        tinf_decode_trees(d, d.ltree, d.dtree);
  	        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
  	        break;
  	      default:
  	        res = TINF_DATA_ERROR;
  	    }

  	    if (res !== TINF_OK)
  	      { throw new Error('Data error'); }

  	  } while (!bfinal);

  	  if (d.destLen < d.dest.length) {
  	    if (typeof d.dest.slice === 'function')
  	      { return d.dest.slice(0, d.destLen); }
  	    else
  	      { return d.dest.subarray(0, d.destLen); }
  	  }
  	  
  	  return d.dest;
  	}

  	/* -------------------- *
  	 * -- initialization -- *
  	 * -------------------- */

  	/* build fixed huffman trees */
  	tinf_build_fixed_trees(sltree, sdtree);

  	/* build extra bits and base tables */
  	tinf_build_bits_base(length_bits, length_base, 4, 3);
  	tinf_build_bits_base(dist_bits, dist_base, 2, 1);

  	/* fix a special case */
  	length_bits[28] = 0;
  	length_base[28] = 258;

  	var tinyInflate = tinf_uncompress;

  	// The Bounding Box object

  	function derive(v0, v1, v2, v3, t) {
  	    return Math.pow(1 - t, 3) * v0 +
  	        3 * Math.pow(1 - t, 2) * t * v1 +
  	        3 * (1 - t) * Math.pow(t, 2) * v2 +
  	        Math.pow(t, 3) * v3;
  	}
  	/**
  	 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
  	 * It is used to calculate the bounding box of a glyph or text path.
  	 *
  	 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
  	 *
  	 * @exports opentype.BoundingBox
  	 * @class
  	 * @constructor
  	 */
  	function BoundingBox() {
  	    this.x1 = Number.NaN;
  	    this.y1 = Number.NaN;
  	    this.x2 = Number.NaN;
  	    this.y2 = Number.NaN;
  	}

  	/**
  	 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
  	 */
  	BoundingBox.prototype.isEmpty = function() {
  	    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
  	};

  	/**
  	 * Add the point to the bounding box.
  	 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
  	 * @param {number} x - The X coordinate of the point.
  	 * @param {number} y - The Y coordinate of the point.
  	 */
  	BoundingBox.prototype.addPoint = function(x, y) {
  	    if (typeof x === 'number') {
  	        if (isNaN(this.x1) || isNaN(this.x2)) {
  	            this.x1 = x;
  	            this.x2 = x;
  	        }
  	        if (x < this.x1) {
  	            this.x1 = x;
  	        }
  	        if (x > this.x2) {
  	            this.x2 = x;
  	        }
  	    }
  	    if (typeof y === 'number') {
  	        if (isNaN(this.y1) || isNaN(this.y2)) {
  	            this.y1 = y;
  	            this.y2 = y;
  	        }
  	        if (y < this.y1) {
  	            this.y1 = y;
  	        }
  	        if (y > this.y2) {
  	            this.y2 = y;
  	        }
  	    }
  	};

  	/**
  	 * Add a X coordinate to the bounding box.
  	 * This extends the bounding box to include the X coordinate.
  	 * This function is used internally inside of addBezier.
  	 * @param {number} x - The X coordinate of the point.
  	 */
  	BoundingBox.prototype.addX = function(x) {
  	    this.addPoint(x, null);
  	};

  	/**
  	 * Add a Y coordinate to the bounding box.
  	 * This extends the bounding box to include the Y coordinate.
  	 * This function is used internally inside of addBezier.
  	 * @param {number} y - The Y coordinate of the point.
  	 */
  	BoundingBox.prototype.addY = function(y) {
  	    this.addPoint(null, y);
  	};

  	/**
  	 * Add a BÃ©zier curve to the bounding box.
  	 * This extends the bounding box to include the entire BÃ©zier.
  	 * @param {number} x0 - The starting X coordinate.
  	 * @param {number} y0 - The starting Y coordinate.
  	 * @param {number} x1 - The X coordinate of the first control point.
  	 * @param {number} y1 - The Y coordinate of the first control point.
  	 * @param {number} x2 - The X coordinate of the second control point.
  	 * @param {number} y2 - The Y coordinate of the second control point.
  	 * @param {number} x - The ending X coordinate.
  	 * @param {number} y - The ending Y coordinate.
  	 */
  	BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
  	    var this$1 = this;

  	    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
  	    // and https://github.com/icons8/svg-path-bounding-box

  	    var p0 = [x0, y0];
  	    var p1 = [x1, y1];
  	    var p2 = [x2, y2];
  	    var p3 = [x, y];

  	    this.addPoint(x0, y0);
  	    this.addPoint(x, y);

  	    for (var i = 0; i <= 1; i++) {
  	        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
  	        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
  	        var c = 3 * p1[i] - 3 * p0[i];

  	        if (a === 0) {
  	            if (b === 0) { continue; }
  	            var t = -c / b;
  	            if (0 < t && t < 1) {
  	                if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
  	                if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
  	            }
  	            continue;
  	        }

  	        var b2ac = Math.pow(b, 2) - 4 * c * a;
  	        if (b2ac < 0) { continue; }
  	        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
  	        if (0 < t1 && t1 < 1) {
  	            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
  	            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
  	        }
  	        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
  	        if (0 < t2 && t2 < 1) {
  	            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
  	            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
  	        }
  	    }
  	};

  	/**
  	 * Add a quadratic curve to the bounding box.
  	 * This extends the bounding box to include the entire quadratic curve.
  	 * @param {number} x0 - The starting X coordinate.
  	 * @param {number} y0 - The starting Y coordinate.
  	 * @param {number} x1 - The X coordinate of the control point.
  	 * @param {number} y1 - The Y coordinate of the control point.
  	 * @param {number} x - The ending X coordinate.
  	 * @param {number} y - The ending Y coordinate.
  	 */
  	BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
  	    var cp1x = x0 + 2 / 3 * (x1 - x0);
  	    var cp1y = y0 + 2 / 3 * (y1 - y0);
  	    var cp2x = cp1x + 1 / 3 * (x - x0);
  	    var cp2y = cp1y + 1 / 3 * (y - y0);
  	    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
  	};

  	// Geometric objects

  	/**
  	 * A bÃ©zier path containing a set of path commands similar to a SVG path.
  	 * Paths can be drawn on a context using `draw`.
  	 * @exports opentype.Path
  	 * @class
  	 * @constructor
  	 */
  	function Path() {
  	    this.commands = [];
  	    this.fill = 'black';
  	    this.stroke = null;
  	    this.strokeWidth = 1;
  	}

  	/**
  	 * @param  {number} x
  	 * @param  {number} y
  	 */
  	Path.prototype.moveTo = function(x, y) {
  	    this.commands.push({
  	        type: 'M',
  	        x: x,
  	        y: y
  	    });
  	};

  	/**
  	 * @param  {number} x
  	 * @param  {number} y
  	 */
  	Path.prototype.lineTo = function(x, y) {
  	    this.commands.push({
  	        type: 'L',
  	        x: x,
  	        y: y
  	    });
  	};

  	/**
  	 * Draws cubic curve
  	 * @function
  	 * curveTo
  	 * @memberof opentype.Path.prototype
  	 * @param  {number} x1 - x of control 1
  	 * @param  {number} y1 - y of control 1
  	 * @param  {number} x2 - x of control 2
  	 * @param  {number} y2 - y of control 2
  	 * @param  {number} x - x of path point
  	 * @param  {number} y - y of path point
  	 */

  	/**
  	 * Draws cubic curve
  	 * @function
  	 * bezierCurveTo
  	 * @memberof opentype.Path.prototype
  	 * @param  {number} x1 - x of control 1
  	 * @param  {number} y1 - y of control 1
  	 * @param  {number} x2 - x of control 2
  	 * @param  {number} y2 - y of control 2
  	 * @param  {number} x - x of path point
  	 * @param  {number} y - y of path point
  	 * @see curveTo
  	 */
  	Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
  	    this.commands.push({
  	        type: 'C',
  	        x1: x1,
  	        y1: y1,
  	        x2: x2,
  	        y2: y2,
  	        x: x,
  	        y: y
  	    });
  	};

  	/**
  	 * Draws quadratic curve
  	 * @function
  	 * quadraticCurveTo
  	 * @memberof opentype.Path.prototype
  	 * @param  {number} x1 - x of control
  	 * @param  {number} y1 - y of control
  	 * @param  {number} x - x of path point
  	 * @param  {number} y - y of path point
  	 */

  	/**
  	 * Draws quadratic curve
  	 * @function
  	 * quadTo
  	 * @memberof opentype.Path.prototype
  	 * @param  {number} x1 - x of control
  	 * @param  {number} y1 - y of control
  	 * @param  {number} x - x of path point
  	 * @param  {number} y - y of path point
  	 */
  	Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
  	    this.commands.push({
  	        type: 'Q',
  	        x1: x1,
  	        y1: y1,
  	        x: x,
  	        y: y
  	    });
  	};

  	/**
  	 * Closes the path
  	 * @function closePath
  	 * @memberof opentype.Path.prototype
  	 */

  	/**
  	 * Close the path
  	 * @function close
  	 * @memberof opentype.Path.prototype
  	 */
  	Path.prototype.close = Path.prototype.closePath = function() {
  	    this.commands.push({
  	        type: 'Z'
  	    });
  	};

  	/**
  	 * Add the given path or list of commands to the commands of this path.
  	 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
  	 */
  	Path.prototype.extend = function(pathOrCommands) {
  	    if (pathOrCommands.commands) {
  	        pathOrCommands = pathOrCommands.commands;
  	    } else if (pathOrCommands instanceof BoundingBox) {
  	        var box = pathOrCommands;
  	        this.moveTo(box.x1, box.y1);
  	        this.lineTo(box.x2, box.y1);
  	        this.lineTo(box.x2, box.y2);
  	        this.lineTo(box.x1, box.y2);
  	        this.close();
  	        return;
  	    }

  	    Array.prototype.push.apply(this.commands, pathOrCommands);
  	};

  	/**
  	 * Calculate the bounding box of the path.
  	 * @returns {opentype.BoundingBox}
  	 */
  	Path.prototype.getBoundingBox = function() {
  	    var this$1 = this;

  	    var box = new BoundingBox();

  	    var startX = 0;
  	    var startY = 0;
  	    var prevX = 0;
  	    var prevY = 0;
  	    for (var i = 0; i < this.commands.length; i++) {
  	        var cmd = this$1.commands[i];
  	        switch (cmd.type) {
  	            case 'M':
  	                box.addPoint(cmd.x, cmd.y);
  	                startX = prevX = cmd.x;
  	                startY = prevY = cmd.y;
  	                break;
  	            case 'L':
  	                box.addPoint(cmd.x, cmd.y);
  	                prevX = cmd.x;
  	                prevY = cmd.y;
  	                break;
  	            case 'Q':
  	                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
  	                prevX = cmd.x;
  	                prevY = cmd.y;
  	                break;
  	            case 'C':
  	                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
  	                prevX = cmd.x;
  	                prevY = cmd.y;
  	                break;
  	            case 'Z':
  	                prevX = startX;
  	                prevY = startY;
  	                break;
  	            default:
  	                throw new Error('Unexpected path command ' + cmd.type);
  	        }
  	    }
  	    if (box.isEmpty()) {
  	        box.addPoint(0, 0);
  	    }
  	    return box;
  	};

  	/**
  	 * Draw the path to a 2D context.
  	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
  	 */
  	Path.prototype.draw = function(ctx) {
  	    var this$1 = this;

  	    ctx.beginPath();
  	    for (var i = 0; i < this.commands.length; i += 1) {
  	        var cmd = this$1.commands[i];
  	        if (cmd.type === 'M') {
  	            ctx.moveTo(cmd.x, cmd.y);
  	        } else if (cmd.type === 'L') {
  	            ctx.lineTo(cmd.x, cmd.y);
  	        } else if (cmd.type === 'C') {
  	            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
  	        } else if (cmd.type === 'Q') {
  	            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
  	        } else if (cmd.type === 'Z') {
  	            ctx.closePath();
  	        }
  	    }

  	    if (this.fill) {
  	        ctx.fillStyle = this.fill;
  	        ctx.fill();
  	    }

  	    if (this.stroke) {
  	        ctx.strokeStyle = this.stroke;
  	        ctx.lineWidth = this.strokeWidth;
  	        ctx.stroke();
  	    }
  	};

  	/**
  	 * Convert the Path to a string of path data instructions
  	 * See http://www.w3.org/TR/SVG/paths.html#PathData
  	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
  	 * @return {string}
  	 */
  	Path.prototype.toPathData = function(decimalPlaces) {
  	    var this$1 = this;

  	    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

  	    function floatToString(v) {
  	        if (Math.round(v) === v) {
  	            return '' + Math.round(v);
  	        } else {
  	            return v.toFixed(decimalPlaces);
  	        }
  	    }

  	    function packValues() {
  	        var arguments$1 = arguments;

  	        var s = '';
  	        for (var i = 0; i < arguments.length; i += 1) {
  	            var v = arguments$1[i];
  	            if (v >= 0 && i > 0) {
  	                s += ' ';
  	            }

  	            s += floatToString(v);
  	        }

  	        return s;
  	    }

  	    var d = '';
  	    for (var i = 0; i < this.commands.length; i += 1) {
  	        var cmd = this$1.commands[i];
  	        if (cmd.type === 'M') {
  	            d += 'M' + packValues(cmd.x, cmd.y);
  	        } else if (cmd.type === 'L') {
  	            d += 'L' + packValues(cmd.x, cmd.y);
  	        } else if (cmd.type === 'C') {
  	            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
  	        } else if (cmd.type === 'Q') {
  	            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
  	        } else if (cmd.type === 'Z') {
  	            d += 'Z';
  	        }
  	    }

  	    return d;
  	};

  	/**
  	 * Convert the path to an SVG <path> element, as a string.
  	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
  	 * @return {string}
  	 */
  	Path.prototype.toSVG = function(decimalPlaces) {
  	    var svg = '<path d="';
  	    svg += this.toPathData(decimalPlaces);
  	    svg += '"';
  	    if (this.fill && this.fill !== 'black') {
  	        if (this.fill === null) {
  	            svg += ' fill="none"';
  	        } else {
  	            svg += ' fill="' + this.fill + '"';
  	        }
  	    }

  	    if (this.stroke) {
  	        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
  	    }

  	    svg += '/>';
  	    return svg;
  	};

  	/**
  	 * Convert the path to a DOM element.
  	 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
  	 * @return {SVGPathElement}
  	 */
  	Path.prototype.toDOMElement = function(decimalPlaces) {
  	    var temporaryPath = this.toPathData(decimalPlaces);
  	    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

  	    newPath.setAttribute('d', temporaryPath);

  	    return newPath;
  	};

  	// Run-time checking of preconditions.

  	function fail(message) {
  	    throw new Error(message);
  	}

  	// Precondition function that checks if the given predicate is true.
  	// If not, it will throw an error.
  	function argument(predicate, message) {
  	    if (!predicate) {
  	        fail(message);
  	    }
  	}
  	var check = { fail: fail, argument: argument, assert: argument };

  	// Data types used in the OpenType font file.

  	var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
  	var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

  	/**
  	 * @exports opentype.decode
  	 * @class
  	 */
  	var decode = {};
  	/**
  	 * @exports opentype.encode
  	 * @class
  	 */
  	var encode = {};
  	/**
  	 * @exports opentype.sizeOf
  	 * @class
  	 */
  	var sizeOf = {};

  	// Return a function that always returns the same value.
  	function constant(v) {
  	    return function() {
  	        return v;
  	    };
  	}

  	// OpenType data types //////////////////////////////////////////////////////

  	/**
  	 * Convert an 8-bit unsigned integer to a list of 1 byte.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.BYTE = function(v) {
  	    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
  	    return [v];
  	};
  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.BYTE = constant(1);

  	/**
  	 * Convert a 8-bit signed integer to a list of 1 byte.
  	 * @param {string}
  	 * @returns {Array}
  	 */
  	encode.CHAR = function(v) {
  	    return [v.charCodeAt(0)];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.CHAR = constant(1);

  	/**
  	 * Convert an ASCII string to a list of bytes.
  	 * @param {string}
  	 * @returns {Array}
  	 */
  	encode.CHARARRAY = function(v) {
  	    var b = [];
  	    for (var i = 0; i < v.length; i += 1) {
  	        b[i] = v.charCodeAt(i);
  	    }

  	    return b;
  	};

  	/**
  	 * @param {Array}
  	 * @returns {number}
  	 */
  	sizeOf.CHARARRAY = function(v) {
  	    return v.length;
  	};

  	/**
  	 * Convert a 16-bit unsigned integer to a list of 2 bytes.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.USHORT = function(v) {
  	    return [(v >> 8) & 0xFF, v & 0xFF];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.USHORT = constant(2);

  	/**
  	 * Convert a 16-bit signed integer to a list of 2 bytes.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.SHORT = function(v) {
  	    // Two's complement
  	    if (v >= LIMIT16) {
  	        v = -(2 * LIMIT16 - v);
  	    }

  	    return [(v >> 8) & 0xFF, v & 0xFF];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.SHORT = constant(2);

  	/**
  	 * Convert a 24-bit unsigned integer to a list of 3 bytes.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.UINT24 = function(v) {
  	    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.UINT24 = constant(3);

  	/**
  	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.ULONG = function(v) {
  	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.ULONG = constant(4);

  	/**
  	 * Convert a 32-bit unsigned integer to a list of 4 bytes.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.LONG = function(v) {
  	    // Two's complement
  	    if (v >= LIMIT32) {
  	        v = -(2 * LIMIT32 - v);
  	    }

  	    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.LONG = constant(4);

  	encode.FIXED = encode.ULONG;
  	sizeOf.FIXED = sizeOf.ULONG;

  	encode.FWORD = encode.SHORT;
  	sizeOf.FWORD = sizeOf.SHORT;

  	encode.UFWORD = encode.USHORT;
  	sizeOf.UFWORD = sizeOf.USHORT;

  	/**
  	 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.LONGDATETIME = function(v) {
  	    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.LONGDATETIME = constant(8);

  	/**
  	 * Convert a 4-char tag to a list of 4 bytes.
  	 * @param {string}
  	 * @returns {Array}
  	 */
  	encode.TAG = function(v) {
  	    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
  	    return [v.charCodeAt(0),
  	            v.charCodeAt(1),
  	            v.charCodeAt(2),
  	            v.charCodeAt(3)];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.TAG = constant(4);

  	// CFF data types ///////////////////////////////////////////////////////////

  	encode.Card8 = encode.BYTE;
  	sizeOf.Card8 = sizeOf.BYTE;

  	encode.Card16 = encode.USHORT;
  	sizeOf.Card16 = sizeOf.USHORT;

  	encode.OffSize = encode.BYTE;
  	sizeOf.OffSize = sizeOf.BYTE;

  	encode.SID = encode.USHORT;
  	sizeOf.SID = sizeOf.USHORT;

  	// Convert a numeric operand or charstring number to a variable-size list of bytes.
  	/**
  	 * Convert a numeric operand or charstring number to a variable-size list of bytes.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.NUMBER = function(v) {
  	    if (v >= -107 && v <= 107) {
  	        return [v + 139];
  	    } else if (v >= 108 && v <= 1131) {
  	        v = v - 108;
  	        return [(v >> 8) + 247, v & 0xFF];
  	    } else if (v >= -1131 && v <= -108) {
  	        v = -v - 108;
  	        return [(v >> 8) + 251, v & 0xFF];
  	    } else if (v >= -32768 && v <= 32767) {
  	        return encode.NUMBER16(v);
  	    } else {
  	        return encode.NUMBER32(v);
  	    }
  	};

  	/**
  	 * @param {number}
  	 * @returns {number}
  	 */
  	sizeOf.NUMBER = function(v) {
  	    return encode.NUMBER(v).length;
  	};

  	/**
  	 * Convert a signed number between -32768 and +32767 to a three-byte value.
  	 * This ensures we always use three bytes, but is not the most compact format.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.NUMBER16 = function(v) {
  	    return [28, (v >> 8) & 0xFF, v & 0xFF];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.NUMBER16 = constant(3);

  	/**
  	 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
  	 * This is useful if you want to be sure you always use four bytes,
  	 * at the expense of wasting a few bytes for smaller numbers.
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.NUMBER32 = function(v) {
  	    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  	};

  	/**
  	 * @constant
  	 * @type {number}
  	 */
  	sizeOf.NUMBER32 = constant(5);

  	/**
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.REAL = function(v) {
  	    var value = v.toString();

  	    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
  	    // This code converts it back to a number without the epsilon.
  	    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
  	    if (m) {
  	        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
  	        value = (Math.round(v * epsilon) / epsilon).toString();
  	    }

  	    var nibbles = '';
  	    for (var i = 0, ii = value.length; i < ii; i += 1) {
  	        var c = value[i];
  	        if (c === 'e') {
  	            nibbles += value[++i] === '-' ? 'c' : 'b';
  	        } else if (c === '.') {
  	            nibbles += 'a';
  	        } else if (c === '-') {
  	            nibbles += 'e';
  	        } else {
  	            nibbles += c;
  	        }
  	    }

  	    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
  	    var out = [30];
  	    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
  	        out.push(parseInt(nibbles.substr(i$1, 2), 16));
  	    }

  	    return out;
  	};

  	/**
  	 * @param {number}
  	 * @returns {number}
  	 */
  	sizeOf.REAL = function(v) {
  	    return encode.REAL(v).length;
  	};

  	encode.NAME = encode.CHARARRAY;
  	sizeOf.NAME = sizeOf.CHARARRAY;

  	encode.STRING = encode.CHARARRAY;
  	sizeOf.STRING = sizeOf.CHARARRAY;

  	/**
  	 * @param {DataView} data
  	 * @param {number} offset
  	 * @param {number} numBytes
  	 * @returns {string}
  	 */
  	decode.UTF8 = function(data, offset, numBytes) {
  	    var codePoints = [];
  	    var numChars = numBytes;
  	    for (var j = 0; j < numChars; j++, offset += 1) {
  	        codePoints[j] = data.getUint8(offset);
  	    }

  	    return String.fromCharCode.apply(null, codePoints);
  	};

  	/**
  	 * @param {DataView} data
  	 * @param {number} offset
  	 * @param {number} numBytes
  	 * @returns {string}
  	 */
  	decode.UTF16 = function(data, offset, numBytes) {
  	    var codePoints = [];
  	    var numChars = numBytes / 2;
  	    for (var j = 0; j < numChars; j++, offset += 2) {
  	        codePoints[j] = data.getUint16(offset);
  	    }

  	    return String.fromCharCode.apply(null, codePoints);
  	};

  	/**
  	 * Convert a JavaScript string to UTF16-BE.
  	 * @param {string}
  	 * @returns {Array}
  	 */
  	encode.UTF16 = function(v) {
  	    var b = [];
  	    for (var i = 0; i < v.length; i += 1) {
  	        var codepoint = v.charCodeAt(i);
  	        b[b.length] = (codepoint >> 8) & 0xFF;
  	        b[b.length] = codepoint & 0xFF;
  	    }

  	    return b;
  	};

  	/**
  	 * @param {string}
  	 * @returns {number}
  	 */
  	sizeOf.UTF16 = function(v) {
  	    return v.length * 2;
  	};

  	// Data for converting old eight-bit Macintosh encodings to Unicode.
  	// This representation is optimized for decoding; encoding is slower
  	// and needs more memory. The assumption is that all opentype.js users
  	// want to open fonts, but saving a font will be comparatively rare
  	// so it can be more expensive. Keyed by IANA character set name.
  	//
  	// Python script for generating these strings:
  	//
  	//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
  	//     print(s.encode('utf-8'))
  	/**
  	 * @private
  	 */
  	var eightBitMacEncodings = {
  	    'x-mac-croatian':  // Python: 'mac_croatian'
  	    'Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Å â„¢Â´Â¨â‰ Å½Ã˜âˆžÂ±â‰¤â‰¥âˆ†Âµâˆ‚âˆ‘âˆÅ¡âˆ«ÂªÂºÎ©Å¾Ã¸' +
  	    'Â¿Â¡Â¬âˆšÆ’â‰ˆÄ†Â«ÄŒâ€¦Â Ã€ÃƒÃ•Å’Å“Äâ€”â€œâ€â€˜â€™Ã·â—Šï£¿Â©â„â‚¬â€¹â€ºÃ†Â»â€“Â·â€šâ€žâ€°Ã‚Ä‡ÃÄÃˆÃÃŽÃÃŒÃ“Ã”Ä‘Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ï€Ã‹ËšÂ¸ÃŠÃ¦Ë‡',
  	    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
  	    'ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°ÒÂ£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–ÂµÒ‘ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑš' +
  	    'Ñ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽ',
  	    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
  	    'Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜á¸‚Â±â‰¤â‰¥á¸ƒÄŠÄ‹á¸Šá¸‹á¸žá¸ŸÄ Ä¡á¹€Ã¦Ã¸' +
  	    'á¹á¹–á¹—É¼Æ’Å¿á¹ Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™á¹¡áº›Ã¿Å¸á¹ªâ‚¬â€¹â€ºÅ¶Å·á¹«Â·á»²á»³âŠÃ‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”â™£Ã’ÃšÃ›Ã™Ä±ÃÃ½Å´Åµáº„áº…áº€áºáº‚áºƒ',
  	    'x-mac-greek':  // Python: 'mac_greek'
  	    'Ã„Â¹Â²Ã‰Â³Ã–ÃœÎ…Ã Ã¢Ã¤Î„Â¨Ã§Ã©Ã¨ÃªÃ«Â£â„¢Ã®Ã¯â€¢Â½â€°Ã´Ã¶Â¦â‚¬Ã¹Ã»Ã¼â€ Î“Î”Î˜Î›ÎžÎ ÃŸÂ®Â©Î£ÎªÂ§â‰ Â°Â·Î‘Â±â‰¤â‰¥Â¥Î’Î•Î–Î—Î™ÎšÎœÎ¦Î«Î¨Î©' +
  	    'Î¬ÎÂ¬ÎŸÎ¡â‰ˆÎ¤Â«Â»â€¦Â Î¥Î§Î†ÎˆÅ“â€“â€•â€œâ€â€˜â€™Ã·Î‰ÎŠÎŒÎŽÎ­Î®Î¯ÏŒÎÏÎ±Î²ÏˆÎ´ÎµÏ†Î³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿Ï€ÏŽÏÏƒÏ„Î¸Ï‰Ï‚Ï‡Ï…Î¶ÏŠÏ‹ÎÎ°\u00AD',
  	    'x-mac-icelandic':  // Python: 'mac_iceland'
  	    'Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºÎ©Ã¦Ã¸' +
  	    'Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„â‚¬ÃÃ°ÃžÃ¾Ã½Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï£¿Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡',
  	    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
  	    'áƒá„á…á†áŠá‹á±á²á³á´á¸á¹á‘‰á‘Žá‘á‘á‘‘á‘•á‘–á‘¦á‘­á‘®á‘¯á‘°á‘²á‘³á’ƒá’‹á’Œá’á’Žá’á’‘Â°á’¡á’¥á’¦â€¢Â¶á’§Â®Â©â„¢á’¨á’ªá’«á’»á“‚á“ƒá“„á“…á“‡á“ˆá“á“¯á“°á“±á“²á“´á“µá”…á“•á“–á“—' +
  	    'á“˜á“šá“›á“ªá”¨á”©á”ªá”«á”­â€¦Â á”®á”¾á••á•–á•—â€“â€”â€œâ€â€˜â€™á•˜á•™á•šá•á•†á•‡á•ˆá•‰á•‹á•Œá•á•¿á–€á–á–‚á–ƒá–„á–…á–á–á–‘á–’á–“á–”á–•á™±á™²á™³á™´á™µá™¶á––á– á–¡á–¢á–£á–¤á–¥á–¦á•¼ÅÅ‚',
  	    'x-mac-ce':  // Python: 'mac_latin2'
  	    'Ã„Ä€ÄÃ‰Ä„Ã–ÃœÃ¡Ä…ÄŒÃ¤ÄÄ†Ä‡Ã©Å¹ÅºÄŽÃ­ÄÄ’Ä“Ä–Ã³Ä—Ã´Ã¶ÃµÃºÄšÄ›Ã¼â€ Â°Ä˜Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Ä™Â¨â‰ Ä£Ä®Ä¯Äªâ‰¤â‰¥Ä«Ä¶âˆ‚âˆ‘Å‚Ä»Ä¼Ä½Ä¾Ä¹ÄºÅ…' +
  	    'Å†ÅƒÂ¬âˆšÅ„Å‡âˆ†Â«Â»â€¦Â ÅˆÅÃ•Å‘ÅŒâ€“â€”â€œâ€â€˜â€™Ã·â—ŠÅÅ”Å•Å˜â€¹â€ºÅ™Å–Å—Å â€šâ€žÅ¡ÅšÅ›ÃÅ¤Å¥ÃÅ½Å¾ÅªÃ“Ã”Å«Å®ÃšÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë‡',
  	    macintosh:  // Python: 'mac_roman'
  	    'Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºÎ©Ã¦Ã¸' +
  	    'Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„â‚¬â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï£¿Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡',
  	    'x-mac-romanian':  // Python: 'mac_romanian'
  	    'Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ä‚È˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºÎ©ÄƒÈ™' +
  	    'Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„â‚¬â€¹â€ºÈšÈ›â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï£¿Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡',
  	    'x-mac-turkish':  // Python: 'mac_turkish'
  	    'Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºÎ©Ã¦Ã¸' +
  	    'Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸ÄžÄŸÄ°Ä±ÅžÅŸâ€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï£¿Ã’ÃšÃ›Ã™ï¢ Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡'
  	};

  	/**
  	 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
  	 * string, or 'undefined' if the encoding is unsupported. For example, we do
  	 * not support Chinese, Japanese or Korean because these would need large
  	 * mapping tables.
  	 * @param {DataView} dataView
  	 * @param {number} offset
  	 * @param {number} dataLength
  	 * @param {string} encoding
  	 * @returns {string}
  	 */
  	decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
  	    var table = eightBitMacEncodings[encoding];
  	    if (table === undefined) {
  	        return undefined;
  	    }

  	    var result = '';
  	    for (var i = 0; i < dataLength; i++) {
  	        var c = dataView.getUint8(offset + i);
  	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
  	        // mapped to U+0000..U+007F; we only need to look up the others.
  	        if (c <= 0x7F) {
  	            result += String.fromCharCode(c);
  	        } else {
  	            result += table[c & 0x7F];
  	        }
  	    }

  	    return result;
  	};

  	// Helper function for encode.MACSTRING. Returns a dictionary for mapping
  	// Unicode character codes to their 8-bit MacOS equivalent. This table
  	// is not exactly a super cheap data structure, but we do not care because
  	// encoding Macintosh strings is only rarely needed in typical applications.
  	var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
  	var macEncodingCacheKeys;
  	var getMacEncodingTable = function (encoding) {
  	    // Since we use encoding as a cache key for WeakMap, it has to be
  	    // a String object and not a literal. And at least on NodeJS 2.10.1,
  	    // WeakMap requires that the same String instance is passed for cache hits.
  	    if (!macEncodingCacheKeys) {
  	        macEncodingCacheKeys = {};
  	        for (var e in eightBitMacEncodings) {
  	            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
  	            macEncodingCacheKeys[e] = new String(e);
  	        }
  	    }

  	    var cacheKey = macEncodingCacheKeys[encoding];
  	    if (cacheKey === undefined) {
  	        return undefined;
  	    }

  	    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
  	    // since garbage collection may run at any time, it could also kick in
  	    // between the calls to cache.has() and cache.get(). In that case,
  	    // we would return 'undefined' even though we do support the encoding.
  	    if (macEncodingTableCache) {
  	        var cachedTable = macEncodingTableCache.get(cacheKey);
  	        if (cachedTable !== undefined) {
  	            return cachedTable;
  	        }
  	    }

  	    var decodingTable = eightBitMacEncodings[encoding];
  	    if (decodingTable === undefined) {
  	        return undefined;
  	    }

  	    var encodingTable = {};
  	    for (var i = 0; i < decodingTable.length; i++) {
  	        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
  	    }

  	    if (macEncodingTableCache) {
  	        macEncodingTableCache.set(cacheKey, encodingTable);
  	    }

  	    return encodingTable;
  	};

  	/**
  	 * Encodes an old-style Macintosh string. Returns a byte array upon success.
  	 * If the requested encoding is unsupported, or if the input string contains
  	 * a character that cannot be expressed in the encoding, the function returns
  	 * 'undefined'.
  	 * @param {string} str
  	 * @param {string} encoding
  	 * @returns {Array}
  	 */
  	encode.MACSTRING = function(str, encoding) {
  	    var table = getMacEncodingTable(encoding);
  	    if (table === undefined) {
  	        return undefined;
  	    }

  	    var result = [];
  	    for (var i = 0; i < str.length; i++) {
  	        var c = str.charCodeAt(i);

  	        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
  	        // mapped to U+0000..U+007F; we only need to look up the others.
  	        if (c >= 0x80) {
  	            c = table[c];
  	            if (c === undefined) {
  	                // str contains a Unicode character that cannot be encoded
  	                // in the requested encoding.
  	                return undefined;
  	            }
  	        }
  	        result[i] = c;
  	        // result.push(c);
  	    }

  	    return result;
  	};

  	/**
  	 * @param {string} str
  	 * @param {string} encoding
  	 * @returns {number}
  	 */
  	sizeOf.MACSTRING = function(str, encoding) {
  	    var b = encode.MACSTRING(str, encoding);
  	    if (b !== undefined) {
  	        return b.length;
  	    } else {
  	        return 0;
  	    }
  	};

  	// Helper for encode.VARDELTAS
  	function isByteEncodable(value) {
  	    return value >= -128 && value <= 127;
  	}

  	// Helper for encode.VARDELTAS
  	function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
  	    var runLength = 0;
  	    var numDeltas = deltas.length;
  	    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
  	        ++pos;
  	        ++runLength;
  	    }
  	    result.push(0x80 | (runLength - 1));
  	    return pos;
  	}

  	// Helper for encode.VARDELTAS
  	function encodeVarDeltaRunAsBytes(deltas, offset, result) {
  	    var runLength = 0;
  	    var numDeltas = deltas.length;
  	    var pos = offset;
  	    while (pos < numDeltas && runLength < 64) {
  	        var value = deltas[pos];
  	        if (!isByteEncodable(value)) {
  	            break;
  	        }

  	        // Within a byte-encoded run of deltas, a single zero is best
  	        // stored literally as 0x00 value. However, if we have two or
  	        // more zeroes in a sequence, it is better to start a new run.
  	        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
  	        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
  	        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
  	        // when starting a new run.
  	        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
  	            break;
  	        }

  	        ++pos;
  	        ++runLength;
  	    }
  	    result.push(runLength - 1);
  	    for (var i = offset; i < pos; ++i) {
  	        result.push((deltas[i] + 256) & 0xff);
  	    }
  	    return pos;
  	}

  	// Helper for encode.VARDELTAS
  	function encodeVarDeltaRunAsWords(deltas, offset, result) {
  	    var runLength = 0;
  	    var numDeltas = deltas.length;
  	    var pos = offset;
  	    while (pos < numDeltas && runLength < 64) {
  	        var value = deltas[pos];

  	        // Within a word-encoded run of deltas, it is easiest to start
  	        // a new run (with a different encoding) whenever we encounter
  	        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
  	        // needs 7 bytes when storing the zero inside the current run
  	        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
  	        // new run (40 66 66 80 40 77 77).
  	        if (value === 0) {
  	            break;
  	        }

  	        // Within a word-encoded run of deltas, a single value in the
  	        // range (-128..127) should be encoded within the current run
  	        // because it is more compact. For example, the sequence
  	        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
  	        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
  	        // a new run (40 66 66 00 02 40 77 77).
  	        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
  	            break;
  	        }

  	        ++pos;
  	        ++runLength;
  	    }
  	    result.push(0x40 | (runLength - 1));
  	    for (var i = offset; i < pos; ++i) {
  	        var val = deltas[i];
  	        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
  	    }
  	    return pos;
  	}

  	/**
  	 * Encode a list of variation adjustment deltas.
  	 *
  	 * Variation adjustment deltas are used in â€˜gvarâ€™ and â€˜cvarâ€™ tables.
  	 * They indicate how points (in â€˜gvarâ€™) or values (in â€˜cvarâ€™) get adjusted
  	 * when generating instances of variation fonts.
  	 *
  	 * @see https://www.microsoft.com/typography/otspec/gvar.htm
  	 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
  	 * @param {Array}
  	 * @return {Array}
  	 */
  	encode.VARDELTAS = function(deltas) {
  	    var pos = 0;
  	    var result = [];
  	    while (pos < deltas.length) {
  	        var value = deltas[pos];
  	        if (value === 0) {
  	            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
  	        } else if (value >= -128 && value <= 127) {
  	            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
  	        } else {
  	            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
  	        }
  	    }
  	    return result;
  	};

  	// Convert a list of values to a CFF INDEX structure.
  	// The values should be objects containing name / type / value.
  	/**
  	 * @param {Array} l
  	 * @returns {Array}
  	 */
  	encode.INDEX = function(l) {
  	    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
  	    //    i, v;
  	    // Because we have to know which data type to use to encode the offsets,
  	    // we have to go through the values twice: once to encode the data and
  	    // calculate the offsets, then again to encode the offsets using the fitting data type.
  	    var offset = 1; // First offset is always 1.
  	    var offsets = [offset];
  	    var data = [];
  	    for (var i = 0; i < l.length; i += 1) {
  	        var v = encode.OBJECT(l[i]);
  	        Array.prototype.push.apply(data, v);
  	        offset += v.length;
  	        offsets.push(offset);
  	    }

  	    if (data.length === 0) {
  	        return [0, 0];
  	    }

  	    var encodedOffsets = [];
  	    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
  	    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
  	    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
  	        var encodedOffset = offsetEncoder(offsets[i$1]);
  	        Array.prototype.push.apply(encodedOffsets, encodedOffset);
  	    }

  	    return Array.prototype.concat(encode.Card16(l.length),
  	                           encode.OffSize(offSize),
  	                           encodedOffsets,
  	                           data);
  	};

  	/**
  	 * @param {Array}
  	 * @returns {number}
  	 */
  	sizeOf.INDEX = function(v) {
  	    return encode.INDEX(v).length;
  	};

  	/**
  	 * Convert an object to a CFF DICT structure.
  	 * The keys should be numeric.
  	 * The values should be objects containing name / type / value.
  	 * @param {Object} m
  	 * @returns {Array}
  	 */
  	encode.DICT = function(m) {
  	    var d = [];
  	    var keys = Object.keys(m);
  	    var length = keys.length;

  	    for (var i = 0; i < length; i += 1) {
  	        // Object.keys() return string keys, but our keys are always numeric.
  	        var k = parseInt(keys[i], 0);
  	        var v = m[k];
  	        // Value comes before the key.
  	        d = d.concat(encode.OPERAND(v.value, v.type));
  	        d = d.concat(encode.OPERATOR(k));
  	    }

  	    return d;
  	};

  	/**
  	 * @param {Object}
  	 * @returns {number}
  	 */
  	sizeOf.DICT = function(m) {
  	    return encode.DICT(m).length;
  	};

  	/**
  	 * @param {number}
  	 * @returns {Array}
  	 */
  	encode.OPERATOR = function(v) {
  	    if (v < 1200) {
  	        return [v];
  	    } else {
  	        return [12, v - 1200];
  	    }
  	};

  	/**
  	 * @param {Array} v
  	 * @param {string}
  	 * @returns {Array}
  	 */
  	encode.OPERAND = function(v, type) {
  	    var d = [];
  	    if (Array.isArray(type)) {
  	        for (var i = 0; i < type.length; i += 1) {
  	            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
  	            d = d.concat(encode.OPERAND(v[i], type[i]));
  	        }
  	    } else {
  	        if (type === 'SID') {
  	            d = d.concat(encode.NUMBER(v));
  	        } else if (type === 'offset') {
  	            // We make it easy for ourselves and always encode offsets as
  	            // 4 bytes. This makes offset calculation for the top dict easier.
  	            d = d.concat(encode.NUMBER32(v));
  	        } else if (type === 'number') {
  	            d = d.concat(encode.NUMBER(v));
  	        } else if (type === 'real') {
  	            d = d.concat(encode.REAL(v));
  	        } else {
  	            throw new Error('Unknown operand type ' + type);
  	            // FIXME Add support for booleans
  	        }
  	    }

  	    return d;
  	};

  	encode.OP = encode.BYTE;
  	sizeOf.OP = sizeOf.BYTE;

  	// memoize charstring encoding using WeakMap if available
  	var wmm = typeof WeakMap === 'function' && new WeakMap();

  	/**
  	 * Convert a list of CharString operations to bytes.
  	 * @param {Array}
  	 * @returns {Array}
  	 */
  	encode.CHARSTRING = function(ops) {
  	    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
  	    if (wmm) {
  	        var cachedValue = wmm.get(ops);
  	        if (cachedValue !== undefined) {
  	            return cachedValue;
  	        }
  	    }

  	    var d = [];
  	    var length = ops.length;

  	    for (var i = 0; i < length; i += 1) {
  	        var op = ops[i];
  	        d = d.concat(encode[op.type](op.value));
  	    }

  	    if (wmm) {
  	        wmm.set(ops, d);
  	    }

  	    return d;
  	};

  	/**
  	 * @param {Array}
  	 * @returns {number}
  	 */
  	sizeOf.CHARSTRING = function(ops) {
  	    return encode.CHARSTRING(ops).length;
  	};

  	// Utility functions ////////////////////////////////////////////////////////

  	/**
  	 * Convert an object containing name / type / value to bytes.
  	 * @param {Object}
  	 * @returns {Array}
  	 */
  	encode.OBJECT = function(v) {
  	    var encodingFunction = encode[v.type];
  	    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
  	    return encodingFunction(v.value);
  	};

  	/**
  	 * @param {Object}
  	 * @returns {number}
  	 */
  	sizeOf.OBJECT = function(v) {
  	    var sizeOfFunction = sizeOf[v.type];
  	    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
  	    return sizeOfFunction(v.value);
  	};

  	/**
  	 * Convert a table object to bytes.
  	 * A table contains a list of fields containing the metadata (name, type and default value).
  	 * The table itself has the field values set as attributes.
  	 * @param {opentype.Table}
  	 * @returns {Array}
  	 */
  	encode.TABLE = function(table) {
  	    var d = [];
  	    var length = table.fields.length;
  	    var subtables = [];
  	    var subtableOffsets = [];

  	    for (var i = 0; i < length; i += 1) {
  	        var field = table.fields[i];
  	        var encodingFunction = encode[field.type];
  	        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
  	        var value = table[field.name];
  	        if (value === undefined) {
  	            value = field.value;
  	        }

  	        var bytes = encodingFunction(value);

  	        if (field.type === 'TABLE') {
  	            subtableOffsets.push(d.length);
  	            d = d.concat([0, 0]);
  	            subtables.push(bytes);
  	        } else {
  	            d = d.concat(bytes);
  	        }
  	    }

  	    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
  	        var o = subtableOffsets[i$1];
  	        var offset = d.length;
  	        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
  	        d[o] = offset >> 8;
  	        d[o + 1] = offset & 0xff;
  	        d = d.concat(subtables[i$1]);
  	    }

  	    return d;
  	};

  	/**
  	 * @param {opentype.Table}
  	 * @returns {number}
  	 */
  	sizeOf.TABLE = function(table) {
  	    var numBytes = 0;
  	    var length = table.fields.length;

  	    for (var i = 0; i < length; i += 1) {
  	        var field = table.fields[i];
  	        var sizeOfFunction = sizeOf[field.type];
  	        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
  	        var value = table[field.name];
  	        if (value === undefined) {
  	            value = field.value;
  	        }

  	        numBytes += sizeOfFunction(value);

  	        // Subtables take 2 more bytes for offsets.
  	        if (field.type === 'TABLE') {
  	            numBytes += 2;
  	        }
  	    }

  	    return numBytes;
  	};

  	encode.RECORD = encode.TABLE;
  	sizeOf.RECORD = sizeOf.TABLE;

  	// Merge in a list of bytes.
  	encode.LITERAL = function(v) {
  	    return v;
  	};

  	sizeOf.LITERAL = function(v) {
  	    return v.length;
  	};

  	// Table metadata

  	/**
  	 * @exports opentype.Table
  	 * @class
  	 * @param {string} tableName
  	 * @param {Array} fields
  	 * @param {Object} options
  	 * @constructor
  	 */
  	function Table(tableName, fields, options) {
  	    var this$1 = this;

  	    for (var i = 0; i < fields.length; i += 1) {
  	        var field = fields[i];
  	        this$1[field.name] = field.value;
  	    }

  	    this.tableName = tableName;
  	    this.fields = fields;
  	    if (options) {
  	        var optionKeys = Object.keys(options);
  	        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
  	            var k = optionKeys[i$1];
  	            var v = options[k];
  	            if (this$1[k] !== undefined) {
  	                this$1[k] = v;
  	            }
  	        }
  	    }
  	}

  	/**
  	 * Encodes the table and returns an array of bytes
  	 * @return {Array}
  	 */
  	Table.prototype.encode = function() {
  	    return encode.TABLE(this);
  	};

  	/**
  	 * Get the size of the table.
  	 * @return {number}
  	 */
  	Table.prototype.sizeOf = function() {
  	    return sizeOf.TABLE(this);
  	};

  	/**
  	 * @private
  	 */
  	function ushortList(itemName, list, count) {
  	    if (count === undefined) {
  	        count = list.length;
  	    }
  	    var fields = new Array(list.length + 1);
  	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
  	    for (var i = 0; i < list.length; i++) {
  	        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
  	    }
  	    return fields;
  	}

  	/**
  	 * @private
  	 */
  	function tableList(itemName, records, itemCallback) {
  	    var count = records.length;
  	    var fields = new Array(count + 1);
  	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
  	    for (var i = 0; i < count; i++) {
  	        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
  	    }
  	    return fields;
  	}

  	/**
  	 * @private
  	 */
  	function recordList(itemName, records, itemCallback) {
  	    var count = records.length;
  	    var fields = [];
  	    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
  	    for (var i = 0; i < count; i++) {
  	        fields = fields.concat(itemCallback(records[i], i));
  	    }
  	    return fields;
  	}

  	// Common Layout Tables

  	/**
  	 * @exports opentype.Coverage
  	 * @class
  	 * @param {opentype.Table}
  	 * @constructor
  	 * @extends opentype.Table
  	 */
  	function Coverage(coverageTable) {
  	    if (coverageTable.format === 1) {
  	        Table.call(this, 'coverageTable',
  	            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
  	            .concat(ushortList('glyph', coverageTable.glyphs))
  	        );
  	    } else {
  	        check.assert(false, 'Can\'t create coverage table format 2 yet.');
  	    }
  	}
  	Coverage.prototype = Object.create(Table.prototype);
  	Coverage.prototype.constructor = Coverage;

  	function ScriptList(scriptListTable) {
  	    Table.call(this, 'scriptListTable',
  	        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
  	            var script = scriptRecord.script;
  	            var defaultLangSys = script.defaultLangSys;
  	            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
  	            return [
  	                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
  	                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
  	                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
  	                        {name: 'lookupOrder', type: 'USHORT', value: 0},
  	                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
  	                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
  	                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
  	                        var langSys = langSysRecord.langSys;
  	                        return [
  	                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
  	                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
  	                                {name: 'lookupOrder', type: 'USHORT', value: 0},
  	                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
  	                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
  	                        ];
  	                    })))}
  	            ];
  	        })
  	    );
  	}
  	ScriptList.prototype = Object.create(Table.prototype);
  	ScriptList.prototype.constructor = ScriptList;

  	/**
  	 * @exports opentype.FeatureList
  	 * @class
  	 * @param {opentype.Table}
  	 * @constructor
  	 * @extends opentype.Table
  	 */
  	function FeatureList(featureListTable) {
  	    Table.call(this, 'featureListTable',
  	        recordList('featureRecord', featureListTable, function(featureRecord, i) {
  	            var feature = featureRecord.feature;
  	            return [
  	                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
  	                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
  	                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
  	            ];
  	        })
  	    );
  	}
  	FeatureList.prototype = Object.create(Table.prototype);
  	FeatureList.prototype.constructor = FeatureList;

  	/**
  	 * @exports opentype.LookupList
  	 * @class
  	 * @param {opentype.Table}
  	 * @param {Object}
  	 * @constructor
  	 * @extends opentype.Table
  	 */
  	function LookupList(lookupListTable, subtableMakers) {
  	    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
  	        var subtableCallback = subtableMakers[lookupTable.lookupType];
  	        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
  	        return new Table('lookupTable', [
  	            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
  	            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
  	        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
  	    }));
  	}
  	LookupList.prototype = Object.create(Table.prototype);
  	LookupList.prototype.constructor = LookupList;

  	// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
  	// Don't use offsets inside Records (probable bug), only in Tables.
  	var table = {
  	    Table: Table,
  	    Record: Table,
  	    Coverage: Coverage,
  	    ScriptList: ScriptList,
  	    FeatureList: FeatureList,
  	    LookupList: LookupList,
  	    ushortList: ushortList,
  	    tableList: tableList,
  	    recordList: recordList,
  	};

  	// Parsing utility functions

  	// Retrieve an unsigned byte from the DataView.
  	function getByte(dataView, offset) {
  	    return dataView.getUint8(offset);
  	}

  	// Retrieve an unsigned 16-bit short from the DataView.
  	// The value is stored in big endian.
  	function getUShort(dataView, offset) {
  	    return dataView.getUint16(offset, false);
  	}

  	// Retrieve a signed 16-bit short from the DataView.
  	// The value is stored in big endian.
  	function getShort(dataView, offset) {
  	    return dataView.getInt16(offset, false);
  	}

  	// Retrieve an unsigned 32-bit long from the DataView.
  	// The value is stored in big endian.
  	function getULong(dataView, offset) {
  	    return dataView.getUint32(offset, false);
  	}

  	// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
  	// The value is stored in big endian.
  	function getFixed(dataView, offset) {
  	    var decimal = dataView.getInt16(offset, false);
  	    var fraction = dataView.getUint16(offset + 2, false);
  	    return decimal + fraction / 65535;
  	}

  	// Retrieve a 4-character tag from the DataView.
  	// Tags are used to identify tables.
  	function getTag(dataView, offset) {
  	    var tag = '';
  	    for (var i = offset; i < offset + 4; i += 1) {
  	        tag += String.fromCharCode(dataView.getInt8(i));
  	    }

  	    return tag;
  	}

  	// Retrieve an offset from the DataView.
  	// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
  	function getOffset(dataView, offset, offSize) {
  	    var v = 0;
  	    for (var i = 0; i < offSize; i += 1) {
  	        v <<= 8;
  	        v += dataView.getUint8(offset + i);
  	    }

  	    return v;
  	}

  	// Retrieve a number of bytes from start offset to the end offset from the DataView.
  	function getBytes(dataView, startOffset, endOffset) {
  	    var bytes = [];
  	    for (var i = startOffset; i < endOffset; i += 1) {
  	        bytes.push(dataView.getUint8(i));
  	    }

  	    return bytes;
  	}

  	// Convert the list of bytes to a string.
  	function bytesToString(bytes) {
  	    var s = '';
  	    for (var i = 0; i < bytes.length; i += 1) {
  	        s += String.fromCharCode(bytes[i]);
  	    }

  	    return s;
  	}

  	var typeOffsets = {
  	    byte: 1,
  	    uShort: 2,
  	    short: 2,
  	    uLong: 4,
  	    fixed: 4,
  	    longDateTime: 8,
  	    tag: 4
  	};

  	// A stateful parser that changes the offset whenever a value is retrieved.
  	// The data is a DataView.
  	function Parser(data, offset) {
  	    this.data = data;
  	    this.offset = offset;
  	    this.relativeOffset = 0;
  	}

  	Parser.prototype.parseByte = function() {
  	    var v = this.data.getUint8(this.offset + this.relativeOffset);
  	    this.relativeOffset += 1;
  	    return v;
  	};

  	Parser.prototype.parseChar = function() {
  	    var v = this.data.getInt8(this.offset + this.relativeOffset);
  	    this.relativeOffset += 1;
  	    return v;
  	};

  	Parser.prototype.parseCard8 = Parser.prototype.parseByte;

  	Parser.prototype.parseUShort = function() {
  	    var v = this.data.getUint16(this.offset + this.relativeOffset);
  	    this.relativeOffset += 2;
  	    return v;
  	};

  	Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
  	Parser.prototype.parseSID = Parser.prototype.parseUShort;
  	Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

  	Parser.prototype.parseShort = function() {
  	    var v = this.data.getInt16(this.offset + this.relativeOffset);
  	    this.relativeOffset += 2;
  	    return v;
  	};

  	Parser.prototype.parseF2Dot14 = function() {
  	    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  	    this.relativeOffset += 2;
  	    return v;
  	};

  	Parser.prototype.parseULong = function() {
  	    var v = getULong(this.data, this.offset + this.relativeOffset);
  	    this.relativeOffset += 4;
  	    return v;
  	};

  	Parser.prototype.parseOffset32 = Parser.prototype.parseULong;

  	Parser.prototype.parseFixed = function() {
  	    var v = getFixed(this.data, this.offset + this.relativeOffset);
  	    this.relativeOffset += 4;
  	    return v;
  	};

  	Parser.prototype.parseString = function(length) {
  	    var dataView = this.data;
  	    var offset = this.offset + this.relativeOffset;
  	    var string = '';
  	    this.relativeOffset += length;
  	    for (var i = 0; i < length; i++) {
  	        string += String.fromCharCode(dataView.getUint8(offset + i));
  	    }

  	    return string;
  	};

  	Parser.prototype.parseTag = function() {
  	    return this.parseString(4);
  	};

  	// LONGDATETIME is a 64-bit integer.
  	// JavaScript and unix timestamps traditionally use 32 bits, so we
  	// only take the last 32 bits.
  	// + Since until 2038 those bits will be filled by zeros we can ignore them.
  	Parser.prototype.parseLongDateTime = function() {
  	    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
  	    // Subtract seconds between 01/01/1904 and 01/01/1970
  	    // to convert Apple Mac timestamp to Standard Unix timestamp
  	    v -= 2082844800;
  	    this.relativeOffset += 8;
  	    return v;
  	};

  	Parser.prototype.parseVersion = function(minorBase) {
  	    var major = getUShort(this.data, this.offset + this.relativeOffset);

  	    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
  	    // Default returns the correct number if minor = 0xN000 where N is 0-9
  	    // Set minorBase to 1 for tables that use minor = N where N is 0-9
  	    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
  	    this.relativeOffset += 4;
  	    if (minorBase === undefined) { minorBase = 0x1000; }
  	    return major + minor / minorBase / 10;
  	};

  	Parser.prototype.skip = function(type, amount) {
  	    if (amount === undefined) {
  	        amount = 1;
  	    }

  	    this.relativeOffset += typeOffsets[type] * amount;
  	};

  	///// Parsing lists and records ///////////////////////////////

  	// Parse a list of 32 bit unsigned integers.
  	Parser.prototype.parseULongList = function(count) {
  	    if (count === undefined) { count = this.parseULong(); }
  	    var offsets = new Array(count);
  	    var dataView = this.data;
  	    var offset = this.offset + this.relativeOffset;
  	    for (var i = 0; i < count; i++) {
  	        offsets[i] = dataView.getUint32(offset);
  	        offset += 4;
  	    }

  	    this.relativeOffset += count * 4;
  	    return offsets;
  	};

  	// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
  	// or provided as an argument.
  	Parser.prototype.parseOffset16List =
  	Parser.prototype.parseUShortList = function(count) {
  	    if (count === undefined) { count = this.parseUShort(); }
  	    var offsets = new Array(count);
  	    var dataView = this.data;
  	    var offset = this.offset + this.relativeOffset;
  	    for (var i = 0; i < count; i++) {
  	        offsets[i] = dataView.getUint16(offset);
  	        offset += 2;
  	    }

  	    this.relativeOffset += count * 2;
  	    return offsets;
  	};

  	// Parses a list of 16 bit signed integers.
  	Parser.prototype.parseShortList = function(count) {
  	    var list = new Array(count);
  	    var dataView = this.data;
  	    var offset = this.offset + this.relativeOffset;
  	    for (var i = 0; i < count; i++) {
  	        list[i] = dataView.getInt16(offset);
  	        offset += 2;
  	    }

  	    this.relativeOffset += count * 2;
  	    return list;
  	};

  	// Parses a list of bytes.
  	Parser.prototype.parseByteList = function(count) {
  	    var list = new Array(count);
  	    var dataView = this.data;
  	    var offset = this.offset + this.relativeOffset;
  	    for (var i = 0; i < count; i++) {
  	        list[i] = dataView.getUint8(offset++);
  	    }

  	    this.relativeOffset += count;
  	    return list;
  	};

  	/**
  	 * Parse a list of items.
  	 * Record count is optional, if omitted it is read from the stream.
  	 * itemCallback is one of the Parser methods.
  	 */
  	Parser.prototype.parseList = function(count, itemCallback) {
  	    var this$1 = this;

  	    if (!itemCallback) {
  	        itemCallback = count;
  	        count = this.parseUShort();
  	    }
  	    var list = new Array(count);
  	    for (var i = 0; i < count; i++) {
  	        list[i] = itemCallback.call(this$1);
  	    }
  	    return list;
  	};

  	Parser.prototype.parseList32 = function(count, itemCallback) {
  	    var this$1 = this;

  	    if (!itemCallback) {
  	        itemCallback = count;
  	        count = this.parseULong();
  	    }
  	    var list = new Array(count);
  	    for (var i = 0; i < count; i++) {
  	        list[i] = itemCallback.call(this$1);
  	    }
  	    return list;
  	};

  	/**
  	 * Parse a list of records.
  	 * Record count is optional, if omitted it is read from the stream.
  	 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
  	 */
  	Parser.prototype.parseRecordList = function(count, recordDescription) {
  	    var this$1 = this;

  	    // If the count argument is absent, read it in the stream.
  	    if (!recordDescription) {
  	        recordDescription = count;
  	        count = this.parseUShort();
  	    }
  	    var records = new Array(count);
  	    var fields = Object.keys(recordDescription);
  	    for (var i = 0; i < count; i++) {
  	        var rec = {};
  	        for (var j = 0; j < fields.length; j++) {
  	            var fieldName = fields[j];
  	            var fieldType = recordDescription[fieldName];
  	            rec[fieldName] = fieldType.call(this$1);
  	        }
  	        records[i] = rec;
  	    }
  	    return records;
  	};

  	Parser.prototype.parseRecordList32 = function(count, recordDescription) {
  	    var this$1 = this;

  	    // If the count argument is absent, read it in the stream.
  	    if (!recordDescription) {
  	        recordDescription = count;
  	        count = this.parseULong();
  	    }
  	    var records = new Array(count);
  	    var fields = Object.keys(recordDescription);
  	    for (var i = 0; i < count; i++) {
  	        var rec = {};
  	        for (var j = 0; j < fields.length; j++) {
  	            var fieldName = fields[j];
  	            var fieldType = recordDescription[fieldName];
  	            rec[fieldName] = fieldType.call(this$1);
  	        }
  	        records[i] = rec;
  	    }
  	    return records;
  	};

  	// Parse a data structure into an object
  	// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
  	Parser.prototype.parseStruct = function(description) {
  	    var this$1 = this;

  	    if (typeof description === 'function') {
  	        return description.call(this);
  	    } else {
  	        var fields = Object.keys(description);
  	        var struct = {};
  	        for (var j = 0; j < fields.length; j++) {
  	            var fieldName = fields[j];
  	            var fieldType = description[fieldName];
  	            struct[fieldName] = fieldType.call(this$1);
  	        }
  	        return struct;
  	    }
  	};

  	/**
  	 * Parse a GPOS valueRecord
  	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
  	 * valueFormat is optional, if omitted it is read from the stream.
  	 */
  	Parser.prototype.parseValueRecord = function(valueFormat) {
  	    if (valueFormat === undefined) {
  	        valueFormat = this.parseUShort();
  	    }
  	    if (valueFormat === 0) {
  	        // valueFormat2 in kerning pairs is most often 0
  	        // in this case return undefined instead of an empty object, to save space
  	        return;
  	    }
  	    var valueRecord = {};

  	    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
  	    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
  	    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
  	    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }

  	    // Device table (non-variable font) / VariationIndex table (variable font) not supported
  	    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
  	    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
  	    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
  	    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
  	    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }

  	    return valueRecord;
  	};

  	/**
  	 * Parse a list of GPOS valueRecords
  	 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
  	 * valueFormat and valueCount are read from the stream.
  	 */
  	Parser.prototype.parseValueRecordList = function() {
  	    var this$1 = this;

  	    var valueFormat = this.parseUShort();
  	    var valueCount = this.parseUShort();
  	    var values = new Array(valueCount);
  	    for (var i = 0; i < valueCount; i++) {
  	        values[i] = this$1.parseValueRecord(valueFormat);
  	    }
  	    return values;
  	};

  	Parser.prototype.parsePointer = function(description) {
  	    var structOffset = this.parseOffset16();
  	    if (structOffset > 0) {
  	        // NULL offset => return undefined
  	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
  	    }
  	    return undefined;
  	};

  	Parser.prototype.parsePointer32 = function(description) {
  	    var structOffset = this.parseOffset32();
  	    if (structOffset > 0) {
  	        // NULL offset => return undefined
  	        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
  	    }
  	    return undefined;
  	};

  	/**
  	 * Parse a list of offsets to lists of 16-bit integers,
  	 * or a list of offsets to lists of offsets to any kind of items.
  	 * If itemCallback is not provided, a list of list of UShort is assumed.
  	 * If provided, itemCallback is called on each item and must parse the item.
  	 * See examples in tables/gsub.js
  	 */
  	Parser.prototype.parseListOfLists = function(itemCallback) {
  	    var this$1 = this;

  	    var offsets = this.parseOffset16List();
  	    var count = offsets.length;
  	    var relativeOffset = this.relativeOffset;
  	    var list = new Array(count);
  	    for (var i = 0; i < count; i++) {
  	        var start = offsets[i];
  	        if (start === 0) {
  	            // NULL offset
  	            // Add i as owned property to list. Convenient with assert.
  	            list[i] = undefined;
  	            continue;
  	        }
  	        this$1.relativeOffset = start;
  	        if (itemCallback) {
  	            var subOffsets = this$1.parseOffset16List();
  	            var subList = new Array(subOffsets.length);
  	            for (var j = 0; j < subOffsets.length; j++) {
  	                this$1.relativeOffset = start + subOffsets[j];
  	                subList[j] = itemCallback.call(this$1);
  	            }
  	            list[i] = subList;
  	        } else {
  	            list[i] = this$1.parseUShortList();
  	        }
  	    }
  	    this.relativeOffset = relativeOffset;
  	    return list;
  	};

  	///// Complex tables parsing //////////////////////////////////

  	// Parse a coverage table in a GSUB, GPOS or GDEF table.
  	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
  	// parser.offset must point to the start of the table containing the coverage.
  	Parser.prototype.parseCoverage = function() {
  	    var this$1 = this;

  	    var startOffset = this.offset + this.relativeOffset;
  	    var format = this.parseUShort();
  	    var count = this.parseUShort();
  	    if (format === 1) {
  	        return {
  	            format: 1,
  	            glyphs: this.parseUShortList(count)
  	        };
  	    } else if (format === 2) {
  	        var ranges = new Array(count);
  	        for (var i = 0; i < count; i++) {
  	            ranges[i] = {
  	                start: this$1.parseUShort(),
  	                end: this$1.parseUShort(),
  	                index: this$1.parseUShort()
  	            };
  	        }
  	        return {
  	            format: 2,
  	            ranges: ranges
  	        };
  	    }
  	    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
  	};

  	// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
  	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
  	Parser.prototype.parseClassDef = function() {
  	    var startOffset = this.offset + this.relativeOffset;
  	    var format = this.parseUShort();
  	    if (format === 1) {
  	        return {
  	            format: 1,
  	            startGlyph: this.parseUShort(),
  	            classes: this.parseUShortList()
  	        };
  	    } else if (format === 2) {
  	        return {
  	            format: 2,
  	            ranges: this.parseRecordList({
  	                start: Parser.uShort,
  	                end: Parser.uShort,
  	                classId: Parser.uShort
  	            })
  	        };
  	    }
  	    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
  	};

  	///// Static methods ///////////////////////////////////
  	// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

  	Parser.list = function(count, itemCallback) {
  	    return function() {
  	        return this.parseList(count, itemCallback);
  	    };
  	};

  	Parser.list32 = function(count, itemCallback) {
  	    return function() {
  	        return this.parseList32(count, itemCallback);
  	    };
  	};

  	Parser.recordList = function(count, recordDescription) {
  	    return function() {
  	        return this.parseRecordList(count, recordDescription);
  	    };
  	};

  	Parser.recordList32 = function(count, recordDescription) {
  	    return function() {
  	        return this.parseRecordList32(count, recordDescription);
  	    };
  	};

  	Parser.pointer = function(description) {
  	    return function() {
  	        return this.parsePointer(description);
  	    };
  	};

  	Parser.pointer32 = function(description) {
  	    return function() {
  	        return this.parsePointer32(description);
  	    };
  	};

  	Parser.tag = Parser.prototype.parseTag;
  	Parser.byte = Parser.prototype.parseByte;
  	Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
  	Parser.uShortList = Parser.prototype.parseUShortList;
  	Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
  	Parser.uLongList = Parser.prototype.parseULongList;
  	Parser.struct = Parser.prototype.parseStruct;
  	Parser.coverage = Parser.prototype.parseCoverage;
  	Parser.classDef = Parser.prototype.parseClassDef;

  	///// Script, Feature, Lookup lists ///////////////////////////////////////////////
  	// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

  	var langSysTable = {
  	    reserved: Parser.uShort,
  	    reqFeatureIndex: Parser.uShort,
  	    featureIndexes: Parser.uShortList
  	};

  	Parser.prototype.parseScriptList = function() {
  	    return this.parsePointer(Parser.recordList({
  	        tag: Parser.tag,
  	        script: Parser.pointer({
  	            defaultLangSys: Parser.pointer(langSysTable),
  	            langSysRecords: Parser.recordList({
  	                tag: Parser.tag,
  	                langSys: Parser.pointer(langSysTable)
  	            })
  	        })
  	    })) || [];
  	};

  	Parser.prototype.parseFeatureList = function() {
  	    return this.parsePointer(Parser.recordList({
  	        tag: Parser.tag,
  	        feature: Parser.pointer({
  	            featureParams: Parser.offset16,
  	            lookupListIndexes: Parser.uShortList
  	        })
  	    })) || [];
  	};

  	Parser.prototype.parseLookupList = function(lookupTableParsers) {
  	    return this.parsePointer(Parser.list(Parser.pointer(function() {
  	        var lookupType = this.parseUShort();
  	        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
  	        var lookupFlag = this.parseUShort();
  	        var useMarkFilteringSet = lookupFlag & 0x10;
  	        return {
  	            lookupType: lookupType,
  	            lookupFlag: lookupFlag,
  	            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
  	            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
  	        };
  	    }))) || [];
  	};

  	Parser.prototype.parseFeatureVariationsList = function() {
  	    return this.parsePointer32(function() {
  	        var majorVersion = this.parseUShort();
  	        var minorVersion = this.parseUShort();
  	        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
  	        var featureVariations = this.parseRecordList32({
  	            conditionSetOffset: Parser.offset32,
  	            featureTableSubstitutionOffset: Parser.offset32
  	        });
  	        return featureVariations;
  	    }) || [];
  	};

  	var parse = {
  	    getByte: getByte,
  	    getCard8: getByte,
  	    getUShort: getUShort,
  	    getCard16: getUShort,
  	    getShort: getShort,
  	    getULong: getULong,
  	    getFixed: getFixed,
  	    getTag: getTag,
  	    getOffset: getOffset,
  	    getBytes: getBytes,
  	    bytesToString: bytesToString,
  	    Parser: Parser,
  	};

  	// The `cmap` table stores the mappings from characters to glyphs.

  	function parseCmapTableFormat12(cmap, p) {
  	    //Skip reserved.
  	    p.parseUShort();

  	    // Length in bytes of the sub-tables.
  	    cmap.length = p.parseULong();
  	    cmap.language = p.parseULong();

  	    var groupCount;
  	    cmap.groupCount = groupCount = p.parseULong();
  	    cmap.glyphIndexMap = {};

  	    for (var i = 0; i < groupCount; i += 1) {
  	        var startCharCode = p.parseULong();
  	        var endCharCode = p.parseULong();
  	        var startGlyphId = p.parseULong();

  	        for (var c = startCharCode; c <= endCharCode; c += 1) {
  	            cmap.glyphIndexMap[c] = startGlyphId;
  	            startGlyphId++;
  	        }
  	    }
  	}

  	function parseCmapTableFormat4(cmap, p, data, start, offset) {
  	    // Length in bytes of the sub-tables.
  	    cmap.length = p.parseUShort();
  	    cmap.language = p.parseUShort();

  	    // segCount is stored x 2.
  	    var segCount;
  	    cmap.segCount = segCount = p.parseUShort() >> 1;

  	    // Skip searchRange, entrySelector, rangeShift.
  	    p.skip('uShort', 3);

  	    // The "unrolled" mapping from character codes to glyph indices.
  	    cmap.glyphIndexMap = {};
  	    var endCountParser = new parse.Parser(data, start + offset + 14);
  	    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
  	    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
  	    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
  	    var glyphIndexOffset = start + offset + 16 + segCount * 8;
  	    for (var i = 0; i < segCount - 1; i += 1) {
  	        var glyphIndex = (void 0);
  	        var endCount = endCountParser.parseUShort();
  	        var startCount = startCountParser.parseUShort();
  	        var idDelta = idDeltaParser.parseShort();
  	        var idRangeOffset = idRangeOffsetParser.parseUShort();
  	        for (var c = startCount; c <= endCount; c += 1) {
  	            if (idRangeOffset !== 0) {
  	                // The idRangeOffset is relative to the current position in the idRangeOffset array.
  	                // Take the current offset in the idRangeOffset array.
  	                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

  	                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
  	                glyphIndexOffset += idRangeOffset;

  	                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
  	                glyphIndexOffset += (c - startCount) * 2;
  	                glyphIndex = parse.getUShort(data, glyphIndexOffset);
  	                if (glyphIndex !== 0) {
  	                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
  	                }
  	            } else {
  	                glyphIndex = (c + idDelta) & 0xFFFF;
  	            }

  	            cmap.glyphIndexMap[c] = glyphIndex;
  	        }
  	    }
  	}

  	// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
  	// There are many available formats, but we only support the Windows format 4 and 12.
  	// This function returns a `CmapEncoding` object or null if no supported format could be found.
  	function parseCmapTable(data, start) {
  	    var cmap = {};
  	    cmap.version = parse.getUShort(data, start);
  	    check.argument(cmap.version === 0, 'cmap table version should be 0.');

  	    // The cmap table can contain many sub-tables, each with their own format.
  	    // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
  	    cmap.numTables = parse.getUShort(data, start + 2);
  	    var offset = -1;
  	    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
  	        var platformId = parse.getUShort(data, start + 4 + (i * 8));
  	        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
  	        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||
  	            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {
  	            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
  	            break;
  	        }
  	    }

  	    if (offset === -1) {
  	        // There is no cmap table in the font that we support.
  	        throw new Error('No valid cmap sub-tables found.');
  	    }

  	    var p = new parse.Parser(data, start + offset);
  	    cmap.format = p.parseUShort();

  	    if (cmap.format === 12) {
  	        parseCmapTableFormat12(cmap, p);
  	    } else if (cmap.format === 4) {
  	        parseCmapTableFormat4(cmap, p, data, start, offset);
  	    } else {
  	        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
  	    }

  	    return cmap;
  	}

  	function addSegment(t, code, glyphIndex) {
  	    t.segments.push({
  	        end: code,
  	        start: code,
  	        delta: -(code - glyphIndex),
  	        offset: 0,
  	        glyphIndex: glyphIndex
  	    });
  	}

  	function addTerminatorSegment(t) {
  	    t.segments.push({
  	        end: 0xFFFF,
  	        start: 0xFFFF,
  	        delta: 1,
  	        offset: 0
  	    });
  	}

  	// Make cmap table, format 4 by default, 12 if needed only
  	function makeCmapTable(glyphs) {
  	    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
  	    var isPlan0Only = true;
  	    var i;

  	    // Check if we need to add cmap format 12 or if format 4 only is fine
  	    for (i = glyphs.length - 1; i > 0; i -= 1) {
  	        var g = glyphs.get(i);
  	        if (g.unicode > 65535) {
  	            console.log('Adding CMAP format 12 (needed!)');
  	            isPlan0Only = false;
  	            break;
  	        }
  	    }

  	    var cmapTable = [
  	        {name: 'version', type: 'USHORT', value: 0},
  	        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},

  	        // CMAP 4 header
  	        {name: 'platformID', type: 'USHORT', value: 3},
  	        {name: 'encodingID', type: 'USHORT', value: 1},
  	        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
  	    ];

  	    if (!isPlan0Only)
  	        { cmapTable = cmapTable.concat([
  	            // CMAP 12 header
  	            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
  	            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
  	            {name: 'cmap12Offset', type: 'ULONG', value: 0}
  	        ]); }

  	    cmapTable = cmapTable.concat([
  	        // CMAP 4 Subtable
  	        {name: 'format', type: 'USHORT', value: 4},
  	        {name: 'cmap4Length', type: 'USHORT', value: 0},
  	        {name: 'language', type: 'USHORT', value: 0},
  	        {name: 'segCountX2', type: 'USHORT', value: 0},
  	        {name: 'searchRange', type: 'USHORT', value: 0},
  	        {name: 'entrySelector', type: 'USHORT', value: 0},
  	        {name: 'rangeShift', type: 'USHORT', value: 0}
  	    ]);

  	    var t = new table.Table('cmap', cmapTable);

  	    t.segments = [];
  	    for (i = 0; i < glyphs.length; i += 1) {
  	        var glyph = glyphs.get(i);
  	        for (var j = 0; j < glyph.unicodes.length; j += 1) {
  	            addSegment(t, glyph.unicodes[j], i);
  	        }

  	        t.segments = t.segments.sort(function (a, b) {
  	            return a.start - b.start;
  	        });
  	    }

  	    addTerminatorSegment(t);

  	    var segCount = t.segments.length;
  	    var segCountToRemove = 0;

  	    // CMAP 4
  	    // Set up parallel segment arrays.
  	    var endCounts = [];
  	    var startCounts = [];
  	    var idDeltas = [];
  	    var idRangeOffsets = [];
  	    var glyphIds = [];

  	    // CMAP 12
  	    var cmap12Groups = [];

  	    // Reminder this loop is not following the specification at 100%
  	    // The specification -> find suites of characters and make a group
  	    // Here we're doing one group for each letter
  	    // Doing as the spec can save 8 times (or more) space
  	    for (i = 0; i < segCount; i += 1) {
  	        var segment = t.segments[i];

  	        // CMAP 4
  	        if (segment.end <= 65535 && segment.start <= 65535) {
  	            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
  	            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
  	            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
  	            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
  	            if (segment.glyphId !== undefined) {
  	                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
  	            }
  	        } else {
  	            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
  	            segCountToRemove += 1;
  	        }

  	        // CMAP 12
  	        // Skip Terminator Segment
  	        if (!isPlan0Only && segment.glyphIndex !== undefined) {
  	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
  	            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
  	            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
  	        }
  	    }

  	    // CMAP 4 Subtable
  	    t.segCountX2 = (segCount - segCountToRemove) * 2;
  	    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
  	    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
  	    t.rangeShift = t.segCountX2 - t.searchRange;

  	    t.fields = t.fields.concat(endCounts);
  	    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
  	    t.fields = t.fields.concat(startCounts);
  	    t.fields = t.fields.concat(idDeltas);
  	    t.fields = t.fields.concat(idRangeOffsets);
  	    t.fields = t.fields.concat(glyphIds);

  	    t.cmap4Length = 14 + // Subtable header
  	        endCounts.length * 2 +
  	        2 + // reservedPad
  	        startCounts.length * 2 +
  	        idDeltas.length * 2 +
  	        idRangeOffsets.length * 2 +
  	        glyphIds.length * 2;

  	    if (!isPlan0Only) {
  	        // CMAP 12 Subtable
  	        var cmap12Length = 16 + // Subtable header
  	            cmap12Groups.length * 4;

  	        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
  	        t.fields = t.fields.concat([
  	            {name: 'cmap12Format', type: 'USHORT', value: 12},
  	            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
  	            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
  	            {name: 'cmap12Language', type: 'ULONG', value: 0},
  	            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
  	        ]);

  	        t.fields = t.fields.concat(cmap12Groups);
  	    }

  	    return t;
  	}

  	var cmap = { parse: parseCmapTable, make: makeCmapTable };

  	// Glyph encoding

  	var cffStandardStrings = [
  	    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
  	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
  	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
  	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
  	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
  	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
  	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
  	    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
  	    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
  	    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
  	    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
  	    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
  	    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
  	    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
  	    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
  	    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
  	    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
  	    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
  	    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
  	    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
  	    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
  	    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
  	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
  	    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
  	    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
  	    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
  	    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
  	    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
  	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
  	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
  	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
  	    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
  	    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
  	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
  	    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
  	    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
  	    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
  	    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
  	    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
  	    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
  	    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
  	    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
  	    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

  	var cffStandardEncoding = [
  	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
  	    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
  	    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
  	    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
  	    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
  	    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
  	    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
  	    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
  	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
  	    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
  	    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
  	    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
  	    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
  	    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
  	    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
  	    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
  	    'lslash', 'oslash', 'oe', 'germandbls'];

  	var cffExpertEncoding = [
  	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
  	    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
  	    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
  	    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
  	    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
  	    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
  	    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
  	    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
  	    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
  	    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
  	    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
  	    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
  	    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
  	    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
  	    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
  	    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
  	    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
  	    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
  	    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
  	    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
  	    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
  	    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
  	    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
  	    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
  	    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
  	    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

  	var standardNames = [
  	    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
  	    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
  	    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
  	    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
  	    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
  	    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
  	    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
  	    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
  	    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
  	    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
  	    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
  	    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
  	    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
  	    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
  	    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
  	    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
  	    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
  	    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
  	    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
  	    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
  	    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
  	    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
  	    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
  	    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
  	    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

  	/**
  	 * This is the encoding used for fonts created from scratch.
  	 * It loops through all glyphs and finds the appropriate unicode value.
  	 * Since it's linear time, other encodings will be faster.
  	 * @exports opentype.DefaultEncoding
  	 * @class
  	 * @constructor
  	 * @param {opentype.Font}
  	 */
  	function DefaultEncoding(font) {
  	    this.font = font;
  	}

  	DefaultEncoding.prototype.charToGlyphIndex = function(c) {
  	    var code = c.codePointAt(0);
  	    var glyphs = this.font.glyphs;
  	    if (glyphs) {
  	        for (var i = 0; i < glyphs.length; i += 1) {
  	            var glyph = glyphs.get(i);
  	            for (var j = 0; j < glyph.unicodes.length; j += 1) {
  	                if (glyph.unicodes[j] === code) {
  	                    return i;
  	                }
  	            }
  	        }
  	    }
  	    return null;
  	};

  	/**
  	 * @exports opentype.CmapEncoding
  	 * @class
  	 * @constructor
  	 * @param {Object} cmap - a object with the cmap encoded data
  	 */
  	function CmapEncoding(cmap) {
  	    this.cmap = cmap;
  	}

  	/**
  	 * @param  {string} c - the character
  	 * @return {number} The glyph index.
  	 */
  	CmapEncoding.prototype.charToGlyphIndex = function(c) {
  	    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
  	};

  	/**
  	 * @exports opentype.CffEncoding
  	 * @class
  	 * @constructor
  	 * @param {string} encoding - The encoding
  	 * @param {Array} charset - The character set.
  	 */
  	function CffEncoding(encoding, charset) {
  	    this.encoding = encoding;
  	    this.charset = charset;
  	}

  	/**
  	 * @param  {string} s - The character
  	 * @return {number} The index.
  	 */
  	CffEncoding.prototype.charToGlyphIndex = function(s) {
  	    var code = s.codePointAt(0);
  	    var charName = this.encoding[code];
  	    return this.charset.indexOf(charName);
  	};

  	/**
  	 * @exports opentype.GlyphNames
  	 * @class
  	 * @constructor
  	 * @param {Object} post
  	 */
  	function GlyphNames(post) {
  	    var this$1 = this;

  	    switch (post.version) {
  	        case 1:
  	            this.names = standardNames.slice();
  	            break;
  	        case 2:
  	            this.names = new Array(post.numberOfGlyphs);
  	            for (var i = 0; i < post.numberOfGlyphs; i++) {
  	                if (post.glyphNameIndex[i] < standardNames.length) {
  	                    this$1.names[i] = standardNames[post.glyphNameIndex[i]];
  	                } else {
  	                    this$1.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
  	                }
  	            }

  	            break;
  	        case 2.5:
  	            this.names = new Array(post.numberOfGlyphs);
  	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
  	                this$1.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
  	            }

  	            break;
  	        case 3:
  	            this.names = [];
  	            break;
  	        default:
  	            this.names = [];
  	            break;
  	    }
  	}

  	/**
  	 * Gets the index of a glyph by name.
  	 * @param  {string} name - The glyph name
  	 * @return {number} The index
  	 */
  	GlyphNames.prototype.nameToGlyphIndex = function(name) {
  	    return this.names.indexOf(name);
  	};

  	/**
  	 * @param  {number} gid
  	 * @return {string}
  	 */
  	GlyphNames.prototype.glyphIndexToName = function(gid) {
  	    return this.names[gid];
  	};

  	/**
  	 * @alias opentype.addGlyphNames
  	 * @param {opentype.Font}
  	 */
  	function addGlyphNames(font) {
  	    var glyph;
  	    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  	    var charCodes = Object.keys(glyphIndexMap);

  	    for (var i = 0; i < charCodes.length; i += 1) {
  	        var c = charCodes[i];
  	        var glyphIndex = glyphIndexMap[c];
  	        glyph = font.glyphs.get(glyphIndex);
  	        glyph.addUnicode(parseInt(c));
  	    }

  	    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
  	        glyph = font.glyphs.get(i$1);
  	        if (font.cffEncoding) {
  	            if (font.isCIDFont) {
  	                glyph.name = 'gid' + i$1;
  	            } else {
  	                glyph.name = font.cffEncoding.charset[i$1];
  	            }
  	        } else if (font.glyphNames.names) {
  	            glyph.name = font.glyphNames.glyphIndexToName(i$1);
  	        }
  	    }
  	}

  	// Drawing utility functions.

  	// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
  	function line(ctx, x1, y1, x2, y2) {
  	    ctx.beginPath();
  	    ctx.moveTo(x1, y1);
  	    ctx.lineTo(x2, y2);
  	    ctx.stroke();
  	}

  	var draw = { line: line };

  	// The Glyph object
  	// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency

  	function getPathDefinition(glyph, path) {
  	    var _path = path || new Path();
  	    return {
  	        configurable: true,

  	        get: function() {
  	            if (typeof _path === 'function') {
  	                _path = _path();
  	            }

  	            return _path;
  	        },

  	        set: function(p) {
  	            _path = p;
  	        }
  	    };
  	}
  	/**
  	 * @typedef GlyphOptions
  	 * @type Object
  	 * @property {string} [name] - The glyph name
  	 * @property {number} [unicode]
  	 * @property {Array} [unicodes]
  	 * @property {number} [xMin]
  	 * @property {number} [yMin]
  	 * @property {number} [xMax]
  	 * @property {number} [yMax]
  	 * @property {number} [advanceWidth]
  	 */

  	// A Glyph is an individual mark that often corresponds to a character.
  	// Some glyphs, such as ligatures, are a combination of many characters.
  	// Glyphs are the basic building blocks of a font.
  	//
  	// The `Glyph` class contains utility methods for drawing the path and its points.
  	/**
  	 * @exports opentype.Glyph
  	 * @class
  	 * @param {GlyphOptions}
  	 * @constructor
  	 */
  	function Glyph(options) {
  	    // By putting all the code on a prototype function (which is only declared once)
  	    // we reduce the memory requirements for larger fonts by some 2%
  	    this.bindConstructorValues(options);
  	}

  	/**
  	 * @param  {GlyphOptions}
  	 */
  	Glyph.prototype.bindConstructorValues = function(options) {
  	    this.index = options.index || 0;

  	    // These three values cannot be deferred for memory optimization:
  	    this.name = options.name || null;
  	    this.unicode = options.unicode || undefined;
  	    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

  	    // But by binding these values only when necessary, we reduce can
  	    // the memory requirements by almost 3% for larger fonts.
  	    if (options.xMin) {
  	        this.xMin = options.xMin;
  	    }

  	    if (options.yMin) {
  	        this.yMin = options.yMin;
  	    }

  	    if (options.xMax) {
  	        this.xMax = options.xMax;
  	    }

  	    if (options.yMax) {
  	        this.yMax = options.yMax;
  	    }

  	    if (options.advanceWidth) {
  	        this.advanceWidth = options.advanceWidth;
  	    }

  	    // The path for a glyph is the most memory intensive, and is bound as a value
  	    // with a getter/setter to ensure we actually do path parsing only once the
  	    // path is actually needed by anything.
  	    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
  	};

  	/**
  	 * @param {number}
  	 */
  	Glyph.prototype.addUnicode = function(unicode) {
  	    if (this.unicodes.length === 0) {
  	        this.unicode = unicode;
  	    }

  	    this.unicodes.push(unicode);
  	};

  	/**
  	 * Calculate the minimum bounding box for this glyph.
  	 * @return {opentype.BoundingBox}
  	 */
  	Glyph.prototype.getBoundingBox = function() {
  	    return this.path.getBoundingBox();
  	};

  	/**
  	 * Convert the glyph to a Path we can draw on a drawing context.
  	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
  	 * @param  {opentype.Font} if hinting is to be used, the font
  	 * @return {opentype.Path}
  	 */
  	Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
  	    x = x !== undefined ? x : 0;
  	    y = y !== undefined ? y : 0;
  	    fontSize = fontSize !== undefined ? fontSize : 72;
  	    var commands;
  	    var hPoints;
  	    if (!options) { options = { }; }
  	    var xScale = options.xScale;
  	    var yScale = options.yScale;

  	    if (options.hinting && font && font.hinting) {
  	        // in case of hinting, the hinting engine takes care
  	        // of scaling the points (not the path) before hinting.
  	        hPoints = this.path && font.hinting.exec(this, fontSize);
  	        // in case the hinting engine failed hPoints is undefined
  	        // and thus reverts to plain rending
  	    }

  	    if (hPoints) {
  	        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
  	        commands = font.hinting.getCommands(hPoints);
  	        x = Math.round(x);
  	        y = Math.round(y);
  	        // TODO in case of hinting xyScaling is not yet supported
  	        xScale = yScale = 1;
  	    } else {
  	        commands = this.path.commands;
  	        var scale = 1 / this.path.unitsPerEm * fontSize;
  	        if (xScale === undefined) { xScale = scale; }
  	        if (yScale === undefined) { yScale = scale; }
  	    }

  	    var p = new Path();
  	    for (var i = 0; i < commands.length; i += 1) {
  	        var cmd = commands[i];
  	        if (cmd.type === 'M') {
  	            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
  	        } else if (cmd.type === 'L') {
  	            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
  	        } else if (cmd.type === 'Q') {
  	            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
  	                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
  	        } else if (cmd.type === 'C') {
  	            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
  	                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
  	                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
  	        } else if (cmd.type === 'Z') {
  	            p.closePath();
  	        }
  	    }

  	    return p;
  	};

  	/**
  	 * Split the glyph into contours.
  	 * This function is here for backwards compatibility, and to
  	 * provide raw access to the TrueType glyph outlines.
  	 * @return {Array}
  	 */
  	Glyph.prototype.getContours = function() {
  	    var this$1 = this;

  	    if (this.points === undefined) {
  	        return [];
  	    }

  	    var contours = [];
  	    var currentContour = [];
  	    for (var i = 0; i < this.points.length; i += 1) {
  	        var pt = this$1.points[i];
  	        currentContour.push(pt);
  	        if (pt.lastPointOfContour) {
  	            contours.push(currentContour);
  	            currentContour = [];
  	        }
  	    }

  	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
  	    return contours;
  	};

  	/**
  	 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
  	 * @return {Object}
  	 */
  	Glyph.prototype.getMetrics = function() {
  	    var commands = this.path.commands;
  	    var xCoords = [];
  	    var yCoords = [];
  	    for (var i = 0; i < commands.length; i += 1) {
  	        var cmd = commands[i];
  	        if (cmd.type !== 'Z') {
  	            xCoords.push(cmd.x);
  	            yCoords.push(cmd.y);
  	        }

  	        if (cmd.type === 'Q' || cmd.type === 'C') {
  	            xCoords.push(cmd.x1);
  	            yCoords.push(cmd.y1);
  	        }

  	        if (cmd.type === 'C') {
  	            xCoords.push(cmd.x2);
  	            yCoords.push(cmd.y2);
  	        }
  	    }

  	    var metrics = {
  	        xMin: Math.min.apply(null, xCoords),
  	        yMin: Math.min.apply(null, yCoords),
  	        xMax: Math.max.apply(null, xCoords),
  	        yMax: Math.max.apply(null, yCoords),
  	        leftSideBearing: this.leftSideBearing
  	    };

  	    if (!isFinite(metrics.xMin)) {
  	        metrics.xMin = 0;
  	    }

  	    if (!isFinite(metrics.xMax)) {
  	        metrics.xMax = this.advanceWidth;
  	    }

  	    if (!isFinite(metrics.yMin)) {
  	        metrics.yMin = 0;
  	    }

  	    if (!isFinite(metrics.yMax)) {
  	        metrics.yMax = 0;
  	    }

  	    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
  	    return metrics;
  	};

  	/**
  	 * Draw the glyph on the given context.
  	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
  	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param  {Object=} options - xScale, yScale to stretch the glyph.
  	 */
  	Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
  	    this.getPath(x, y, fontSize, options).draw(ctx);
  	};

  	/**
  	 * Draw the points of the glyph.
  	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
  	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
  	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 */
  	Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
  	    function drawCircles(l, x, y, scale) {
  	        var PI_SQ = Math.PI * 2;
  	        ctx.beginPath();
  	        for (var j = 0; j < l.length; j += 1) {
  	            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
  	            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
  	        }

  	        ctx.closePath();
  	        ctx.fill();
  	    }

  	    x = x !== undefined ? x : 0;
  	    y = y !== undefined ? y : 0;
  	    fontSize = fontSize !== undefined ? fontSize : 24;
  	    var scale = 1 / this.path.unitsPerEm * fontSize;

  	    var blueCircles = [];
  	    var redCircles = [];
  	    var path = this.path;
  	    for (var i = 0; i < path.commands.length; i += 1) {
  	        var cmd = path.commands[i];
  	        if (cmd.x !== undefined) {
  	            blueCircles.push({x: cmd.x, y: -cmd.y});
  	        }

  	        if (cmd.x1 !== undefined) {
  	            redCircles.push({x: cmd.x1, y: -cmd.y1});
  	        }

  	        if (cmd.x2 !== undefined) {
  	            redCircles.push({x: cmd.x2, y: -cmd.y2});
  	        }
  	    }

  	    ctx.fillStyle = 'blue';
  	    drawCircles(blueCircles, x, y, scale);
  	    ctx.fillStyle = 'red';
  	    drawCircles(redCircles, x, y, scale);
  	};

  	/**
  	 * Draw lines indicating important font measurements.
  	 * Black lines indicate the origin of the coordinate system (point 0,0).
  	 * Blue lines indicate the glyph bounding box.
  	 * Green line indicates the advance width of the glyph.
  	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
  	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 */
  	Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
  	    var scale;
  	    x = x !== undefined ? x : 0;
  	    y = y !== undefined ? y : 0;
  	    fontSize = fontSize !== undefined ? fontSize : 24;
  	    scale = 1 / this.path.unitsPerEm * fontSize;
  	    ctx.lineWidth = 1;

  	    // Draw the origin
  	    ctx.strokeStyle = 'black';
  	    draw.line(ctx, x, -10000, x, 10000);
  	    draw.line(ctx, -10000, y, 10000, y);

  	    // This code is here due to memory optimization: by not using
  	    // defaults in the constructor, we save a notable amount of memory.
  	    var xMin = this.xMin || 0;
  	    var yMin = this.yMin || 0;
  	    var xMax = this.xMax || 0;
  	    var yMax = this.yMax || 0;
  	    var advanceWidth = this.advanceWidth || 0;

  	    // Draw the glyph box
  	    ctx.strokeStyle = 'blue';
  	    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
  	    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
  	    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
  	    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

  	    // Draw the advance width
  	    ctx.strokeStyle = 'green';
  	    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
  	};

  	// The GlyphSet object

  	// Define a property on the glyph that depends on the path being loaded.
  	function defineDependentProperty(glyph, externalName, internalName) {
  	    Object.defineProperty(glyph, externalName, {
  	        get: function() {
  	            // Request the path property to make sure the path is loaded.
  	            glyph.path; // jshint ignore:line
  	            return glyph[internalName];
  	        },
  	        set: function(newValue) {
  	            glyph[internalName] = newValue;
  	        },
  	        enumerable: true,
  	        configurable: true
  	    });
  	}

  	/**
  	 * A GlyphSet represents all glyphs available in the font, but modelled using
  	 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
  	 * necessary, to keep the memory footprint down.
  	 * @exports opentype.GlyphSet
  	 * @class
  	 * @param {opentype.Font}
  	 * @param {Array}
  	 */
  	function GlyphSet(font, glyphs) {
  	    var this$1 = this;

  	    this.font = font;
  	    this.glyphs = {};
  	    if (Array.isArray(glyphs)) {
  	        for (var i = 0; i < glyphs.length; i++) {
  	            this$1.glyphs[i] = glyphs[i];
  	        }
  	    }

  	    this.length = (glyphs && glyphs.length) || 0;
  	}

  	/**
  	 * @param  {number} index
  	 * @return {opentype.Glyph}
  	 */
  	GlyphSet.prototype.get = function(index) {
  	    if (typeof this.glyphs[index] === 'function') {
  	        this.glyphs[index] = this.glyphs[index]();
  	    }

  	    return this.glyphs[index];
  	};

  	/**
  	 * @param  {number} index
  	 * @param  {Object}
  	 */
  	GlyphSet.prototype.push = function(index, loader) {
  	    this.glyphs[index] = loader;
  	    this.length++;
  	};

  	/**
  	 * @alias opentype.glyphLoader
  	 * @param  {opentype.Font} font
  	 * @param  {number} index
  	 * @return {opentype.Glyph}
  	 */
  	function glyphLoader(font, index) {
  	    return new Glyph({index: index, font: font});
  	}

  	/**
  	 * Generate a stub glyph that can be filled with all metadata *except*
  	 * the "points" and "path" properties, which must be loaded only once
  	 * the glyph's path is actually requested for text shaping.
  	 * @alias opentype.ttfGlyphLoader
  	 * @param  {opentype.Font} font
  	 * @param  {number} index
  	 * @param  {Function} parseGlyph
  	 * @param  {Object} data
  	 * @param  {number} position
  	 * @param  {Function} buildPath
  	 * @return {opentype.Glyph}
  	 */
  	function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
  	    return function() {
  	        var glyph = new Glyph({index: index, font: font});

  	        glyph.path = function() {
  	            parseGlyph(glyph, data, position);
  	            var path = buildPath(font.glyphs, glyph);
  	            path.unitsPerEm = font.unitsPerEm;
  	            return path;
  	        };

  	        defineDependentProperty(glyph, 'xMin', '_xMin');
  	        defineDependentProperty(glyph, 'xMax', '_xMax');
  	        defineDependentProperty(glyph, 'yMin', '_yMin');
  	        defineDependentProperty(glyph, 'yMax', '_yMax');

  	        return glyph;
  	    };
  	}
  	/**
  	 * @alias opentype.cffGlyphLoader
  	 * @param  {opentype.Font} font
  	 * @param  {number} index
  	 * @param  {Function} parseCFFCharstring
  	 * @param  {string} charstring
  	 * @return {opentype.Glyph}
  	 */
  	function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
  	    return function() {
  	        var glyph = new Glyph({index: index, font: font});

  	        glyph.path = function() {
  	            var path = parseCFFCharstring(font, glyph, charstring);
  	            path.unitsPerEm = font.unitsPerEm;
  	            return path;
  	        };

  	        return glyph;
  	    };
  	}

  	var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

  	// The `CFF` table contains the glyph outlines in PostScript format.

  	// Custom equals function that can also check lists.
  	function equals(a, b) {
  	    if (a === b) {
  	        return true;
  	    } else if (Array.isArray(a) && Array.isArray(b)) {
  	        if (a.length !== b.length) {
  	            return false;
  	        }

  	        for (var i = 0; i < a.length; i += 1) {
  	            if (!equals(a[i], b[i])) {
  	                return false;
  	            }
  	        }

  	        return true;
  	    } else {
  	        return false;
  	    }
  	}

  	// Subroutines are encoded using the negative half of the number space.
  	// See type 2 chapter 4.7 "Subroutine operators".
  	function calcCFFSubroutineBias(subrs) {
  	    var bias;
  	    if (subrs.length < 1240) {
  	        bias = 107;
  	    } else if (subrs.length < 33900) {
  	        bias = 1131;
  	    } else {
  	        bias = 32768;
  	    }

  	    return bias;
  	}

  	// Parse a `CFF` INDEX array.
  	// An index array consists of a list of offsets, then a list of objects at those offsets.
  	function parseCFFIndex(data, start, conversionFn) {
  	    var offsets = [];
  	    var objects = [];
  	    var count = parse.getCard16(data, start);
  	    var objectOffset;
  	    var endOffset;
  	    if (count !== 0) {
  	        var offsetSize = parse.getByte(data, start + 2);
  	        objectOffset = start + ((count + 1) * offsetSize) + 2;
  	        var pos = start + 3;
  	        for (var i = 0; i < count + 1; i += 1) {
  	            offsets.push(parse.getOffset(data, pos, offsetSize));
  	            pos += offsetSize;
  	        }

  	        // The total size of the index array is 4 header bytes + the value of the last offset.
  	        endOffset = objectOffset + offsets[count];
  	    } else {
  	        endOffset = start + 2;
  	    }

  	    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
  	        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
  	        if (conversionFn) {
  	            value = conversionFn(value);
  	        }

  	        objects.push(value);
  	    }

  	    return {objects: objects, startOffset: start, endOffset: endOffset};
  	}

  	// Parse a `CFF` DICT real value.
  	function parseFloatOperand(parser) {
  	    var s = '';
  	    var eof = 15;
  	    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
  	    while (true) {
  	        var b = parser.parseByte();
  	        var n1 = b >> 4;
  	        var n2 = b & 15;

  	        if (n1 === eof) {
  	            break;
  	        }

  	        s += lookup[n1];

  	        if (n2 === eof) {
  	            break;
  	        }

  	        s += lookup[n2];
  	    }

  	    return parseFloat(s);
  	}

  	// Parse a `CFF` DICT operand.
  	function parseOperand(parser, b0) {
  	    var b1;
  	    var b2;
  	    var b3;
  	    var b4;
  	    if (b0 === 28) {
  	        b1 = parser.parseByte();
  	        b2 = parser.parseByte();
  	        return b1 << 8 | b2;
  	    }

  	    if (b0 === 29) {
  	        b1 = parser.parseByte();
  	        b2 = parser.parseByte();
  	        b3 = parser.parseByte();
  	        b4 = parser.parseByte();
  	        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
  	    }

  	    if (b0 === 30) {
  	        return parseFloatOperand(parser);
  	    }

  	    if (b0 >= 32 && b0 <= 246) {
  	        return b0 - 139;
  	    }

  	    if (b0 >= 247 && b0 <= 250) {
  	        b1 = parser.parseByte();
  	        return (b0 - 247) * 256 + b1 + 108;
  	    }

  	    if (b0 >= 251 && b0 <= 254) {
  	        b1 = parser.parseByte();
  	        return -(b0 - 251) * 256 - b1 - 108;
  	    }

  	    throw new Error('Invalid b0 ' + b0);
  	}

  	// Convert the entries returned by `parseDict` to a proper dictionary.
  	// If a value is a list of one, it is unpacked.
  	function entriesToObject(entries) {
  	    var o = {};
  	    for (var i = 0; i < entries.length; i += 1) {
  	        var key = entries[i][0];
  	        var values = entries[i][1];
  	        var value = (void 0);
  	        if (values.length === 1) {
  	            value = values[0];
  	        } else {
  	            value = values;
  	        }

  	        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
  	            throw new Error('Object ' + o + ' already has key ' + key);
  	        }

  	        o[key] = value;
  	    }

  	    return o;
  	}

  	// Parse a `CFF` DICT object.
  	// A dictionary contains key-value pairs in a compact tokenized format.
  	function parseCFFDict(data, start, size) {
  	    start = start !== undefined ? start : 0;
  	    var parser = new parse.Parser(data, start);
  	    var entries = [];
  	    var operands = [];
  	    size = size !== undefined ? size : data.length;

  	    while (parser.relativeOffset < size) {
  	        var op = parser.parseByte();

  	        // The first byte for each dict item distinguishes between operator (key) and operand (value).
  	        // Values <= 21 are operators.
  	        if (op <= 21) {
  	            // Two-byte operators have an initial escape byte of 12.
  	            if (op === 12) {
  	                op = 1200 + parser.parseByte();
  	            }

  	            entries.push([op, operands]);
  	            operands = [];
  	        } else {
  	            // Since the operands (values) come before the operators (keys), we store all operands in a list
  	            // until we encounter an operator.
  	            operands.push(parseOperand(parser, op));
  	        }
  	    }

  	    return entriesToObject(entries);
  	}

  	// Given a String Index (SID), return the value of the string.
  	// Strings below index 392 are standard CFF strings and are not encoded in the font.
  	function getCFFString(strings, index) {
  	    if (index <= 390) {
  	        index = cffStandardStrings[index];
  	    } else {
  	        index = strings[index - 391];
  	    }

  	    return index;
  	}

  	// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
  	// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
  	function interpretDict(dict, meta, strings) {
  	    var newDict = {};
  	    var value;

  	    // Because we also want to include missing values, we start out from the meta list
  	    // and lookup values in the dict.
  	    for (var i = 0; i < meta.length; i += 1) {
  	        var m = meta[i];

  	        if (Array.isArray(m.type)) {
  	            var values = [];
  	            values.length = m.type.length;
  	            for (var j = 0; j < m.type.length; j++) {
  	                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
  	                if (value === undefined) {
  	                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
  	                }
  	                if (m.type[j] === 'SID') {
  	                    value = getCFFString(strings, value);
  	                }
  	                values[j] = value;
  	            }
  	            newDict[m.name] = values;
  	        } else {
  	            value = dict[m.op];
  	            if (value === undefined) {
  	                value = m.value !== undefined ? m.value : null;
  	            }

  	            if (m.type === 'SID') {
  	                value = getCFFString(strings, value);
  	            }
  	            newDict[m.name] = value;
  	        }
  	    }

  	    return newDict;
  	}

  	// Parse the CFF header.
  	function parseCFFHeader(data, start) {
  	    var header = {};
  	    header.formatMajor = parse.getCard8(data, start);
  	    header.formatMinor = parse.getCard8(data, start + 1);
  	    header.size = parse.getCard8(data, start + 2);
  	    header.offsetSize = parse.getCard8(data, start + 3);
  	    header.startOffset = start;
  	    header.endOffset = start + 4;
  	    return header;
  	}

  	var TOP_DICT_META = [
  	    {name: 'version', op: 0, type: 'SID'},
  	    {name: 'notice', op: 1, type: 'SID'},
  	    {name: 'copyright', op: 1200, type: 'SID'},
  	    {name: 'fullName', op: 2, type: 'SID'},
  	    {name: 'familyName', op: 3, type: 'SID'},
  	    {name: 'weight', op: 4, type: 'SID'},
  	    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
  	    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
  	    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
  	    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
  	    {name: 'paintType', op: 1205, type: 'number', value: 0},
  	    {name: 'charstringType', op: 1206, type: 'number', value: 2},
  	    {
  	        name: 'fontMatrix',
  	        op: 1207,
  	        type: ['real', 'real', 'real', 'real', 'real', 'real'],
  	        value: [0.001, 0, 0, 0.001, 0, 0]
  	    },
  	    {name: 'uniqueId', op: 13, type: 'number'},
  	    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
  	    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
  	    {name: 'xuid', op: 14, type: [], value: null},
  	    {name: 'charset', op: 15, type: 'offset', value: 0},
  	    {name: 'encoding', op: 16, type: 'offset', value: 0},
  	    {name: 'charStrings', op: 17, type: 'offset', value: 0},
  	    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
  	    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
  	    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
  	    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
  	    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
  	    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
  	    {name: 'uidBase', op: 1235, type: 'number'},
  	    {name: 'fdArray', op: 1236, type: 'offset'},
  	    {name: 'fdSelect', op: 1237, type: 'offset'},
  	    {name: 'fontName', op: 1238, type: 'SID'}
  	];

  	var PRIVATE_DICT_META = [
  	    {name: 'subrs', op: 19, type: 'offset', value: 0},
  	    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
  	    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
  	];

  	// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
  	// The top dictionary contains the essential metadata for the font, together with the private dictionary.
  	function parseCFFTopDict(data, strings) {
  	    var dict = parseCFFDict(data, 0, data.byteLength);
  	    return interpretDict(dict, TOP_DICT_META, strings);
  	}

  	// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
  	function parseCFFPrivateDict(data, start, size, strings) {
  	    var dict = parseCFFDict(data, start, size);
  	    return interpretDict(dict, PRIVATE_DICT_META, strings);
  	}

  	// Returns a list of "Top DICT"s found using an INDEX list.
  	// Used to read both the usual high-level Top DICTs and also the FDArray
  	// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
  	// a Private DICT that is read and saved into the Top DICT.
  	//
  	// In addition to the expected/optional values as outlined in TOP_DICT_META
  	// the following values might be saved into the Top DICT.
  	//
  	//    _subrs []        array of local CFF subroutines from Private DICT
  	//    _subrsBias       bias value computed from number of subroutines
  	//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
  	//    _defaultWidthX   default widths for CFF characters
  	//    _nominalWidthX   bias added to width embedded within glyph description
  	//
  	//    _privateDict     saved copy of parsed Private DICT from Top DICT
  	function gatherCFFTopDicts(data, start, cffIndex, strings) {
  	    var topDictArray = [];
  	    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
  	        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
  	        var topDict = parseCFFTopDict(topDictData, strings);
  	        topDict._subrs = [];
  	        topDict._subrsBias = 0;
  	        var privateSize = topDict.private[0];
  	        var privateOffset = topDict.private[1];
  	        if (privateSize !== 0 && privateOffset !== 0) {
  	            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
  	            topDict._defaultWidthX = privateDict.defaultWidthX;
  	            topDict._nominalWidthX = privateDict.nominalWidthX;
  	            if (privateDict.subrs !== 0) {
  	                var subrOffset = privateOffset + privateDict.subrs;
  	                var subrIndex = parseCFFIndex(data, subrOffset + start);
  	                topDict._subrs = subrIndex.objects;
  	                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
  	            }
  	            topDict._privateDict = privateDict;
  	        }
  	        topDictArray.push(topDict);
  	    }
  	    return topDictArray;
  	}

  	// Parse the CFF charset table, which contains internal names for all the glyphs.
  	// This function will return a list of glyph names.
  	// See Adobe TN #5176 chapter 13, "Charsets".
  	function parseCFFCharset(data, start, nGlyphs, strings) {
  	    var sid;
  	    var count;
  	    var parser = new parse.Parser(data, start);

  	    // The .notdef glyph is not included, so subtract 1.
  	    nGlyphs -= 1;
  	    var charset = ['.notdef'];

  	    var format = parser.parseCard8();
  	    if (format === 0) {
  	        for (var i = 0; i < nGlyphs; i += 1) {
  	            sid = parser.parseSID();
  	            charset.push(getCFFString(strings, sid));
  	        }
  	    } else if (format === 1) {
  	        while (charset.length <= nGlyphs) {
  	            sid = parser.parseSID();
  	            count = parser.parseCard8();
  	            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
  	                charset.push(getCFFString(strings, sid));
  	                sid += 1;
  	            }
  	        }
  	    } else if (format === 2) {
  	        while (charset.length <= nGlyphs) {
  	            sid = parser.parseSID();
  	            count = parser.parseCard16();
  	            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
  	                charset.push(getCFFString(strings, sid));
  	                sid += 1;
  	            }
  	        }
  	    } else {
  	        throw new Error('Unknown charset format ' + format);
  	    }

  	    return charset;
  	}

  	// Parse the CFF encoding data. Only one encoding can be specified per font.
  	// See Adobe TN #5176 chapter 12, "Encodings".
  	function parseCFFEncoding(data, start, charset) {
  	    var code;
  	    var enc = {};
  	    var parser = new parse.Parser(data, start);
  	    var format = parser.parseCard8();
  	    if (format === 0) {
  	        var nCodes = parser.parseCard8();
  	        for (var i = 0; i < nCodes; i += 1) {
  	            code = parser.parseCard8();
  	            enc[code] = i;
  	        }
  	    } else if (format === 1) {
  	        var nRanges = parser.parseCard8();
  	        code = 1;
  	        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
  	            var first = parser.parseCard8();
  	            var nLeft = parser.parseCard8();
  	            for (var j = first; j <= first + nLeft; j += 1) {
  	                enc[j] = code;
  	                code += 1;
  	            }
  	        }
  	    } else {
  	        throw new Error('Unknown encoding format ' + format);
  	    }

  	    return new CffEncoding(enc, charset);
  	}

  	// Take in charstring code and return a Glyph object.
  	// The encoding is described in the Type 2 Charstring Format
  	// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
  	function parseCFFCharstring(font, glyph, code) {
  	    var c1x;
  	    var c1y;
  	    var c2x;
  	    var c2y;
  	    var p = new Path();
  	    var stack = [];
  	    var nStems = 0;
  	    var haveWidth = false;
  	    var open = false;
  	    var x = 0;
  	    var y = 0;
  	    var subrs;
  	    var subrsBias;
  	    var defaultWidthX;
  	    var nominalWidthX;
  	    if (font.isCIDFont) {
  	        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
  	        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
  	        subrs = fdDict._subrs;
  	        subrsBias = fdDict._subrsBias;
  	        defaultWidthX = fdDict._defaultWidthX;
  	        nominalWidthX = fdDict._nominalWidthX;
  	    } else {
  	        subrs = font.tables.cff.topDict._subrs;
  	        subrsBias = font.tables.cff.topDict._subrsBias;
  	        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
  	        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
  	    }
  	    var width = defaultWidthX;

  	    function newContour(x, y) {
  	        if (open) {
  	            p.closePath();
  	        }

  	        p.moveTo(x, y);
  	        open = true;
  	    }

  	    function parseStems() {
  	        var hasWidthArg;

  	        // The number of stem operators on the stack is always even.
  	        // If the value is uneven, that means a width is specified.
  	        hasWidthArg = stack.length % 2 !== 0;
  	        if (hasWidthArg && !haveWidth) {
  	            width = stack.shift() + nominalWidthX;
  	        }

  	        nStems += stack.length >> 1;
  	        stack.length = 0;
  	        haveWidth = true;
  	    }

  	    function parse$$1(code) {
  	        var b1;
  	        var b2;
  	        var b3;
  	        var b4;
  	        var codeIndex;
  	        var subrCode;
  	        var jpx;
  	        var jpy;
  	        var c3x;
  	        var c3y;
  	        var c4x;
  	        var c4y;

  	        var i = 0;
  	        while (i < code.length) {
  	            var v = code[i];
  	            i += 1;
  	            switch (v) {
  	                case 1: // hstem
  	                    parseStems();
  	                    break;
  	                case 3: // vstem
  	                    parseStems();
  	                    break;
  	                case 4: // vmoveto
  	                    if (stack.length > 1 && !haveWidth) {
  	                        width = stack.shift() + nominalWidthX;
  	                        haveWidth = true;
  	                    }

  	                    y += stack.pop();
  	                    newContour(x, y);
  	                    break;
  	                case 5: // rlineto
  	                    while (stack.length > 0) {
  	                        x += stack.shift();
  	                        y += stack.shift();
  	                        p.lineTo(x, y);
  	                    }

  	                    break;
  	                case 6: // hlineto
  	                    while (stack.length > 0) {
  	                        x += stack.shift();
  	                        p.lineTo(x, y);
  	                        if (stack.length === 0) {
  	                            break;
  	                        }

  	                        y += stack.shift();
  	                        p.lineTo(x, y);
  	                    }

  	                    break;
  	                case 7: // vlineto
  	                    while (stack.length > 0) {
  	                        y += stack.shift();
  	                        p.lineTo(x, y);
  	                        if (stack.length === 0) {
  	                            break;
  	                        }

  	                        x += stack.shift();
  	                        p.lineTo(x, y);
  	                    }

  	                    break;
  	                case 8: // rrcurveto
  	                    while (stack.length > 0) {
  	                        c1x = x + stack.shift();
  	                        c1y = y + stack.shift();
  	                        c2x = c1x + stack.shift();
  	                        c2y = c1y + stack.shift();
  	                        x = c2x + stack.shift();
  	                        y = c2y + stack.shift();
  	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                    }

  	                    break;
  	                case 10: // callsubr
  	                    codeIndex = stack.pop() + subrsBias;
  	                    subrCode = subrs[codeIndex];
  	                    if (subrCode) {
  	                        parse$$1(subrCode);
  	                    }

  	                    break;
  	                case 11: // return
  	                    return;
  	                case 12: // flex operators
  	                    v = code[i];
  	                    i += 1;
  	                    switch (v) {
  	                        case 35: // flex
  	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
  	                            c1x = x   + stack.shift();    // dx1
  	                            c1y = y   + stack.shift();    // dy1
  	                            c2x = c1x + stack.shift();    // dx2
  	                            c2y = c1y + stack.shift();    // dy2
  	                            jpx = c2x + stack.shift();    // dx3
  	                            jpy = c2y + stack.shift();    // dy3
  	                            c3x = jpx + stack.shift();    // dx4
  	                            c3y = jpy + stack.shift();    // dy4
  	                            c4x = c3x + stack.shift();    // dx5
  	                            c4y = c3y + stack.shift();    // dy5
  	                            x = c4x   + stack.shift();    // dx6
  	                            y = c4y   + stack.shift();    // dy6
  	                            stack.shift();                // flex depth
  	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
  	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
  	                            break;
  	                        case 34: // hflex
  	                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
  	                            c1x = x   + stack.shift();    // dx1
  	                            c1y = y;                      // dy1
  	                            c2x = c1x + stack.shift();    // dx2
  	                            c2y = c1y + stack.shift();    // dy2
  	                            jpx = c2x + stack.shift();    // dx3
  	                            jpy = c2y;                    // dy3
  	                            c3x = jpx + stack.shift();    // dx4
  	                            c3y = c2y;                    // dy4
  	                            c4x = c3x + stack.shift();    // dx5
  	                            c4y = y;                      // dy5
  	                            x = c4x + stack.shift();      // dx6
  	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
  	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
  	                            break;
  	                        case 36: // hflex1
  	                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
  	                            c1x = x   + stack.shift();    // dx1
  	                            c1y = y   + stack.shift();    // dy1
  	                            c2x = c1x + stack.shift();    // dx2
  	                            c2y = c1y + stack.shift();    // dy2
  	                            jpx = c2x + stack.shift();    // dx3
  	                            jpy = c2y;                    // dy3
  	                            c3x = jpx + stack.shift();    // dx4
  	                            c3y = c2y;                    // dy4
  	                            c4x = c3x + stack.shift();    // dx5
  	                            c4y = c3y + stack.shift();    // dy5
  	                            x = c4x + stack.shift();      // dx6
  	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
  	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
  	                            break;
  	                        case 37: // flex1
  	                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
  	                            c1x = x   + stack.shift();    // dx1
  	                            c1y = y   + stack.shift();    // dy1
  	                            c2x = c1x + stack.shift();    // dx2
  	                            c2y = c1y + stack.shift();    // dy2
  	                            jpx = c2x + stack.shift();    // dx3
  	                            jpy = c2y + stack.shift();    // dy3
  	                            c3x = jpx + stack.shift();    // dx4
  	                            c3y = jpy + stack.shift();    // dy4
  	                            c4x = c3x + stack.shift();    // dx5
  	                            c4y = c3y + stack.shift();    // dy5
  	                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
  	                                x = c4x + stack.shift();
  	                            } else {
  	                                y = c4y + stack.shift();
  	                            }

  	                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
  	                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
  	                            break;
  	                        default:
  	                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
  	                            stack.length = 0;
  	                    }
  	                    break;
  	                case 14: // endchar
  	                    if (stack.length > 0 && !haveWidth) {
  	                        width = stack.shift() + nominalWidthX;
  	                        haveWidth = true;
  	                    }

  	                    if (open) {
  	                        p.closePath();
  	                        open = false;
  	                    }

  	                    break;
  	                case 18: // hstemhm
  	                    parseStems();
  	                    break;
  	                case 19: // hintmask
  	                case 20: // cntrmask
  	                    parseStems();
  	                    i += (nStems + 7) >> 3;
  	                    break;
  	                case 21: // rmoveto
  	                    if (stack.length > 2 && !haveWidth) {
  	                        width = stack.shift() + nominalWidthX;
  	                        haveWidth = true;
  	                    }

  	                    y += stack.pop();
  	                    x += stack.pop();
  	                    newContour(x, y);
  	                    break;
  	                case 22: // hmoveto
  	                    if (stack.length > 1 && !haveWidth) {
  	                        width = stack.shift() + nominalWidthX;
  	                        haveWidth = true;
  	                    }

  	                    x += stack.pop();
  	                    newContour(x, y);
  	                    break;
  	                case 23: // vstemhm
  	                    parseStems();
  	                    break;
  	                case 24: // rcurveline
  	                    while (stack.length > 2) {
  	                        c1x = x + stack.shift();
  	                        c1y = y + stack.shift();
  	                        c2x = c1x + stack.shift();
  	                        c2y = c1y + stack.shift();
  	                        x = c2x + stack.shift();
  	                        y = c2y + stack.shift();
  	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                    }

  	                    x += stack.shift();
  	                    y += stack.shift();
  	                    p.lineTo(x, y);
  	                    break;
  	                case 25: // rlinecurve
  	                    while (stack.length > 6) {
  	                        x += stack.shift();
  	                        y += stack.shift();
  	                        p.lineTo(x, y);
  	                    }

  	                    c1x = x + stack.shift();
  	                    c1y = y + stack.shift();
  	                    c2x = c1x + stack.shift();
  	                    c2y = c1y + stack.shift();
  	                    x = c2x + stack.shift();
  	                    y = c2y + stack.shift();
  	                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                    break;
  	                case 26: // vvcurveto
  	                    if (stack.length % 2) {
  	                        x += stack.shift();
  	                    }

  	                    while (stack.length > 0) {
  	                        c1x = x;
  	                        c1y = y + stack.shift();
  	                        c2x = c1x + stack.shift();
  	                        c2y = c1y + stack.shift();
  	                        x = c2x;
  	                        y = c2y + stack.shift();
  	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                    }

  	                    break;
  	                case 27: // hhcurveto
  	                    if (stack.length % 2) {
  	                        y += stack.shift();
  	                    }

  	                    while (stack.length > 0) {
  	                        c1x = x + stack.shift();
  	                        c1y = y;
  	                        c2x = c1x + stack.shift();
  	                        c2y = c1y + stack.shift();
  	                        x = c2x + stack.shift();
  	                        y = c2y;
  	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                    }

  	                    break;
  	                case 28: // shortint
  	                    b1 = code[i];
  	                    b2 = code[i + 1];
  	                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
  	                    i += 2;
  	                    break;
  	                case 29: // callgsubr
  	                    codeIndex = stack.pop() + font.gsubrsBias;
  	                    subrCode = font.gsubrs[codeIndex];
  	                    if (subrCode) {
  	                        parse$$1(subrCode);
  	                    }

  	                    break;
  	                case 30: // vhcurveto
  	                    while (stack.length > 0) {
  	                        c1x = x;
  	                        c1y = y + stack.shift();
  	                        c2x = c1x + stack.shift();
  	                        c2y = c1y + stack.shift();
  	                        x = c2x + stack.shift();
  	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
  	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                        if (stack.length === 0) {
  	                            break;
  	                        }

  	                        c1x = x + stack.shift();
  	                        c1y = y;
  	                        c2x = c1x + stack.shift();
  	                        c2y = c1y + stack.shift();
  	                        y = c2y + stack.shift();
  	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
  	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                    }

  	                    break;
  	                case 31: // hvcurveto
  	                    while (stack.length > 0) {
  	                        c1x = x + stack.shift();
  	                        c1y = y;
  	                        c2x = c1x + stack.shift();
  	                        c2y = c1y + stack.shift();
  	                        y = c2y + stack.shift();
  	                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
  	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                        if (stack.length === 0) {
  	                            break;
  	                        }

  	                        c1x = x;
  	                        c1y = y + stack.shift();
  	                        c2x = c1x + stack.shift();
  	                        c2y = c1y + stack.shift();
  	                        x = c2x + stack.shift();
  	                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
  	                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
  	                    }

  	                    break;
  	                default:
  	                    if (v < 32) {
  	                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
  	                    } else if (v < 247) {
  	                        stack.push(v - 139);
  	                    } else if (v < 251) {
  	                        b1 = code[i];
  	                        i += 1;
  	                        stack.push((v - 247) * 256 + b1 + 108);
  	                    } else if (v < 255) {
  	                        b1 = code[i];
  	                        i += 1;
  	                        stack.push(-(v - 251) * 256 - b1 - 108);
  	                    } else {
  	                        b1 = code[i];
  	                        b2 = code[i + 1];
  	                        b3 = code[i + 2];
  	                        b4 = code[i + 3];
  	                        i += 4;
  	                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
  	                    }
  	            }
  	        }
  	    }

  	    parse$$1(code);

  	    glyph.advanceWidth = width;
  	    return p;
  	}

  	function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
  	    var fdSelect = [];
  	    var fdIndex;
  	    var parser = new parse.Parser(data, start);
  	    var format = parser.parseCard8();
  	    if (format === 0) {
  	        // Simple list of nGlyphs elements
  	        for (var iGid = 0; iGid < nGlyphs; iGid++) {
  	            fdIndex = parser.parseCard8();
  	            if (fdIndex >= fdArrayCount) {
  	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
  	            }
  	            fdSelect.push(fdIndex);
  	        }
  	    } else if (format === 3) {
  	        // Ranges
  	        var nRanges = parser.parseCard16();
  	        var first = parser.parseCard16();
  	        if (first !== 0) {
  	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
  	        }
  	        var next;
  	        for (var iRange = 0; iRange < nRanges; iRange++) {
  	            fdIndex = parser.parseCard8();
  	            next = parser.parseCard16();
  	            if (fdIndex >= fdArrayCount) {
  	                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
  	            }
  	            if (next > nGlyphs) {
  	                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
  	            }
  	            for (; first < next; first++) {
  	                fdSelect.push(fdIndex);
  	            }
  	            first = next;
  	        }
  	        if (next !== nGlyphs) {
  	            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
  	        }
  	    } else {
  	        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
  	    }
  	    return fdSelect;
  	}

  	// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
  	function parseCFFTable(data, start, font) {
  	    font.tables.cff = {};
  	    var header = parseCFFHeader(data, start);
  	    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
  	    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
  	    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
  	    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
  	    font.gsubrs = globalSubrIndex.objects;
  	    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

  	    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
  	    if (topDictArray.length !== 1) {
  	        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
  	    }

  	    var topDict = topDictArray[0];
  	    font.tables.cff.topDict = topDict;

  	    if (topDict._privateDict) {
  	        font.defaultWidthX = topDict._privateDict.defaultWidthX;
  	        font.nominalWidthX = topDict._privateDict.nominalWidthX;
  	    }

  	    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
  	        font.isCIDFont = true;
  	    }

  	    if (font.isCIDFont) {
  	        var fdArrayOffset = topDict.fdArray;
  	        var fdSelectOffset = topDict.fdSelect;
  	        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
  	            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
  	        }
  	        fdArrayOffset += start;
  	        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
  	        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
  	        topDict._fdArray = fdArray;
  	        fdSelectOffset += start;
  	        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
  	    }

  	    var privateDictOffset = start + topDict.private[1];
  	    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
  	    font.defaultWidthX = privateDict.defaultWidthX;
  	    font.nominalWidthX = privateDict.nominalWidthX;

  	    if (privateDict.subrs !== 0) {
  	        var subrOffset = privateDictOffset + privateDict.subrs;
  	        var subrIndex = parseCFFIndex(data, subrOffset);
  	        font.subrs = subrIndex.objects;
  	        font.subrsBias = calcCFFSubroutineBias(font.subrs);
  	    } else {
  	        font.subrs = [];
  	        font.subrsBias = 0;
  	    }

  	    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
  	    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
  	    font.nGlyphs = charStringsIndex.objects.length;

  	    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
  	    if (topDict.encoding === 0) {
  	        // Standard encoding
  	        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
  	    } else if (topDict.encoding === 1) {
  	        // Expert encoding
  	        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
  	    } else {
  	        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
  	    }

  	    // Prefer the CMAP encoding to the CFF encoding.
  	    font.encoding = font.encoding || font.cffEncoding;

  	    font.glyphs = new glyphset.GlyphSet(font);
  	    for (var i = 0; i < font.nGlyphs; i += 1) {
  	        var charString = charStringsIndex.objects[i];
  	        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
  	    }
  	}

  	// Convert a string to a String ID (SID).
  	// The list of strings is modified in place.
  	function encodeString(s, strings) {
  	    var sid;

  	    // Is the string in the CFF standard strings?
  	    var i = cffStandardStrings.indexOf(s);
  	    if (i >= 0) {
  	        sid = i;
  	    }

  	    // Is the string already in the string index?
  	    i = strings.indexOf(s);
  	    if (i >= 0) {
  	        sid = i + cffStandardStrings.length;
  	    } else {
  	        sid = cffStandardStrings.length + strings.length;
  	        strings.push(s);
  	    }

  	    return sid;
  	}

  	function makeHeader() {
  	    return new table.Record('Header', [
  	        {name: 'major', type: 'Card8', value: 1},
  	        {name: 'minor', type: 'Card8', value: 0},
  	        {name: 'hdrSize', type: 'Card8', value: 4},
  	        {name: 'major', type: 'Card8', value: 1}
  	    ]);
  	}

  	function makeNameIndex(fontNames) {
  	    var t = new table.Record('Name INDEX', [
  	        {name: 'names', type: 'INDEX', value: []}
  	    ]);
  	    t.names = [];
  	    for (var i = 0; i < fontNames.length; i += 1) {
  	        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
  	    }

  	    return t;
  	}

  	// Given a dictionary's metadata, create a DICT structure.
  	function makeDict(meta, attrs, strings) {
  	    var m = {};
  	    for (var i = 0; i < meta.length; i += 1) {
  	        var entry = meta[i];
  	        var value = attrs[entry.name];
  	        if (value !== undefined && !equals(value, entry.value)) {
  	            if (entry.type === 'SID') {
  	                value = encodeString(value, strings);
  	            }

  	            m[entry.op] = {name: entry.name, type: entry.type, value: value};
  	        }
  	    }

  	    return m;
  	}

  	// The Top DICT houses the global font attributes.
  	function makeTopDict(attrs, strings) {
  	    var t = new table.Record('Top DICT', [
  	        {name: 'dict', type: 'DICT', value: {}}
  	    ]);
  	    t.dict = makeDict(TOP_DICT_META, attrs, strings);
  	    return t;
  	}

  	function makeTopDictIndex(topDict) {
  	    var t = new table.Record('Top DICT INDEX', [
  	        {name: 'topDicts', type: 'INDEX', value: []}
  	    ]);
  	    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
  	    return t;
  	}

  	function makeStringIndex(strings) {
  	    var t = new table.Record('String INDEX', [
  	        {name: 'strings', type: 'INDEX', value: []}
  	    ]);
  	    t.strings = [];
  	    for (var i = 0; i < strings.length; i += 1) {
  	        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
  	    }

  	    return t;
  	}

  	function makeGlobalSubrIndex() {
  	    // Currently we don't use subroutines.
  	    return new table.Record('Global Subr INDEX', [
  	        {name: 'subrs', type: 'INDEX', value: []}
  	    ]);
  	}

  	function makeCharsets(glyphNames, strings) {
  	    var t = new table.Record('Charsets', [
  	        {name: 'format', type: 'Card8', value: 0}
  	    ]);
  	    for (var i = 0; i < glyphNames.length; i += 1) {
  	        var glyphName = glyphNames[i];
  	        var glyphSID = encodeString(glyphName, strings);
  	        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
  	    }

  	    return t;
  	}

  	function glyphToOps(glyph) {
  	    var ops = [];
  	    var path = glyph.path;
  	    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
  	    var x = 0;
  	    var y = 0;
  	    for (var i = 0; i < path.commands.length; i += 1) {
  	        var dx = (void 0);
  	        var dy = (void 0);
  	        var cmd = path.commands[i];
  	        if (cmd.type === 'Q') {
  	            // CFF only supports bÃ©zier curves, so convert the quad to a bÃ©zier.
  	            var _13 = 1 / 3;
  	            var _23 = 2 / 3;

  	            // We're going to create a new command so we don't change the original path.
  	            cmd = {
  	                type: 'C',
  	                x: cmd.x,
  	                y: cmd.y,
  	                x1: _13 * x + _23 * cmd.x1,
  	                y1: _13 * y + _23 * cmd.y1,
  	                x2: _13 * cmd.x + _23 * cmd.x1,
  	                y2: _13 * cmd.y + _23 * cmd.y1
  	            };
  	        }

  	        if (cmd.type === 'M') {
  	            dx = Math.round(cmd.x - x);
  	            dy = Math.round(cmd.y - y);
  	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
  	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
  	            ops.push({name: 'rmoveto', type: 'OP', value: 21});
  	            x = Math.round(cmd.x);
  	            y = Math.round(cmd.y);
  	        } else if (cmd.type === 'L') {
  	            dx = Math.round(cmd.x - x);
  	            dy = Math.round(cmd.y - y);
  	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
  	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
  	            ops.push({name: 'rlineto', type: 'OP', value: 5});
  	            x = Math.round(cmd.x);
  	            y = Math.round(cmd.y);
  	        } else if (cmd.type === 'C') {
  	            var dx1 = Math.round(cmd.x1 - x);
  	            var dy1 = Math.round(cmd.y1 - y);
  	            var dx2 = Math.round(cmd.x2 - cmd.x1);
  	            var dy2 = Math.round(cmd.y2 - cmd.y1);
  	            dx = Math.round(cmd.x - cmd.x2);
  	            dy = Math.round(cmd.y - cmd.y2);
  	            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
  	            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
  	            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
  	            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
  	            ops.push({name: 'dx', type: 'NUMBER', value: dx});
  	            ops.push({name: 'dy', type: 'NUMBER', value: dy});
  	            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
  	            x = Math.round(cmd.x);
  	            y = Math.round(cmd.y);
  	        }

  	        // Contours are closed automatically.
  	    }

  	    ops.push({name: 'endchar', type: 'OP', value: 14});
  	    return ops;
  	}

  	function makeCharStringsIndex(glyphs) {
  	    var t = new table.Record('CharStrings INDEX', [
  	        {name: 'charStrings', type: 'INDEX', value: []}
  	    ]);

  	    for (var i = 0; i < glyphs.length; i += 1) {
  	        var glyph = glyphs.get(i);
  	        var ops = glyphToOps(glyph);
  	        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
  	    }

  	    return t;
  	}

  	function makePrivateDict(attrs, strings) {
  	    var t = new table.Record('Private DICT', [
  	        {name: 'dict', type: 'DICT', value: {}}
  	    ]);
  	    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
  	    return t;
  	}

  	function makeCFFTable(glyphs, options) {
  	    var t = new table.Table('CFF ', [
  	        {name: 'header', type: 'RECORD'},
  	        {name: 'nameIndex', type: 'RECORD'},
  	        {name: 'topDictIndex', type: 'RECORD'},
  	        {name: 'stringIndex', type: 'RECORD'},
  	        {name: 'globalSubrIndex', type: 'RECORD'},
  	        {name: 'charsets', type: 'RECORD'},
  	        {name: 'charStringsIndex', type: 'RECORD'},
  	        {name: 'privateDict', type: 'RECORD'}
  	    ]);

  	    var fontScale = 1 / options.unitsPerEm;
  	    // We use non-zero values for the offsets so that the DICT encodes them.
  	    // This is important because the size of the Top DICT plays a role in offset calculation,
  	    // and the size shouldn't change after we've written correct offsets.
  	    var attrs = {
  	        version: options.version,
  	        fullName: options.fullName,
  	        familyName: options.familyName,
  	        weight: options.weightName,
  	        fontBBox: options.fontBBox || [0, 0, 0, 0],
  	        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
  	        charset: 999,
  	        encoding: 0,
  	        charStrings: 999,
  	        private: [0, 999]
  	    };

  	    var privateAttrs = {};

  	    var glyphNames = [];
  	    var glyph;

  	    // Skip first glyph (.notdef)
  	    for (var i = 1; i < glyphs.length; i += 1) {
  	        glyph = glyphs.get(i);
  	        glyphNames.push(glyph.name);
  	    }

  	    var strings = [];

  	    t.header = makeHeader();
  	    t.nameIndex = makeNameIndex([options.postScriptName]);
  	    var topDict = makeTopDict(attrs, strings);
  	    t.topDictIndex = makeTopDictIndex(topDict);
  	    t.globalSubrIndex = makeGlobalSubrIndex();
  	    t.charsets = makeCharsets(glyphNames, strings);
  	    t.charStringsIndex = makeCharStringsIndex(glyphs);
  	    t.privateDict = makePrivateDict(privateAttrs, strings);

  	    // Needs to come at the end, to encode all custom strings used in the font.
  	    t.stringIndex = makeStringIndex(strings);

  	    var startOffset = t.header.sizeOf() +
  	        t.nameIndex.sizeOf() +
  	        t.topDictIndex.sizeOf() +
  	        t.stringIndex.sizeOf() +
  	        t.globalSubrIndex.sizeOf();
  	    attrs.charset = startOffset;

  	    // We use the CFF standard encoding; proper encoding will be handled in cmap.
  	    attrs.encoding = 0;
  	    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
  	    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

  	    // Recreate the Top DICT INDEX with the correct offsets.
  	    topDict = makeTopDict(attrs, strings);
  	    t.topDictIndex = makeTopDictIndex(topDict);

  	    return t;
  	}

  	var cff = { parse: parseCFFTable, make: makeCFFTable };

  	// The `head` table contains global information about the font.

  	// Parse the header `head` table
  	function parseHeadTable(data, start) {
  	    var head = {};
  	    var p = new parse.Parser(data, start);
  	    head.version = p.parseVersion();
  	    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
  	    head.checkSumAdjustment = p.parseULong();
  	    head.magicNumber = p.parseULong();
  	    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
  	    head.flags = p.parseUShort();
  	    head.unitsPerEm = p.parseUShort();
  	    head.created = p.parseLongDateTime();
  	    head.modified = p.parseLongDateTime();
  	    head.xMin = p.parseShort();
  	    head.yMin = p.parseShort();
  	    head.xMax = p.parseShort();
  	    head.yMax = p.parseShort();
  	    head.macStyle = p.parseUShort();
  	    head.lowestRecPPEM = p.parseUShort();
  	    head.fontDirectionHint = p.parseShort();
  	    head.indexToLocFormat = p.parseShort();
  	    head.glyphDataFormat = p.parseShort();
  	    return head;
  	}

  	function makeHeadTable(options) {
  	    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
  	    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
  	    var createdTimestamp = timestamp;

  	    if (options.createdTimestamp) {
  	        createdTimestamp = options.createdTimestamp + 2082844800;
  	    }

  	    return new table.Table('head', [
  	        {name: 'version', type: 'FIXED', value: 0x00010000},
  	        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
  	        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
  	        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
  	        {name: 'flags', type: 'USHORT', value: 0},
  	        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
  	        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
  	        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
  	        {name: 'xMin', type: 'SHORT', value: 0},
  	        {name: 'yMin', type: 'SHORT', value: 0},
  	        {name: 'xMax', type: 'SHORT', value: 0},
  	        {name: 'yMax', type: 'SHORT', value: 0},
  	        {name: 'macStyle', type: 'USHORT', value: 0},
  	        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
  	        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
  	        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
  	        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
  	    ], options);
  	}

  	var head = { parse: parseHeadTable, make: makeHeadTable };

  	// The `hhea` table contains information for horizontal layout.

  	// Parse the horizontal header `hhea` table
  	function parseHheaTable(data, start) {
  	    var hhea = {};
  	    var p = new parse.Parser(data, start);
  	    hhea.version = p.parseVersion();
  	    hhea.ascender = p.parseShort();
  	    hhea.descender = p.parseShort();
  	    hhea.lineGap = p.parseShort();
  	    hhea.advanceWidthMax = p.parseUShort();
  	    hhea.minLeftSideBearing = p.parseShort();
  	    hhea.minRightSideBearing = p.parseShort();
  	    hhea.xMaxExtent = p.parseShort();
  	    hhea.caretSlopeRise = p.parseShort();
  	    hhea.caretSlopeRun = p.parseShort();
  	    hhea.caretOffset = p.parseShort();
  	    p.relativeOffset += 8;
  	    hhea.metricDataFormat = p.parseShort();
  	    hhea.numberOfHMetrics = p.parseUShort();
  	    return hhea;
  	}

  	function makeHheaTable(options) {
  	    return new table.Table('hhea', [
  	        {name: 'version', type: 'FIXED', value: 0x00010000},
  	        {name: 'ascender', type: 'FWORD', value: 0},
  	        {name: 'descender', type: 'FWORD', value: 0},
  	        {name: 'lineGap', type: 'FWORD', value: 0},
  	        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
  	        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
  	        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
  	        {name: 'xMaxExtent', type: 'FWORD', value: 0},
  	        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
  	        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
  	        {name: 'caretOffset', type: 'SHORT', value: 0},
  	        {name: 'reserved1', type: 'SHORT', value: 0},
  	        {name: 'reserved2', type: 'SHORT', value: 0},
  	        {name: 'reserved3', type: 'SHORT', value: 0},
  	        {name: 'reserved4', type: 'SHORT', value: 0},
  	        {name: 'metricDataFormat', type: 'SHORT', value: 0},
  	        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
  	    ], options);
  	}

  	var hhea = { parse: parseHheaTable, make: makeHheaTable };

  	// The `hmtx` table contains the horizontal metrics for all glyphs.

  	// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
  	// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
  	function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
  	    var advanceWidth;
  	    var leftSideBearing;
  	    var p = new parse.Parser(data, start);
  	    for (var i = 0; i < numGlyphs; i += 1) {
  	        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
  	        if (i < numMetrics) {
  	            advanceWidth = p.parseUShort();
  	            leftSideBearing = p.parseShort();
  	        }

  	        var glyph = glyphs.get(i);
  	        glyph.advanceWidth = advanceWidth;
  	        glyph.leftSideBearing = leftSideBearing;
  	    }
  	}

  	function makeHmtxTable(glyphs) {
  	    var t = new table.Table('hmtx', []);
  	    for (var i = 0; i < glyphs.length; i += 1) {
  	        var glyph = glyphs.get(i);
  	        var advanceWidth = glyph.advanceWidth || 0;
  	        var leftSideBearing = glyph.leftSideBearing || 0;
  	        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
  	        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
  	    }

  	    return t;
  	}

  	var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };

  	// The `ltag` table stores IETF BCP-47 language tags. It allows supporting

  	function makeLtagTable(tags) {
  	    var result = new table.Table('ltag', [
  	        {name: 'version', type: 'ULONG', value: 1},
  	        {name: 'flags', type: 'ULONG', value: 0},
  	        {name: 'numTags', type: 'ULONG', value: tags.length}
  	    ]);

  	    var stringPool = '';
  	    var stringPoolOffset = 12 + tags.length * 4;
  	    for (var i = 0; i < tags.length; ++i) {
  	        var pos = stringPool.indexOf(tags[i]);
  	        if (pos < 0) {
  	            pos = stringPool.length;
  	            stringPool += tags[i];
  	        }

  	        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
  	        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
  	    }

  	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
  	    return result;
  	}

  	function parseLtagTable(data, start) {
  	    var p = new parse.Parser(data, start);
  	    var tableVersion = p.parseULong();
  	    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
  	    // The 'ltag' specification does not define any flags; skip the field.
  	    p.skip('uLong', 1);
  	    var numTags = p.parseULong();

  	    var tags = [];
  	    for (var i = 0; i < numTags; i++) {
  	        var tag = '';
  	        var offset = start + p.parseUShort();
  	        var length = p.parseUShort();
  	        for (var j = offset; j < offset + length; ++j) {
  	            tag += String.fromCharCode(data.getInt8(j));
  	        }

  	        tags.push(tag);
  	    }

  	    return tags;
  	}

  	var ltag = { make: makeLtagTable, parse: parseLtagTable };

  	// The `maxp` table establishes the memory requirements for the font.

  	// Parse the maximum profile `maxp` table.
  	function parseMaxpTable(data, start) {
  	    var maxp = {};
  	    var p = new parse.Parser(data, start);
  	    maxp.version = p.parseVersion();
  	    maxp.numGlyphs = p.parseUShort();
  	    if (maxp.version === 1.0) {
  	        maxp.maxPoints = p.parseUShort();
  	        maxp.maxContours = p.parseUShort();
  	        maxp.maxCompositePoints = p.parseUShort();
  	        maxp.maxCompositeContours = p.parseUShort();
  	        maxp.maxZones = p.parseUShort();
  	        maxp.maxTwilightPoints = p.parseUShort();
  	        maxp.maxStorage = p.parseUShort();
  	        maxp.maxFunctionDefs = p.parseUShort();
  	        maxp.maxInstructionDefs = p.parseUShort();
  	        maxp.maxStackElements = p.parseUShort();
  	        maxp.maxSizeOfInstructions = p.parseUShort();
  	        maxp.maxComponentElements = p.parseUShort();
  	        maxp.maxComponentDepth = p.parseUShort();
  	    }

  	    return maxp;
  	}

  	function makeMaxpTable(numGlyphs) {
  	    return new table.Table('maxp', [
  	        {name: 'version', type: 'FIXED', value: 0x00005000},
  	        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
  	    ]);
  	}

  	var maxp = { parse: parseMaxpTable, make: makeMaxpTable };

  	// The `name` naming table.

  	// NameIDs for the name table.
  	var nameTableNames = [
  	    'copyright',              // 0
  	    'fontFamily',             // 1
  	    'fontSubfamily',          // 2
  	    'uniqueID',               // 3
  	    'fullName',               // 4
  	    'version',                // 5
  	    'postScriptName',         // 6
  	    'trademark',              // 7
  	    'manufacturer',           // 8
  	    'designer',               // 9
  	    'description',            // 10
  	    'manufacturerURL',        // 11
  	    'designerURL',            // 12
  	    'license',                // 13
  	    'licenseURL',             // 14
  	    'reserved',               // 15
  	    'preferredFamily',        // 16
  	    'preferredSubfamily',     // 17
  	    'compatibleFullName',     // 18
  	    'sampleText',             // 19
  	    'postScriptFindFontName', // 20
  	    'wwsFamily',              // 21
  	    'wwsSubfamily'            // 22
  	];

  	var macLanguages = {
  	    0: 'en',
  	    1: 'fr',
  	    2: 'de',
  	    3: 'it',
  	    4: 'nl',
  	    5: 'sv',
  	    6: 'es',
  	    7: 'da',
  	    8: 'pt',
  	    9: 'no',
  	    10: 'he',
  	    11: 'ja',
  	    12: 'ar',
  	    13: 'fi',
  	    14: 'el',
  	    15: 'is',
  	    16: 'mt',
  	    17: 'tr',
  	    18: 'hr',
  	    19: 'zh-Hant',
  	    20: 'ur',
  	    21: 'hi',
  	    22: 'th',
  	    23: 'ko',
  	    24: 'lt',
  	    25: 'pl',
  	    26: 'hu',
  	    27: 'es',
  	    28: 'lv',
  	    29: 'se',
  	    30: 'fo',
  	    31: 'fa',
  	    32: 'ru',
  	    33: 'zh',
  	    34: 'nl-BE',
  	    35: 'ga',
  	    36: 'sq',
  	    37: 'ro',
  	    38: 'cz',
  	    39: 'sk',
  	    40: 'si',
  	    41: 'yi',
  	    42: 'sr',
  	    43: 'mk',
  	    44: 'bg',
  	    45: 'uk',
  	    46: 'be',
  	    47: 'uz',
  	    48: 'kk',
  	    49: 'az-Cyrl',
  	    50: 'az-Arab',
  	    51: 'hy',
  	    52: 'ka',
  	    53: 'mo',
  	    54: 'ky',
  	    55: 'tg',
  	    56: 'tk',
  	    57: 'mn-CN',
  	    58: 'mn',
  	    59: 'ps',
  	    60: 'ks',
  	    61: 'ku',
  	    62: 'sd',
  	    63: 'bo',
  	    64: 'ne',
  	    65: 'sa',
  	    66: 'mr',
  	    67: 'bn',
  	    68: 'as',
  	    69: 'gu',
  	    70: 'pa',
  	    71: 'or',
  	    72: 'ml',
  	    73: 'kn',
  	    74: 'ta',
  	    75: 'te',
  	    76: 'si',
  	    77: 'my',
  	    78: 'km',
  	    79: 'lo',
  	    80: 'vi',
  	    81: 'id',
  	    82: 'tl',
  	    83: 'ms',
  	    84: 'ms-Arab',
  	    85: 'am',
  	    86: 'ti',
  	    87: 'om',
  	    88: 'so',
  	    89: 'sw',
  	    90: 'rw',
  	    91: 'rn',
  	    92: 'ny',
  	    93: 'mg',
  	    94: 'eo',
  	    128: 'cy',
  	    129: 'eu',
  	    130: 'ca',
  	    131: 'la',
  	    132: 'qu',
  	    133: 'gn',
  	    134: 'ay',
  	    135: 'tt',
  	    136: 'ug',
  	    137: 'dz',
  	    138: 'jv',
  	    139: 'su',
  	    140: 'gl',
  	    141: 'af',
  	    142: 'br',
  	    143: 'iu',
  	    144: 'gd',
  	    145: 'gv',
  	    146: 'ga',
  	    147: 'to',
  	    148: 'el-polyton',
  	    149: 'kl',
  	    150: 'az',
  	    151: 'nn'
  	};

  	// MacOS language ID â†’ MacOS script ID
  	//
  	// Note that the script ID is not sufficient to determine what encoding
  	// to use in TrueType files. For some languages, MacOS used a modification
  	// of a mainstream script. For example, an Icelandic name would be stored
  	// with smRoman in the TrueType naming table, but the actual encoding
  	// is a special Icelandic version of the normal Macintosh Roman encoding.
  	// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
  	// Syllables but MacOS had run out of available script codes, so this was
  	// done as a (pretty radical) "modification" of Ethiopic.
  	//
  	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
  	var macLanguageToScript = {
  	    0: 0,  // langEnglish â†’ smRoman
  	    1: 0,  // langFrench â†’ smRoman
  	    2: 0,  // langGerman â†’ smRoman
  	    3: 0,  // langItalian â†’ smRoman
  	    4: 0,  // langDutch â†’ smRoman
  	    5: 0,  // langSwedish â†’ smRoman
  	    6: 0,  // langSpanish â†’ smRoman
  	    7: 0,  // langDanish â†’ smRoman
  	    8: 0,  // langPortuguese â†’ smRoman
  	    9: 0,  // langNorwegian â†’ smRoman
  	    10: 5,  // langHebrew â†’ smHebrew
  	    11: 1,  // langJapanese â†’ smJapanese
  	    12: 4,  // langArabic â†’ smArabic
  	    13: 0,  // langFinnish â†’ smRoman
  	    14: 6,  // langGreek â†’ smGreek
  	    15: 0,  // langIcelandic â†’ smRoman (modified)
  	    16: 0,  // langMaltese â†’ smRoman
  	    17: 0,  // langTurkish â†’ smRoman (modified)
  	    18: 0,  // langCroatian â†’ smRoman (modified)
  	    19: 2,  // langTradChinese â†’ smTradChinese
  	    20: 4,  // langUrdu â†’ smArabic
  	    21: 9,  // langHindi â†’ smDevanagari
  	    22: 21,  // langThai â†’ smThai
  	    23: 3,  // langKorean â†’ smKorean
  	    24: 29,  // langLithuanian â†’ smCentralEuroRoman
  	    25: 29,  // langPolish â†’ smCentralEuroRoman
  	    26: 29,  // langHungarian â†’ smCentralEuroRoman
  	    27: 29,  // langEstonian â†’ smCentralEuroRoman
  	    28: 29,  // langLatvian â†’ smCentralEuroRoman
  	    29: 0,  // langSami â†’ smRoman
  	    30: 0,  // langFaroese â†’ smRoman (modified)
  	    31: 4,  // langFarsi â†’ smArabic (modified)
  	    32: 7,  // langRussian â†’ smCyrillic
  	    33: 25,  // langSimpChinese â†’ smSimpChinese
  	    34: 0,  // langFlemish â†’ smRoman
  	    35: 0,  // langIrishGaelic â†’ smRoman (modified)
  	    36: 0,  // langAlbanian â†’ smRoman
  	    37: 0,  // langRomanian â†’ smRoman (modified)
  	    38: 29,  // langCzech â†’ smCentralEuroRoman
  	    39: 29,  // langSlovak â†’ smCentralEuroRoman
  	    40: 0,  // langSlovenian â†’ smRoman (modified)
  	    41: 5,  // langYiddish â†’ smHebrew
  	    42: 7,  // langSerbian â†’ smCyrillic
  	    43: 7,  // langMacedonian â†’ smCyrillic
  	    44: 7,  // langBulgarian â†’ smCyrillic
  	    45: 7,  // langUkrainian â†’ smCyrillic (modified)
  	    46: 7,  // langByelorussian â†’ smCyrillic
  	    47: 7,  // langUzbek â†’ smCyrillic
  	    48: 7,  // langKazakh â†’ smCyrillic
  	    49: 7,  // langAzerbaijani â†’ smCyrillic
  	    50: 4,  // langAzerbaijanAr â†’ smArabic
  	    51: 24,  // langArmenian â†’ smArmenian
  	    52: 23,  // langGeorgian â†’ smGeorgian
  	    53: 7,  // langMoldavian â†’ smCyrillic
  	    54: 7,  // langKirghiz â†’ smCyrillic
  	    55: 7,  // langTajiki â†’ smCyrillic
  	    56: 7,  // langTurkmen â†’ smCyrillic
  	    57: 27,  // langMongolian â†’ smMongolian
  	    58: 7,  // langMongolianCyr â†’ smCyrillic
  	    59: 4,  // langPashto â†’ smArabic
  	    60: 4,  // langKurdish â†’ smArabic
  	    61: 4,  // langKashmiri â†’ smArabic
  	    62: 4,  // langSindhi â†’ smArabic
  	    63: 26,  // langTibetan â†’ smTibetan
  	    64: 9,  // langNepali â†’ smDevanagari
  	    65: 9,  // langSanskrit â†’ smDevanagari
  	    66: 9,  // langMarathi â†’ smDevanagari
  	    67: 13,  // langBengali â†’ smBengali
  	    68: 13,  // langAssamese â†’ smBengali
  	    69: 11,  // langGujarati â†’ smGujarati
  	    70: 10,  // langPunjabi â†’ smGurmukhi
  	    71: 12,  // langOriya â†’ smOriya
  	    72: 17,  // langMalayalam â†’ smMalayalam
  	    73: 16,  // langKannada â†’ smKannada
  	    74: 14,  // langTamil â†’ smTamil
  	    75: 15,  // langTelugu â†’ smTelugu
  	    76: 18,  // langSinhalese â†’ smSinhalese
  	    77: 19,  // langBurmese â†’ smBurmese
  	    78: 20,  // langKhmer â†’ smKhmer
  	    79: 22,  // langLao â†’ smLao
  	    80: 30,  // langVietnamese â†’ smVietnamese
  	    81: 0,  // langIndonesian â†’ smRoman
  	    82: 0,  // langTagalog â†’ smRoman
  	    83: 0,  // langMalayRoman â†’ smRoman
  	    84: 4,  // langMalayArabic â†’ smArabic
  	    85: 28,  // langAmharic â†’ smEthiopic
  	    86: 28,  // langTigrinya â†’ smEthiopic
  	    87: 28,  // langOromo â†’ smEthiopic
  	    88: 0,  // langSomali â†’ smRoman
  	    89: 0,  // langSwahili â†’ smRoman
  	    90: 0,  // langKinyarwanda â†’ smRoman
  	    91: 0,  // langRundi â†’ smRoman
  	    92: 0,  // langNyanja â†’ smRoman
  	    93: 0,  // langMalagasy â†’ smRoman
  	    94: 0,  // langEsperanto â†’ smRoman
  	    128: 0,  // langWelsh â†’ smRoman (modified)
  	    129: 0,  // langBasque â†’ smRoman
  	    130: 0,  // langCatalan â†’ smRoman
  	    131: 0,  // langLatin â†’ smRoman
  	    132: 0,  // langQuechua â†’ smRoman
  	    133: 0,  // langGuarani â†’ smRoman
  	    134: 0,  // langAymara â†’ smRoman
  	    135: 7,  // langTatar â†’ smCyrillic
  	    136: 4,  // langUighur â†’ smArabic
  	    137: 26,  // langDzongkha â†’ smTibetan
  	    138: 0,  // langJavaneseRom â†’ smRoman
  	    139: 0,  // langSundaneseRom â†’ smRoman
  	    140: 0,  // langGalician â†’ smRoman
  	    141: 0,  // langAfrikaans â†’ smRoman
  	    142: 0,  // langBreton â†’ smRoman (modified)
  	    143: 28,  // langInuktitut â†’ smEthiopic (modified)
  	    144: 0,  // langScottishGaelic â†’ smRoman (modified)
  	    145: 0,  // langManxGaelic â†’ smRoman (modified)
  	    146: 0,  // langIrishGaelicScript â†’ smRoman (modified)
  	    147: 0,  // langTongan â†’ smRoman
  	    148: 6,  // langGreekAncient â†’ smRoman
  	    149: 0,  // langGreenlandic â†’ smRoman
  	    150: 0,  // langAzerbaijanRoman â†’ smRoman
  	    151: 0   // langNynorsk â†’ smRoman
  	};

  	// While Microsoft indicates a region/country for all its language
  	// IDs, we omit the region code if it's equal to the "most likely
  	// region subtag" according to Unicode CLDR. For scripts, we omit
  	// the subtag if it is equal to the Suppress-Script entry in the
  	// IANA language subtag registry for IETF BCP 47.
  	//
  	// For example, Microsoft states that its language code 0x041A is
  	// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
  	// and not 'hr-HR' because Croatia is the default country for Croatian,
  	// according to Unicode CLDR. As another example, Microsoft states
  	// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
  	// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
  	// for the Croatian language, according to IANA.
  	//
  	// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
  	// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
  	var windowsLanguages = {
  	    0x0436: 'af',
  	    0x041C: 'sq',
  	    0x0484: 'gsw',
  	    0x045E: 'am',
  	    0x1401: 'ar-DZ',
  	    0x3C01: 'ar-BH',
  	    0x0C01: 'ar',
  	    0x0801: 'ar-IQ',
  	    0x2C01: 'ar-JO',
  	    0x3401: 'ar-KW',
  	    0x3001: 'ar-LB',
  	    0x1001: 'ar-LY',
  	    0x1801: 'ary',
  	    0x2001: 'ar-OM',
  	    0x4001: 'ar-QA',
  	    0x0401: 'ar-SA',
  	    0x2801: 'ar-SY',
  	    0x1C01: 'aeb',
  	    0x3801: 'ar-AE',
  	    0x2401: 'ar-YE',
  	    0x042B: 'hy',
  	    0x044D: 'as',
  	    0x082C: 'az-Cyrl',
  	    0x042C: 'az',
  	    0x046D: 'ba',
  	    0x042D: 'eu',
  	    0x0423: 'be',
  	    0x0845: 'bn',
  	    0x0445: 'bn-IN',
  	    0x201A: 'bs-Cyrl',
  	    0x141A: 'bs',
  	    0x047E: 'br',
  	    0x0402: 'bg',
  	    0x0403: 'ca',
  	    0x0C04: 'zh-HK',
  	    0x1404: 'zh-MO',
  	    0x0804: 'zh',
  	    0x1004: 'zh-SG',
  	    0x0404: 'zh-TW',
  	    0x0483: 'co',
  	    0x041A: 'hr',
  	    0x101A: 'hr-BA',
  	    0x0405: 'cs',
  	    0x0406: 'da',
  	    0x048C: 'prs',
  	    0x0465: 'dv',
  	    0x0813: 'nl-BE',
  	    0x0413: 'nl',
  	    0x0C09: 'en-AU',
  	    0x2809: 'en-BZ',
  	    0x1009: 'en-CA',
  	    0x2409: 'en-029',
  	    0x4009: 'en-IN',
  	    0x1809: 'en-IE',
  	    0x2009: 'en-JM',
  	    0x4409: 'en-MY',
  	    0x1409: 'en-NZ',
  	    0x3409: 'en-PH',
  	    0x4809: 'en-SG',
  	    0x1C09: 'en-ZA',
  	    0x2C09: 'en-TT',
  	    0x0809: 'en-GB',
  	    0x0409: 'en',
  	    0x3009: 'en-ZW',
  	    0x0425: 'et',
  	    0x0438: 'fo',
  	    0x0464: 'fil',
  	    0x040B: 'fi',
  	    0x080C: 'fr-BE',
  	    0x0C0C: 'fr-CA',
  	    0x040C: 'fr',
  	    0x140C: 'fr-LU',
  	    0x180C: 'fr-MC',
  	    0x100C: 'fr-CH',
  	    0x0462: 'fy',
  	    0x0456: 'gl',
  	    0x0437: 'ka',
  	    0x0C07: 'de-AT',
  	    0x0407: 'de',
  	    0x1407: 'de-LI',
  	    0x1007: 'de-LU',
  	    0x0807: 'de-CH',
  	    0x0408: 'el',
  	    0x046F: 'kl',
  	    0x0447: 'gu',
  	    0x0468: 'ha',
  	    0x040D: 'he',
  	    0x0439: 'hi',
  	    0x040E: 'hu',
  	    0x040F: 'is',
  	    0x0470: 'ig',
  	    0x0421: 'id',
  	    0x045D: 'iu',
  	    0x085D: 'iu-Latn',
  	    0x083C: 'ga',
  	    0x0434: 'xh',
  	    0x0435: 'zu',
  	    0x0410: 'it',
  	    0x0810: 'it-CH',
  	    0x0411: 'ja',
  	    0x044B: 'kn',
  	    0x043F: 'kk',
  	    0x0453: 'km',
  	    0x0486: 'quc',
  	    0x0487: 'rw',
  	    0x0441: 'sw',
  	    0x0457: 'kok',
  	    0x0412: 'ko',
  	    0x0440: 'ky',
  	    0x0454: 'lo',
  	    0x0426: 'lv',
  	    0x0427: 'lt',
  	    0x082E: 'dsb',
  	    0x046E: 'lb',
  	    0x042F: 'mk',
  	    0x083E: 'ms-BN',
  	    0x043E: 'ms',
  	    0x044C: 'ml',
  	    0x043A: 'mt',
  	    0x0481: 'mi',
  	    0x047A: 'arn',
  	    0x044E: 'mr',
  	    0x047C: 'moh',
  	    0x0450: 'mn',
  	    0x0850: 'mn-CN',
  	    0x0461: 'ne',
  	    0x0414: 'nb',
  	    0x0814: 'nn',
  	    0x0482: 'oc',
  	    0x0448: 'or',
  	    0x0463: 'ps',
  	    0x0415: 'pl',
  	    0x0416: 'pt',
  	    0x0816: 'pt-PT',
  	    0x0446: 'pa',
  	    0x046B: 'qu-BO',
  	    0x086B: 'qu-EC',
  	    0x0C6B: 'qu',
  	    0x0418: 'ro',
  	    0x0417: 'rm',
  	    0x0419: 'ru',
  	    0x243B: 'smn',
  	    0x103B: 'smj-NO',
  	    0x143B: 'smj',
  	    0x0C3B: 'se-FI',
  	    0x043B: 'se',
  	    0x083B: 'se-SE',
  	    0x203B: 'sms',
  	    0x183B: 'sma-NO',
  	    0x1C3B: 'sms',
  	    0x044F: 'sa',
  	    0x1C1A: 'sr-Cyrl-BA',
  	    0x0C1A: 'sr',
  	    0x181A: 'sr-Latn-BA',
  	    0x081A: 'sr-Latn',
  	    0x046C: 'nso',
  	    0x0432: 'tn',
  	    0x045B: 'si',
  	    0x041B: 'sk',
  	    0x0424: 'sl',
  	    0x2C0A: 'es-AR',
  	    0x400A: 'es-BO',
  	    0x340A: 'es-CL',
  	    0x240A: 'es-CO',
  	    0x140A: 'es-CR',
  	    0x1C0A: 'es-DO',
  	    0x300A: 'es-EC',
  	    0x440A: 'es-SV',
  	    0x100A: 'es-GT',
  	    0x480A: 'es-HN',
  	    0x080A: 'es-MX',
  	    0x4C0A: 'es-NI',
  	    0x180A: 'es-PA',
  	    0x3C0A: 'es-PY',
  	    0x280A: 'es-PE',
  	    0x500A: 'es-PR',

  	    // Microsoft has defined two different language codes for
  	    // â€œSpanish with modern sortingâ€ and â€œSpanish with traditional
  	    // sortingâ€. This makes sense for collation APIs, and it would be
  	    // possible to express this in BCP 47 language tags via Unicode
  	    // extensions (eg., es-u-co-trad is Spanish with traditional
  	    // sorting). However, for storing names in fonts, the distinction
  	    // does not make sense, so we give â€œesâ€ in both cases.
  	    0x0C0A: 'es',
  	    0x040A: 'es',

  	    0x540A: 'es-US',
  	    0x380A: 'es-UY',
  	    0x200A: 'es-VE',
  	    0x081D: 'sv-FI',
  	    0x041D: 'sv',
  	    0x045A: 'syr',
  	    0x0428: 'tg',
  	    0x085F: 'tzm',
  	    0x0449: 'ta',
  	    0x0444: 'tt',
  	    0x044A: 'te',
  	    0x041E: 'th',
  	    0x0451: 'bo',
  	    0x041F: 'tr',
  	    0x0442: 'tk',
  	    0x0480: 'ug',
  	    0x0422: 'uk',
  	    0x042E: 'hsb',
  	    0x0420: 'ur',
  	    0x0843: 'uz-Cyrl',
  	    0x0443: 'uz',
  	    0x042A: 'vi',
  	    0x0452: 'cy',
  	    0x0488: 'wo',
  	    0x0485: 'sah',
  	    0x0478: 'ii',
  	    0x046A: 'yo'
  	};

  	// Returns a IETF BCP 47 language code, for example 'zh-Hant'
  	// for 'Chinese in the traditional script'.
  	function getLanguageCode(platformID, languageID, ltag) {
  	    switch (platformID) {
  	        case 0:  // Unicode
  	            if (languageID === 0xFFFF) {
  	                return 'und';
  	            } else if (ltag) {
  	                return ltag[languageID];
  	            }

  	            break;

  	        case 1:  // Macintosh
  	            return macLanguages[languageID];

  	        case 3:  // Windows
  	            return windowsLanguages[languageID];
  	    }

  	    return undefined;
  	}

  	var utf16 = 'utf-16';

  	// MacOS script ID â†’ encoding. This table stores the default case,
  	// which can be overridden by macLanguageEncodings.
  	var macScriptEncodings = {
  	    0: 'macintosh',           // smRoman
  	    1: 'x-mac-japanese',      // smJapanese
  	    2: 'x-mac-chinesetrad',   // smTradChinese
  	    3: 'x-mac-korean',        // smKorean
  	    6: 'x-mac-greek',         // smGreek
  	    7: 'x-mac-cyrillic',      // smCyrillic
  	    9: 'x-mac-devanagai',     // smDevanagari
  	    10: 'x-mac-gurmukhi',     // smGurmukhi
  	    11: 'x-mac-gujarati',     // smGujarati
  	    12: 'x-mac-oriya',        // smOriya
  	    13: 'x-mac-bengali',      // smBengali
  	    14: 'x-mac-tamil',        // smTamil
  	    15: 'x-mac-telugu',       // smTelugu
  	    16: 'x-mac-kannada',      // smKannada
  	    17: 'x-mac-malayalam',    // smMalayalam
  	    18: 'x-mac-sinhalese',    // smSinhalese
  	    19: 'x-mac-burmese',      // smBurmese
  	    20: 'x-mac-khmer',        // smKhmer
  	    21: 'x-mac-thai',         // smThai
  	    22: 'x-mac-lao',          // smLao
  	    23: 'x-mac-georgian',     // smGeorgian
  	    24: 'x-mac-armenian',     // smArmenian
  	    25: 'x-mac-chinesesimp',  // smSimpChinese
  	    26: 'x-mac-tibetan',      // smTibetan
  	    27: 'x-mac-mongolian',    // smMongolian
  	    28: 'x-mac-ethiopic',     // smEthiopic
  	    29: 'x-mac-ce',           // smCentralEuroRoman
  	    30: 'x-mac-vietnamese',   // smVietnamese
  	    31: 'x-mac-extarabic'     // smExtArabic
  	};

  	// MacOS language ID â†’ encoding. This table stores the exceptional
  	// cases, which override macScriptEncodings. For writing MacOS naming
  	// tables, we need to emit a MacOS script ID. Therefore, we cannot
  	// merge macScriptEncodings into macLanguageEncodings.
  	//
  	// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
  	var macLanguageEncodings = {
  	    15: 'x-mac-icelandic',    // langIcelandic
  	    17: 'x-mac-turkish',      // langTurkish
  	    18: 'x-mac-croatian',     // langCroatian
  	    24: 'x-mac-ce',           // langLithuanian
  	    25: 'x-mac-ce',           // langPolish
  	    26: 'x-mac-ce',           // langHungarian
  	    27: 'x-mac-ce',           // langEstonian
  	    28: 'x-mac-ce',           // langLatvian
  	    30: 'x-mac-icelandic',    // langFaroese
  	    37: 'x-mac-romanian',     // langRomanian
  	    38: 'x-mac-ce',           // langCzech
  	    39: 'x-mac-ce',           // langSlovak
  	    40: 'x-mac-ce',           // langSlovenian
  	    143: 'x-mac-inuit',       // langInuktitut
  	    146: 'x-mac-gaelic'       // langIrishGaelicScript
  	};

  	function getEncoding(platformID, encodingID, languageID) {
  	    switch (platformID) {
  	        case 0:  // Unicode
  	            return utf16;

  	        case 1:  // Apple Macintosh
  	            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

  	        case 3:  // Microsoft Windows
  	            if (encodingID === 1 || encodingID === 10) {
  	                return utf16;
  	            }

  	            break;
  	    }

  	    return undefined;
  	}

  	// Parse the naming `name` table.
  	// FIXME: Format 1 additional fields are not supported yet.
  	// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
  	function parseNameTable(data, start, ltag) {
  	    var name = {};
  	    var p = new parse.Parser(data, start);
  	    var format = p.parseUShort();
  	    var count = p.parseUShort();
  	    var stringOffset = p.offset + p.parseUShort();
  	    for (var i = 0; i < count; i++) {
  	        var platformID = p.parseUShort();
  	        var encodingID = p.parseUShort();
  	        var languageID = p.parseUShort();
  	        var nameID = p.parseUShort();
  	        var property = nameTableNames[nameID] || nameID;
  	        var byteLength = p.parseUShort();
  	        var offset = p.parseUShort();
  	        var language = getLanguageCode(platformID, languageID, ltag);
  	        var encoding = getEncoding(platformID, encodingID, languageID);
  	        if (encoding !== undefined && language !== undefined) {
  	            var text = (void 0);
  	            if (encoding === utf16) {
  	                text = decode.UTF16(data, stringOffset + offset, byteLength);
  	            } else {
  	                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
  	            }

  	            if (text) {
  	                var translations = name[property];
  	                if (translations === undefined) {
  	                    translations = name[property] = {};
  	                }

  	                translations[language] = text;
  	            }
  	        }
  	    }

  	    var langTagCount = 0;
  	    if (format === 1) {
  	        // FIXME: Also handle Microsoft's 'name' table 1.
  	        langTagCount = p.parseUShort();
  	    }

  	    return name;
  	}

  	// {23: 'foo'} â†’ {'foo': 23}
  	// ['bar', 'baz'] â†’ {'bar': 0, 'baz': 1}
  	function reverseDict(dict) {
  	    var result = {};
  	    for (var key in dict) {
  	        result[dict[key]] = parseInt(key);
  	    }

  	    return result;
  	}

  	function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
  	    return new table.Record('NameRecord', [
  	        {name: 'platformID', type: 'USHORT', value: platformID},
  	        {name: 'encodingID', type: 'USHORT', value: encodingID},
  	        {name: 'languageID', type: 'USHORT', value: languageID},
  	        {name: 'nameID', type: 'USHORT', value: nameID},
  	        {name: 'length', type: 'USHORT', value: length},
  	        {name: 'offset', type: 'USHORT', value: offset}
  	    ]);
  	}

  	// Finds the position of needle in haystack, or -1 if not there.
  	// Like String.indexOf(), but for arrays.
  	function findSubArray(needle, haystack) {
  	    var needleLength = needle.length;
  	    var limit = haystack.length - needleLength + 1;

  	    loop:
  	    for (var pos = 0; pos < limit; pos++) {
  	        for (; pos < limit; pos++) {
  	            for (var k = 0; k < needleLength; k++) {
  	                if (haystack[pos + k] !== needle[k]) {
  	                    continue loop;
  	                }
  	            }

  	            return pos;
  	        }
  	    }

  	    return -1;
  	}

  	function addStringToPool(s, pool) {
  	    var offset = findSubArray(s, pool);
  	    if (offset < 0) {
  	        offset = pool.length;
  	        var i = 0;
  	        var len = s.length;
  	        for (; i < len; ++i) {
  	            pool.push(s[i]);
  	        }

  	    }

  	    return offset;
  	}

  	function makeNameTable(names, ltag) {
  	    var nameID;
  	    var nameIDs = [];

  	    var namesWithNumericKeys = {};
  	    var nameTableIds = reverseDict(nameTableNames);
  	    for (var key in names) {
  	        var id = nameTableIds[key];
  	        if (id === undefined) {
  	            id = key;
  	        }

  	        nameID = parseInt(id);

  	        if (isNaN(nameID)) {
  	            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
  	        }

  	        namesWithNumericKeys[nameID] = names[key];
  	        nameIDs.push(nameID);
  	    }

  	    var macLanguageIds = reverseDict(macLanguages);
  	    var windowsLanguageIds = reverseDict(windowsLanguages);

  	    var nameRecords = [];
  	    var stringPool = [];

  	    for (var i = 0; i < nameIDs.length; i++) {
  	        nameID = nameIDs[i];
  	        var translations = namesWithNumericKeys[nameID];
  	        for (var lang in translations) {
  	            var text = translations[lang];

  	            // For MacOS, we try to emit the name in the form that was introduced
  	            // in the initial version of the TrueType spec (in the late 1980s).
  	            // However, this can fail for various reasons: the requested BCP 47
  	            // language code might not have an old-style Mac equivalent;
  	            // we might not have a codec for the needed character encoding;
  	            // or the name might contain characters that cannot be expressed
  	            // in the old-style Macintosh encoding. In case of failure, we emit
  	            // the name in a more modern fashion (Unicode encoding with BCP 47
  	            // language tags) that is recognized by MacOS 10.5, released in 2009.
  	            // If fonts were only read by operating systems, we could simply
  	            // emit all names in the modern form; this would be much easier.
  	            // However, there are many applications and libraries that read
  	            // 'name' tables directly, and these will usually only recognize
  	            // the ancient form (silently skipping the unrecognized names).
  	            var macPlatform = 1;  // Macintosh
  	            var macLanguage = macLanguageIds[lang];
  	            var macScript = macLanguageToScript[macLanguage];
  	            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
  	            var macName = encode.MACSTRING(text, macEncoding);
  	            if (macName === undefined) {
  	                macPlatform = 0;  // Unicode
  	                macLanguage = ltag.indexOf(lang);
  	                if (macLanguage < 0) {
  	                    macLanguage = ltag.length;
  	                    ltag.push(lang);
  	                }

  	                macScript = 4;  // Unicode 2.0 and later
  	                macName = encode.UTF16(text);
  	            }

  	            var macNameOffset = addStringToPool(macName, stringPool);
  	            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
  	                                            nameID, macName.length, macNameOffset));

  	            var winLanguage = windowsLanguageIds[lang];
  	            if (winLanguage !== undefined) {
  	                var winName = encode.UTF16(text);
  	                var winNameOffset = addStringToPool(winName, stringPool);
  	                nameRecords.push(makeNameRecord(3, 1, winLanguage,
  	                                                nameID, winName.length, winNameOffset));
  	            }
  	        }
  	    }

  	    nameRecords.sort(function(a, b) {
  	        return ((a.platformID - b.platformID) ||
  	                (a.encodingID - b.encodingID) ||
  	                (a.languageID - b.languageID) ||
  	                (a.nameID - b.nameID));
  	    });

  	    var t = new table.Table('name', [
  	        {name: 'format', type: 'USHORT', value: 0},
  	        {name: 'count', type: 'USHORT', value: nameRecords.length},
  	        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
  	    ]);

  	    for (var r = 0; r < nameRecords.length; r++) {
  	        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
  	    }

  	    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
  	    return t;
  	}

  	var _name = { parse: parseNameTable, make: makeNameTable };

  	// The `OS/2` table contains metrics required in OpenType fonts.

  	var unicodeRanges = [
  	    {begin: 0x0000, end: 0x007F}, // Basic Latin
  	    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
  	    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
  	    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
  	    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
  	    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
  	    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
  	    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
  	    {begin: 0x2C80, end: 0x2CFF}, // Coptic
  	    {begin: 0x0400, end: 0x04FF}, // Cyrillic
  	    {begin: 0x0530, end: 0x058F}, // Armenian
  	    {begin: 0x0590, end: 0x05FF}, // Hebrew
  	    {begin: 0xA500, end: 0xA63F}, // Vai
  	    {begin: 0x0600, end: 0x06FF}, // Arabic
  	    {begin: 0x07C0, end: 0x07FF}, // NKo
  	    {begin: 0x0900, end: 0x097F}, // Devanagari
  	    {begin: 0x0980, end: 0x09FF}, // Bengali
  	    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
  	    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
  	    {begin: 0x0B00, end: 0x0B7F}, // Oriya
  	    {begin: 0x0B80, end: 0x0BFF}, // Tamil
  	    {begin: 0x0C00, end: 0x0C7F}, // Telugu
  	    {begin: 0x0C80, end: 0x0CFF}, // Kannada
  	    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
  	    {begin: 0x0E00, end: 0x0E7F}, // Thai
  	    {begin: 0x0E80, end: 0x0EFF}, // Lao
  	    {begin: 0x10A0, end: 0x10FF}, // Georgian
  	    {begin: 0x1B00, end: 0x1B7F}, // Balinese
  	    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
  	    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
  	    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
  	    {begin: 0x2000, end: 0x206F}, // General Punctuation
  	    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
  	    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
  	    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
  	    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
  	    {begin: 0x2150, end: 0x218F}, // Number Forms
  	    {begin: 0x2190, end: 0x21FF}, // Arrows
  	    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
  	    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
  	    {begin: 0x2400, end: 0x243F}, // Control Pictures
  	    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
  	    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
  	    {begin: 0x2500, end: 0x257F}, // Box Drawing
  	    {begin: 0x2580, end: 0x259F}, // Block Elements
  	    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
  	    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
  	    {begin: 0x2700, end: 0x27BF}, // Dingbats
  	    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
  	    {begin: 0x3040, end: 0x309F}, // Hiragana
  	    {begin: 0x30A0, end: 0x30FF}, // Katakana
  	    {begin: 0x3100, end: 0x312F}, // Bopomofo
  	    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
  	    {begin: 0xA840, end: 0xA87F}, // Phags-pa
  	    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
  	    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
  	    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
  	    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
  	    {begin: 0x10900, end: 0x1091F}, // Phoenicia
  	    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
  	    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
  	    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
  	    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
  	    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
  	    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
  	    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
  	    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
  	    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
  	    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
  	    {begin: 0xFFF0, end: 0xFFFF}, // Specials
  	    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
  	    {begin: 0x0700, end: 0x074F}, // Syriac
  	    {begin: 0x0780, end: 0x07BF}, // Thaana
  	    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
  	    {begin: 0x1000, end: 0x109F}, // Myanmar
  	    {begin: 0x1200, end: 0x137F}, // Ethiopic
  	    {begin: 0x13A0, end: 0x13FF}, // Cherokee
  	    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
  	    {begin: 0x1680, end: 0x169F}, // Ogham
  	    {begin: 0x16A0, end: 0x16FF}, // Runic
  	    {begin: 0x1780, end: 0x17FF}, // Khmer
  	    {begin: 0x1800, end: 0x18AF}, // Mongolian
  	    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
  	    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
  	    {begin: 0x1700, end: 0x171F}, // Tagalog
  	    {begin: 0x10300, end: 0x1032F}, // Old Italic
  	    {begin: 0x10330, end: 0x1034F}, // Gothic
  	    {begin: 0x10400, end: 0x1044F}, // Deseret
  	    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
  	    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
  	    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
  	    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
  	    {begin: 0xE0000, end: 0xE007F}, // Tags
  	    {begin: 0x1900, end: 0x194F}, // Limbu
  	    {begin: 0x1950, end: 0x197F}, // Tai Le
  	    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
  	    {begin: 0x1A00, end: 0x1A1F}, // Buginese
  	    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
  	    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
  	    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
  	    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
  	    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
  	    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
  	    {begin: 0x10380, end: 0x1039F}, // Ugaritic
  	    {begin: 0x103A0, end: 0x103DF}, // Old Persian
  	    {begin: 0x10450, end: 0x1047F}, // Shavian
  	    {begin: 0x10480, end: 0x104AF}, // Osmanya
  	    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
  	    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
  	    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
  	    {begin: 0x12000, end: 0x123FF}, // Cuneiform
  	    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
  	    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
  	    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
  	    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
  	    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
  	    {begin: 0xA900, end: 0xA92F}, // Kayah Li
  	    {begin: 0xA930, end: 0xA95F}, // Rejang
  	    {begin: 0xAA00, end: 0xAA5F}, // Cham
  	    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
  	    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
  	    {begin: 0x102A0, end: 0x102DF}, // Carian
  	    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
  	];

  	function getUnicodeRange(unicode) {
  	    for (var i = 0; i < unicodeRanges.length; i += 1) {
  	        var range = unicodeRanges[i];
  	        if (unicode >= range.begin && unicode < range.end) {
  	            return i;
  	        }
  	    }

  	    return -1;
  	}

  	// Parse the OS/2 and Windows metrics `OS/2` table
  	function parseOS2Table(data, start) {
  	    var os2 = {};
  	    var p = new parse.Parser(data, start);
  	    os2.version = p.parseUShort();
  	    os2.xAvgCharWidth = p.parseShort();
  	    os2.usWeightClass = p.parseUShort();
  	    os2.usWidthClass = p.parseUShort();
  	    os2.fsType = p.parseUShort();
  	    os2.ySubscriptXSize = p.parseShort();
  	    os2.ySubscriptYSize = p.parseShort();
  	    os2.ySubscriptXOffset = p.parseShort();
  	    os2.ySubscriptYOffset = p.parseShort();
  	    os2.ySuperscriptXSize = p.parseShort();
  	    os2.ySuperscriptYSize = p.parseShort();
  	    os2.ySuperscriptXOffset = p.parseShort();
  	    os2.ySuperscriptYOffset = p.parseShort();
  	    os2.yStrikeoutSize = p.parseShort();
  	    os2.yStrikeoutPosition = p.parseShort();
  	    os2.sFamilyClass = p.parseShort();
  	    os2.panose = [];
  	    for (var i = 0; i < 10; i++) {
  	        os2.panose[i] = p.parseByte();
  	    }

  	    os2.ulUnicodeRange1 = p.parseULong();
  	    os2.ulUnicodeRange2 = p.parseULong();
  	    os2.ulUnicodeRange3 = p.parseULong();
  	    os2.ulUnicodeRange4 = p.parseULong();
  	    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
  	    os2.fsSelection = p.parseUShort();
  	    os2.usFirstCharIndex = p.parseUShort();
  	    os2.usLastCharIndex = p.parseUShort();
  	    os2.sTypoAscender = p.parseShort();
  	    os2.sTypoDescender = p.parseShort();
  	    os2.sTypoLineGap = p.parseShort();
  	    os2.usWinAscent = p.parseUShort();
  	    os2.usWinDescent = p.parseUShort();
  	    if (os2.version >= 1) {
  	        os2.ulCodePageRange1 = p.parseULong();
  	        os2.ulCodePageRange2 = p.parseULong();
  	    }

  	    if (os2.version >= 2) {
  	        os2.sxHeight = p.parseShort();
  	        os2.sCapHeight = p.parseShort();
  	        os2.usDefaultChar = p.parseUShort();
  	        os2.usBreakChar = p.parseUShort();
  	        os2.usMaxContent = p.parseUShort();
  	    }

  	    return os2;
  	}

  	function makeOS2Table(options) {
  	    return new table.Table('OS/2', [
  	        {name: 'version', type: 'USHORT', value: 0x0003},
  	        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
  	        {name: 'usWeightClass', type: 'USHORT', value: 0},
  	        {name: 'usWidthClass', type: 'USHORT', value: 0},
  	        {name: 'fsType', type: 'USHORT', value: 0},
  	        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
  	        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
  	        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
  	        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
  	        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
  	        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
  	        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
  	        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
  	        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
  	        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
  	        {name: 'sFamilyClass', type: 'SHORT', value: 0},
  	        {name: 'bFamilyType', type: 'BYTE', value: 0},
  	        {name: 'bSerifStyle', type: 'BYTE', value: 0},
  	        {name: 'bWeight', type: 'BYTE', value: 0},
  	        {name: 'bProportion', type: 'BYTE', value: 0},
  	        {name: 'bContrast', type: 'BYTE', value: 0},
  	        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
  	        {name: 'bArmStyle', type: 'BYTE', value: 0},
  	        {name: 'bLetterform', type: 'BYTE', value: 0},
  	        {name: 'bMidline', type: 'BYTE', value: 0},
  	        {name: 'bXHeight', type: 'BYTE', value: 0},
  	        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
  	        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
  	        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
  	        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
  	        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
  	        {name: 'fsSelection', type: 'USHORT', value: 0},
  	        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
  	        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
  	        {name: 'sTypoAscender', type: 'SHORT', value: 0},
  	        {name: 'sTypoDescender', type: 'SHORT', value: 0},
  	        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
  	        {name: 'usWinAscent', type: 'USHORT', value: 0},
  	        {name: 'usWinDescent', type: 'USHORT', value: 0},
  	        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
  	        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
  	        {name: 'sxHeight', type: 'SHORT', value: 0},
  	        {name: 'sCapHeight', type: 'SHORT', value: 0},
  	        {name: 'usDefaultChar', type: 'USHORT', value: 0},
  	        {name: 'usBreakChar', type: 'USHORT', value: 0},
  	        {name: 'usMaxContext', type: 'USHORT', value: 0}
  	    ], options);
  	}

  	var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

  	// The `post` table stores additional PostScript information, such as glyph names.

  	// Parse the PostScript `post` table
  	function parsePostTable(data, start) {
  	    var post = {};
  	    var p = new parse.Parser(data, start);
  	    post.version = p.parseVersion();
  	    post.italicAngle = p.parseFixed();
  	    post.underlinePosition = p.parseShort();
  	    post.underlineThickness = p.parseShort();
  	    post.isFixedPitch = p.parseULong();
  	    post.minMemType42 = p.parseULong();
  	    post.maxMemType42 = p.parseULong();
  	    post.minMemType1 = p.parseULong();
  	    post.maxMemType1 = p.parseULong();
  	    switch (post.version) {
  	        case 1:
  	            post.names = standardNames.slice();
  	            break;
  	        case 2:
  	            post.numberOfGlyphs = p.parseUShort();
  	            post.glyphNameIndex = new Array(post.numberOfGlyphs);
  	            for (var i = 0; i < post.numberOfGlyphs; i++) {
  	                post.glyphNameIndex[i] = p.parseUShort();
  	            }

  	            post.names = [];
  	            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
  	                if (post.glyphNameIndex[i$1] >= standardNames.length) {
  	                    var nameLength = p.parseChar();
  	                    post.names.push(p.parseString(nameLength));
  	                }
  	            }

  	            break;
  	        case 2.5:
  	            post.numberOfGlyphs = p.parseUShort();
  	            post.offset = new Array(post.numberOfGlyphs);
  	            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
  	                post.offset[i$2] = p.parseChar();
  	            }

  	            break;
  	    }
  	    return post;
  	}

  	function makePostTable() {
  	    return new table.Table('post', [
  	        {name: 'version', type: 'FIXED', value: 0x00030000},
  	        {name: 'italicAngle', type: 'FIXED', value: 0},
  	        {name: 'underlinePosition', type: 'FWORD', value: 0},
  	        {name: 'underlineThickness', type: 'FWORD', value: 0},
  	        {name: 'isFixedPitch', type: 'ULONG', value: 0},
  	        {name: 'minMemType42', type: 'ULONG', value: 0},
  	        {name: 'maxMemType42', type: 'ULONG', value: 0},
  	        {name: 'minMemType1', type: 'ULONG', value: 0},
  	        {name: 'maxMemType1', type: 'ULONG', value: 0}
  	    ]);
  	}

  	var post = { parse: parsePostTable, make: makePostTable };

  	// The `GSUB` table contains ligatures, among other things.

  	var subtableParsers = new Array(9);         // subtableParsers[0] is unused

  	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
  	subtableParsers[1] = function parseLookup1() {
  	    var start = this.offset + this.relativeOffset;
  	    var substFormat = this.parseUShort();
  	    if (substFormat === 1) {
  	        return {
  	            substFormat: 1,
  	            coverage: this.parsePointer(Parser.coverage),
  	            deltaGlyphId: this.parseUShort()
  	        };
  	    } else if (substFormat === 2) {
  	        return {
  	            substFormat: 2,
  	            coverage: this.parsePointer(Parser.coverage),
  	            substitute: this.parseOffset16List()
  	        };
  	    }
  	    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
  	};

  	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
  	subtableParsers[2] = function parseLookup2() {
  	    var substFormat = this.parseUShort();
  	    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
  	    return {
  	        substFormat: substFormat,
  	        coverage: this.parsePointer(Parser.coverage),
  	        sequences: this.parseListOfLists()
  	    };
  	};

  	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
  	subtableParsers[3] = function parseLookup3() {
  	    var substFormat = this.parseUShort();
  	    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
  	    return {
  	        substFormat: substFormat,
  	        coverage: this.parsePointer(Parser.coverage),
  	        alternateSets: this.parseListOfLists()
  	    };
  	};

  	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
  	subtableParsers[4] = function parseLookup4() {
  	    var substFormat = this.parseUShort();
  	    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
  	    return {
  	        substFormat: substFormat,
  	        coverage: this.parsePointer(Parser.coverage),
  	        ligatureSets: this.parseListOfLists(function() {
  	            return {
  	                ligGlyph: this.parseUShort(),
  	                components: this.parseUShortList(this.parseUShort() - 1)
  	            };
  	        })
  	    };
  	};

  	var lookupRecordDesc = {
  	    sequenceIndex: Parser.uShort,
  	    lookupListIndex: Parser.uShort
  	};

  	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
  	subtableParsers[5] = function parseLookup5() {
  	    var start = this.offset + this.relativeOffset;
  	    var substFormat = this.parseUShort();

  	    if (substFormat === 1) {
  	        return {
  	            substFormat: substFormat,
  	            coverage: this.parsePointer(Parser.coverage),
  	            ruleSets: this.parseListOfLists(function() {
  	                var glyphCount = this.parseUShort();
  	                var substCount = this.parseUShort();
  	                return {
  	                    input: this.parseUShortList(glyphCount - 1),
  	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
  	                };
  	            })
  	        };
  	    } else if (substFormat === 2) {
  	        return {
  	            substFormat: substFormat,
  	            coverage: this.parsePointer(Parser.coverage),
  	            classDef: this.parsePointer(Parser.classDef),
  	            classSets: this.parseListOfLists(function() {
  	                var glyphCount = this.parseUShort();
  	                var substCount = this.parseUShort();
  	                return {
  	                    classes: this.parseUShortList(glyphCount - 1),
  	                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
  	                };
  	            })
  	        };
  	    } else if (substFormat === 3) {
  	        var glyphCount = this.parseUShort();
  	        var substCount = this.parseUShort();
  	        return {
  	            substFormat: substFormat,
  	            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
  	            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
  	        };
  	    }
  	    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
  	};

  	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
  	subtableParsers[6] = function parseLookup6() {
  	    var start = this.offset + this.relativeOffset;
  	    var substFormat = this.parseUShort();
  	    if (substFormat === 1) {
  	        return {
  	            substFormat: 1,
  	            coverage: this.parsePointer(Parser.coverage),
  	            chainRuleSets: this.parseListOfLists(function() {
  	                return {
  	                    backtrack: this.parseUShortList(),
  	                    input: this.parseUShortList(this.parseShort() - 1),
  	                    lookahead: this.parseUShortList(),
  	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
  	                };
  	            })
  	        };
  	    } else if (substFormat === 2) {
  	        return {
  	            substFormat: 2,
  	            coverage: this.parsePointer(Parser.coverage),
  	            backtrackClassDef: this.parsePointer(Parser.classDef),
  	            inputClassDef: this.parsePointer(Parser.classDef),
  	            lookaheadClassDef: this.parsePointer(Parser.classDef),
  	            chainClassSet: this.parseListOfLists(function() {
  	                return {
  	                    backtrack: this.parseUShortList(),
  	                    input: this.parseUShortList(this.parseShort() - 1),
  	                    lookahead: this.parseUShortList(),
  	                    lookupRecords: this.parseRecordList(lookupRecordDesc)
  	                };
  	            })
  	        };
  	    } else if (substFormat === 3) {
  	        return {
  	            substFormat: 3,
  	            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
  	            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
  	            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
  	            lookupRecords: this.parseRecordList(lookupRecordDesc)
  	        };
  	    }
  	    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
  	};

  	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
  	subtableParsers[7] = function parseLookup7() {
  	    // Extension Substitution subtable
  	    var substFormat = this.parseUShort();
  	    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
  	    var extensionLookupType = this.parseUShort();
  	    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
  	    return {
  	        substFormat: 1,
  	        lookupType: extensionLookupType,
  	        extension: subtableParsers[extensionLookupType].call(extensionParser)
  	    };
  	};

  	// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
  	subtableParsers[8] = function parseLookup8() {
  	    var substFormat = this.parseUShort();
  	    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
  	    return {
  	        substFormat: substFormat,
  	        coverage: this.parsePointer(Parser.coverage),
  	        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
  	        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
  	        substitutes: this.parseUShortList()
  	    };
  	};

  	// https://www.microsoft.com/typography/OTSPEC/gsub.htm
  	function parseGsubTable(data, start) {
  	    start = start || 0;
  	    var p = new Parser(data, start);
  	    var tableVersion = p.parseVersion(1);
  	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
  	    if (tableVersion === 1) {
  	        return {
  	            version: tableVersion,
  	            scripts: p.parseScriptList(),
  	            features: p.parseFeatureList(),
  	            lookups: p.parseLookupList(subtableParsers)
  	        };
  	    } else {
  	        return {
  	            version: tableVersion,
  	            scripts: p.parseScriptList(),
  	            features: p.parseFeatureList(),
  	            lookups: p.parseLookupList(subtableParsers),
  	            variations: p.parseFeatureVariationsList()
  	        };
  	    }

  	}

  	// GSUB Writing //////////////////////////////////////////////
  	var subtableMakers = new Array(9);

  	subtableMakers[1] = function makeLookup1(subtable) {
  	    if (subtable.substFormat === 1) {
  	        return new table.Table('substitutionTable', [
  	            {name: 'substFormat', type: 'USHORT', value: 1},
  	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
  	            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
  	        ]);
  	    } else {
  	        return new table.Table('substitutionTable', [
  	            {name: 'substFormat', type: 'USHORT', value: 2},
  	            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
  	        ].concat(table.ushortList('substitute', subtable.substitute)));
  	    }
  	};

  	subtableMakers[3] = function makeLookup3(subtable) {
  	    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
  	    return new table.Table('substitutionTable', [
  	        {name: 'substFormat', type: 'USHORT', value: 1},
  	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
  	    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
  	        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
  	    })));
  	};

  	subtableMakers[4] = function makeLookup4(subtable) {
  	    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
  	    return new table.Table('substitutionTable', [
  	        {name: 'substFormat', type: 'USHORT', value: 1},
  	        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
  	    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
  	        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
  	            return new table.Table('ligatureTable',
  	                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
  	                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
  	            );
  	        }));
  	    })));
  	};

  	function makeGsubTable(gsub) {
  	    return new table.Table('GSUB', [
  	        {name: 'version', type: 'ULONG', value: 0x10000},
  	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
  	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
  	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
  	    ]);
  	}

  	var gsub = { parse: parseGsubTable, make: makeGsubTable };

  	// The `GPOS` table contains kerning pairs, among other things.

  	// Parse the metadata `meta` table.
  	// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
  	function parseMetaTable(data, start) {
  	    var p = new parse.Parser(data, start);
  	    var tableVersion = p.parseULong();
  	    check.argument(tableVersion === 1, 'Unsupported META table version.');
  	    p.parseULong(); // flags - currently unused and set to 0
  	    p.parseULong(); // tableOffset
  	    var numDataMaps = p.parseULong();

  	    var tags = {};
  	    for (var i = 0; i < numDataMaps; i++) {
  	        var tag = p.parseTag();
  	        var dataOffset = p.parseULong();
  	        var dataLength = p.parseULong();
  	        var text = decode.UTF8(data, start + dataOffset, dataLength);

  	        tags[tag] = text;
  	    }
  	    return tags;
  	}

  	function makeMetaTable(tags) {
  	    var numTags = Object.keys(tags).length;
  	    var stringPool = '';
  	    var stringPoolOffset = 16 + numTags * 12;

  	    var result = new table.Table('meta', [
  	        {name: 'version', type: 'ULONG', value: 1},
  	        {name: 'flags', type: 'ULONG', value: 0},
  	        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
  	        {name: 'numTags', type: 'ULONG', value: numTags}
  	    ]);

  	    for (var tag in tags) {
  	        var pos = stringPool.length;
  	        stringPool += tags[tag];

  	        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
  	        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
  	        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
  	    }

  	    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

  	    return result;
  	}

  	var meta = { parse: parseMetaTable, make: makeMetaTable };

  	// The `sfnt` wrapper provides organization for the tables in the font.

  	function log2(v) {
  	    return Math.log(v) / Math.log(2) | 0;
  	}

  	function computeCheckSum(bytes) {
  	    while (bytes.length % 4 !== 0) {
  	        bytes.push(0);
  	    }

  	    var sum = 0;
  	    for (var i = 0; i < bytes.length; i += 4) {
  	        sum += (bytes[i] << 24) +
  	            (bytes[i + 1] << 16) +
  	            (bytes[i + 2] << 8) +
  	            (bytes[i + 3]);
  	    }

  	    sum %= Math.pow(2, 32);
  	    return sum;
  	}

  	function makeTableRecord(tag, checkSum, offset, length) {
  	    return new table.Record('Table Record', [
  	        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
  	        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
  	        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
  	        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
  	    ]);
  	}

  	function makeSfntTable(tables) {
  	    var sfnt = new table.Table('sfnt', [
  	        {name: 'version', type: 'TAG', value: 'OTTO'},
  	        {name: 'numTables', type: 'USHORT', value: 0},
  	        {name: 'searchRange', type: 'USHORT', value: 0},
  	        {name: 'entrySelector', type: 'USHORT', value: 0},
  	        {name: 'rangeShift', type: 'USHORT', value: 0}
  	    ]);
  	    sfnt.tables = tables;
  	    sfnt.numTables = tables.length;
  	    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
  	    sfnt.searchRange = 16 * highestPowerOf2;
  	    sfnt.entrySelector = log2(highestPowerOf2);
  	    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

  	    var recordFields = [];
  	    var tableFields = [];

  	    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
  	    while (offset % 4 !== 0) {
  	        offset += 1;
  	        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
  	    }

  	    for (var i = 0; i < tables.length; i += 1) {
  	        var t = tables[i];
  	        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
  	        var tableLength = t.sizeOf();
  	        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
  	        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
  	        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
  	        offset += tableLength;
  	        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
  	        while (offset % 4 !== 0) {
  	            offset += 1;
  	            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
  	        }
  	    }

  	    // Table records need to be sorted alphabetically.
  	    recordFields.sort(function(r1, r2) {
  	        if (r1.value.tag > r2.value.tag) {
  	            return 1;
  	        } else {
  	            return -1;
  	        }
  	    });

  	    sfnt.fields = sfnt.fields.concat(recordFields);
  	    sfnt.fields = sfnt.fields.concat(tableFields);
  	    return sfnt;
  	}

  	// Get the metrics for a character. If the string has more than one character
  	// this function returns metrics for the first available character.
  	// You can provide optional fallback metrics if no characters are available.
  	function metricsForChar(font, chars, notFoundMetrics) {
  	    for (var i = 0; i < chars.length; i += 1) {
  	        var glyphIndex = font.charToGlyphIndex(chars[i]);
  	        if (glyphIndex > 0) {
  	            var glyph = font.glyphs.get(glyphIndex);
  	            return glyph.getMetrics();
  	        }
  	    }

  	    return notFoundMetrics;
  	}

  	function average(vs) {
  	    var sum = 0;
  	    for (var i = 0; i < vs.length; i += 1) {
  	        sum += vs[i];
  	    }

  	    return sum / vs.length;
  	}

  	// Convert the font object to a SFNT data structure.
  	// This structure contains all the necessary tables and metadata to create a binary OTF file.
  	function fontToSfntTable(font) {
  	    var xMins = [];
  	    var yMins = [];
  	    var xMaxs = [];
  	    var yMaxs = [];
  	    var advanceWidths = [];
  	    var leftSideBearings = [];
  	    var rightSideBearings = [];
  	    var firstCharIndex;
  	    var lastCharIndex = 0;
  	    var ulUnicodeRange1 = 0;
  	    var ulUnicodeRange2 = 0;
  	    var ulUnicodeRange3 = 0;
  	    var ulUnicodeRange4 = 0;

  	    for (var i = 0; i < font.glyphs.length; i += 1) {
  	        var glyph = font.glyphs.get(i);
  	        var unicode = glyph.unicode | 0;

  	        if (isNaN(glyph.advanceWidth)) {
  	            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
  	        }

  	        if (firstCharIndex > unicode || firstCharIndex === undefined) {
  	            // ignore .notdef char
  	            if (unicode > 0) {
  	                firstCharIndex = unicode;
  	            }
  	        }

  	        if (lastCharIndex < unicode) {
  	            lastCharIndex = unicode;
  	        }

  	        var position = os2.getUnicodeRange(unicode);
  	        if (position < 32) {
  	            ulUnicodeRange1 |= 1 << position;
  	        } else if (position < 64) {
  	            ulUnicodeRange2 |= 1 << position - 32;
  	        } else if (position < 96) {
  	            ulUnicodeRange3 |= 1 << position - 64;
  	        } else if (position < 123) {
  	            ulUnicodeRange4 |= 1 << position - 96;
  	        } else {
  	            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
  	        }
  	        // Skip non-important characters.
  	        if (glyph.name === '.notdef') { continue; }
  	        var metrics = glyph.getMetrics();
  	        xMins.push(metrics.xMin);
  	        yMins.push(metrics.yMin);
  	        xMaxs.push(metrics.xMax);
  	        yMaxs.push(metrics.yMax);
  	        leftSideBearings.push(metrics.leftSideBearing);
  	        rightSideBearings.push(metrics.rightSideBearing);
  	        advanceWidths.push(glyph.advanceWidth);
  	    }

  	    var globals = {
  	        xMin: Math.min.apply(null, xMins),
  	        yMin: Math.min.apply(null, yMins),
  	        xMax: Math.max.apply(null, xMaxs),
  	        yMax: Math.max.apply(null, yMaxs),
  	        advanceWidthMax: Math.max.apply(null, advanceWidths),
  	        advanceWidthAvg: average(advanceWidths),
  	        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
  	        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
  	        minRightSideBearing: Math.min.apply(null, rightSideBearings)
  	    };
  	    globals.ascender = font.ascender;
  	    globals.descender = font.descender;

  	    var headTable = head.make({
  	        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
  	        unitsPerEm: font.unitsPerEm,
  	        xMin: globals.xMin,
  	        yMin: globals.yMin,
  	        xMax: globals.xMax,
  	        yMax: globals.yMax,
  	        lowestRecPPEM: 3,
  	        createdTimestamp: font.createdTimestamp
  	    });

  	    var hheaTable = hhea.make({
  	        ascender: globals.ascender,
  	        descender: globals.descender,
  	        advanceWidthMax: globals.advanceWidthMax,
  	        minLeftSideBearing: globals.minLeftSideBearing,
  	        minRightSideBearing: globals.minRightSideBearing,
  	        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
  	        numberOfHMetrics: font.glyphs.length
  	    });

  	    var maxpTable = maxp.make(font.glyphs.length);

  	    var os2Table = os2.make({
  	        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
  	        usWeightClass: font.tables.os2.usWeightClass,
  	        usWidthClass: font.tables.os2.usWidthClass,
  	        usFirstCharIndex: firstCharIndex,
  	        usLastCharIndex: lastCharIndex,
  	        ulUnicodeRange1: ulUnicodeRange1,
  	        ulUnicodeRange2: ulUnicodeRange2,
  	        ulUnicodeRange3: ulUnicodeRange3,
  	        ulUnicodeRange4: ulUnicodeRange4,
  	        fsSelection: font.tables.os2.fsSelection, // REGULAR
  	        // See http://typophile.com/node/13081 for more info on vertical metrics.
  	        // We get metrics for typical characters (such as "x" for xHeight).
  	        // We provide some fallback characters if characters are unavailable: their
  	        // ordering was chosen experimentally.
  	        sTypoAscender: globals.ascender,
  	        sTypoDescender: globals.descender,
  	        sTypoLineGap: 0,
  	        usWinAscent: globals.yMax,
  	        usWinDescent: Math.abs(globals.yMin),
  	        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
  	        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
  	        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
  	        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
  	        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
  	    });

  	    var hmtxTable = hmtx.make(font.glyphs);
  	    var cmapTable = cmap.make(font.glyphs);

  	    var englishFamilyName = font.getEnglishName('fontFamily');
  	    var englishStyleName = font.getEnglishName('fontSubfamily');
  	    var englishFullName = englishFamilyName + ' ' + englishStyleName;
  	    var postScriptName = font.getEnglishName('postScriptName');
  	    if (!postScriptName) {
  	        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
  	    }

  	    var names = {};
  	    for (var n in font.names) {
  	        names[n] = font.names[n];
  	    }

  	    if (!names.uniqueID) {
  	        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
  	    }

  	    if (!names.postScriptName) {
  	        names.postScriptName = {en: postScriptName};
  	    }

  	    if (!names.preferredFamily) {
  	        names.preferredFamily = font.names.fontFamily;
  	    }

  	    if (!names.preferredSubfamily) {
  	        names.preferredSubfamily = font.names.fontSubfamily;
  	    }

  	    var languageTags = [];
  	    var nameTable = _name.make(names, languageTags);
  	    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

  	    var postTable = post.make();
  	    var cffTable = cff.make(font.glyphs, {
  	        version: font.getEnglishName('version'),
  	        fullName: englishFullName,
  	        familyName: englishFamilyName,
  	        weightName: englishStyleName,
  	        postScriptName: postScriptName,
  	        unitsPerEm: font.unitsPerEm,
  	        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
  	    });

  	    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

  	    // The order does not matter because makeSfntTable() will sort them.
  	    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
  	    if (ltagTable) {
  	        tables.push(ltagTable);
  	    }
  	    // Optional tables
  	    if (font.tables.gsub) {
  	        tables.push(gsub.make(font.tables.gsub));
  	    }
  	    if (metaTable) {
  	        tables.push(metaTable);
  	    }

  	    var sfntTable = makeSfntTable(tables);

  	    // Compute the font's checkSum and store it in head.checkSumAdjustment.
  	    var bytes = sfntTable.encode();
  	    var checkSum = computeCheckSum(bytes);
  	    var tableFields = sfntTable.fields;
  	    var checkSumAdjusted = false;
  	    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
  	        if (tableFields[i$1].name === 'head table') {
  	            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
  	            checkSumAdjusted = true;
  	            break;
  	        }
  	    }

  	    if (!checkSumAdjusted) {
  	        throw new Error('Could not find head table with checkSum to adjust.');
  	    }

  	    return sfntTable;
  	}

  	var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

  	// The Layout object is the prototype of Substitution objects, and provides

  	function searchTag(arr, tag) {
  	    /* jshint bitwise: false */
  	    var imin = 0;
  	    var imax = arr.length - 1;
  	    while (imin <= imax) {
  	        var imid = (imin + imax) >>> 1;
  	        var val = arr[imid].tag;
  	        if (val === tag) {
  	            return imid;
  	        } else if (val < tag) {
  	            imin = imid + 1;
  	        } else { imax = imid - 1; }
  	    }
  	    // Not found: return -1-insertion point
  	    return -imin - 1;
  	}

  	function binSearch(arr, value) {
  	    /* jshint bitwise: false */
  	    var imin = 0;
  	    var imax = arr.length - 1;
  	    while (imin <= imax) {
  	        var imid = (imin + imax) >>> 1;
  	        var val = arr[imid];
  	        if (val === value) {
  	            return imid;
  	        } else if (val < value) {
  	            imin = imid + 1;
  	        } else { imax = imid - 1; }
  	    }
  	    // Not found: return -1-insertion point
  	    return -imin - 1;
  	}

  	// binary search in a list of ranges (coverage, class definition)
  	function searchRange(ranges, value) {
  	    // jshint bitwise: false
  	    var range;
  	    var imin = 0;
  	    var imax = ranges.length - 1;
  	    while (imin <= imax) {
  	        var imid = (imin + imax) >>> 1;
  	        range = ranges[imid];
  	        var start = range.start;
  	        if (start === value) {
  	            return range;
  	        } else if (start < value) {
  	            imin = imid + 1;
  	        } else { imax = imid - 1; }
  	    }
  	    if (imin > 0) {
  	        range = ranges[imin - 1];
  	        if (value > range.end) { return 0; }
  	        return range;
  	    }
  	}

  	/**
  	 * @exports opentype.Layout
  	 * @class
  	 */
  	function Layout(font, tableName) {
  	    this.font = font;
  	    this.tableName = tableName;
  	}

  	Layout.prototype = {

  	    /**
  	     * Binary search an object by "tag" property
  	     * @instance
  	     * @function searchTag
  	     * @memberof opentype.Layout
  	     * @param  {Array} arr
  	     * @param  {string} tag
  	     * @return {number}
  	     */
  	    searchTag: searchTag,

  	    /**
  	     * Binary search in a list of numbers
  	     * @instance
  	     * @function binSearch
  	     * @memberof opentype.Layout
  	     * @param  {Array} arr
  	     * @param  {number} value
  	     * @return {number}
  	     */
  	    binSearch: binSearch,

  	    /**
  	     * Get or create the Layout table (GSUB, GPOS etc).
  	     * @param  {boolean} create - Whether to create a new one.
  	     * @return {Object} The GSUB or GPOS table.
  	     */
  	    getTable: function(create) {
  	        var layout = this.font.tables[this.tableName];
  	        if (!layout && create) {
  	            layout = this.font.tables[this.tableName] = this.createDefaultTable();
  	        }
  	        return layout;
  	    },

  	    /**
  	     * Returns all scripts in the substitution table.
  	     * @instance
  	     * @return {Array}
  	     */
  	    getScriptNames: function() {
  	        var layout = this.getTable();
  	        if (!layout) { return []; }
  	        return layout.scripts.map(function(script) {
  	            return script.tag;
  	        });
  	    },

  	    /**
  	     * Returns the best bet for a script name.
  	     * Returns 'DFLT' if it exists.
  	     * If not, returns 'latn' if it exists.
  	     * If neither exist, returns undefined.
  	     */
  	    getDefaultScriptName: function() {
  	        var layout = this.getTable();
  	        if (!layout) { return; }
  	        var hasLatn = false;
  	        for (var i = 0; i < layout.scripts.length; i++) {
  	            var name = layout.scripts[i].tag;
  	            if (name === 'DFLT') { return name; }
  	            if (name === 'latn') { hasLatn = true; }
  	        }
  	        if (hasLatn) { return 'latn'; }
  	    },

  	    /**
  	     * Returns all LangSysRecords in the given script.
  	     * @instance
  	     * @param {string} [script='DFLT']
  	     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
  	     * @return {Object} An object with tag and script properties.
  	     */
  	    getScriptTable: function(script, create) {
  	        var layout = this.getTable(create);
  	        if (layout) {
  	            script = script || 'DFLT';
  	            var scripts = layout.scripts;
  	            var pos = searchTag(layout.scripts, script);
  	            if (pos >= 0) {
  	                return scripts[pos].script;
  	            } else if (create) {
  	                var scr = {
  	                    tag: script,
  	                    script: {
  	                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
  	                        langSysRecords: []
  	                    }
  	                };
  	                scripts.splice(-1 - pos, 0, scr);
  	                return scr.script;
  	            }
  	        }
  	    },

  	    /**
  	     * Returns a language system table
  	     * @instance
  	     * @param {string} [script='DFLT']
  	     * @param {string} [language='dlft']
  	     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
  	     * @return {Object}
  	     */
  	    getLangSysTable: function(script, language, create) {
  	        var scriptTable = this.getScriptTable(script, create);
  	        if (scriptTable) {
  	            if (!language || language === 'dflt' || language === 'DFLT') {
  	                return scriptTable.defaultLangSys;
  	            }
  	            var pos = searchTag(scriptTable.langSysRecords, language);
  	            if (pos >= 0) {
  	                return scriptTable.langSysRecords[pos].langSys;
  	            } else if (create) {
  	                var langSysRecord = {
  	                    tag: language,
  	                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
  	                };
  	                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
  	                return langSysRecord.langSys;
  	            }
  	        }
  	    },

  	    /**
  	     * Get a specific feature table.
  	     * @instance
  	     * @param {string} [script='DFLT']
  	     * @param {string} [language='dlft']
  	     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
  	     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
  	     * @return {Object}
  	     */
  	    getFeatureTable: function(script, language, feature, create) {
  	        var langSysTable = this.getLangSysTable(script, language, create);
  	        if (langSysTable) {
  	            var featureRecord;
  	            var featIndexes = langSysTable.featureIndexes;
  	            var allFeatures = this.font.tables[this.tableName].features;
  	            // The FeatureIndex array of indices is in arbitrary order,
  	            // even if allFeatures is sorted alphabetically by feature tag.
  	            for (var i = 0; i < featIndexes.length; i++) {
  	                featureRecord = allFeatures[featIndexes[i]];
  	                if (featureRecord.tag === feature) {
  	                    return featureRecord.feature;
  	                }
  	            }
  	            if (create) {
  	                var index = allFeatures.length;
  	                // Automatic ordering of features would require to shift feature indexes in the script list.
  	                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
  	                featureRecord = {
  	                    tag: feature,
  	                    feature: { params: 0, lookupListIndexes: [] }
  	                };
  	                allFeatures.push(featureRecord);
  	                featIndexes.push(index);
  	                return featureRecord.feature;
  	            }
  	        }
  	    },

  	    /**
  	     * Get the lookup tables of a given type for a script/language/feature.
  	     * @instance
  	     * @param {string} [script='DFLT']
  	     * @param {string} [language='dlft']
  	     * @param {string} feature - 4-letter feature code
  	     * @param {number} lookupType - 1 to 9
  	     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
  	     * @return {Object[]}
  	     */
  	    getLookupTables: function(script, language, feature, lookupType, create) {
  	        var featureTable = this.getFeatureTable(script, language, feature, create);
  	        var tables = [];
  	        if (featureTable) {
  	            var lookupTable;
  	            var lookupListIndexes = featureTable.lookupListIndexes;
  	            var allLookups = this.font.tables[this.tableName].lookups;
  	            // lookupListIndexes are in no particular order, so use naive search.
  	            for (var i = 0; i < lookupListIndexes.length; i++) {
  	                lookupTable = allLookups[lookupListIndexes[i]];
  	                if (lookupTable.lookupType === lookupType) {
  	                    tables.push(lookupTable);
  	                }
  	            }
  	            if (tables.length === 0 && create) {
  	                lookupTable = {
  	                    lookupType: lookupType,
  	                    lookupFlag: 0,
  	                    subtables: [],
  	                    markFilteringSet: undefined
  	                };
  	                var index = allLookups.length;
  	                allLookups.push(lookupTable);
  	                lookupListIndexes.push(index);
  	                return [lookupTable];
  	            }
  	        }
  	        return tables;
  	    },

  	    /**
  	     * Find a glyph in a class definition table
  	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
  	     * @param {object} classDefTable - an OpenType Layout class definition table
  	     * @param {number} glyphIndex - the index of the glyph to find
  	     * @returns {number} -1 if not found
  	     */
  	    getGlyphClass: function(classDefTable, glyphIndex) {
  	        switch (classDefTable.format) {
  	            case 1:
  	                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
  	                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
  	                }
  	                return 0;
  	            case 2:
  	                var range = searchRange(classDefTable.ranges, glyphIndex);
  	                return range ? range.classId : 0;
  	        }
  	    },

  	    /**
  	     * Find a glyph in a coverage table
  	     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
  	     * @param {object} coverageTable - an OpenType Layout coverage table
  	     * @param {number} glyphIndex - the index of the glyph to find
  	     * @returns {number} -1 if not found
  	     */
  	    getCoverageIndex: function(coverageTable, glyphIndex) {
  	        switch (coverageTable.format) {
  	            case 1:
  	                var index = binSearch(coverageTable.glyphs, glyphIndex);
  	                return index >= 0 ? index : -1;
  	            case 2:
  	                var range = searchRange(coverageTable.ranges, glyphIndex);
  	                return range ? range.index + glyphIndex - range.start : -1;
  	        }
  	    },

  	    /**
  	     * Returns the list of glyph indexes of a coverage table.
  	     * Format 1: the list is stored raw
  	     * Format 2: compact list as range records.
  	     * @instance
  	     * @param  {Object} coverageTable
  	     * @return {Array}
  	     */
  	    expandCoverage: function(coverageTable) {
  	        if (coverageTable.format === 1) {
  	            return coverageTable.glyphs;
  	        } else {
  	            var glyphs = [];
  	            var ranges = coverageTable.ranges;
  	            for (var i = 0; i < ranges.length; i++) {
  	                var range = ranges[i];
  	                var start = range.start;
  	                var end = range.end;
  	                for (var j = start; j <= end; j++) {
  	                    glyphs.push(j);
  	                }
  	            }
  	            return glyphs;
  	        }
  	    }

  	};

  	// The Position object provides utility methods to manipulate

  	/**
  	 * @exports opentype.Position
  	 * @class
  	 * @extends opentype.Layout
  	 * @param {opentype.Font}
  	 * @constructor
  	 */
  	function Position(font) {
  	    Layout.call(this, font, 'gpos');
  	}

  	Position.prototype = Layout.prototype;

  	/**
  	 * Init some data for faster and easier access later.
  	 */
  	Position.prototype.init = function() {
  	    var script = this.getDefaultScriptName();
  	    this.defaultKerningTables = this.getKerningTables(script);
  	};

  	/**
  	 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
  	 *
  	 * @param {integer} leftIndex - left glyph index
  	 * @param {integer} rightIndex - right glyph index
  	 * @returns {integer}
  	 */
  	Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
  	    var this$1 = this;

  	    for (var i = 0; i < kerningLookups.length; i++) {
  	        var subtables = kerningLookups[i].subtables;
  	        for (var j = 0; j < subtables.length; j++) {
  	            var subtable = subtables[j];
  	            var covIndex = this$1.getCoverageIndex(subtable.coverage, leftIndex);
  	            if (covIndex < 0) { continue; }
  	            switch (subtable.posFormat) {
  	                case 1:
  	                    // Search Pair Adjustment Positioning Format 1
  	                    var pairSet = subtable.pairSets[covIndex];
  	                    for (var k = 0; k < pairSet.length; k++) {
  	                        var pair = pairSet[k];
  	                        if (pair.secondGlyph === rightIndex) {
  	                            return pair.value1 && pair.value1.xAdvance || 0;
  	                        }
  	                    }
  	                    break;      // left glyph found, not right glyph - try next subtable
  	                case 2:
  	                    // Search Pair Adjustment Positioning Format 2
  	                    var class1 = this$1.getGlyphClass(subtable.classDef1, leftIndex);
  	                    var class2 = this$1.getGlyphClass(subtable.classDef2, rightIndex);
  	                    var pair$1 = subtable.classRecords[class1][class2];
  	                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
  	            }
  	        }
  	    }
  	    return 0;
  	};

  	/**
  	 * List all kerning lookup tables.
  	 *
  	 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
  	 * @param {string} [language='dflt']
  	 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
  	 */
  	Position.prototype.getKerningTables = function(script, language) {
  	    if (this.font.tables.gpos) {
  	        return this.getLookupTables(script, language, 'kern', 2);
  	    }
  	};

  	// The Substitution object provides utility methods to manipulate

  	/**
  	 * @exports opentype.Substitution
  	 * @class
  	 * @extends opentype.Layout
  	 * @param {opentype.Font}
  	 * @constructor
  	 */
  	function Substitution(font) {
  	    Layout.call(this, font, 'gsub');
  	}

  	// Check if 2 arrays of primitives are equal.
  	function arraysEqual(ar1, ar2) {
  	    var n = ar1.length;
  	    if (n !== ar2.length) { return false; }
  	    for (var i = 0; i < n; i++) {
  	        if (ar1[i] !== ar2[i]) { return false; }
  	    }
  	    return true;
  	}

  	// Find the first subtable of a lookup table in a particular format.
  	function getSubstFormat(lookupTable, format, defaultSubtable) {
  	    var subtables = lookupTable.subtables;
  	    for (var i = 0; i < subtables.length; i++) {
  	        var subtable = subtables[i];
  	        if (subtable.substFormat === format) {
  	            return subtable;
  	        }
  	    }
  	    if (defaultSubtable) {
  	        subtables.push(defaultSubtable);
  	        return defaultSubtable;
  	    }
  	    return undefined;
  	}

  	Substitution.prototype = Layout.prototype;

  	/**
  	 * Create a default GSUB table.
  	 * @return {Object} gsub - The GSUB table.
  	 */
  	Substitution.prototype.createDefaultTable = function() {
  	    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
  	    return {
  	        version: 1,
  	        scripts: [{
  	            tag: 'DFLT',
  	            script: {
  	                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
  	                langSysRecords: []
  	            }
  	        }],
  	        features: [],
  	        lookups: []
  	    };
  	};

  	/**
  	 * List all single substitutions (lookup type 1) for a given script, language, and feature.
  	 * @param {string} [script='DFLT']
  	 * @param {string} [language='dflt']
  	 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
  	 * @return {Array} substitutions - The list of substitutions.
  	 */
  	Substitution.prototype.getSingle = function(feature, script, language) {
  	    var this$1 = this;

  	    var substitutions = [];
  	    var lookupTables = this.getLookupTables(script, language, feature, 1);
  	    for (var idx = 0; idx < lookupTables.length; idx++) {
  	        var subtables = lookupTables[idx].subtables;
  	        for (var i = 0; i < subtables.length; i++) {
  	            var subtable = subtables[i];
  	            var glyphs = this$1.expandCoverage(subtable.coverage);
  	            var j = (void 0);
  	            if (subtable.substFormat === 1) {
  	                var delta = subtable.deltaGlyphId;
  	                for (j = 0; j < glyphs.length; j++) {
  	                    var glyph = glyphs[j];
  	                    substitutions.push({ sub: glyph, by: glyph + delta });
  	                }
  	            } else {
  	                var substitute = subtable.substitute;
  	                for (j = 0; j < glyphs.length; j++) {
  	                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
  	                }
  	            }
  	        }
  	    }
  	    return substitutions;
  	};

  	/**
  	 * List all alternates (lookup type 3) for a given script, language, and feature.
  	 * @param {string} [script='DFLT']
  	 * @param {string} [language='dflt']
  	 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
  	 * @return {Array} alternates - The list of alternates
  	 */
  	Substitution.prototype.getAlternates = function(feature, script, language) {
  	    var this$1 = this;

  	    var alternates = [];
  	    var lookupTables = this.getLookupTables(script, language, feature, 3);
  	    for (var idx = 0; idx < lookupTables.length; idx++) {
  	        var subtables = lookupTables[idx].subtables;
  	        for (var i = 0; i < subtables.length; i++) {
  	            var subtable = subtables[i];
  	            var glyphs = this$1.expandCoverage(subtable.coverage);
  	            var alternateSets = subtable.alternateSets;
  	            for (var j = 0; j < glyphs.length; j++) {
  	                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
  	            }
  	        }
  	    }
  	    return alternates;
  	};

  	/**
  	 * List all ligatures (lookup type 4) for a given script, language, and feature.
  	 * The result is an array of ligature objects like { sub: [ids], by: id }
  	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
  	 * @param {string} [script='DFLT']
  	 * @param {string} [language='dflt']
  	 * @return {Array} ligatures - The list of ligatures.
  	 */
  	Substitution.prototype.getLigatures = function(feature, script, language) {
  	    var this$1 = this;

  	    var ligatures = [];
  	    var lookupTables = this.getLookupTables(script, language, feature, 4);
  	    for (var idx = 0; idx < lookupTables.length; idx++) {
  	        var subtables = lookupTables[idx].subtables;
  	        for (var i = 0; i < subtables.length; i++) {
  	            var subtable = subtables[i];
  	            var glyphs = this$1.expandCoverage(subtable.coverage);
  	            var ligatureSets = subtable.ligatureSets;
  	            for (var j = 0; j < glyphs.length; j++) {
  	                var startGlyph = glyphs[j];
  	                var ligSet = ligatureSets[j];
  	                for (var k = 0; k < ligSet.length; k++) {
  	                    var lig = ligSet[k];
  	                    ligatures.push({
  	                        sub: [startGlyph].concat(lig.components),
  	                        by: lig.ligGlyph
  	                    });
  	                }
  	            }
  	        }
  	    }
  	    return ligatures;
  	};

  	/**
  	 * Add or modify a single substitution (lookup type 1)
  	 * Format 2, more flexible, is always used.
  	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
  	 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
  	 * @param {string} [script='DFLT']
  	 * @param {string} [language='dflt']
  	 */
  	Substitution.prototype.addSingle = function(feature, substitution, script, language) {
  	    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
  	    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
  	        substFormat: 2,
  	        coverage: {format: 1, glyphs: []},
  	        substitute: []
  	    });
  	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
  	    var coverageGlyph = substitution.sub;
  	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  	    if (pos < 0) {
  	        pos = -1 - pos;
  	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
  	        subtable.substitute.splice(pos, 0, 0);
  	    }
  	    subtable.substitute[pos] = substitution.by;
  	};

  	/**
  	 * Add or modify an alternate substitution (lookup type 1)
  	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
  	 * @param {Object} substitution - { sub: id, by: [ids] }
  	 * @param {string} [script='DFLT']
  	 * @param {string} [language='dflt']
  	 */
  	Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
  	    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
  	    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
  	        substFormat: 1,
  	        coverage: {format: 1, glyphs: []},
  	        alternateSets: []
  	    });
  	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
  	    var coverageGlyph = substitution.sub;
  	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  	    if (pos < 0) {
  	        pos = -1 - pos;
  	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
  	        subtable.alternateSets.splice(pos, 0, 0);
  	    }
  	    subtable.alternateSets[pos] = substitution.by;
  	};

  	/**
  	 * Add a ligature (lookup type 4)
  	 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
  	 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
  	 * @param {Object} ligature - { sub: [ids], by: id }
  	 * @param {string} [script='DFLT']
  	 * @param {string} [language='dflt']
  	 */
  	Substitution.prototype.addLigature = function(feature, ligature, script, language) {
  	    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
  	    var subtable = lookupTable.subtables[0];
  	    if (!subtable) {
  	        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
  	            substFormat: 1,
  	            coverage: { format: 1, glyphs: [] },
  	            ligatureSets: []
  	        };
  	        lookupTable.subtables[0] = subtable;
  	    }
  	    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
  	    var coverageGlyph = ligature.sub[0];
  	    var ligComponents = ligature.sub.slice(1);
  	    var ligatureTable = {
  	        ligGlyph: ligature.by,
  	        components: ligComponents
  	    };
  	    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  	    if (pos >= 0) {
  	        // ligatureSet already exists
  	        var ligatureSet = subtable.ligatureSets[pos];
  	        for (var i = 0; i < ligatureSet.length; i++) {
  	            // If ligature already exists, return.
  	            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
  	                return;
  	            }
  	        }
  	        // ligature does not exist: add it.
  	        ligatureSet.push(ligatureTable);
  	    } else {
  	        // Create a new ligatureSet and add coverage for the first glyph.
  	        pos = -1 - pos;
  	        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
  	        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
  	    }
  	};

  	/**
  	 * List all feature data for a given script and language.
  	 * @param {string} feature - 4-letter feature name
  	 * @param {string} [script='DFLT']
  	 * @param {string} [language='dflt']
  	 * @return {Array} substitutions - The list of substitutions.
  	 */
  	Substitution.prototype.getFeature = function(feature, script, language) {
  	    if (/ss\d\d/.test(feature)) {
  	        // ss01 - ss20
  	        return this.getSingle(feature, script, language);
  	    }
  	    switch (feature) {
  	        case 'aalt':
  	        case 'salt':
  	            return this.getSingle(feature, script, language)
  	                    .concat(this.getAlternates(feature, script, language));
  	        case 'dlig':
  	        case 'liga':
  	        case 'rlig': return this.getLigatures(feature, script, language);
  	    }
  	    return undefined;
  	};

  	/**
  	 * Add a substitution to a feature for a given script and language.
  	 * @param {string} feature - 4-letter feature name
  	 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
  	 * @param {string} [script='DFLT']
  	 * @param {string} [language='dflt']
  	 */
  	Substitution.prototype.add = function(feature, sub, script, language) {
  	    if (/ss\d\d/.test(feature)) {
  	        // ss01 - ss20
  	        return this.addSingle(feature, sub, script, language);
  	    }
  	    switch (feature) {
  	        case 'aalt':
  	        case 'salt':
  	            if (typeof sub.by === 'number') {
  	                return this.addSingle(feature, sub, script, language);
  	            }
  	            return this.addAlternate(feature, sub, script, language);
  	        case 'dlig':
  	        case 'liga':
  	        case 'rlig':
  	            return this.addLigature(feature, sub, script, language);
  	    }
  	    return undefined;
  	};

  	function isBrowser() {
  	    return typeof window !== 'undefined';
  	}

  	function nodeBufferToArrayBuffer(buffer) {
  	    var ab = new ArrayBuffer(buffer.length);
  	    var view = new Uint8Array(ab);
  	    for (var i = 0; i < buffer.length; ++i) {
  	        view[i] = buffer[i];
  	    }

  	    return ab;
  	}

  	function arrayBufferToNodeBuffer(ab) {
  	    var buffer = new Buffer(ab.byteLength);
  	    var view = new Uint8Array(ab);
  	    for (var i = 0; i < buffer.length; ++i) {
  	        buffer[i] = view[i];
  	    }

  	    return buffer;
  	}

  	function checkArgument(expression, message) {
  	    if (!expression) {
  	        throw message;
  	    }
  	}

  	// The `glyf` table describes the glyphs in TrueType outline format.

  	// Parse the coordinate data for a glyph.
  	function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
  	    var v;
  	    if ((flag & shortVectorBitMask) > 0) {
  	        // The coordinate is 1 byte long.
  	        v = p.parseByte();
  	        // The `same` bit is re-used for short values to signify the sign of the value.
  	        if ((flag & sameBitMask) === 0) {
  	            v = -v;
  	        }

  	        v = previousValue + v;
  	    } else {
  	        //  The coordinate is 2 bytes long.
  	        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
  	        if ((flag & sameBitMask) > 0) {
  	            v = previousValue;
  	        } else {
  	            // Parse the coordinate as a signed 16-bit delta value.
  	            v = previousValue + p.parseShort();
  	        }
  	    }

  	    return v;
  	}

  	// Parse a TrueType glyph.
  	function parseGlyph(glyph, data, start) {
  	    var p = new parse.Parser(data, start);
  	    glyph.numberOfContours = p.parseShort();
  	    glyph._xMin = p.parseShort();
  	    glyph._yMin = p.parseShort();
  	    glyph._xMax = p.parseShort();
  	    glyph._yMax = p.parseShort();
  	    var flags;
  	    var flag;

  	    if (glyph.numberOfContours > 0) {
  	        // This glyph is not a composite.
  	        var endPointIndices = glyph.endPointIndices = [];
  	        for (var i = 0; i < glyph.numberOfContours; i += 1) {
  	            endPointIndices.push(p.parseUShort());
  	        }

  	        glyph.instructionLength = p.parseUShort();
  	        glyph.instructions = [];
  	        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
  	            glyph.instructions.push(p.parseByte());
  	        }

  	        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
  	        flags = [];
  	        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
  	            flag = p.parseByte();
  	            flags.push(flag);
  	            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
  	            if ((flag & 8) > 0) {
  	                var repeatCount = p.parseByte();
  	                for (var j = 0; j < repeatCount; j += 1) {
  	                    flags.push(flag);
  	                    i$2 += 1;
  	                }
  	            }
  	        }

  	        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

  	        if (endPointIndices.length > 0) {
  	            var points = [];
  	            var point;
  	            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
  	            if (numberOfCoordinates > 0) {
  	                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
  	                    flag = flags[i$3];
  	                    point = {};
  	                    point.onCurve = !!(flag & 1);
  	                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
  	                    points.push(point);
  	                }

  	                var px = 0;
  	                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
  	                    flag = flags[i$4];
  	                    point = points[i$4];
  	                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
  	                    px = point.x;
  	                }

  	                var py = 0;
  	                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
  	                    flag = flags[i$5];
  	                    point = points[i$5];
  	                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
  	                    py = point.y;
  	                }
  	            }

  	            glyph.points = points;
  	        } else {
  	            glyph.points = [];
  	        }
  	    } else if (glyph.numberOfContours === 0) {
  	        glyph.points = [];
  	    } else {
  	        glyph.isComposite = true;
  	        glyph.points = [];
  	        glyph.components = [];
  	        var moreComponents = true;
  	        while (moreComponents) {
  	            flags = p.parseUShort();
  	            var component = {
  	                glyphIndex: p.parseUShort(),
  	                xScale: 1,
  	                scale01: 0,
  	                scale10: 0,
  	                yScale: 1,
  	                dx: 0,
  	                dy: 0
  	            };
  	            if ((flags & 1) > 0) {
  	                // The arguments are words
  	                if ((flags & 2) > 0) {
  	                    // values are offset
  	                    component.dx = p.parseShort();
  	                    component.dy = p.parseShort();
  	                } else {
  	                    // values are matched points
  	                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
  	                }

  	            } else {
  	                // The arguments are bytes
  	                if ((flags & 2) > 0) {
  	                    // values are offset
  	                    component.dx = p.parseChar();
  	                    component.dy = p.parseChar();
  	                } else {
  	                    // values are matched points
  	                    component.matchedPoints = [p.parseByte(), p.parseByte()];
  	                }
  	            }

  	            if ((flags & 8) > 0) {
  	                // We have a scale
  	                component.xScale = component.yScale = p.parseF2Dot14();
  	            } else if ((flags & 64) > 0) {
  	                // We have an X / Y scale
  	                component.xScale = p.parseF2Dot14();
  	                component.yScale = p.parseF2Dot14();
  	            } else if ((flags & 128) > 0) {
  	                // We have a 2x2 transformation
  	                component.xScale = p.parseF2Dot14();
  	                component.scale01 = p.parseF2Dot14();
  	                component.scale10 = p.parseF2Dot14();
  	                component.yScale = p.parseF2Dot14();
  	            }

  	            glyph.components.push(component);
  	            moreComponents = !!(flags & 32);
  	        }
  	        if (flags & 0x100) {
  	            // We have instructions
  	            glyph.instructionLength = p.parseUShort();
  	            glyph.instructions = [];
  	            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
  	                glyph.instructions.push(p.parseByte());
  	            }
  	        }
  	    }
  	}

  	// Transform an array of points and return a new array.
  	function transformPoints(points, transform) {
  	    var newPoints = [];
  	    for (var i = 0; i < points.length; i += 1) {
  	        var pt = points[i];
  	        var newPt = {
  	            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
  	            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
  	            onCurve: pt.onCurve,
  	            lastPointOfContour: pt.lastPointOfContour
  	        };
  	        newPoints.push(newPt);
  	    }

  	    return newPoints;
  	}

  	function getContours(points) {
  	    var contours = [];
  	    var currentContour = [];
  	    for (var i = 0; i < points.length; i += 1) {
  	        var pt = points[i];
  	        currentContour.push(pt);
  	        if (pt.lastPointOfContour) {
  	            contours.push(currentContour);
  	            currentContour = [];
  	        }
  	    }

  	    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
  	    return contours;
  	}

  	// Convert the TrueType glyph outline to a Path.
  	function getPath(points) {
  	    var p = new Path();
  	    if (!points) {
  	        return p;
  	    }

  	    var contours = getContours(points);

  	    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
  	        var contour = contours[contourIndex];

  	        var prev = null;
  	        var curr = contour[contour.length - 1];
  	        var next = contour[0];

  	        if (curr.onCurve) {
  	            p.moveTo(curr.x, curr.y);
  	        } else {
  	            if (next.onCurve) {
  	                p.moveTo(next.x, next.y);
  	            } else {
  	                // If both first and last points are off-curve, start at their middle.
  	                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
  	                p.moveTo(start.x, start.y);
  	            }
  	        }

  	        for (var i = 0; i < contour.length; ++i) {
  	            prev = curr;
  	            curr = next;
  	            next = contour[(i + 1) % contour.length];

  	            if (curr.onCurve) {
  	                // This is a straight line.
  	                p.lineTo(curr.x, curr.y);
  	            } else {
  	                var prev2 = prev;
  	                var next2 = next;

  	                if (!prev.onCurve) {
  	                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
  	                }

  	                if (!next.onCurve) {
  	                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
  	                }

  	                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
  	            }
  	        }

  	        p.closePath();
  	    }
  	    return p;
  	}

  	function buildPath(glyphs, glyph) {
  	    if (glyph.isComposite) {
  	        for (var j = 0; j < glyph.components.length; j += 1) {
  	            var component = glyph.components[j];
  	            var componentGlyph = glyphs.get(component.glyphIndex);
  	            // Force the ttfGlyphLoader to parse the glyph.
  	            componentGlyph.getPath();
  	            if (componentGlyph.points) {
  	                var transformedPoints = (void 0);
  	                if (component.matchedPoints === undefined) {
  	                    // component positioned by offset
  	                    transformedPoints = transformPoints(componentGlyph.points, component);
  	                } else {
  	                    // component positioned by matched points
  	                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
  	                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
  	                        throw Error('Matched points out of range in ' + glyph.name);
  	                    }
  	                    var firstPt = glyph.points[component.matchedPoints[0]];
  	                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
  	                    var transform = {
  	                        xScale: component.xScale, scale01: component.scale01,
  	                        scale10: component.scale10, yScale: component.yScale,
  	                        dx: 0, dy: 0
  	                    };
  	                    secondPt = transformPoints([secondPt], transform)[0];
  	                    transform.dx = firstPt.x - secondPt.x;
  	                    transform.dy = firstPt.y - secondPt.y;
  	                    transformedPoints = transformPoints(componentGlyph.points, transform);
  	                }
  	                glyph.points = glyph.points.concat(transformedPoints);
  	            }
  	        }
  	    }

  	    return getPath(glyph.points);
  	}

  	// Parse all the glyphs according to the offsets from the `loca` table.
  	function parseGlyfTable(data, start, loca, font) {
  	    var glyphs = new glyphset.GlyphSet(font);

  	    // The last element of the loca table is invalid.
  	    for (var i = 0; i < loca.length - 1; i += 1) {
  	        var offset = loca[i];
  	        var nextOffset = loca[i + 1];
  	        if (offset !== nextOffset) {
  	            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
  	        } else {
  	            glyphs.push(i, glyphset.glyphLoader(font, i));
  	        }
  	    }

  	    return glyphs;
  	}

  	var glyf = { getPath: getPath, parse: parseGlyfTable };

  	/* A TrueType font hinting interpreter.
  	*
  	* (c) 2017 Axel Kittenberger
  	*
  	* This interpreter has been implemented according to this documentation:
  	* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
  	*
  	* According to the documentation F24DOT6 values are used for pixels.
  	* That means calculation is 1/64 pixel accurate and uses integer operations.
  	* However, Javascript has floating point operations by default and only
  	* those are available. One could make a case to simulate the 1/64 accuracy
  	* exactly by truncating after every division operation
  	* (for example with << 0) to get pixel exactly results as other TrueType
  	* implementations. It may make sense since some fonts are pixel optimized
  	* by hand using DELTAP instructions. The current implementation doesn't
  	* and rather uses full floating point precision.
  	*
  	* xScale, yScale and rotation is currently ignored.
  	*
  	* A few non-trivial instructions are missing as I didn't encounter yet
  	* a font that used them to test a possible implementation.
  	*
  	* Some fonts seem to use undocumented features regarding the twilight zone.
  	* Only some of them are implemented as they were encountered.
  	*
  	* The exports.DEBUG statements are removed on the minified distribution file.
  	*/

  	var instructionTable;
  	var exec;
  	var execGlyph;
  	var execComponent;

  	/*
  	* Creates a hinting object.
  	*
  	* There ought to be exactly one
  	* for each truetype font that is used for hinting.
  	*/
  	function Hinting(font) {
  	    // the font this hinting object is for
  	    this.font = font;

  	    this.getCommands = function (hPoints) {
  	        return glyf.getPath(hPoints).commands;
  	    };

  	    // cached states
  	    this._fpgmState  =
  	    this._prepState  =
  	        undefined;

  	    // errorState
  	    // 0 ... all okay
  	    // 1 ... had an error in a glyf,
  	    //       continue working but stop spamming
  	    //       the console
  	    // 2 ... error at prep, stop hinting at this ppem
  	    // 3 ... error at fpeg, stop hinting for this font at all
  	    this._errorState = 0;
  	}

  	/*
  	* Not rounding.
  	*/
  	function roundOff(v) {
  	    return v;
  	}

  	/*
  	* Rounding to grid.
  	*/
  	function roundToGrid(v) {
  	    //Rounding in TT is supposed to "symmetrical around zero"
  	    return Math.sign(v) * Math.round(Math.abs(v));
  	}

  	/*
  	* Rounding to double grid.
  	*/
  	function roundToDoubleGrid(v) {
  	    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
  	}

  	/*
  	* Rounding to half grid.
  	*/
  	function roundToHalfGrid(v) {
  	    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
  	}

  	/*
  	* Rounding to up to grid.
  	*/
  	function roundUpToGrid(v) {
  	    return Math.sign(v) * Math.ceil(Math.abs(v));
  	}

  	/*
  	* Rounding to down to grid.
  	*/
  	function roundDownToGrid(v) {
  	    return Math.sign(v) * Math.floor(Math.abs(v));
  	}

  	/*
  	* Super rounding.
  	*/
  	var roundSuper = function (v) {
  	    var period = this.srPeriod;
  	    var phase = this.srPhase;
  	    var threshold = this.srThreshold;
  	    var sign = 1;

  	    if (v < 0) {
  	        v = -v;
  	        sign = -1;
  	    }

  	    v += threshold - phase;

  	    v = Math.trunc(v / period) * period;

  	    v += phase;

  	    // according to http://xgridfit.sourceforge.net/round.html
  	    if (v < 0) { return phase * sign; }

  	    return v * sign;
  	};

  	/*
  	* Unit vector of x-axis.
  	*/
  	var xUnitVector = {
  	    x: 1,

  	    y: 0,

  	    axis: 'x',

  	    // Gets the projected distance between two points.
  	    // o1/o2 ... if true, respective original position is used.
  	    distance: function (p1, p2, o1, o2) {
  	        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
  	    },

  	    // Moves point p so the moved position has the same relative
  	    // position to the moved positions of rp1 and rp2 than the
  	    // original positions had.
  	    //
  	    // See APPENDIX on INTERPOLATE at the bottom of this file.
  	    interpolate: function (p, rp1, rp2, pv) {
  	        var do1;
  	        var do2;
  	        var doa1;
  	        var doa2;
  	        var dm1;
  	        var dm2;
  	        var dt;

  	        if (!pv || pv === this) {
  	            do1 = p.xo - rp1.xo;
  	            do2 = p.xo - rp2.xo;
  	            dm1 = rp1.x - rp1.xo;
  	            dm2 = rp2.x - rp2.xo;
  	            doa1 = Math.abs(do1);
  	            doa2 = Math.abs(do2);
  	            dt = doa1 + doa2;

  	            if (dt === 0) {
  	                p.x = p.xo + (dm1 + dm2) / 2;
  	                return;
  	            }

  	            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
  	            return;
  	        }

  	        do1 = pv.distance(p, rp1, true, true);
  	        do2 = pv.distance(p, rp2, true, true);
  	        dm1 = pv.distance(rp1, rp1, false, true);
  	        dm2 = pv.distance(rp2, rp2, false, true);
  	        doa1 = Math.abs(do1);
  	        doa2 = Math.abs(do2);
  	        dt = doa1 + doa2;

  	        if (dt === 0) {
  	            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
  	            return;
  	        }

  	        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  	    },

  	    // Slope of line normal to this
  	    normalSlope: Number.NEGATIVE_INFINITY,

  	    // Sets the point 'p' relative to point 'rp'
  	    // by the distance 'd'.
  	    //
  	    // See APPENDIX on SETRELATIVE at the bottom of this file.
  	    //
  	    // p   ... point to set
  	    // rp  ... reference point
  	    // d   ... distance on projection vector
  	    // pv  ... projection vector (undefined = this)
  	    // org ... if true, uses the original position of rp as reference.
  	    setRelative: function (p, rp, d, pv, org) {
  	        if (!pv || pv === this) {
  	            p.x = (org ? rp.xo : rp.x) + d;
  	            return;
  	        }

  	        var rpx = org ? rp.xo : rp.x;
  	        var rpy = org ? rp.yo : rp.y;
  	        var rpdx = rpx + d * pv.x;
  	        var rpdy = rpy + d * pv.y;

  	        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
  	    },

  	    // Slope of vector line.
  	    slope: 0,

  	    // Touches the point p.
  	    touch: function (p) {
  	        p.xTouched = true;
  	    },

  	    // Tests if a point p is touched.
  	    touched: function (p) {
  	        return p.xTouched;
  	    },

  	    // Untouches the point p.
  	    untouch: function (p) {
  	        p.xTouched = false;
  	    }
  	};

  	/*
  	* Unit vector of y-axis.
  	*/
  	var yUnitVector = {
  	    x: 0,

  	    y: 1,

  	    axis: 'y',

  	    // Gets the projected distance between two points.
  	    // o1/o2 ... if true, respective original position is used.
  	    distance: function (p1, p2, o1, o2) {
  	        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
  	    },

  	    // Moves point p so the moved position has the same relative
  	    // position to the moved positions of rp1 and rp2 than the
  	    // original positions had.
  	    //
  	    // See APPENDIX on INTERPOLATE at the bottom of this file.
  	    interpolate: function (p, rp1, rp2, pv) {
  	        var do1;
  	        var do2;
  	        var doa1;
  	        var doa2;
  	        var dm1;
  	        var dm2;
  	        var dt;

  	        if (!pv || pv === this) {
  	            do1 = p.yo - rp1.yo;
  	            do2 = p.yo - rp2.yo;
  	            dm1 = rp1.y - rp1.yo;
  	            dm2 = rp2.y - rp2.yo;
  	            doa1 = Math.abs(do1);
  	            doa2 = Math.abs(do2);
  	            dt = doa1 + doa2;

  	            if (dt === 0) {
  	                p.y = p.yo + (dm1 + dm2) / 2;
  	                return;
  	            }

  	            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
  	            return;
  	        }

  	        do1 = pv.distance(p, rp1, true, true);
  	        do2 = pv.distance(p, rp2, true, true);
  	        dm1 = pv.distance(rp1, rp1, false, true);
  	        dm2 = pv.distance(rp2, rp2, false, true);
  	        doa1 = Math.abs(do1);
  	        doa2 = Math.abs(do2);
  	        dt = doa1 + doa2;

  	        if (dt === 0) {
  	            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
  	            return;
  	        }

  	        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  	    },

  	    // Slope of line normal to this.
  	    normalSlope: 0,

  	    // Sets the point 'p' relative to point 'rp'
  	    // by the distance 'd'
  	    //
  	    // See APPENDIX on SETRELATIVE at the bottom of this file.
  	    //
  	    // p   ... point to set
  	    // rp  ... reference point
  	    // d   ... distance on projection vector
  	    // pv  ... projection vector (undefined = this)
  	    // org ... if true, uses the original position of rp as reference.
  	    setRelative: function (p, rp, d, pv, org) {
  	        if (!pv || pv === this) {
  	            p.y = (org ? rp.yo : rp.y) + d;
  	            return;
  	        }

  	        var rpx = org ? rp.xo : rp.x;
  	        var rpy = org ? rp.yo : rp.y;
  	        var rpdx = rpx + d * pv.x;
  	        var rpdy = rpy + d * pv.y;

  	        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
  	    },

  	    // Slope of vector line.
  	    slope: Number.POSITIVE_INFINITY,

  	    // Touches the point p.
  	    touch: function (p) {
  	        p.yTouched = true;
  	    },

  	    // Tests if a point p is touched.
  	    touched: function (p) {
  	        return p.yTouched;
  	    },

  	    // Untouches the point p.
  	    untouch: function (p) {
  	        p.yTouched = false;
  	    }
  	};

  	Object.freeze(xUnitVector);
  	Object.freeze(yUnitVector);

  	/*
  	* Creates a unit vector that is not x- or y-axis.
  	*/
  	function UnitVector(x, y) {
  	    this.x = x;
  	    this.y = y;
  	    this.axis = undefined;
  	    this.slope = y / x;
  	    this.normalSlope = -x / y;
  	    Object.freeze(this);
  	}

  	/*
  	* Gets the projected distance between two points.
  	* o1/o2 ... if true, respective original position is used.
  	*/
  	UnitVector.prototype.distance = function(p1, p2, o1, o2) {
  	    return (
  	        this.x * xUnitVector.distance(p1, p2, o1, o2) +
  	        this.y * yUnitVector.distance(p1, p2, o1, o2)
  	    );
  	};

  	/*
  	* Moves point p so the moved position has the same relative
  	* position to the moved positions of rp1 and rp2 than the
  	* original positions had.
  	*
  	* See APPENDIX on INTERPOLATE at the bottom of this file.
  	*/
  	UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
  	    var dm1;
  	    var dm2;
  	    var do1;
  	    var do2;
  	    var doa1;
  	    var doa2;
  	    var dt;

  	    do1 = pv.distance(p, rp1, true, true);
  	    do2 = pv.distance(p, rp2, true, true);
  	    dm1 = pv.distance(rp1, rp1, false, true);
  	    dm2 = pv.distance(rp2, rp2, false, true);
  	    doa1 = Math.abs(do1);
  	    doa2 = Math.abs(do2);
  	    dt = doa1 + doa2;

  	    if (dt === 0) {
  	        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
  	        return;
  	    }

  	    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  	};

  	/*
  	* Sets the point 'p' relative to point 'rp'
  	* by the distance 'd'
  	*
  	* See APPENDIX on SETRELATIVE at the bottom of this file.
  	*
  	* p   ...  point to set
  	* rp  ... reference point
  	* d   ... distance on projection vector
  	* pv  ... projection vector (undefined = this)
  	* org ... if true, uses the original position of rp as reference.
  	*/
  	UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
  	    pv = pv || this;

  	    var rpx = org ? rp.xo : rp.x;
  	    var rpy = org ? rp.yo : rp.y;
  	    var rpdx = rpx + d * pv.x;
  	    var rpdy = rpy + d * pv.y;

  	    var pvns = pv.normalSlope;
  	    var fvs = this.slope;

  	    var px = p.x;
  	    var py = p.y;

  	    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
  	    p.y = fvs * (p.x - px) + py;
  	};

  	/*
  	* Touches the point p.
  	*/
  	UnitVector.prototype.touch = function(p) {
  	    p.xTouched = true;
  	    p.yTouched = true;
  	};

  	/*
  	* Returns a unit vector with x/y coordinates.
  	*/
  	function getUnitVector(x, y) {
  	    var d = Math.sqrt(x * x + y * y);

  	    x /= d;
  	    y /= d;

  	    if (x === 1 && y === 0) { return xUnitVector; }
  	    else if (x === 0 && y === 1) { return yUnitVector; }
  	    else { return new UnitVector(x, y); }
  	}

  	/*
  	* Creates a point in the hinting engine.
  	*/
  	function HPoint(
  	    x,
  	    y,
  	    lastPointOfContour,
  	    onCurve
  	) {
  	    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
  	    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

  	    this.lastPointOfContour = lastPointOfContour;
  	    this.onCurve = onCurve;
  	    this.prevPointOnContour = undefined;
  	    this.nextPointOnContour = undefined;
  	    this.xTouched = false;
  	    this.yTouched = false;

  	    Object.preventExtensions(this);
  	}

  	/*
  	* Returns the next touched point on the contour.
  	*
  	* v  ... unit vector to test touch axis.
  	*/
  	HPoint.prototype.nextTouched = function(v) {
  	    var p = this.nextPointOnContour;

  	    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

  	    return p;
  	};

  	/*
  	* Returns the previous touched point on the contour
  	*
  	* v  ... unit vector to test touch axis.
  	*/
  	HPoint.prototype.prevTouched = function(v) {
  	    var p = this.prevPointOnContour;

  	    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

  	    return p;
  	};

  	/*
  	* The zero point.
  	*/
  	var HPZero = Object.freeze(new HPoint(0, 0));

  	/*
  	* The default state of the interpreter.
  	*
  	* Note: Freezing the defaultState and then deriving from it
  	* makes the V8 Javascript engine going awkward,
  	* so this is avoided, albeit the defaultState shouldn't
  	* ever change.
  	*/
  	var defaultState = {
  	    cvCutIn: 17 / 16,    // control value cut in
  	    deltaBase: 9,
  	    deltaShift: 0.125,
  	    loop: 1,             // loops some instructions
  	    minDis: 1,           // minimum distance
  	    autoFlip: true
  	};

  	/*
  	* The current state of the interpreter.
  	*
  	* env  ... 'fpgm' or 'prep' or 'glyf'
  	* prog ... the program
  	*/
  	function State(env, prog) {
  	    this.env = env;
  	    this.stack = [];
  	    this.prog = prog;

  	    switch (env) {
  	        case 'glyf' :
  	            this.zp0 = this.zp1 = this.zp2 = 1;
  	            this.rp0 = this.rp1 = this.rp2 = 0;
  	            /* fall through */
  	        case 'prep' :
  	            this.fv = this.pv = this.dpv = xUnitVector;
  	            this.round = roundToGrid;
  	    }
  	}

  	/*
  	* Executes a glyph program.
  	*
  	* This does the hinting for each glyph.
  	*
  	* Returns an array of moved points.
  	*
  	* glyph: the glyph to hint
  	* ppem: the size the glyph is rendered for
  	*/
  	Hinting.prototype.exec = function(glyph, ppem) {
  	    if (typeof ppem !== 'number') {
  	        throw new Error('Point size is not a number!');
  	    }

  	    // Received a fatal error, don't do any hinting anymore.
  	    if (this._errorState > 2) { return; }

  	    var font = this.font;
  	    var prepState = this._prepState;

  	    if (!prepState || prepState.ppem !== ppem) {
  	        var fpgmState = this._fpgmState;

  	        if (!fpgmState) {
  	            // Executes the fpgm state.
  	            // This is used by fonts to define functions.
  	            State.prototype = defaultState;

  	            fpgmState =
  	            this._fpgmState =
  	                new State('fpgm', font.tables.fpgm);

  	            fpgmState.funcs = [ ];
  	            fpgmState.font = font;

  	            if (exports.DEBUG) {
  	                console.log('---EXEC FPGM---');
  	                fpgmState.step = -1;
  	            }

  	            try {
  	                exec(fpgmState);
  	            } catch (e) {
  	                console.log('Hinting error in FPGM:' + e);
  	                this._errorState = 3;
  	                return;
  	            }
  	        }

  	        // Executes the prep program for this ppem setting.
  	        // This is used by fonts to set cvt values
  	        // depending on to be rendered font size.

  	        State.prototype = fpgmState;
  	        prepState =
  	        this._prepState =
  	            new State('prep', font.tables.prep);

  	        prepState.ppem = ppem;

  	        // Creates a copy of the cvt table
  	        // and scales it to the current ppem setting.
  	        var oCvt = font.tables.cvt;
  	        if (oCvt) {
  	            var cvt = prepState.cvt = new Array(oCvt.length);
  	            var scale = ppem / font.unitsPerEm;
  	            for (var c = 0; c < oCvt.length; c++) {
  	                cvt[c] = oCvt[c] * scale;
  	            }
  	        } else {
  	            prepState.cvt = [];
  	        }

  	        if (exports.DEBUG) {
  	            console.log('---EXEC PREP---');
  	            prepState.step = -1;
  	        }

  	        try {
  	            exec(prepState);
  	        } catch (e) {
  	            if (this._errorState < 2) {
  	                console.log('Hinting error in PREP:' + e);
  	            }
  	            this._errorState = 2;
  	        }
  	    }

  	    if (this._errorState > 1) { return; }

  	    try {
  	        return execGlyph(glyph, prepState);
  	    } catch (e) {
  	        if (this._errorState < 1) {
  	            console.log('Hinting error:' + e);
  	            console.log('Note: further hinting errors are silenced');
  	        }
  	        this._errorState = 1;
  	        return undefined;
  	    }
  	};

  	/*
  	* Executes the hinting program for a glyph.
  	*/
  	execGlyph = function(glyph, prepState) {
  	    // original point positions
  	    var xScale = prepState.ppem / prepState.font.unitsPerEm;
  	    var yScale = xScale;
  	    var components = glyph.components;
  	    var contours;
  	    var gZone;
  	    var state;

  	    State.prototype = prepState;
  	    if (!components) {
  	        state = new State('glyf', glyph.instructions);
  	        if (exports.DEBUG) {
  	            console.log('---EXEC GLYPH---');
  	            state.step = -1;
  	        }
  	        execComponent(glyph, state, xScale, yScale);
  	        gZone = state.gZone;
  	    } else {
  	        var font = prepState.font;
  	        gZone = [];
  	        contours = [];
  	        for (var i = 0; i < components.length; i++) {
  	            var c = components[i];
  	            var cg = font.glyphs.get(c.glyphIndex);

  	            state = new State('glyf', cg.instructions);

  	            if (exports.DEBUG) {
  	                console.log('---EXEC COMP ' + i + '---');
  	                state.step = -1;
  	            }

  	            execComponent(cg, state, xScale, yScale);
  	            // appends the computed points to the result array
  	            // post processes the component points
  	            var dx = Math.round(c.dx * xScale);
  	            var dy = Math.round(c.dy * yScale);
  	            var gz = state.gZone;
  	            var cc = state.contours;
  	            for (var pi = 0; pi < gz.length; pi++) {
  	                var p = gz[pi];
  	                p.xTouched = p.yTouched = false;
  	                p.xo = p.x = p.x + dx;
  	                p.yo = p.y = p.y + dy;
  	            }

  	            var gLen = gZone.length;
  	            gZone.push.apply(gZone, gz);
  	            for (var j = 0; j < cc.length; j++) {
  	                contours.push(cc[j] + gLen);
  	            }
  	        }

  	        if (glyph.instructions && !state.inhibitGridFit) {
  	            // the composite has instructions on its own
  	            state = new State('glyf', glyph.instructions);

  	            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

  	            state.contours = contours;

  	            // note: HPZero cannot be used here, since
  	            //       the point might be modified
  	            gZone.push(
  	                new HPoint(0, 0),
  	                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
  	            );

  	            if (exports.DEBUG) {
  	                console.log('---EXEC COMPOSITE---');
  	                state.step = -1;
  	            }

  	            exec(state);

  	            gZone.length -= 2;
  	        }
  	    }

  	    return gZone;
  	};

  	/*
  	* Executes the hinting program for a component of a multi-component glyph
  	* or of the glyph itself for a non-component glyph.
  	*/
  	execComponent = function(glyph, state, xScale, yScale)
  	{
  	    var points = glyph.points || [];
  	    var pLen = points.length;
  	    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
  	    var contours = state.contours = [];

  	    // Scales the original points and
  	    // makes copies for the hinted points.
  	    var cp; // current point
  	    for (var i = 0; i < pLen; i++) {
  	        cp = points[i];

  	        gZone[i] = new HPoint(
  	            cp.x * xScale,
  	            cp.y * yScale,
  	            cp.lastPointOfContour,
  	            cp.onCurve
  	        );
  	    }

  	    // Chain links the contours.
  	    var sp; // start point
  	    var np; // next point

  	    for (var i$1 = 0; i$1 < pLen; i$1++) {
  	        cp = gZone[i$1];

  	        if (!sp) {
  	            sp = cp;
  	            contours.push(i$1);
  	        }

  	        if (cp.lastPointOfContour) {
  	            cp.nextPointOnContour = sp;
  	            sp.prevPointOnContour = cp;
  	            sp = undefined;
  	        } else {
  	            np = gZone[i$1 + 1];
  	            cp.nextPointOnContour = np;
  	            np.prevPointOnContour = cp;
  	        }
  	    }

  	    if (state.inhibitGridFit) { return; }

  	    if (exports.DEBUG) {
  	        console.log('PROCESSING GLYPH', state.stack);
  	        for (var i$2 = 0; i$2 < pLen; i$2++) {
  	            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
  	        }
  	    }

  	    gZone.push(
  	        new HPoint(0, 0),
  	        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
  	    );

  	    exec(state);

  	    // Removes the extra points.
  	    gZone.length -= 2;

  	    if (exports.DEBUG) {
  	        console.log('FINISHED GLYPH', state.stack);
  	        for (var i$3 = 0; i$3 < pLen; i$3++) {
  	            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
  	        }
  	    }
  	};

  	/*
  	* Executes the program loaded in state.
  	*/
  	exec = function(state) {
  	    var prog = state.prog;

  	    if (!prog) { return; }

  	    var pLen = prog.length;
  	    var ins;

  	    for (state.ip = 0; state.ip < pLen; state.ip++) {
  	        if (exports.DEBUG) { state.step++; }
  	        ins = instructionTable[prog[state.ip]];

  	        if (!ins) {
  	            throw new Error(
  	                'unknown instruction: 0x' +
  	                Number(prog[state.ip]).toString(16)
  	            );
  	        }

  	        ins(state);

  	        // very extensive debugging for each step
  	        /*
  	        if (exports.DEBUG) {
  	            var da;
  	            if (state.gZone) {
  	                da = [];
  	                for (let i = 0; i < state.gZone.length; i++)
  	                {
  	                    da.push(i + ' ' +
  	                        state.gZone[i].x * 64 + ' ' +
  	                        state.gZone[i].y * 64 + ' ' +
  	                        (state.gZone[i].xTouched ? 'x' : '') +
  	                        (state.gZone[i].yTouched ? 'y' : '')
  	                    );
  	                }
  	                console.log('GZ', da);
  	            }

  	            if (state.tZone) {
  	                da = [];
  	                for (let i = 0; i < state.tZone.length; i++) {
  	                    da.push(i + ' ' +
  	                        state.tZone[i].x * 64 + ' ' +
  	                        state.tZone[i].y * 64 + ' ' +
  	                        (state.tZone[i].xTouched ? 'x' : '') +
  	                        (state.tZone[i].yTouched ? 'y' : '')
  	                    );
  	                }
  	                console.log('TZ', da);
  	            }

  	            if (state.stack.length > 10) {
  	                console.log(
  	                    state.stack.length,
  	                    '...', state.stack.slice(state.stack.length - 10)
  	                );
  	            } else {
  	                console.log(state.stack.length, state.stack);
  	            }
  	        }
  	        */
  	    }
  	};

  	/*
  	* Initializes the twilight zone.
  	*
  	* This is only done if a SZPx instruction
  	* refers to the twilight zone.
  	*/
  	function initTZone(state)
  	{
  	    var tZone = state.tZone = new Array(state.gZone.length);

  	    // no idea if this is actually correct...
  	    for (var i = 0; i < tZone.length; i++)
  	    {
  	        tZone[i] = new HPoint(0, 0);
  	    }
  	}

  	/*
  	* Skips the instruction pointer ahead over an IF/ELSE block.
  	* handleElse .. if true breaks on matching ELSE
  	*/
  	function skip(state, handleElse)
  	{
  	    var prog = state.prog;
  	    var ip = state.ip;
  	    var nesting = 1;
  	    var ins;

  	    do {
  	        ins = prog[++ip];
  	        if (ins === 0x58) // IF
  	            { nesting++; }
  	        else if (ins === 0x59) // EIF
  	            { nesting--; }
  	        else if (ins === 0x40) // NPUSHB
  	            { ip += prog[ip + 1] + 1; }
  	        else if (ins === 0x41) // NPUSHW
  	            { ip += 2 * prog[ip + 1] + 1; }
  	        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
  	            { ip += ins - 0xB0 + 1; }
  	        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
  	            { ip += (ins - 0xB8 + 1) * 2; }
  	        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
  	            { break; }
  	    } while (nesting > 0);

  	    state.ip = ip;
  	}

  	/*----------------------------------------------------------*
  	*          And then a lot of instructions...                *
  	*----------------------------------------------------------*/

  	// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
  	// 0x00-0x01
  	function SVTCA(v, state) {
  	    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

  	    state.fv = state.pv = state.dpv = v;
  	}

  	// SPVTCA[a] Set Projection Vector to Coordinate Axis
  	// 0x02-0x03
  	function SPVTCA(v, state) {
  	    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

  	    state.pv = state.dpv = v;
  	}

  	// SFVTCA[a] Set Freedom Vector to Coordinate Axis
  	// 0x04-0x05
  	function SFVTCA(v, state) {
  	    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

  	    state.fv = v;
  	}

  	// SPVTL[a] Set Projection Vector To Line
  	// 0x06-0x07
  	function SPVTL(a, state) {
  	    var stack = state.stack;
  	    var p2i = stack.pop();
  	    var p1i = stack.pop();
  	    var p2 = state.z2[p2i];
  	    var p1 = state.z1[p1i];

  	    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

  	    var dx;
  	    var dy;

  	    if (!a) {
  	        dx = p1.x - p2.x;
  	        dy = p1.y - p2.y;
  	    } else {
  	        dx = p2.y - p1.y;
  	        dy = p1.x - p2.x;
  	    }

  	    state.pv = state.dpv = getUnitVector(dx, dy);
  	}

  	// SFVTL[a] Set Freedom Vector To Line
  	// 0x08-0x09
  	function SFVTL(a, state) {
  	    var stack = state.stack;
  	    var p2i = stack.pop();
  	    var p1i = stack.pop();
  	    var p2 = state.z2[p2i];
  	    var p1 = state.z1[p1i];

  	    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

  	    var dx;
  	    var dy;

  	    if (!a) {
  	        dx = p1.x - p2.x;
  	        dy = p1.y - p2.y;
  	    } else {
  	        dx = p2.y - p1.y;
  	        dy = p1.x - p2.x;
  	    }

  	    state.fv = getUnitVector(dx, dy);
  	}

  	// SPVFS[] Set Projection Vector From Stack
  	// 0x0A
  	function SPVFS(state) {
  	    var stack = state.stack;
  	    var y = stack.pop();
  	    var x = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

  	    state.pv = state.dpv = getUnitVector(x, y);
  	}

  	// SFVFS[] Set Freedom Vector From Stack
  	// 0x0B
  	function SFVFS(state) {
  	    var stack = state.stack;
  	    var y = stack.pop();
  	    var x = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

  	    state.fv = getUnitVector(x, y);
  	}

  	// GPV[] Get Projection Vector
  	// 0x0C
  	function GPV(state) {
  	    var stack = state.stack;
  	    var pv = state.pv;

  	    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

  	    stack.push(pv.x * 0x4000);
  	    stack.push(pv.y * 0x4000);
  	}

  	// GFV[] Get Freedom Vector
  	// 0x0C
  	function GFV(state) {
  	    var stack = state.stack;
  	    var fv = state.fv;

  	    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

  	    stack.push(fv.x * 0x4000);
  	    stack.push(fv.y * 0x4000);
  	}

  	// SFVTPV[] Set Freedom Vector To Projection Vector
  	// 0x0E
  	function SFVTPV(state) {
  	    state.fv = state.pv;

  	    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
  	}

  	// ISECT[] moves point p to the InterSECTion of two lines
  	// 0x0F
  	function ISECT(state)
  	{
  	    var stack = state.stack;
  	    var pa0i = stack.pop();
  	    var pa1i = stack.pop();
  	    var pb0i = stack.pop();
  	    var pb1i = stack.pop();
  	    var pi = stack.pop();
  	    var z0 = state.z0;
  	    var z1 = state.z1;
  	    var pa0 = z0[pa0i];
  	    var pa1 = z0[pa1i];
  	    var pb0 = z1[pb0i];
  	    var pb1 = z1[pb1i];
  	    var p = state.z2[pi];

  	    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

  	    // math from
  	    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

  	    var x1 = pa0.x;
  	    var y1 = pa0.y;
  	    var x2 = pa1.x;
  	    var y2 = pa1.y;
  	    var x3 = pb0.x;
  	    var y3 = pb0.y;
  	    var x4 = pb1.x;
  	    var y4 = pb1.y;

  	    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  	    var f1 = x1 * y2 - y1 * x2;
  	    var f2 = x3 * y4 - y3 * x4;

  	    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
  	    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
  	}

  	// SRP0[] Set Reference Point 0
  	// 0x10
  	function SRP0(state) {
  	    state.rp0 = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
  	}

  	// SRP1[] Set Reference Point 1
  	// 0x11
  	function SRP1(state) {
  	    state.rp1 = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
  	}

  	// SRP1[] Set Reference Point 2
  	// 0x12
  	function SRP2(state) {
  	    state.rp2 = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
  	}

  	// SZP0[] Set Zone Pointer 0
  	// 0x13
  	function SZP0(state) {
  	    var n = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

  	    state.zp0 = n;

  	    switch (n) {
  	        case 0:
  	            if (!state.tZone) { initTZone(state); }
  	            state.z0 = state.tZone;
  	            break;
  	        case 1 :
  	            state.z0 = state.gZone;
  	            break;
  	        default :
  	            throw new Error('Invalid zone pointer');
  	    }
  	}

  	// SZP1[] Set Zone Pointer 1
  	// 0x14
  	function SZP1(state) {
  	    var n = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

  	    state.zp1 = n;

  	    switch (n) {
  	        case 0:
  	            if (!state.tZone) { initTZone(state); }
  	            state.z1 = state.tZone;
  	            break;
  	        case 1 :
  	            state.z1 = state.gZone;
  	            break;
  	        default :
  	            throw new Error('Invalid zone pointer');
  	    }
  	}

  	// SZP2[] Set Zone Pointer 2
  	// 0x15
  	function SZP2(state) {
  	    var n = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

  	    state.zp2 = n;

  	    switch (n) {
  	        case 0:
  	            if (!state.tZone) { initTZone(state); }
  	            state.z2 = state.tZone;
  	            break;
  	        case 1 :
  	            state.z2 = state.gZone;
  	            break;
  	        default :
  	            throw new Error('Invalid zone pointer');
  	    }
  	}

  	// SZPS[] Set Zone PointerS
  	// 0x16
  	function SZPS(state) {
  	    var n = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

  	    state.zp0 = state.zp1 = state.zp2 = n;

  	    switch (n) {
  	        case 0:
  	            if (!state.tZone) { initTZone(state); }
  	            state.z0 = state.z1 = state.z2 = state.tZone;
  	            break;
  	        case 1 :
  	            state.z0 = state.z1 = state.z2 = state.gZone;
  	            break;
  	        default :
  	            throw new Error('Invalid zone pointer');
  	    }
  	}

  	// SLOOP[] Set LOOP variable
  	// 0x17
  	function SLOOP(state) {
  	    state.loop = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
  	}

  	// RTG[] Round To Grid
  	// 0x18
  	function RTG(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

  	    state.round = roundToGrid;
  	}

  	// RTHG[] Round To Half Grid
  	// 0x19
  	function RTHG(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

  	    state.round = roundToHalfGrid;
  	}

  	// SMD[] Set Minimum Distance
  	// 0x1A
  	function SMD(state) {
  	    var d = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

  	    state.minDis = d / 0x40;
  	}

  	// ELSE[] ELSE clause
  	// 0x1B
  	function ELSE(state) {
  	    // This instruction has been reached by executing a then branch
  	    // so it just skips ahead until matching EIF.
  	    //
  	    // In case the IF was negative the IF[] instruction already
  	    // skipped forward over the ELSE[]

  	    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

  	    skip(state, false);
  	}

  	// JMPR[] JuMP Relative
  	// 0x1C
  	function JMPR(state) {
  	    var o = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

  	    // A jump by 1 would do nothing.
  	    state.ip += o - 1;
  	}

  	// SCVTCI[] Set Control Value Table Cut-In
  	// 0x1D
  	function SCVTCI(state) {
  	    var n = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

  	    state.cvCutIn = n / 0x40;
  	}

  	// DUP[] DUPlicate top stack element
  	// 0x20
  	function DUP(state) {
  	    var stack = state.stack;

  	    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

  	    stack.push(stack[stack.length - 1]);
  	}

  	// POP[] POP top stack element
  	// 0x21
  	function POP(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

  	    state.stack.pop();
  	}

  	// CLEAR[] CLEAR the stack
  	// 0x22
  	function CLEAR(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

  	    state.stack.length = 0;
  	}

  	// SWAP[] SWAP the top two elements on the stack
  	// 0x23
  	function SWAP(state) {
  	    var stack = state.stack;

  	    var a = stack.pop();
  	    var b = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

  	    stack.push(a);
  	    stack.push(b);
  	}

  	// DEPTH[] DEPTH of the stack
  	// 0x24
  	function DEPTH(state) {
  	    var stack = state.stack;

  	    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

  	    stack.push(stack.length);
  	}

  	// LOOPCALL[] LOOPCALL function
  	// 0x2A
  	function LOOPCALL(state) {
  	    var stack = state.stack;
  	    var fn = stack.pop();
  	    var c = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

  	    // saves callers program
  	    var cip = state.ip;
  	    var cprog = state.prog;

  	    state.prog = state.funcs[fn];

  	    // executes the function
  	    for (var i = 0; i < c; i++) {
  	        exec(state);

  	        if (exports.DEBUG) { console.log(
  	            ++state.step,
  	            i + 1 < c ? 'next loopcall' : 'done loopcall',
  	            i
  	        ); }
  	    }

  	    // restores the callers program
  	    state.ip = cip;
  	    state.prog = cprog;
  	}

  	// CALL[] CALL function
  	// 0x2B
  	function CALL(state) {
  	    var fn = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

  	    // saves callers program
  	    var cip = state.ip;
  	    var cprog = state.prog;

  	    state.prog = state.funcs[fn];

  	    // executes the function
  	    exec(state);

  	    // restores the callers program
  	    state.ip = cip;
  	    state.prog = cprog;

  	    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
  	}

  	// CINDEX[] Copy the INDEXed element to the top of the stack
  	// 0x25
  	function CINDEX(state) {
  	    var stack = state.stack;
  	    var k = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

  	    // In case of k == 1, it copies the last element after popping
  	    // thus stack.length - k.
  	    stack.push(stack[stack.length - k]);
  	}

  	// MINDEX[] Move the INDEXed element to the top of the stack
  	// 0x26
  	function MINDEX(state) {
  	    var stack = state.stack;
  	    var k = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

  	    stack.push(stack.splice(stack.length - k, 1)[0]);
  	}

  	// FDEF[] Function DEFinition
  	// 0x2C
  	function FDEF(state) {
  	    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
  	    var stack = state.stack;
  	    var prog = state.prog;
  	    var ip = state.ip;

  	    var fn = stack.pop();
  	    var ipBegin = ip;

  	    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

  	    while (prog[++ip] !== 0x2D){ }

  	    state.ip = ip;
  	    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
  	}

  	// MDAP[a] Move Direct Absolute Point
  	// 0x2E-0x2F
  	function MDAP(round, state) {
  	    var pi = state.stack.pop();
  	    var p = state.z0[pi];
  	    var fv = state.fv;
  	    var pv = state.pv;

  	    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

  	    var d = pv.distance(p, HPZero);

  	    if (round) { d = state.round(d); }

  	    fv.setRelative(p, HPZero, d, pv);
  	    fv.touch(p);

  	    state.rp0 = state.rp1 = pi;
  	}

  	// IUP[a] Interpolate Untouched Points through the outline
  	// 0x30
  	function IUP(v, state) {
  	    var z2 = state.z2;
  	    var pLen = z2.length - 2;
  	    var cp;
  	    var pp;
  	    var np;

  	    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

  	    for (var i = 0; i < pLen; i++) {
  	        cp = z2[i]; // current point

  	        // if this point has been touched go on
  	        if (v.touched(cp)) { continue; }

  	        pp = cp.prevTouched(v);

  	        // no point on the contour has been touched?
  	        if (pp === cp) { continue; }

  	        np = cp.nextTouched(v);

  	        if (pp === np) {
  	            // only one point on the contour has been touched
  	            // so simply moves the point like that

  	            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
  	        }

  	        v.interpolate(cp, pp, np, v);
  	    }
  	}

  	// SHP[] SHift Point using reference point
  	// 0x32-0x33
  	function SHP(a, state) {
  	    var stack = state.stack;
  	    var rpi = a ? state.rp1 : state.rp2;
  	    var rp = (a ? state.z0 : state.z1)[rpi];
  	    var fv = state.fv;
  	    var pv = state.pv;
  	    var loop = state.loop;
  	    var z2 = state.z2;

  	    while (loop--)
  	    {
  	        var pi = stack.pop();
  	        var p = z2[pi];

  	        var d = pv.distance(rp, rp, false, true);
  	        fv.setRelative(p, p, d, pv);
  	        fv.touch(p);

  	        if (exports.DEBUG) {
  	            console.log(
  	                state.step,
  	                (state.loop > 1 ?
  	                   'loop ' + (state.loop - loop) + ': ' :
  	                   ''
  	                ) +
  	                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
  	            );
  	        }
  	    }

  	    state.loop = 1;
  	}

  	// SHC[] SHift Contour using reference point
  	// 0x36-0x37
  	function SHC(a, state) {
  	    var stack = state.stack;
  	    var rpi = a ? state.rp1 : state.rp2;
  	    var rp = (a ? state.z0 : state.z1)[rpi];
  	    var fv = state.fv;
  	    var pv = state.pv;
  	    var ci = stack.pop();
  	    var sp = state.z2[state.contours[ci]];
  	    var p = sp;

  	    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

  	    var d = pv.distance(rp, rp, false, true);

  	    do {
  	        if (p !== rp) { fv.setRelative(p, p, d, pv); }
  	        p = p.nextPointOnContour;
  	    } while (p !== sp);
  	}

  	// SHZ[] SHift Zone using reference point
  	// 0x36-0x37
  	function SHZ(a, state) {
  	    var stack = state.stack;
  	    var rpi = a ? state.rp1 : state.rp2;
  	    var rp = (a ? state.z0 : state.z1)[rpi];
  	    var fv = state.fv;
  	    var pv = state.pv;

  	    var e = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

  	    var z;
  	    switch (e) {
  	        case 0 : z = state.tZone; break;
  	        case 1 : z = state.gZone; break;
  	        default : throw new Error('Invalid zone');
  	    }

  	    var p;
  	    var d = pv.distance(rp, rp, false, true);
  	    var pLen = z.length - 2;
  	    for (var i = 0; i < pLen; i++)
  	    {
  	        p = z[i];
  	        fv.setRelative(p, p, d, pv);
  	        //if (p !== rp) fv.setRelative(p, p, d, pv);
  	    }
  	}

  	// SHPIX[] SHift point by a PIXel amount
  	// 0x38
  	function SHPIX(state) {
  	    var stack = state.stack;
  	    var loop = state.loop;
  	    var fv = state.fv;
  	    var d = stack.pop() / 0x40;
  	    var z2 = state.z2;

  	    while (loop--) {
  	        var pi = stack.pop();
  	        var p = z2[pi];

  	        if (exports.DEBUG) {
  	            console.log(
  	                state.step,
  	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
  	                'SHPIX[]', pi, d
  	            );
  	        }

  	        fv.setRelative(p, p, d);
  	        fv.touch(p);
  	    }

  	    state.loop = 1;
  	}

  	// IP[] Interpolate Point
  	// 0x39
  	function IP(state) {
  	    var stack = state.stack;
  	    var rp1i = state.rp1;
  	    var rp2i = state.rp2;
  	    var loop = state.loop;
  	    var rp1 = state.z0[rp1i];
  	    var rp2 = state.z1[rp2i];
  	    var fv = state.fv;
  	    var pv = state.dpv;
  	    var z2 = state.z2;

  	    while (loop--) {
  	        var pi = stack.pop();
  	        var p = z2[pi];

  	        if (exports.DEBUG) {
  	            console.log(
  	                state.step,
  	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
  	                'IP[]', pi, rp1i, '<->', rp2i
  	            );
  	        }

  	        fv.interpolate(p, rp1, rp2, pv);

  	        fv.touch(p);
  	    }

  	    state.loop = 1;
  	}

  	// MSIRP[a] Move Stack Indirect Relative Point
  	// 0x3A-0x3B
  	function MSIRP(a, state) {
  	    var stack = state.stack;
  	    var d = stack.pop() / 64;
  	    var pi = stack.pop();
  	    var p = state.z1[pi];
  	    var rp0 = state.z0[state.rp0];
  	    var fv = state.fv;
  	    var pv = state.pv;

  	    fv.setRelative(p, rp0, d, pv);
  	    fv.touch(p);

  	    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

  	    state.rp1 = state.rp0;
  	    state.rp2 = pi;
  	    if (a) { state.rp0 = pi; }
  	}

  	// ALIGNRP[] Align to reference point.
  	// 0x3C
  	function ALIGNRP(state) {
  	    var stack = state.stack;
  	    var rp0i = state.rp0;
  	    var rp0 = state.z0[rp0i];
  	    var loop = state.loop;
  	    var fv = state.fv;
  	    var pv = state.pv;
  	    var z1 = state.z1;

  	    while (loop--) {
  	        var pi = stack.pop();
  	        var p = z1[pi];

  	        if (exports.DEBUG) {
  	            console.log(
  	                state.step,
  	                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
  	                'ALIGNRP[]', pi
  	            );
  	        }

  	        fv.setRelative(p, rp0, 0, pv);
  	        fv.touch(p);
  	    }

  	    state.loop = 1;
  	}

  	// RTG[] Round To Double Grid
  	// 0x3D
  	function RTDG(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

  	    state.round = roundToDoubleGrid;
  	}

  	// MIAP[a] Move Indirect Absolute Point
  	// 0x3E-0x3F
  	function MIAP(round, state) {
  	    var stack = state.stack;
  	    var n = stack.pop();
  	    var pi = stack.pop();
  	    var p = state.z0[pi];
  	    var fv = state.fv;
  	    var pv = state.pv;
  	    var cv = state.cvt[n];

  	    if (exports.DEBUG) {
  	        console.log(
  	            state.step,
  	            'MIAP[' + round + ']',
  	            n, '(', cv, ')', pi
  	        );
  	    }

  	    var d = pv.distance(p, HPZero);

  	    if (round) {
  	        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }

  	        d = state.round(d);
  	    }

  	    fv.setRelative(p, HPZero, d, pv);

  	    if (state.zp0 === 0) {
  	        p.xo = p.x;
  	        p.yo = p.y;
  	    }

  	    fv.touch(p);

  	    state.rp0 = state.rp1 = pi;
  	}

  	// NPUSB[] PUSH N Bytes
  	// 0x40
  	function NPUSHB(state) {
  	    var prog = state.prog;
  	    var ip = state.ip;
  	    var stack = state.stack;

  	    var n = prog[++ip];

  	    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

  	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

  	    state.ip = ip;
  	}

  	// NPUSHW[] PUSH N Words
  	// 0x41
  	function NPUSHW(state) {
  	    var ip = state.ip;
  	    var prog = state.prog;
  	    var stack = state.stack;
  	    var n = prog[++ip];

  	    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

  	    for (var i = 0; i < n; i++) {
  	        var w = (prog[++ip] << 8) | prog[++ip];
  	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
  	        stack.push(w);
  	    }

  	    state.ip = ip;
  	}

  	// WS[] Write Store
  	// 0x42
  	function WS(state) {
  	    var stack = state.stack;
  	    var store = state.store;

  	    if (!store) { store = state.store = []; }

  	    var v = stack.pop();
  	    var l = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

  	    store[l] = v;
  	}

  	// RS[] Read Store
  	// 0x43
  	function RS(state) {
  	    var stack = state.stack;
  	    var store = state.store;

  	    var l = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'RS', l); }

  	    var v = (store && store[l]) || 0;

  	    stack.push(v);
  	}

  	// WCVTP[] Write Control Value Table in Pixel units
  	// 0x44
  	function WCVTP(state) {
  	    var stack = state.stack;

  	    var v = stack.pop();
  	    var l = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

  	    state.cvt[l] = v / 0x40;
  	}

  	// RCVT[] Read Control Value Table entry
  	// 0x45
  	function RCVT(state) {
  	    var stack = state.stack;
  	    var cvte = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

  	    stack.push(state.cvt[cvte] * 0x40);
  	}

  	// GC[] Get Coordinate projected onto the projection vector
  	// 0x46-0x47
  	function GC(a, state) {
  	    var stack = state.stack;
  	    var pi = stack.pop();
  	    var p = state.z2[pi];

  	    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

  	    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
  	}

  	// MD[a] Measure Distance
  	// 0x49-0x4A
  	function MD(a, state) {
  	    var stack = state.stack;
  	    var pi2 = stack.pop();
  	    var pi1 = stack.pop();
  	    var p2 = state.z1[pi2];
  	    var p1 = state.z0[pi1];
  	    var d = state.dpv.distance(p1, p2, a, a);

  	    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

  	    state.stack.push(Math.round(d * 64));
  	}

  	// MPPEM[] Measure Pixels Per EM
  	// 0x4B
  	function MPPEM(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
  	    state.stack.push(state.ppem);
  	}

  	// FLIPON[] set the auto FLIP Boolean to ON
  	// 0x4D
  	function FLIPON(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
  	    state.autoFlip = true;
  	}

  	// LT[] Less Than
  	// 0x50
  	function LT(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

  	    stack.push(e1 < e2 ? 1 : 0);
  	}

  	// LTEQ[] Less Than or EQual
  	// 0x53
  	function LTEQ(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

  	    stack.push(e1 <= e2 ? 1 : 0);
  	}

  	// GTEQ[] Greater Than
  	// 0x52
  	function GT(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

  	    stack.push(e1 > e2 ? 1 : 0);
  	}

  	// GTEQ[] Greater Than or EQual
  	// 0x53
  	function GTEQ(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

  	    stack.push(e1 >= e2 ? 1 : 0);
  	}

  	// EQ[] EQual
  	// 0x54
  	function EQ(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

  	    stack.push(e2 === e1 ? 1 : 0);
  	}

  	// NEQ[] Not EQual
  	// 0x55
  	function NEQ(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

  	    stack.push(e2 !== e1 ? 1 : 0);
  	}

  	// ODD[] ODD
  	// 0x56
  	function ODD(state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

  	    stack.push(Math.trunc(n) % 2 ? 1 : 0);
  	}

  	// EVEN[] EVEN
  	// 0x57
  	function EVEN(state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

  	    stack.push(Math.trunc(n) % 2 ? 0 : 1);
  	}

  	// IF[] IF test
  	// 0x58
  	function IF(state) {
  	    var test = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

  	    // if test is true it just continues
  	    // if not the ip is skipped until matching ELSE or EIF
  	    if (!test) {
  	        skip(state, true);

  	        if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
  	    }
  	}

  	// EIF[] End IF
  	// 0x59
  	function EIF(state) {
  	    // this can be reached normally when
  	    // executing an else branch.
  	    // -> just ignore it

  	    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
  	}

  	// AND[] logical AND
  	// 0x5A
  	function AND(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

  	    stack.push(e2 && e1 ? 1 : 0);
  	}

  	// OR[] logical OR
  	// 0x5B
  	function OR(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

  	    stack.push(e2 || e1 ? 1 : 0);
  	}

  	// NOT[] logical NOT
  	// 0x5C
  	function NOT(state) {
  	    var stack = state.stack;
  	    var e = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

  	    stack.push(e ? 0 : 1);
  	}

  	// DELTAP1[] DELTA exception P1
  	// DELTAP2[] DELTA exception P2
  	// DELTAP3[] DELTA exception P3
  	// 0x5D, 0x71, 0x72
  	function DELTAP123(b, state) {
  	    var stack = state.stack;
  	    var n = stack.pop();
  	    var fv = state.fv;
  	    var pv = state.pv;
  	    var ppem = state.ppem;
  	    var base = state.deltaBase + (b - 1) * 16;
  	    var ds = state.deltaShift;
  	    var z0 = state.z0;

  	    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

  	    for (var i = 0; i < n; i++) {
  	        var pi = stack.pop();
  	        var arg = stack.pop();
  	        var appem = base + ((arg & 0xF0) >> 4);
  	        if (appem !== ppem) { continue; }

  	        var mag = (arg & 0x0F) - 8;
  	        if (mag >= 0) { mag++; }
  	        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

  	        var p = z0[pi];
  	        fv.setRelative(p, p, mag * ds, pv);
  	    }
  	}

  	// SDB[] Set Delta Base in the graphics state
  	// 0x5E
  	function SDB(state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

  	    state.deltaBase = n;
  	}

  	// SDS[] Set Delta Shift in the graphics state
  	// 0x5F
  	function SDS(state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

  	    state.deltaShift = Math.pow(0.5, n);
  	}

  	// ADD[] ADD
  	// 0x60
  	function ADD(state) {
  	    var stack = state.stack;
  	    var n2 = stack.pop();
  	    var n1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

  	    stack.push(n1 + n2);
  	}

  	// SUB[] SUB
  	// 0x61
  	function SUB(state) {
  	    var stack = state.stack;
  	    var n2 = stack.pop();
  	    var n1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

  	    stack.push(n1 - n2);
  	}

  	// DIV[] DIV
  	// 0x62
  	function DIV(state) {
  	    var stack = state.stack;
  	    var n2 = stack.pop();
  	    var n1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

  	    stack.push(n1 * 64 / n2);
  	}

  	// MUL[] MUL
  	// 0x63
  	function MUL(state) {
  	    var stack = state.stack;
  	    var n2 = stack.pop();
  	    var n1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

  	    stack.push(n1 * n2 / 64);
  	}

  	// ABS[] ABSolute value
  	// 0x64
  	function ABS(state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

  	    stack.push(Math.abs(n));
  	}

  	// NEG[] NEGate
  	// 0x65
  	function NEG(state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

  	    stack.push(-n);
  	}

  	// FLOOR[] FLOOR
  	// 0x66
  	function FLOOR(state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

  	    stack.push(Math.floor(n / 0x40) * 0x40);
  	}

  	// CEILING[] CEILING
  	// 0x67
  	function CEILING(state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

  	    stack.push(Math.ceil(n / 0x40) * 0x40);
  	}

  	// ROUND[ab] ROUND value
  	// 0x68-0x6B
  	function ROUND(dt, state) {
  	    var stack = state.stack;
  	    var n = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

  	    stack.push(state.round(n / 0x40) * 0x40);
  	}

  	// WCVTF[] Write Control Value Table in Funits
  	// 0x70
  	function WCVTF(state) {
  	    var stack = state.stack;
  	    var v = stack.pop();
  	    var l = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

  	    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
  	}

  	// DELTAC1[] DELTA exception C1
  	// DELTAC2[] DELTA exception C2
  	// DELTAC3[] DELTA exception C3
  	// 0x73, 0x74, 0x75
  	function DELTAC123(b, state) {
  	    var stack = state.stack;
  	    var n = stack.pop();
  	    var ppem = state.ppem;
  	    var base = state.deltaBase + (b - 1) * 16;
  	    var ds = state.deltaShift;

  	    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

  	    for (var i = 0; i < n; i++) {
  	        var c = stack.pop();
  	        var arg = stack.pop();
  	        var appem = base + ((arg & 0xF0) >> 4);
  	        if (appem !== ppem) { continue; }

  	        var mag = (arg & 0x0F) - 8;
  	        if (mag >= 0) { mag++; }

  	        var delta = mag * ds;

  	        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

  	        state.cvt[c] += delta;
  	    }
  	}

  	// SROUND[] Super ROUND
  	// 0x76
  	function SROUND(state) {
  	    var n = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

  	    state.round = roundSuper;

  	    var period;

  	    switch (n & 0xC0) {
  	        case 0x00:
  	            period = 0.5;
  	            break;
  	        case 0x40:
  	            period = 1;
  	            break;
  	        case 0x80:
  	            period = 2;
  	            break;
  	        default:
  	            throw new Error('invalid SROUND value');
  	    }

  	    state.srPeriod = period;

  	    switch (n & 0x30) {
  	        case 0x00:
  	            state.srPhase = 0;
  	            break;
  	        case 0x10:
  	            state.srPhase = 0.25 * period;
  	            break;
  	        case 0x20:
  	            state.srPhase = 0.5  * period;
  	            break;
  	        case 0x30:
  	            state.srPhase = 0.75 * period;
  	            break;
  	        default: throw new Error('invalid SROUND value');
  	    }

  	    n &= 0x0F;

  	    if (n === 0) { state.srThreshold = 0; }
  	    else { state.srThreshold = (n / 8 - 0.5) * period; }
  	}

  	// S45ROUND[] Super ROUND 45 degrees
  	// 0x77
  	function S45ROUND(state) {
  	    var n = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

  	    state.round = roundSuper;

  	    var period;

  	    switch (n & 0xC0) {
  	        case 0x00:
  	            period = Math.sqrt(2) / 2;
  	            break;
  	        case 0x40:
  	            period = Math.sqrt(2);
  	            break;
  	        case 0x80:
  	            period = 2 * Math.sqrt(2);
  	            break;
  	        default:
  	            throw new Error('invalid S45ROUND value');
  	    }

  	    state.srPeriod = period;

  	    switch (n & 0x30) {
  	        case 0x00:
  	            state.srPhase = 0;
  	            break;
  	        case 0x10:
  	            state.srPhase = 0.25 * period;
  	            break;
  	        case 0x20:
  	            state.srPhase = 0.5  * period;
  	            break;
  	        case 0x30:
  	            state.srPhase = 0.75 * period;
  	            break;
  	        default:
  	            throw new Error('invalid S45ROUND value');
  	    }

  	    n &= 0x0F;

  	    if (n === 0) { state.srThreshold = 0; }
  	    else { state.srThreshold = (n / 8 - 0.5) * period; }
  	}

  	// ROFF[] Round Off
  	// 0x7A
  	function ROFF(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

  	    state.round = roundOff;
  	}

  	// RUTG[] Round Up To Grid
  	// 0x7C
  	function RUTG(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

  	    state.round = roundUpToGrid;
  	}

  	// RDTG[] Round Down To Grid
  	// 0x7D
  	function RDTG(state) {
  	    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

  	    state.round = roundDownToGrid;
  	}

  	// SCANCTRL[] SCAN conversion ConTRoL
  	// 0x85
  	function SCANCTRL(state) {
  	    var n = state.stack.pop();

  	    // ignored by opentype.js

  	    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
  	}

  	// SDPVTL[a] Set Dual Projection Vector To Line
  	// 0x86-0x87
  	function SDPVTL(a, state) {
  	    var stack = state.stack;
  	    var p2i = stack.pop();
  	    var p1i = stack.pop();
  	    var p2 = state.z2[p2i];
  	    var p1 = state.z1[p1i];

  	    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }

  	    var dx;
  	    var dy;

  	    if (!a) {
  	        dx = p1.x - p2.x;
  	        dy = p1.y - p2.y;
  	    } else {
  	        dx = p2.y - p1.y;
  	        dy = p1.x - p2.x;
  	    }

  	    state.dpv = getUnitVector(dx, dy);
  	}

  	// GETINFO[] GET INFOrmation
  	// 0x88
  	function GETINFO(state) {
  	    var stack = state.stack;
  	    var sel = stack.pop();
  	    var r = 0;

  	    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

  	    // v35 as in no subpixel hinting
  	    if (sel & 0x01) { r = 35; }

  	    // TODO rotation and stretch currently not supported
  	    // and thus those GETINFO are always 0.

  	    // opentype.js is always gray scaling
  	    if (sel & 0x20) { r |= 0x1000; }

  	    stack.push(r);
  	}

  	// ROLL[] ROLL the top three stack elements
  	// 0x8A
  	function ROLL(state) {
  	    var stack = state.stack;
  	    var a = stack.pop();
  	    var b = stack.pop();
  	    var c = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

  	    stack.push(b);
  	    stack.push(a);
  	    stack.push(c);
  	}

  	// MAX[] MAXimum of top two stack elements
  	// 0x8B
  	function MAX(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

  	    stack.push(Math.max(e1, e2));
  	}

  	// MIN[] MINimum of top two stack elements
  	// 0x8C
  	function MIN(state) {
  	    var stack = state.stack;
  	    var e2 = stack.pop();
  	    var e1 = stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

  	    stack.push(Math.min(e1, e2));
  	}

  	// SCANTYPE[] SCANTYPE
  	// 0x8D
  	function SCANTYPE(state) {
  	    var n = state.stack.pop();
  	    // ignored by opentype.js
  	    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
  	}

  	// INSTCTRL[] INSTCTRL
  	// 0x8D
  	function INSTCTRL(state) {
  	    var s = state.stack.pop();
  	    var v = state.stack.pop();

  	    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

  	    switch (s) {
  	        case 1 : state.inhibitGridFit = !!v; return;
  	        case 2 : state.ignoreCvt = !!v; return;
  	        default: throw new Error('invalid INSTCTRL[] selector');
  	    }
  	}

  	// PUSHB[abc] PUSH Bytes
  	// 0xB0-0xB7
  	function PUSHB(n, state) {
  	    var stack = state.stack;
  	    var prog = state.prog;
  	    var ip = state.ip;

  	    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

  	    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

  	    state.ip = ip;
  	}

  	// PUSHW[abc] PUSH Words
  	// 0xB8-0xBF
  	function PUSHW(n, state) {
  	    var ip = state.ip;
  	    var prog = state.prog;
  	    var stack = state.stack;

  	    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

  	    for (var i = 0; i < n; i++) {
  	        var w = (prog[++ip] << 8) | prog[++ip];
  	        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
  	        stack.push(w);
  	    }

  	    state.ip = ip;
  	}

  	// MDRP[abcde] Move Direct Relative Point
  	// 0xD0-0xEF
  	// (if indirect is 0)
  	//
  	// and
  	//
  	// MIRP[abcde] Move Indirect Relative Point
  	// 0xE0-0xFF
  	// (if indirect is 1)

  	function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
  	    var stack = state.stack;
  	    var cvte = indirect && stack.pop();
  	    var pi = stack.pop();
  	    var rp0i = state.rp0;
  	    var rp = state.z0[rp0i];
  	    var p = state.z1[pi];

  	    var md = state.minDis;
  	    var fv = state.fv;
  	    var pv = state.dpv;
  	    var od; // original distance
  	    var d; // moving distance
  	    var sign; // sign of distance
  	    var cv;

  	    d = od = pv.distance(p, rp, true, true);
  	    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

  	    // TODO consider autoFlip
  	    d = Math.abs(d);

  	    if (indirect) {
  	        cv = state.cvt[cvte];

  	        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
  	    }

  	    if (keepD && d < md) { d = md; }

  	    if (ro) { d = state.round(d); }

  	    fv.setRelative(p, rp, sign * d, pv);
  	    fv.touch(p);

  	    if (exports.DEBUG) {
  	        console.log(
  	            state.step,
  	            (indirect ? 'MIRP[' : 'MDRP[') +
  	            (setRp0 ? 'M' : 'm') +
  	            (keepD ? '>' : '_') +
  	            (ro ? 'R' : '_') +
  	            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
  	            ']',
  	            indirect ?
  	                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
  	                '',
  	            pi,
  	            '(d =', od, '->', sign * d, ')'
  	        );
  	    }

  	    state.rp1 = state.rp0;
  	    state.rp2 = pi;
  	    if (setRp0) { state.rp0 = pi; }
  	}

  	/*
  	* The instruction table.
  	*/
  	instructionTable = [
  	    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
  	    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
  	    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
  	    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
  	    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
  	    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
  	    /* 0x06 */ SPVTL.bind(undefined, 0),
  	    /* 0x07 */ SPVTL.bind(undefined, 1),
  	    /* 0x08 */ SFVTL.bind(undefined, 0),
  	    /* 0x09 */ SFVTL.bind(undefined, 1),
  	    /* 0x0A */ SPVFS,
  	    /* 0x0B */ SFVFS,
  	    /* 0x0C */ GPV,
  	    /* 0x0D */ GFV,
  	    /* 0x0E */ SFVTPV,
  	    /* 0x0F */ ISECT,
  	    /* 0x10 */ SRP0,
  	    /* 0x11 */ SRP1,
  	    /* 0x12 */ SRP2,
  	    /* 0x13 */ SZP0,
  	    /* 0x14 */ SZP1,
  	    /* 0x15 */ SZP2,
  	    /* 0x16 */ SZPS,
  	    /* 0x17 */ SLOOP,
  	    /* 0x18 */ RTG,
  	    /* 0x19 */ RTHG,
  	    /* 0x1A */ SMD,
  	    /* 0x1B */ ELSE,
  	    /* 0x1C */ JMPR,
  	    /* 0x1D */ SCVTCI,
  	    /* 0x1E */ undefined,   // TODO SSWCI
  	    /* 0x1F */ undefined,   // TODO SSW
  	    /* 0x20 */ DUP,
  	    /* 0x21 */ POP,
  	    /* 0x22 */ CLEAR,
  	    /* 0x23 */ SWAP,
  	    /* 0x24 */ DEPTH,
  	    /* 0x25 */ CINDEX,
  	    /* 0x26 */ MINDEX,
  	    /* 0x27 */ undefined,   // TODO ALIGNPTS
  	    /* 0x28 */ undefined,
  	    /* 0x29 */ undefined,   // TODO UTP
  	    /* 0x2A */ LOOPCALL,
  	    /* 0x2B */ CALL,
  	    /* 0x2C */ FDEF,
  	    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
  	    /* 0x2E */ MDAP.bind(undefined, 0),
  	    /* 0x2F */ MDAP.bind(undefined, 1),
  	    /* 0x30 */ IUP.bind(undefined, yUnitVector),
  	    /* 0x31 */ IUP.bind(undefined, xUnitVector),
  	    /* 0x32 */ SHP.bind(undefined, 0),
  	    /* 0x33 */ SHP.bind(undefined, 1),
  	    /* 0x34 */ SHC.bind(undefined, 0),
  	    /* 0x35 */ SHC.bind(undefined, 1),
  	    /* 0x36 */ SHZ.bind(undefined, 0),
  	    /* 0x37 */ SHZ.bind(undefined, 1),
  	    /* 0x38 */ SHPIX,
  	    /* 0x39 */ IP,
  	    /* 0x3A */ MSIRP.bind(undefined, 0),
  	    /* 0x3B */ MSIRP.bind(undefined, 1),
  	    /* 0x3C */ ALIGNRP,
  	    /* 0x3D */ RTDG,
  	    /* 0x3E */ MIAP.bind(undefined, 0),
  	    /* 0x3F */ MIAP.bind(undefined, 1),
  	    /* 0x40 */ NPUSHB,
  	    /* 0x41 */ NPUSHW,
  	    /* 0x42 */ WS,
  	    /* 0x43 */ RS,
  	    /* 0x44 */ WCVTP,
  	    /* 0x45 */ RCVT,
  	    /* 0x46 */ GC.bind(undefined, 0),
  	    /* 0x47 */ GC.bind(undefined, 1),
  	    /* 0x48 */ undefined,   // TODO SCFS
  	    /* 0x49 */ MD.bind(undefined, 0),
  	    /* 0x4A */ MD.bind(undefined, 1),
  	    /* 0x4B */ MPPEM,
  	    /* 0x4C */ undefined,   // TODO MPS
  	    /* 0x4D */ FLIPON,
  	    /* 0x4E */ undefined,   // TODO FLIPOFF
  	    /* 0x4F */ undefined,   // TODO DEBUG
  	    /* 0x50 */ LT,
  	    /* 0x51 */ LTEQ,
  	    /* 0x52 */ GT,
  	    /* 0x53 */ GTEQ,
  	    /* 0x54 */ EQ,
  	    /* 0x55 */ NEQ,
  	    /* 0x56 */ ODD,
  	    /* 0x57 */ EVEN,
  	    /* 0x58 */ IF,
  	    /* 0x59 */ EIF,
  	    /* 0x5A */ AND,
  	    /* 0x5B */ OR,
  	    /* 0x5C */ NOT,
  	    /* 0x5D */ DELTAP123.bind(undefined, 1),
  	    /* 0x5E */ SDB,
  	    /* 0x5F */ SDS,
  	    /* 0x60 */ ADD,
  	    /* 0x61 */ SUB,
  	    /* 0x62 */ DIV,
  	    /* 0x63 */ MUL,
  	    /* 0x64 */ ABS,
  	    /* 0x65 */ NEG,
  	    /* 0x66 */ FLOOR,
  	    /* 0x67 */ CEILING,
  	    /* 0x68 */ ROUND.bind(undefined, 0),
  	    /* 0x69 */ ROUND.bind(undefined, 1),
  	    /* 0x6A */ ROUND.bind(undefined, 2),
  	    /* 0x6B */ ROUND.bind(undefined, 3),
  	    /* 0x6C */ undefined,   // TODO NROUND[ab]
  	    /* 0x6D */ undefined,   // TODO NROUND[ab]
  	    /* 0x6E */ undefined,   // TODO NROUND[ab]
  	    /* 0x6F */ undefined,   // TODO NROUND[ab]
  	    /* 0x70 */ WCVTF,
  	    /* 0x71 */ DELTAP123.bind(undefined, 2),
  	    /* 0x72 */ DELTAP123.bind(undefined, 3),
  	    /* 0x73 */ DELTAC123.bind(undefined, 1),
  	    /* 0x74 */ DELTAC123.bind(undefined, 2),
  	    /* 0x75 */ DELTAC123.bind(undefined, 3),
  	    /* 0x76 */ SROUND,
  	    /* 0x77 */ S45ROUND,
  	    /* 0x78 */ undefined,   // TODO JROT[]
  	    /* 0x79 */ undefined,   // TODO JROF[]
  	    /* 0x7A */ ROFF,
  	    /* 0x7B */ undefined,
  	    /* 0x7C */ RUTG,
  	    /* 0x7D */ RDTG,
  	    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
  	    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
  	    /* 0x80 */ undefined,   // TODO FLIPPT
  	    /* 0x81 */ undefined,   // TODO FLIPRGON
  	    /* 0x82 */ undefined,   // TODO FLIPRGOFF
  	    /* 0x83 */ undefined,
  	    /* 0x84 */ undefined,
  	    /* 0x85 */ SCANCTRL,
  	    /* 0x86 */ SDPVTL.bind(undefined, 0),
  	    /* 0x87 */ SDPVTL.bind(undefined, 1),
  	    /* 0x88 */ GETINFO,
  	    /* 0x89 */ undefined,   // TODO IDEF
  	    /* 0x8A */ ROLL,
  	    /* 0x8B */ MAX,
  	    /* 0x8C */ MIN,
  	    /* 0x8D */ SCANTYPE,
  	    /* 0x8E */ INSTCTRL,
  	    /* 0x8F */ undefined,
  	    /* 0x90 */ undefined,
  	    /* 0x91 */ undefined,
  	    /* 0x92 */ undefined,
  	    /* 0x93 */ undefined,
  	    /* 0x94 */ undefined,
  	    /* 0x95 */ undefined,
  	    /* 0x96 */ undefined,
  	    /* 0x97 */ undefined,
  	    /* 0x98 */ undefined,
  	    /* 0x99 */ undefined,
  	    /* 0x9A */ undefined,
  	    /* 0x9B */ undefined,
  	    /* 0x9C */ undefined,
  	    /* 0x9D */ undefined,
  	    /* 0x9E */ undefined,
  	    /* 0x9F */ undefined,
  	    /* 0xA0 */ undefined,
  	    /* 0xA1 */ undefined,
  	    /* 0xA2 */ undefined,
  	    /* 0xA3 */ undefined,
  	    /* 0xA4 */ undefined,
  	    /* 0xA5 */ undefined,
  	    /* 0xA6 */ undefined,
  	    /* 0xA7 */ undefined,
  	    /* 0xA8 */ undefined,
  	    /* 0xA9 */ undefined,
  	    /* 0xAA */ undefined,
  	    /* 0xAB */ undefined,
  	    /* 0xAC */ undefined,
  	    /* 0xAD */ undefined,
  	    /* 0xAE */ undefined,
  	    /* 0xAF */ undefined,
  	    /* 0xB0 */ PUSHB.bind(undefined, 1),
  	    /* 0xB1 */ PUSHB.bind(undefined, 2),
  	    /* 0xB2 */ PUSHB.bind(undefined, 3),
  	    /* 0xB3 */ PUSHB.bind(undefined, 4),
  	    /* 0xB4 */ PUSHB.bind(undefined, 5),
  	    /* 0xB5 */ PUSHB.bind(undefined, 6),
  	    /* 0xB6 */ PUSHB.bind(undefined, 7),
  	    /* 0xB7 */ PUSHB.bind(undefined, 8),
  	    /* 0xB8 */ PUSHW.bind(undefined, 1),
  	    /* 0xB9 */ PUSHW.bind(undefined, 2),
  	    /* 0xBA */ PUSHW.bind(undefined, 3),
  	    /* 0xBB */ PUSHW.bind(undefined, 4),
  	    /* 0xBC */ PUSHW.bind(undefined, 5),
  	    /* 0xBD */ PUSHW.bind(undefined, 6),
  	    /* 0xBE */ PUSHW.bind(undefined, 7),
  	    /* 0xBF */ PUSHW.bind(undefined, 8),
  	    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
  	    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
  	    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
  	    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
  	    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
  	    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
  	    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
  	    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
  	    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
  	    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
  	    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
  	    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
  	    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
  	    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
  	    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
  	    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
  	    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
  	    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
  	    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
  	    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
  	    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
  	    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
  	    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
  	    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
  	    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
  	    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
  	    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
  	    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
  	    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
  	    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
  	    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
  	    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
  	    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
  	    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
  	    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
  	    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
  	    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
  	    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
  	    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
  	    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
  	    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
  	    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
  	    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
  	    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
  	    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
  	    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
  	    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
  	    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
  	    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
  	    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
  	    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
  	    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
  	    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
  	    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
  	    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
  	    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
  	    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
  	    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
  	    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
  	    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
  	    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
  	    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
  	    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
  	    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
  	];

  	/*****************************
  	  Mathematical Considerations
  	******************************

  	fv ... refers to freedom vector
  	pv ... refers to projection vector
  	rp ... refers to reference point
  	p  ... refers to to point being operated on
  	d  ... refers to distance

  	SETRELATIVE:
  	============

  	case freedom vector == x-axis:
  	------------------------------

  	                        (pv)
  	                     .-'
  	              rpd .-'
  	               .-*
  	          d .-'90Â°'
  	         .-'       '
  	      .-'           '
  	   *-'               ' b
  	  rp                  '
  	                       '
  	                        '
  	            p *----------*-------------- (fv)
  	                          pm

  	  rpdx = rpx + d * pv.x
  	  rpdy = rpy + d * pv.y

  	  equation of line b

  	   y - rpdy = pvns * (x- rpdx)

  	   y = p.y

  	   x = rpdx + ( p.y - rpdy ) / pvns


  	case freedom vector == y-axis:
  	------------------------------

  	    * pm
  	    |\
  	    | \
  	    |  \
  	    |   \
  	    |    \
  	    |     \
  	    |      \
  	    |       \
  	    |        \
  	    |         \ b
  	    |          \
  	    |           \
  	    |            \    .-' (pv)
  	    |         90Â° \.-'
  	    |           .-'* rpd
  	    |        .-'
  	    *     *-'  d
  	    p     rp

  	  rpdx = rpx + d * pv.x
  	  rpdy = rpy + d * pv.y

  	  equation of line b:
  	           pvns ... normal slope to pv

  	   y - rpdy = pvns * (x - rpdx)

  	   x = p.x

  	   y = rpdy +  pvns * (p.x - rpdx)



  	generic case:
  	-------------


  	                              .'(fv)
  	                            .'
  	                          .* pm
  	                        .' !
  	                      .'    .
  	                    .'      !
  	                  .'         . b
  	                .'           !
  	               *              .
  	              p               !
  	                         90Â°   .    ... (pv)
  	                           ...-*-'''
  	                  ...---'''    rpd
  	         ...---'''   d
  	   *--'''
  	  rp

  	    rpdx = rpx + d * pv.x
  	    rpdy = rpy + d * pv.y

  	 equation of line b:
  	    pvns... normal slope to pv

  	    y - rpdy = pvns * (x - rpdx)

  	 equation of freedom vector line:
  	    fvs ... slope of freedom vector (=fy/fx)

  	    y - py = fvs * (x - px)


  	  on pm both equations are true for same x/y

  	    y - rpdy = pvns * (x - rpdx)

  	    y - py = fvs * (x - px)

  	  form to y and set equal:

  	    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

  	  expand:

  	    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

  	  switch:

  	    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

  	  solve for x:

  	    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



  	          fvs * px - pvns * rpdx + rpdy - py
  	    x =  -----------------------------------
  	                 fvs - pvns

  	  and:

  	    y = fvs * (x - px) + py



  	INTERPOLATE:
  	============

  	Examples of point interpolation.

  	The weight of the movement of the reference point gets bigger
  	the further the other reference point is away, thus the safest
  	option (that is avoiding 0/0 divisions) is to weight the
  	original distance of the other point by the sum of both distances.

  	If the sum of both distances is 0, then move the point by the
  	arithmetic average of the movement of both reference points.




  	           (+6)
  	    rp1o *---->*rp1
  	         .     .                          (+12)
  	         .     .                  rp2o *---------->* rp2
  	         .     .                       .           .
  	         .     .                       .           .
  	         .    10          20           .           .
  	         |.........|...................|           .
  	               .   .                               .
  	               .   . (+8)                          .
  	                po *------>*p                      .
  	               .           .                       .
  	               .    12     .          24           .
  	               |...........|.......................|
  	                                  36


  	-------



  	           (+10)
  	    rp1o *-------->*rp1
  	         .         .                      (-10)
  	         .         .              rp2 *<---------* rpo2
  	         .         .                   .         .
  	         .         .                   .         .
  	         .    10   .          30       .         .
  	         |.........|.............................|
  	                   .                   .
  	                   . (+5)              .
  	                po *--->* p            .
  	                   .    .              .
  	                   .    .   20         .
  	                   |....|..............|
  	                     5        15


  	-------


  	           (+10)
  	    rp1o *-------->*rp1
  	         .         .
  	         .         .
  	    rp2o *-------->*rp2


  	                               (+10)
  	                          po *-------->* p

  	-------


  	           (+10)
  	    rp1o *-------->*rp1
  	         .         .
  	         .         .(+30)
  	    rp2o *---------------------------->*rp2


  	                                        (+25)
  	                          po *----------------------->* p



  	vim: set ts=4 sw=4 expandtab:
  	*****/

  	/**
  	 * Converts a string into a list of tokens.
  	 */

  	/**
  	 * Create a new token
  	 * @param {string} char a single char
  	 */
  	function Token(char) {
  	    this.char = char;
  	    this.state = {};
  	    this.activeState = null;
  	}

  	/**
  	 * Create a new context range
  	 * @param {number} startIndex range start index
  	 * @param {number} endOffset range end index offset
  	 * @param {string} contextName owner context name
  	 */
  	function ContextRange(startIndex, endOffset, contextName) {
  	    this.contextName = contextName;
  	    this.startIndex = startIndex;
  	    this.endOffset = endOffset;
  	}

  	/**
  	 * Check context start and end
  	 * @param {string} contextName a unique context name
  	 * @param {function} checkStart a predicate function the indicates a context's start
  	 * @param {function} checkEnd a predicate function the indicates a context's end
  	 */
  	function ContextChecker(contextName, checkStart, checkEnd) {
  	    this.contextName = contextName;
  	    this.openRange = null;
  	    this.ranges = [];
  	    this.checkStart = checkStart;
  	    this.checkEnd = checkEnd;
  	}

  	/**
  	 * Create a context params
  	 * @param {array} context a list of items
  	 * @param {number} currentIndex current item index
  	 */
  	function ContextParams(context, currentIndex) {
  	    this.context = context;
  	    this.index = currentIndex;
  	    this.length = context.length;
  	    this.current = context[currentIndex];
  	    this.backtrack = context.slice(0, currentIndex);
  	    this.lookahead = context.slice(currentIndex + 1);
  	}

  	/**
  	 * Create an event instance
  	 * @param {string} eventId event unique id
  	 */
  	function Event(eventId) {
  	    this.eventId = eventId;
  	    this.subscribers = [];
  	}

  	/**
  	 * Initialize a core events and auto subscribe required event handlers
  	 * @param {any} events an object that enlists core events handlers
  	 */
  	function initializeCoreEvents(events) {
  	    var this$1 = this;

  	    var coreEvents = [
  	        'start', 'end', 'next', 'newToken', 'contextStart',
  	        'contextEnd', 'insertToken', 'removeToken', 'removeRange',
  	        'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'
  	    ];

  	    coreEvents.forEach(function (eventId) {
  	        Object.defineProperty(this$1.events, eventId, {
  	            value: new Event(eventId)
  	        });
  	    });

  	    if (!!events) {
  	        coreEvents.forEach(function (eventId) {
  	            var event = events[eventId];
  	            if (typeof event === 'function') {
  	                this$1.events[eventId].subscribe(event);
  	            }
  	        });
  	    }
  	    var requiresContextUpdate = [
  	        'insertToken', 'removeToken', 'removeRange',
  	        'replaceToken', 'replaceRange', 'composeRUD'
  	    ];
  	    requiresContextUpdate.forEach(function (eventId) {
  	        this$1.events[eventId].subscribe(
  	            this$1.updateContextsRanges
  	        );
  	    });
  	}

  	/**
  	 * Converts a string into a list of tokens
  	 * @param {any} events tokenizer core events
  	 */
  	function Tokenizer(events) {
  	    this.tokens = [];
  	    this.registeredContexts = {};
  	    this.contextCheckers = [];
  	    this.events = {};
  	    this.registeredModifiers = [];

  	    initializeCoreEvents.call(this, events);
  	}

  	/**
  	 * Sets the state of a token, usually called by a state modifier.
  	 * @param {string} key state item key
  	 * @param {any} value state item value
  	 */
  	Token.prototype.setState = function(key, value) {
  	    this.state[key] = value;
  	    this.activeState = { key: key, value: this.state[key] };
  	    return this.activeState;
  	};

  	Token.prototype.getState = function (stateId) {
  	    return this.state[stateId] || null;
  	};

  	/**
  	 * Checks if an index exists in the tokens list.
  	 * @param {number} index token index
  	 */
  	Tokenizer.prototype.inboundIndex = function(index) {
  	    return index >= 0 && index < this.tokens.length;
  	};

  	/**
  	 * Compose and apply a list of operations (replace, update, delete)
  	 * @param {array} RUDs replace, update and delete operations
  	 * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)
  	 */
  	Tokenizer.prototype.composeRUD = function (RUDs) {
  	    var this$1 = this;

  	    var silent = true;
  	    var state = RUDs.map(function (RUD) { return (
  	        this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent))
  	    ); });
  	    var hasFAILObject = function (obj) { return (
  	        typeof obj === 'object' &&
  	        obj.hasOwnProperty('FAIL')
  	    ); };
  	    if (state.every(hasFAILObject)) {
  	        return {
  	            FAIL: "composeRUD: one or more operations hasn't completed successfully",
  	            report: state.filter(hasFAILObject)
  	        };
  	    }
  	    this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);
  	};

  	/**
  	 * Replace a range of tokens with a list of tokens
  	 * @param {number} startIndex range start index
  	 * @param {number} offset range offset
  	 * @param {token} tokens a list of tokens to replace
  	 * @param {boolean} silent dispatch events and update context ranges
  	 */
  	Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {
  	    offset = offset !== null ? offset : this.tokens.length;
  	    var isTokenType = tokens.every(function (token) { return token instanceof Token; });
  	    if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
  	        var replaced = this.tokens.splice.apply(
  	            this.tokens, [startIndex, offset].concat(tokens)
  	        );
  	        if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }
  	        return [replaced, tokens];
  	    } else {
  	        return { FAIL: 'replaceRange: invalid tokens or startIndex.' };
  	    }
  	};

  	/**
  	 * Replace a token with another token
  	 * @param {number} index token index
  	 * @param {token} token a token to replace
  	 * @param {boolean} silent dispatch events and update context ranges
  	 */
  	Tokenizer.prototype.replaceToken = function (index, token, silent) {
  	    if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
  	        var replaced = this.tokens.splice(index, 1, token);
  	        if (!silent) { this.dispatch('replaceToken', [index, token]); }
  	        return [replaced[0], token];
  	    } else {
  	        return { FAIL: 'replaceToken: invalid token or index.' };
  	    }
  	};

  	/**
  	 * Removes a range of tokens
  	 * @param {number} startIndex range start index
  	 * @param {number} offset range offset
  	 * @param {boolean} silent dispatch events and update context ranges
  	 */
  	Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
  	    offset = !isNaN(offset) ? offset : this.tokens.length;
  	    var tokens = this.tokens.splice(startIndex, offset);
  	    if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }
  	    return tokens;
  	};

  	/**
  	 * Remove a token at a certain index
  	 * @param {number} index token index
  	 * @param {boolean} silent dispatch events and update context ranges
  	 */
  	Tokenizer.prototype.removeToken = function(index, silent) {
  	    if (!isNaN(index) && this.inboundIndex(index)) {
  	        var token = this.tokens.splice(index, 1);
  	        if (!silent) { this.dispatch('removeToken', [token, index]); }
  	        return token;
  	    } else {
  	        return { FAIL: 'removeToken: invalid token index.' };
  	    }
  	};

  	/**
  	 * Insert a list of tokens at a certain index
  	 * @param {array} tokens a list of tokens to insert
  	 * @param {number} index insert the list of tokens at index
  	 * @param {boolean} silent dispatch events and update context ranges
  	 */
  	Tokenizer.prototype.insertToken = function (tokens, index, silent) {
  	    var tokenType = tokens.every(
  	        function (token) { return token instanceof Token; }
  	    );
  	    if (tokenType) {
  	        this.tokens.splice.apply(
  	            this.tokens, [index, 0].concat(tokens)
  	        );
  	        if (!silent) { this.dispatch('insertToken', [tokens, index]); }
  	        return tokens;
  	    } else {
  	        return { FAIL: 'insertToken: invalid token(s).' };
  	    }
  	};

  	/**
  	 * A state modifier that is called on 'newToken' event
  	 * @param {string} modifierId state modifier id
  	 * @param {function} condition a predicate function that returns true or false
  	 * @param {function} modifier a function to update token state
  	 */
  	Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
  	    this.events.newToken.subscribe(function(token, contextParams) {
  	        var conditionParams = [token, contextParams];
  	        var canApplyModifier = (
  	            condition === null ||
  	            condition.apply(this, conditionParams) === true
  	        );
  	        var modifierParams = [token, contextParams];
  	        if (canApplyModifier) {
  	            var newStateValue = modifier.apply(this, modifierParams);
  	            token.setState(modifierId, newStateValue);
  	        }
  	    });
  	    this.registeredModifiers.push(modifierId);
  	};

  	/**
  	 * Subscribe a handler to an event
  	 * @param {function} eventHandler an event handler function
  	 */
  	Event.prototype.subscribe = function (eventHandler) {
  	    if (typeof eventHandler === 'function') {
  	        return ((this.subscribers.push(eventHandler)) - 1);
  	    } else {
  	        return { FAIL: ("invalid '" + (this.eventId) + "' event handler")};
  	    }
  	};

  	/**
  	 * Unsubscribe an event handler
  	 * @param {string} subsId subscription id
  	 */
  	Event.prototype.unsubscribe = function (subsId) {
  	    this.subscribers.splice(subsId, 1);
  	};

  	/**
  	 * Sets context params current value index
  	 * @param {number} index context params current value index
  	 */
  	ContextParams.prototype.setCurrentIndex = function(index) {
  	    this.index = index;
  	    this.current = this.context[index];
  	    this.backtrack = this.context.slice(0, index);
  	    this.lookahead = this.context.slice(index + 1);
  	};

  	/**
  	 * Get an item at an offset from the current value
  	 * example (current value is 3):
  	 *  1    2   [3]   4    5   |   items values
  	 * -2   -1    0    1    2   |   offset values
  	 * @param {number} offset an offset from current value index
  	 */
  	ContextParams.prototype.get = function (offset) {
  	    switch (true) {
  	        case (offset === 0):
  	            return this.current;
  	        case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
  	            return this.backtrack.slice(offset)[0];
  	        case (offset > 0 && offset <= this.lookahead.length):
  	            return this.lookahead[offset - 1];
  	        default:
  	            return null;
  	    }
  	};

  	/**
  	 * Converts a context range into a string value
  	 * @param {contextRange} range a context range
  	 */
  	Tokenizer.prototype.rangeToText = function (range) {
  	    if (range instanceof ContextRange) {
  	        return (
  	            this.getRangeTokens(range)
  	                .map(function (token) { return token.char; }).join('')
  	        );
  	    }
  	};

  	/**
  	 * Converts all tokens into a string
  	 */
  	Tokenizer.prototype.getText = function () {
  	    return this.tokens.map(function (token) { return token.char; }).join('');
  	};

  	/**
  	 * Get a context by name
  	 * @param {string} contextName context name to get
  	 */
  	Tokenizer.prototype.getContext = function (contextName) {
  	    var context = this.registeredContexts[contextName];
  	    return !!context ? context : null;
  	};

  	/**
  	 * Subscribes a new event handler to an event
  	 * @param {string} eventName event name to subscribe to
  	 * @param {function} eventHandler a function to be invoked on event
  	 */
  	Tokenizer.prototype.on = function(eventName, eventHandler) {
  	    var event = this.events[eventName];
  	    if (!!event) {
  	        return event.subscribe(eventHandler);
  	    } else {
  	        return null;
  	    }
  	};

  	/**
  	 * Dispatches an event
  	 * @param {string} eventName event name
  	 * @param {any} args event handler arguments
  	 */
  	Tokenizer.prototype.dispatch = function(eventName, args) {
  	    var this$1 = this;

  	    var event = this.events[eventName];
  	    if (event instanceof Event) {
  	        event.subscribers.forEach(function (subscriber) {
  	            subscriber.apply(this$1, args || []);
  	        });
  	    }
  	};

  	/**
  	 * Register a new context checker
  	 * @param {string} contextName a unique context name
  	 * @param {function} contextStartCheck a predicate function that returns true on context start
  	 * @param {function} contextEndCheck  a predicate function that returns true on context end
  	 * TODO: call tokenize on registration to update context ranges with the new context.
  	 */
  	Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
  	    if (!!this.getContext(contextName)) { return {
  	        FAIL:
  	        ("context name '" + contextName + "' is already registered.")
  	    }; }
  	    if (typeof contextStartCheck !== 'function') { return {
  	        FAIL:
  	        "missing context start check."
  	    }; }
  	    if (typeof contextEndCheck !== 'function') { return {
  	        FAIL:
  	        "missing context end check."
  	    }; }
  	    var contextCheckers = new ContextChecker(
  	        contextName, contextStartCheck, contextEndCheck
  	    );
  	    this.registeredContexts[contextName] = contextCheckers;
  	    this.contextCheckers.push(contextCheckers);
  	    return contextCheckers;
  	};

  	/**
  	 * Gets a context range tokens
  	 * @param {contextRange} range a context range
  	 */
  	Tokenizer.prototype.getRangeTokens = function(range) {
  	    var endIndex = range.startIndex + range.endOffset;
  	    return [].concat(
  	        this.tokens
  	            .slice(range.startIndex, endIndex)
  	    );
  	};

  	/**
  	 * Gets the ranges of a context
  	 * @param {string} contextName context name
  	 */
  	Tokenizer.prototype.getContextRanges = function(contextName) {
  	    var context = this.getContext(contextName);
  	    if (!!context) {
  	        return context.ranges;
  	    } else {
  	        return { FAIL: ("context checker '" + contextName + "' is not registered.") };
  	    }
  	};

  	/**
  	 * Resets context ranges to run context update
  	 */
  	Tokenizer.prototype.resetContextsRanges = function () {
  	    var registeredContexts = this.registeredContexts;
  	    for (var contextName in registeredContexts) {
  	        if (registeredContexts.hasOwnProperty(contextName)) {
  	            var context = registeredContexts[contextName];
  	            context.ranges = [];
  	        }
  	    }
  	};

  	/**
  	 * Updates context ranges
  	 */
  	Tokenizer.prototype.updateContextsRanges = function () {
  	    var this$1 = this;

  	    this.resetContextsRanges();
  	    var chars = this.tokens.map(function (token) { return token.char; });
  	    for (var i = 0; i < chars.length; i++) {
  	        var contextParams = new ContextParams(chars, i);
  	        this$1.runContextCheck(contextParams);
  	    }
  	    this.dispatch('updateContextsRanges', [this.registeredContexts]);
  	};

  	/**
  	 * Sets the end offset of an open range
  	 * @param {number} offset range end offset
  	 * @param {string} contextName context name
  	 */
  	Tokenizer.prototype.setEndOffset = function (offset, contextName) {
  	    var startIndex = this.getContext(contextName).openRange.startIndex;
  	    var range = new ContextRange(startIndex, offset, contextName);
  	    var ranges = this.getContext(contextName).ranges;
  	    range.rangeId = contextName + "." + (ranges.length);
  	    ranges.push(range);
  	    this.getContext(contextName).openRange = null;
  	    return range;
  	};

  	/**
  	 * Runs a context check on the current context
  	 * @param {contextParams} contextParams current context params
  	 */
  	Tokenizer.prototype.runContextCheck = function(contextParams) {
  	    var this$1 = this;

  	    var index = contextParams.index;
  	    this.contextCheckers.forEach(function (contextChecker) {
  	        var contextName = contextChecker.contextName;
  	        var openRange = this$1.getContext(contextName).openRange;
  	        if (!openRange && contextChecker.checkStart(contextParams)) {
  	            openRange = new ContextRange(index, null, contextName);
  	            this$1.getContext(contextName).openRange = openRange;
  	            this$1.dispatch('contextStart', [contextName, index]);
  	        }
  	        if (!!openRange && contextChecker.checkEnd(contextParams)) {
  	            var offset = (index - openRange.startIndex) + 1;
  	            var range = this$1.setEndOffset(offset, contextName);
  	            this$1.dispatch('contextEnd', [contextName, range]);
  	        }
  	    });
  	};

  	/**
  	 * Converts a text into a list of tokens
  	 * @param {string} text a text to tokenize
  	 */
  	Tokenizer.prototype.tokenize = function (text) {
  	    var this$1 = this;

  	    this.tokens = [];
  	    this.resetContextsRanges();
  	    var chars = Array.from(text);
  	    this.dispatch('start');
  	    for (var i = 0; i < chars.length; i++) {
  	        var char = chars[i];
  	        var contextParams = new ContextParams(chars, i);
  	        this$1.dispatch('next', [contextParams]);
  	        this$1.runContextCheck(contextParams);
  	        var token = new Token(char);
  	        this$1.tokens.push(token);
  	        this$1.dispatch('newToken', [token, contextParams]);
  	    }
  	    this.dispatch('end', [this.tokens]);
  	    return this.tokens;
  	};

  	// â•­â”€â”„â”„â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  	// â”Š Character Class Assertions â”Š Checks if a char belongs to a certain class â”Š
  	// â•°â”€â•¾â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
  	// jscs:disable maximumLineLength
  	/**
  	 * Check if a char is Arabic
  	 * @param {string} c a single char
  	 */
  	function isArabicChar(c) {
  	    return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
  	}

  	/**
  	 * Check if a char is an isolated arabic char
  	 * @param {string} c a single char
  	 */
  	function isIsolatedArabicChar(char) {
  	    return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
  	}

  	/**
  	 * Check if a char is an Arabic Tashkeel char
  	 * @param {string} c a single char
  	 */
  	function isTashkeelArabicChar(char) {
  	    return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
  	}

  	/**
  	 * Check if a char is whitespace char
  	 * @param {string} c a single char
  	 */
  	function isWhiteSpace(c) {
  	    return /\s/.test(c);
  	}

  	/**
  	 * Arabic word context checkers
  	 */

  	function arabicWordStartCheck(contextParams) {
  	    var char = contextParams.current;
  	    var prevChar = contextParams.get(-1);
  	    return (
  	        // ? arabic first char
  	        (prevChar === null && isArabicChar(char)) ||
  	        // ? arabic char preceded with a non arabic char
  	        (!isArabicChar(prevChar) && isArabicChar(char))
  	    );
  	}

  	function arabicWordEndCheck(contextParams) {
  	    var nextChar = contextParams.get(1);
  	    return (
  	        // ? last arabic char
  	        (nextChar === null) ||
  	        // ? next char is not arabic
  	        (!isArabicChar(nextChar))
  	    );
  	}
  	var arabicWordCheck = { arabicWordStartCheck: arabicWordStartCheck, arabicWordEndCheck: arabicWordEndCheck };

  	/**
  	 * Arabic sentence context checkers
  	 */

  	function arabicSentenceStartCheck(contextParams) {
  	    var char = contextParams.current;
  	    var prevChar = contextParams.get(-1);
  	    return (
  	        // ? an arabic char preceded with a non arabic char
  	        (isArabicChar(char) || isTashkeelArabicChar(char)) &&
  	        !isArabicChar(prevChar)
  	    );
  	}

  	function arabicSentenceEndCheck(contextParams) {
  	    var nextChar = contextParams.get(1);
  	    switch (true) {
  	        case nextChar === null:
  	            return true;
  	        case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
  	            var nextIsWhitespace = isWhiteSpace(nextChar);
  	            if (!nextIsWhitespace) { return true; }
  	            if (nextIsWhitespace) {
  	                var arabicCharAhead = false;
  	                arabicCharAhead = (
  	                    contextParams.lookahead.some(
  	                        function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }
  	                    )
  	                );
  	                if (!arabicCharAhead) { return true; }
  	            }
  	            break;
  	        default:
  	            return false;
  	    }
  	}
  	var arabicSentenceCheck = { arabicSentenceStartCheck: arabicSentenceStartCheck, arabicSentenceEndCheck: arabicSentenceEndCheck };

  	/**
  	 * Apply Arabic presentation forms to a range of tokens
  	 */
  	/**
  	 * Check if a char can be connected to it's preceding char
  	 * @param {ContextParams} charContextParams context params of a char
  	 */
  	function willConnectPrev(charContextParams) {
  	    var backtrack = [].concat(charContextParams.backtrack);
  	    for (var i = backtrack.length - 1; i >= 0; i--) {
  	        var prevChar = backtrack[i];
  	        var isolated = isIsolatedArabicChar(prevChar);
  	        var tashkeel = isTashkeelArabicChar(prevChar);
  	        if (!isolated && !tashkeel) { return true; }
  	        if (isolated) { return false; }
  	    }
  	    return false;
  	}

  	/**
  	 * Check if a char can be connected to it's proceeding char
  	 * @param {ContextParams} charContextParams context params of a char
  	 */
  	function willConnectNext(charContextParams) {
  	    if (isIsolatedArabicChar(charContextParams.current)) { return false; }
  	    for (var i = 0; i < charContextParams.lookahead.length; i++) {
  	        var nextChar = charContextParams.lookahead[i];
  	        var tashkeel = isTashkeelArabicChar(nextChar);
  	        if (!tashkeel) { return true; }
  	    }
  	    return false;
  	}

  	/**
  	 * Apply arabic presentation forms to a list of tokens
  	 * @param {ContextRange} range a range of tokens
  	 */
  	function arabicPresentationForms(range) {
  	    var features = this.features.arab;
  	    var rangeTokens = this.tokenizer.getRangeTokens(range);
  	    if (rangeTokens.length === 1) { return; }
  	    var getSubstitutionIndex = function (substitution) { return (
  	        substitution.length === 1 &&
  	        substitution[0].id === 12 &&
  	        substitution[0].substitution
  	    ); };
  	    var applyForm = function (tag, token, params) {
  	        if (!features.hasOwnProperty(tag)) { return; }
  	        var substitution = features[tag].lookup(params) || null;
  	        var substIndex = getSubstitutionIndex(substitution)[0];
  	        if (substIndex >= 0) {
  	            return token.setState(tag, substIndex);
  	        }
  	    };
  	    var tokensParams = new ContextParams(rangeTokens, 0);
  	    var charContextParams = new ContextParams(rangeTokens.map(function (t){ return t.char; }), 0);
  	    rangeTokens.forEach(function (token, i) {
  	        if (isTashkeelArabicChar(token.char)) { return; }
  	        tokensParams.setCurrentIndex(i);
  	        charContextParams.setCurrentIndex(i);
  	        var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)
  	        if (willConnectPrev(charContextParams)) { CONNECT |= 1; }
  	        if (willConnectNext(charContextParams)) { CONNECT |= 2; }
  	        switch (CONNECT) {
  	            case 0: // isolated * original form
  	                return;
  	            case 1: // fina
  	                applyForm('fina', token, tokensParams);
  	                break;
  	            case 2: // init
  	                applyForm('init', token, tokensParams);
  	                break;
  	            case 3: // medi
  	                applyForm('medi', token, tokensParams);
  	                break;
  	        }
  	    });
  	}

  	/**
  	 * Apply Arabic required ligatures feature to a range of tokens
  	 */

  	/**
  	 * Apply Arabic required ligatures to a context range
  	 * @param {ContextRange} range a range of tokens
  	 */
  	function arabicRequiredLigatures(range) {
  	    var features = this.features.arab;
  	    if (!features.hasOwnProperty('rlig')) { return; }
  	    var tokens = this.tokenizer.getRangeTokens(range);
  	    for (var i = 0; i < tokens.length; i++) {
  	        var lookupParams = new ContextParams(tokens, i);
  	        var substitution = features.rlig.lookup(lookupParams) || null;
  	        var chainingContext = (
  	            substitution.length === 1 &&
  	            substitution[0].id === 63 &&
  	            substitution[0].substitution
  	        );
  	        var ligature = (
  	            substitution.length === 1 &&
  	            substitution[0].id === 41 &&
  	            substitution[0].substitution[0]
  	        );
  	        var token = tokens[i];
  	        if (!!ligature) {
  	            token.setState('rlig', [ligature.ligGlyph]);
  	            for (var c = 0; c < ligature.components.length; c++) {
  	                var component = ligature.components[c];
  	                var lookaheadToken = lookupParams.get(c + 1);
  	                if (lookaheadToken.activeState.value === component) {
  	                    lookaheadToken.state.deleted = true;
  	                }
  	            }
  	        } else if (chainingContext) {
  	            var substIndex = (
  	                chainingContext &&
  	                chainingContext.length === 1 &&
  	                chainingContext[0].id === 12 &&
  	                chainingContext[0].substitution
  	            );
  	            if (!!substIndex && substIndex >= 0) { token.setState('rlig', substIndex); }
  	        }
  	    }
  	}

  	/**
  	 * Infer bidirectional properties for a given text and apply
  	 * the corresponding layout rules.
  	 */

  	/**
  	 * Create Bidi. features
  	 * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'
  	 */
  	function Bidi(baseDir) {
  	    this.baseDir = baseDir || 'ltr';
  	    this.tokenizer = new Tokenizer();
  	    this.features = [];
  	}

  	/**
  	 * Sets Bidi text
  	 * @param {string} text a text input
  	 */
  	Bidi.prototype.setText = function (text) {
  	    this.text = text;
  	};

  	/**
  	 * Store essential context checks:
  	 * arabic word check for applying gsub features
  	 * arabic sentence check for adjusting arabic layout
  	 */
  	Bidi.prototype.contextChecks = ({
  	    arabicWordCheck: arabicWordCheck,
  	    arabicSentenceCheck: arabicSentenceCheck
  	});

  	/**
  	 * Register arabic word check
  	 */
  	function registerArabicWordCheck() {
  	    var checks = this.contextChecks.arabicWordCheck;
  	    return this.tokenizer.registerContextChecker(
  	        'arabicWord',
  	        checks.arabicWordStartCheck,
  	        checks.arabicWordEndCheck
  	    );
  	}

  	/**
  	 * Register arabic sentence check
  	 */
  	function registerArabicSentenceCheck() {
  	    var checks = this.contextChecks.arabicSentenceCheck;
  	    return this.tokenizer.registerContextChecker(
  	        'arabicSentence',
  	        checks.arabicSentenceStartCheck,
  	        checks.arabicSentenceEndCheck
  	    );
  	}

  	/**
  	 * Perform pre tokenization procedure then
  	 * tokenize text input
  	 */
  	function tokenizeText() {
  	    registerArabicWordCheck.call(this);
  	    registerArabicSentenceCheck.call(this);
  	    return this.tokenizer.tokenize(this.text);
  	}

  	/**
  	 * Reverse arabic sentence layout
  	 * TODO: check base dir before applying adjustments - priority low
  	 */
  	function reverseArabicSentences() {
  	    var this$1 = this;

  	    var ranges = this.tokenizer.getContextRanges('arabicSentence');
  	    ranges.forEach(function (range) {
  	        var rangeTokens = this$1.tokenizer.getRangeTokens(range);
  	        this$1.tokenizer.replaceRange(
  	            range.startIndex,
  	            range.endOffset,
  	            rangeTokens.reverse()
  	        );
  	    });
  	}

  	/**
  	 * Subscribe arabic presentation form features
  	 * @param {feature} feature a feature to apply
  	 */
  	Bidi.prototype.subscribeArabicForms = function(feature) {
  	    var this$1 = this;

  	    this.tokenizer.events.contextEnd.subscribe(
  	        function (contextName, range) {
  	            if (contextName === 'arabicWord') {
  	                return arabicPresentationForms.call(
  	                    this$1.tokenizer, range, feature
  	                );
  	            }
  	        }
  	    );
  	};

  	/**
  	 * Apply Gsub features
  	 * @param {feature} features a list of features
  	 */
  	Bidi.prototype.applyFeatures = function (features) {
  	    var this$1 = this;

  	    for (var i = 0; i < features.length; i++) {
  	        var feature = features[i];
  	        if (feature) {
  	            var script = feature.script;
  	            if (!this$1.features[script]) {
  	                this$1.features[script] = {};
  	            }
  	            this$1.features[script][feature.tag] = feature;
  	        }
  	    }
  	};

  	/**
  	 * Register a state modifier
  	 * @param {string} modifierId state modifier id
  	 * @param {function} condition a predicate function that returns true or false
  	 * @param {function} modifier a modifier function to set token state
  	 */
  	Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {
  	    this.tokenizer.registerModifier(modifierId, condition, modifier);
  	};

  	/**
  	 * Check if 'glyphIndex' is registered
  	 */
  	function checkGlyphIndexStatus() {
  	    if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {
  	        throw new Error(
  	            'glyphIndex modifier is required to apply ' +
  	            'arabic presentation features.'
  	        );
  	    }
  	}

  	/**
  	 * Apply arabic presentation forms features
  	 */
  	function applyArabicPresentationForms() {
  	    var this$1 = this;

  	    if (!this.features.hasOwnProperty('arab')) { return; }
  	    checkGlyphIndexStatus.call(this);
  	    var ranges = this.tokenizer.getContextRanges('arabicWord');
  	    ranges.forEach(function (range) {
  	        arabicPresentationForms.call(this$1, range);
  	    });
  	}

  	/**
  	 * Apply required arabic ligatures
  	 */
  	function applyArabicRequireLigatures() {
  	    var this$1 = this;

  	    if (!this.features.hasOwnProperty('arab')) { return; }
  	    if (!this.features.arab.hasOwnProperty('rlig')) { return; }
  	    checkGlyphIndexStatus.call(this);
  	    var ranges = this.tokenizer.getContextRanges('arabicWord');
  	    ranges.forEach(function (range) {
  	        arabicRequiredLigatures.call(this$1, range);
  	    });
  	}

  	/**
  	 * process text input
  	 * @param {string} text an input text
  	 */
  	Bidi.prototype.processText = function(text) {
  	    if (!this.text || this.text !== text) {
  	        this.setText(text);
  	        tokenizeText.call(this);
  	        applyArabicPresentationForms.call(this);
  	        applyArabicRequireLigatures.call(this);
  	        reverseArabicSentences.call(this);
  	    }
  	};

  	/**
  	 * Process a string of text to identify and adjust
  	 * bidirectional text entities.
  	 * @param {string} text input text
  	 */
  	Bidi.prototype.getBidiText = function (text) {
  	    this.processText(text);
  	    return this.tokenizer.getText();
  	};

  	/**
  	 * Get the current state index of each token
  	 * @param {text} text an input text
  	 */
  	Bidi.prototype.getTextGlyphs = function (text) {
  	    var this$1 = this;

  	    this.processText(text);
  	    var indexes = [];
  	    for (var i = 0; i < this.tokenizer.tokens.length; i++) {
  	        var token = this$1.tokenizer.tokens[i];
  	        if (token.state.deleted) { continue; }
  	        var index = token.activeState.value;
  	        indexes.push(Array.isArray(index) ? index[0] : index);
  	    }
  	    return indexes;
  	};

  	/**
  	 * Query a feature by some of it's properties to lookup a glyph substitution.
  	 */

  	// DEFAULT TEXT BASE DIRECTION
  	var BASE_DIR = 'ltr';

  	/**
  	 * Create feature query instance
  	 * @param {Font} font opentype font instance
  	 * @param {string} baseDir text base direction
  	 */
  	function FeatureQuery(font, baseDir) {
  	    this.font = font;
  	    this.features = {};
  	    BASE_DIR = !!baseDir ? baseDir : BASE_DIR;
  	}

  	/**
  	 * Create a new feature lookup
  	 * @param {string} tag feature tag
  	 * @param {feature} feature reference to feature at gsub table
  	 * @param {FeatureLookups} feature lookups associated with this feature
  	 * @param {string} script gsub script tag
  	 */
  	function Feature(tag, feature, featureLookups, script) {
  	    this.tag = tag;
  	    this.featureRef = feature;
  	    this.lookups = featureLookups.lookups;
  	    this.script = script;
  	}

  	/**
  	 * Create a coverage table lookup
  	 * @param {any} coverageTable gsub coverage table
  	 */
  	function Coverage$1(coverageTable) {
  	    this.table = coverageTable;
  	}

  	/**
  	 * Create a ligature set lookup
  	 * @param {any} ligatureSets gsub ligature set
  	 */
  	function LigatureSets(ligatureSets) {
  	    this.ligatureSets = ligatureSets;
  	}

  	/**
  	 * Lookup a glyph ligature
  	 * @param {ContextParams} contextParams context params to lookup
  	 * @param {number} ligSetIndex ligature set index at ligature sets
  	 */
  	LigatureSets.prototype.lookup = function (contextParams, ligSetIndex) {
  	    var ligatureSet = this.ligatureSets[ligSetIndex];
  	    var matchComponents = function (components, indexes) {
  	        if (components.length > indexes.length) { return null; }
  	        for (var c = 0; c < components.length; c++) {
  	            var component = components[c];
  	            var index = indexes[c];
  	            if (component !== index) { return false; }
  	        }
  	        return true;
  	    };
  	    for (var s = 0; s < ligatureSet.length; s++) {
  	        var ligSetItem = ligatureSet[s];
  	        var lookaheadIndexes = contextParams.lookahead.map(
  	            function (token) { return token.activeState.value; }
  	        );
  	        if (BASE_DIR === 'rtl') { lookaheadIndexes.reverse(); }
  	        var componentsMatch = matchComponents(
  	            ligSetItem.components, lookaheadIndexes
  	        );
  	        if (componentsMatch) { return ligSetItem; }
  	    }
  	    return null;
  	};

  	/**
  	 * Create a feature substitution
  	 * @param {any} lookups a reference to gsub lookups
  	 * @param {Lookuptable} lookupTable a feature lookup table
  	 * @param {any} subtable substitution table
  	 */
  	function Substitution$1(lookups, lookupTable, subtable) {
  	    this.lookups = lookups;
  	    this.subtable = subtable;
  	    this.lookupTable = lookupTable;
  	    if (subtable.hasOwnProperty('coverage')) {
  	        this.coverage = new Coverage$1(
  	            subtable.coverage
  	        );
  	    }
  	    if (subtable.hasOwnProperty('inputCoverage')) {
  	        this.inputCoverage = subtable.inputCoverage.map(
  	            function (table) { return new Coverage$1(table); }
  	        );
  	    }
  	    if (subtable.hasOwnProperty('backtrackCoverage')) {
  	        this.backtrackCoverage = subtable.backtrackCoverage.map(
  	            function (table) { return new Coverage$1(table); }
  	        );
  	    }
  	    if (subtable.hasOwnProperty('lookaheadCoverage')) {
  	        this.lookaheadCoverage = subtable.lookaheadCoverage.map(
  	            function (table) { return new Coverage$1(table); }
  	        );
  	    }
  	    if (subtable.hasOwnProperty('ligatureSets')) {
  	        this.ligatureSets = new LigatureSets(subtable.ligatureSets);
  	    }
  	}

  	/**
  	 * Create a lookup table lookup
  	 * @param {number} index table index at gsub lookups
  	 * @param {any} lookups a reference to gsub lookups
  	 */
  	function LookupTable(index, lookups) {
  	    this.index = index;
  	    this.subtables = lookups[index].subtables.map(
  	        function (subtable) { return new Substitution$1(
  	            lookups, lookups[index], subtable
  	        ); }
  	    );
  	}

  	function FeatureLookups(lookups, lookupListIndexes) {
  	    this.lookups = lookupListIndexes.map(
  	        function (index) { return new LookupTable(index, lookups); }
  	    );
  	}

  	/**
  	 * Lookup a lookup table subtables
  	 * @param {ContextParams} contextParams context params to lookup
  	 */
  	LookupTable.prototype.lookup = function (contextParams) {
  	    var this$1 = this;

  	    var substitutions = [];
  	    for (var i = 0; i < this.subtables.length; i++) {
  	        var subsTable = this$1.subtables[i];
  	        var substitution = subsTable.lookup(contextParams);
  	        if (substitution !== null || substitution.length) {
  	            substitutions = substitutions.concat(substitution);
  	        }
  	    }
  	    return substitutions;
  	};

  	/**
  	 * Handle a single substitution - format 2
  	 * @param {ContextParams} contextParams context params to lookup
  	 */
  	function singleSubstitutionFormat2(contextParams) {
  	    var glyphIndex = contextParams.current.activeState.value;
  	    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
  	    var substituteIndex = this.coverage.lookup(glyphIndex);
  	    if (substituteIndex === -1) { return []; }
  	    return [this.subtable.substitute[substituteIndex]];
  	}

  	/**
  	 * Lookup a list of coverage tables
  	 * @param {any} coverageList a list of coverage tables
  	 * @param {any} contextParams context params to lookup
  	 */
  	function lookupCoverageList(coverageList, contextParams) {
  	    var lookupList = [];
  	    for (var i = 0; i < coverageList.length; i++) {
  	        var coverage = coverageList[i];
  	        var glyphIndex = contextParams.current.activeState.value;
  	        glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
  	        var lookupIndex = coverage.lookup(glyphIndex);
  	        if (lookupIndex !== -1) {
  	            lookupList.push(lookupIndex);
  	        }
  	    }
  	    if (lookupList.length !== coverageList.length) { return -1; }
  	    return lookupList;
  	}

  	/**
  	 * Handle chaining context substitution - format 3
  	 * @param {any} contextParams context params to lookup
  	 */
  	function chainingSubstitutionFormat3(contextParams) {
  	    var this$1 = this;

  	    var lookupsCount = (
  	        this.inputCoverage.length +
  	        this.lookaheadCoverage.length +
  	        this.backtrackCoverage.length
  	    );
  	    if (contextParams.context.length < lookupsCount) { return []; }
  	    // INPUT LOOKUP //
  	    var inputLookups = lookupCoverageList(
  	        this.inputCoverage, contextParams
  	    );
  	    if (inputLookups === -1) { return []; }
  	    // LOOKAHEAD LOOKUP //
  	    var lookaheadOffset = this.inputCoverage.length - 1;
  	    if (contextParams.lookahead.length < this.lookaheadCoverage.length) { return []; }
  	    var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
  	    while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
  	        lookaheadContext.shift();
  	    }
  	    var lookaheadParams = new ContextParams(lookaheadContext, 0);
  	    var lookaheadLookups = lookupCoverageList(
  	        this.lookaheadCoverage, lookaheadParams
  	    );
  	    // BACKTRACK LOOKUP //
  	    var backtrackContext = [].concat(contextParams.backtrack);
  	    backtrackContext.reverse();
  	    while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
  	        backtrackContext.shift();
  	    }
  	    if (backtrackContext.length < this.backtrackCoverage.length) { return []; }
  	    var backtrackParams = new ContextParams(backtrackContext, 0);
  	    var backtrackLookups = lookupCoverageList(
  	        this.backtrackCoverage, backtrackParams
  	    );
  	    var contextRulesMatch = (
  	        inputLookups.length === this.inputCoverage.length &&
  	        lookaheadLookups.length === this.lookaheadCoverage.length &&
  	        backtrackLookups.length === this.backtrackCoverage.length
  	    );
  	    var substitutions = [];
  	    if (contextRulesMatch) {
  	        var lookupRecords = this.subtable.lookupRecords;
  	        for (var i = 0; i < lookupRecords.length; i++) {
  	            var lookupRecord = lookupRecords[i];
  	            for (var j = 0; j < inputLookups.length; j++) {
  	                var inputContext = new ContextParams([contextParams.get(j)], 0);
  	                var lookupIndex = lookupRecord.lookupListIndex;
  	                var lookupTable = new LookupTable(lookupIndex, this$1.lookups);
  	                var lookup = lookupTable.lookup(inputContext);
  	                substitutions = substitutions.concat(lookup);
  	            }
  	        }
  	    }
  	    return substitutions;
  	}

  	/**
  	 * Handle ligature substitution - format 1
  	 * @param {any} contextParams context params to lookup
  	 */
  	function ligatureSubstitutionFormat1(contextParams) {
  	    // COVERAGE LOOKUP //
  	    var glyphIndex = contextParams.current.activeState.value;
  	    var ligSetIndex = this.coverage.lookup(glyphIndex);
  	    if (ligSetIndex === -1) { return []; }
  	    // COMPONENTS LOOKUP * note that components is logically ordered
  	    var ligGlyphs = this.ligatureSets.lookup(contextParams, ligSetIndex);
  	    return ligGlyphs ? [ligGlyphs] : [];
  	}

  	/**
  	 * [ LOOKUP TYPES ]
  	 * -------------------------------
  	 * Single                        1;
  	 * Multiple                      2;
  	 * Alternate                     3;
  	 * Ligature                      4;
  	 * Context                       5;
  	 * ChainingContext               6;
  	 * ExtensionSubstitution         7;
  	 * ReverseChainingContext        8;
  	 * -------------------------------
  	 * @param {any} contextParams context params to lookup
  	 */
  	Substitution$1.prototype.lookup = function (contextParams) {
  	    var substitutions = [];
  	    var lookupType = this.lookupTable.lookupType;
  	    var substFormat = this.subtable.substFormat;
  	    if (lookupType === 1 && substFormat === 2) {
  	        var substitution = singleSubstitutionFormat2.call(this, contextParams);
  	        if (substitution.length > 0) {
  	            substitutions.push({ id: 12, substitution: substitution });
  	        }
  	    }
  	    if (lookupType === 6 && substFormat === 3) {
  	        var substitution$1 = chainingSubstitutionFormat3.call(this, contextParams);
  	        if (substitution$1.length > 0) {
  	            substitutions.push({ id: 63, substitution: substitution$1 });
  	        }
  	    }
  	    if (lookupType === 4 && substFormat === 1) {
  	        var substitution$2 = ligatureSubstitutionFormat1.call(this, contextParams);
  	        if (substitution$2.length > 0) {
  	            substitutions.push({ id: 41, substitution: substitution$2 });
  	        }
  	    }
  	    return substitutions;
  	};

  	/**
  	 * Lookup a coverage table
  	 * @param {number} glyphIndex to lookup
  	 */
  	Coverage$1.prototype.lookup = function (glyphIndex) {
  	    if (!glyphIndex) { return -1; }
  	    switch (this.table.format) {
  	        case 1:
  	            return this.table.glyphs.indexOf(glyphIndex);

  	        case 2:
  	            var ranges = this.table.ranges;
  	            for (var i = 0; i < ranges.length; i++) {
  	                var range = ranges[i];
  	                if (glyphIndex >= range.start && glyphIndex <= range.end) {
  	                    var offset = glyphIndex - range.start;
  	                    return range.index + offset;
  	                }
  	            }
  	            break;
  	        default:
  	            return -1; // not found
  	    }
  	    return -1;
  	};

  	/**
  	 * Lookup a feature for a substitution or more
  	 * @param {any} contextParams context params to lookup
  	 */
  	Feature.prototype.lookup = function(contextParams) {
  	    var this$1 = this;

  	    var lookups = [];
  	    for (var i = 0; i < this.lookups.length; i++) {
  	        var lookupTable = this$1.lookups[i];
  	        var lookup = lookupTable.lookup(contextParams);
  	        if (lookup !== null || lookup.length) {
  	            lookups = lookups.concat(lookup);
  	        }
  	    }
  	    return lookups;
  	};

  	/**
  	 * Get feature indexes of a specific script
  	 * @param {string} scriptTag script tag
  	 */
  	FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
  	    if (!scriptTag) { return []; }
  	    var tables = this.font.tables;
  	    if (!tables.gsub) { return []; }
  	    var scripts = this.font.tables.gsub.scripts;
  	    for (var i = 0; i < scripts.length; i++) {
  	        var script = scripts[i];
  	        if (script.tag === scriptTag) {
  	            var defaultLangSys = script.script.defaultLangSys;
  	            return defaultLangSys.featureIndexes;
  	        } else {
  	            var langSysRecords = script.langSysRecords;
  	            if (!!langSysRecords) {
  	                for (var j = 0; j < langSysRecords.length; j++) {
  	                    var langSysRecord = langSysRecords[j];
  	                    if (langSysRecord.tag === scriptTag) {
  	                        var langSys = langSysRecord.langSys;
  	                        return langSys.featureIndexes;
  	                    }
  	                }
  	            }
  	        }
  	    }
  	    return [];
  	};

  	/**
  	 * Map a feature tag to a gsub feature
  	 * @param {any} features gsub features
  	 * @param {*} scriptTag script tag
  	 */
  	FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {
  	    var this$1 = this;

  	    var tags = {};
  	    for (var i = 0; i < features.length; i++) {
  	        var feature = features[i].feature;
  	        var tag = features[i].tag;
  	        var lookups = this$1.font.tables.gsub.lookups;
  	        var featureLookups = new FeatureLookups(lookups, feature.lookupListIndexes);
  	        tags[tag] = new Feature(tag, feature, featureLookups, scriptTag);
  	    }
  	    this.features[scriptTag].tags = tags;
  	};

  	/**
  	 * Get features of a specific script
  	 * @param {string} scriptTag script tag
  	 */
  	FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {
  	    var features = this.features[scriptTag];
  	    if (this.features.hasOwnProperty(scriptTag)) { return features; }
  	    var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
  	    if (!featuresIndexes) { return null; }
  	    var gsub = this.font.tables.gsub;
  	    features = featuresIndexes.map(function (index) { return gsub.features[index]; });
  	    this.features[scriptTag] = features;
  	    this.mapTagsToFeatures(features, scriptTag);
  	    return features;
  	};

  	/**
  	 * Query a feature by it's properties
  	 * @param {any} query an object that describes the properties of a query
  	 */
  	FeatureQuery.prototype.getFeature = function (query) {
  	    if (!this.font) { return { FAIL: "No font was found"}; }
  	    if (!this.features.hasOwnProperty(query.script)) {
  	        this.getScriptFeatures(query.script);
  	    }
  	    return this.features[query.script].tags[query.tag] || null;
  	};

  	// The Font object

  	/**
  	 * @typedef FontOptions
  	 * @type Object
  	 * @property {Boolean} empty - whether to create a new empty font
  	 * @property {string} familyName
  	 * @property {string} styleName
  	 * @property {string=} fullName
  	 * @property {string=} postScriptName
  	 * @property {string=} designer
  	 * @property {string=} designerURL
  	 * @property {string=} manufacturer
  	 * @property {string=} manufacturerURL
  	 * @property {string=} license
  	 * @property {string=} licenseURL
  	 * @property {string=} version
  	 * @property {string=} description
  	 * @property {string=} copyright
  	 * @property {string=} trademark
  	 * @property {Number} unitsPerEm
  	 * @property {Number} ascender
  	 * @property {Number} descender
  	 * @property {Number} createdTimestamp
  	 * @property {string=} weightClass
  	 * @property {string=} widthClass
  	 * @property {string=} fsSelection
  	 */

  	/**
  	 * A Font represents a loaded OpenType font file.
  	 * It contains a set of glyphs and methods to draw text on a drawing context,
  	 * or to get a path representing the text.
  	 * @exports opentype.Font
  	 * @class
  	 * @param {FontOptions}
  	 * @constructor
  	 */
  	function Font(options) {
  	    options = options || {};

  	    if (!options.empty) {
  	        // Check that we've provided the minimum set of names.
  	        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
  	        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
  	        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
  	        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
  	        checkArgument(options.descender, 'When creating a new Font object, descender is required.');
  	        checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');

  	        // OS X will complain if the names are empty, so we put a single space everywhere by default.
  	        this.names = {
  	            fontFamily: {en: options.familyName || ' '},
  	            fontSubfamily: {en: options.styleName || ' '},
  	            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
  	            // postScriptName may not contain any whitespace
  	            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')},
  	            designer: {en: options.designer || ' '},
  	            designerURL: {en: options.designerURL || ' '},
  	            manufacturer: {en: options.manufacturer || ' '},
  	            manufacturerURL: {en: options.manufacturerURL || ' '},
  	            license: {en: options.license || ' '},
  	            licenseURL: {en: options.licenseURL || ' '},
  	            version: {en: options.version || 'Version 0.1'},
  	            description: {en: options.description || ' '},
  	            copyright: {en: options.copyright || ' '},
  	            trademark: {en: options.trademark || ' '}
  	        };
  	        this.unitsPerEm = options.unitsPerEm || 1000;
  	        this.ascender = options.ascender;
  	        this.descender = options.descender;
  	        this.createdTimestamp = options.createdTimestamp;
  	        this.tables = { os2: {
  	            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
  	            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
  	            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
  	        } };
  	    }

  	    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
  	    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
  	    this.encoding = new DefaultEncoding(this);
  	    this.position = new Position(this);
  	    this.substitution = new Substitution(this);
  	    this.tables = this.tables || {};

  	    Object.defineProperty(this, 'hinting', {
  	        get: function() {
  	            if (this._hinting) { return this._hinting; }
  	            if (this.outlinesFormat === 'truetype') {
  	                return (this._hinting = new Hinting(this));
  	            }
  	        }
  	    });
  	}

  	/**
  	 * Check if the font has a glyph for the given character.
  	 * @param  {string}
  	 * @return {Boolean}
  	 */
  	Font.prototype.hasChar = function(c) {
  	    return this.encoding.charToGlyphIndex(c) !== null;
  	};

  	/**
  	 * Convert the given character to a single glyph index.
  	 * Note that this function assumes that there is a one-to-one mapping between
  	 * the given character and a glyph; for complex scripts this might not be the case.
  	 * @param  {string}
  	 * @return {Number}
  	 */
  	Font.prototype.charToGlyphIndex = function(s) {
  	    return this.encoding.charToGlyphIndex(s);
  	};

  	/**
  	 * Convert the given character to a single Glyph object.
  	 * Note that this function assumes that there is a one-to-one mapping between
  	 * the given character and a glyph; for complex scripts this might not be the case.
  	 * @param  {string}
  	 * @return {opentype.Glyph}
  	 */
  	Font.prototype.charToGlyph = function(c) {
  	    var glyphIndex = this.charToGlyphIndex(c);
  	    var glyph = this.glyphs.get(glyphIndex);
  	    if (!glyph) {
  	        // .notdef
  	        glyph = this.glyphs.get(0);
  	    }

  	    return glyph;
  	};

  	/**
  	 * Convert the given text to a list of Glyph objects.
  	 * Note that there is no strict one-to-one mapping between characters and
  	 * glyphs, so the list of returned glyphs can be larger or smaller than the
  	 * length of the given string.
  	 * @param  {string}
  	 * @param  {GlyphRenderOptions} [options]
  	 * @return {opentype.Glyph[]}
  	 */
  	Font.prototype.stringToGlyphs = function(s, options) {
  	    var this$1 = this;

  	    options = options || this.defaultRenderOptions;

  	    var bidi = new Bidi();

  	    // Create and register 'glyphIndex' state modifier
  	    var charToGlyphIndexMod = function (token) { return this$1.charToGlyphIndex(token.char); };
  	    bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);

  	    var arabFeatureQuery = new FeatureQuery(this);
  	    var arabFeatures = ['init', 'medi', 'fina', 'rlig'];
  	    bidi.applyFeatures(
  	        arabFeatures.map(function (tag) {
  	            var query = { tag: tag, script: 'arab' };
  	            var feature = arabFeatureQuery.getFeature(query);
  	            if (!!feature) { return feature; }
  	        })
  	    );
  	    var indexes = bidi.getTextGlyphs(s);

  	    var length = indexes.length;

  	    // Apply substitutions on glyph indexes
  	    if (options.features) {
  	        var script = options.script || this.substitution.getDefaultScriptName();
  	        var manyToOne = [];
  	        if (options.features.liga) { manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language)); }
  	        if (options.features.rlig) { manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language)); }
  	        for (var i = 0; i < length; i += 1) {
  	            for (var j = 0; j < manyToOne.length; j++) {
  	                var ligature = manyToOne[j];
  	                var components = ligature.sub;
  	                var compCount = components.length;
  	                var k = 0;
  	                while (k < compCount && components[k] === indexes[i + k]) { k++; }
  	                if (k === compCount) {
  	                    indexes.splice(i, compCount, ligature.by);
  	                    length = length - compCount + 1;
  	                }
  	            }
  	        }
  	    }

  	    // convert glyph indexes to glyph objects
  	    var glyphs = new Array(length);
  	    var notdef = this.glyphs.get(0);
  	    for (var i$1 = 0; i$1 < length; i$1 += 1) {
  	        glyphs[i$1] = this$1.glyphs.get(indexes[i$1]) || notdef;
  	    }
  	    return glyphs;
  	};

  	/**
  	 * @param  {string}
  	 * @return {Number}
  	 */
  	Font.prototype.nameToGlyphIndex = function(name) {
  	    return this.glyphNames.nameToGlyphIndex(name);
  	};

  	/**
  	 * @param  {string}
  	 * @return {opentype.Glyph}
  	 */
  	Font.prototype.nameToGlyph = function(name) {
  	    var glyphIndex = this.nameToGlyphIndex(name);
  	    var glyph = this.glyphs.get(glyphIndex);
  	    if (!glyph) {
  	        // .notdef
  	        glyph = this.glyphs.get(0);
  	    }

  	    return glyph;
  	};

  	/**
  	 * @param  {Number}
  	 * @return {String}
  	 */
  	Font.prototype.glyphIndexToName = function(gid) {
  	    if (!this.glyphNames.glyphIndexToName) {
  	        return '';
  	    }

  	    return this.glyphNames.glyphIndexToName(gid);
  	};

  	/**
  	 * Retrieve the value of the kerning pair between the left glyph (or its index)
  	 * and the right glyph (or its index). If no kerning pair is found, return 0.
  	 * The kerning value gets added to the advance width when calculating the spacing
  	 * between glyphs.
  	 * For GPOS kerning, this method uses the default script and language, which covers
  	 * most use cases. To have greater control, use font.position.getKerningValue .
  	 * @param  {opentype.Glyph} leftGlyph
  	 * @param  {opentype.Glyph} rightGlyph
  	 * @return {Number}
  	 */
  	Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
  	    leftGlyph = leftGlyph.index || leftGlyph;
  	    rightGlyph = rightGlyph.index || rightGlyph;
  	    var gposKerning = this.position.defaultKerningTables;
  	    if (gposKerning) {
  	        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
  	    }
  	    // "kern" table
  	    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
  	};

  	/**
  	 * @typedef GlyphRenderOptions
  	 * @type Object
  	 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
  	 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
  	 * @property {string} [language='dflt'] - language system used to determine which features to apply.
  	 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
  	 * @property {boolean} [kerning=true] - whether to include kerning values
  	 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
  	 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
  	 */
  	Font.prototype.defaultRenderOptions = {
  	    kerning: true,
  	    features: {
  	        liga: true,
  	        rlig: true
  	    }
  	};

  	/**
  	 * Helper function that invokes the given callback for each glyph in the given text.
  	 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
  	 * @param {string} text - The text to apply.
  	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param  {GlyphRenderOptions=} options
  	 * @param  {Function} callback
  	 */
  	Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
  	    var this$1 = this;

  	    x = x !== undefined ? x : 0;
  	    y = y !== undefined ? y : 0;
  	    fontSize = fontSize !== undefined ? fontSize : 72;
  	    options = options || this.defaultRenderOptions;
  	    var fontScale = 1 / this.unitsPerEm * fontSize;
  	    var glyphs = this.stringToGlyphs(text, options);
  	    var kerningLookups;
  	    if (options.kerning) {
  	        var script = options.script || this.position.getDefaultScriptName();
  	        kerningLookups = this.position.getKerningTables(script, options.language);
  	    }
  	    for (var i = 0; i < glyphs.length; i += 1) {
  	        var glyph = glyphs[i];
  	        callback.call(this$1, glyph, x, y, fontSize, options);
  	        if (glyph.advanceWidth) {
  	            x += glyph.advanceWidth * fontScale;
  	        }

  	        if (options.kerning && i < glyphs.length - 1) {
  	            // We should apply position adjustment lookups in a more generic way.
  	            // Here we only use the xAdvance value.
  	            var kerningValue = kerningLookups ?
  	                  this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
  	                  this$1.getKerningValue(glyph, glyphs[i + 1]);
  	            x += kerningValue * fontScale;
  	        }

  	        if (options.letterSpacing) {
  	            x += options.letterSpacing * fontSize;
  	        } else if (options.tracking) {
  	            x += (options.tracking / 1000) * fontSize;
  	        }
  	    }
  	    return x;
  	};

  	/**
  	 * Create a Path object that represents the given text.
  	 * @param  {string} text - The text to create.
  	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param  {GlyphRenderOptions=} options
  	 * @return {opentype.Path}
  	 */
  	Font.prototype.getPath = function(text, x, y, fontSize, options) {
  	    var fullPath = new Path();
  	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
  	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
  	        fullPath.extend(glyphPath);
  	    });
  	    return fullPath;
  	};

  	/**
  	 * Create an array of Path objects that represent the glyphs of a given text.
  	 * @param  {string} text - The text to create.
  	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param  {GlyphRenderOptions=} options
  	 * @return {opentype.Path[]}
  	 */
  	Font.prototype.getPaths = function(text, x, y, fontSize, options) {
  	    var glyphPaths = [];
  	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
  	        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
  	        glyphPaths.push(glyphPath);
  	    });

  	    return glyphPaths;
  	};

  	/**
  	 * Returns the advance width of a text.
  	 *
  	 * This is something different than Path.getBoundingBox() as for example a
  	 * suffixed whitespace increases the advanceWidth but not the bounding box
  	 * or an overhanging letter like a calligraphic 'f' might have a quite larger
  	 * bounding box than its advance width.
  	 *
  	 * This corresponds to canvas2dContext.measureText(text).width
  	 *
  	 * @param  {string} text - The text to create.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param  {GlyphRenderOptions=} options
  	 * @return advance width
  	 */
  	Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
  	    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
  	};

  	/**
  	 * Draw the text on the given drawing context.
  	 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
  	 * @param  {string} text - The text to create.
  	 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param  {GlyphRenderOptions=} options
  	 */
  	Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
  	    this.getPath(text, x, y, fontSize, options).draw(ctx);
  	};

  	/**
  	 * Draw the points of all glyphs in the text.
  	 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
  	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
  	 * @param {string} text - The text to create.
  	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param {GlyphRenderOptions=} options
  	 */
  	Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
  	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
  	        glyph.drawPoints(ctx, gX, gY, gFontSize);
  	    });
  	};

  	/**
  	 * Draw lines indicating important font measurements for all glyphs in the text.
  	 * Black lines indicate the origin of the coordinate system (point 0,0).
  	 * Blue lines indicate the glyph bounding box.
  	 * Green line indicates the advance width of the glyph.
  	 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
  	 * @param {string} text - The text to create.
  	 * @param {number} [x=0] - Horizontal position of the beginning of the text.
  	 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
  	 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
  	 * @param {GlyphRenderOptions=} options
  	 */
  	Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
  	    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
  	        glyph.drawMetrics(ctx, gX, gY, gFontSize);
  	    });
  	};

  	/**
  	 * @param  {string}
  	 * @return {string}
  	 */
  	Font.prototype.getEnglishName = function(name) {
  	    var translations = this.names[name];
  	    if (translations) {
  	        return translations.en;
  	    }
  	};

  	/**
  	 * Validate
  	 */
  	Font.prototype.validate = function() {
  	    var _this = this;

  	    function assert(predicate, message) {
  	    }

  	    function assertNamePresent(name) {
  	        var englishName = _this.getEnglishName(name);
  	        assert(englishName && englishName.trim().length > 0);
  	    }

  	    // Identification information
  	    assertNamePresent('fontFamily');
  	    assertNamePresent('weightName');
  	    assertNamePresent('manufacturer');
  	    assertNamePresent('copyright');
  	    assertNamePresent('version');

  	    // Dimension information
  	    assert(this.unitsPerEm > 0);
  	};

  	/**
  	 * Convert the font object to a SFNT data structure.
  	 * This structure contains all the necessary tables and metadata to create a binary OTF file.
  	 * @return {opentype.Table}
  	 */
  	Font.prototype.toTables = function() {
  	    return sfnt.fontToTable(this);
  	};
  	/**
  	 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
  	 */
  	Font.prototype.toBuffer = function() {
  	    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
  	    return this.toArrayBuffer();
  	};
  	/**
  	 * Converts a `opentype.Font` into an `ArrayBuffer`
  	 * @return {ArrayBuffer}
  	 */
  	Font.prototype.toArrayBuffer = function() {
  	    var sfntTable = this.toTables();
  	    var bytes = sfntTable.encode();
  	    var buffer = new ArrayBuffer(bytes.length);
  	    var intArray = new Uint8Array(buffer);
  	    for (var i = 0; i < bytes.length; i++) {
  	        intArray[i] = bytes[i];
  	    }

  	    return buffer;
  	};

  	/**
  	 * Initiate a download of the OpenType font.
  	 */
  	Font.prototype.download = function(fileName) {
  	    var familyName = this.getEnglishName('fontFamily');
  	    var styleName = this.getEnglishName('fontSubfamily');
  	    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
  	    var arrayBuffer = this.toArrayBuffer();

  	    if (isBrowser()) {
  	        window.URL = window.URL || window.webkitURL;

  	        if (window.URL) {
  	            var dataView = new DataView(arrayBuffer);
  	            var blob = new Blob([dataView], {type: 'font/opentype'});

  	            var link = document.createElement('a');
  	            link.href = window.URL.createObjectURL(blob);
  	            link.download = fileName;

  	            var event = document.createEvent('MouseEvents');
  	            event.initEvent('click', true, false);
  	            link.dispatchEvent(event);
  	        } else {
  	            console.warn('Font file could not be downloaded. Try using a different browser.');
  	        }
  	    } else {
  	        var fs = require$$0;
  	        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
  	        fs.writeFileSync(fileName, buffer);
  	    }
  	};
  	/**
  	 * @private
  	 */
  	Font.prototype.fsSelectionValues = {
  	    ITALIC:              0x001, //1
  	    UNDERSCORE:          0x002, //2
  	    NEGATIVE:            0x004, //4
  	    OUTLINED:            0x008, //8
  	    STRIKEOUT:           0x010, //16
  	    BOLD:                0x020, //32
  	    REGULAR:             0x040, //64
  	    USER_TYPO_METRICS:   0x080, //128
  	    WWS:                 0x100, //256
  	    OBLIQUE:             0x200  //512
  	};

  	/**
  	 * @private
  	 */
  	Font.prototype.usWidthClasses = {
  	    ULTRA_CONDENSED: 1,
  	    EXTRA_CONDENSED: 2,
  	    CONDENSED: 3,
  	    SEMI_CONDENSED: 4,
  	    MEDIUM: 5,
  	    SEMI_EXPANDED: 6,
  	    EXPANDED: 7,
  	    EXTRA_EXPANDED: 8,
  	    ULTRA_EXPANDED: 9
  	};

  	/**
  	 * @private
  	 */
  	Font.prototype.usWeightClasses = {
  	    THIN: 100,
  	    EXTRA_LIGHT: 200,
  	    LIGHT: 300,
  	    NORMAL: 400,
  	    MEDIUM: 500,
  	    SEMI_BOLD: 600,
  	    BOLD: 700,
  	    EXTRA_BOLD: 800,
  	    BLACK:    900
  	};

  	// The `fvar` table stores font variation axes and instances.

  	function addName(name, names) {
  	    var nameString = JSON.stringify(name);
  	    var nameID = 256;
  	    for (var nameKey in names) {
  	        var n = parseInt(nameKey);
  	        if (!n || n < 256) {
  	            continue;
  	        }

  	        if (JSON.stringify(names[nameKey]) === nameString) {
  	            return n;
  	        }

  	        if (nameID <= n) {
  	            nameID = n + 1;
  	        }
  	    }

  	    names[nameID] = name;
  	    return nameID;
  	}

  	function makeFvarAxis(n, axis, names) {
  	    var nameID = addName(axis.name, names);
  	    return [
  	        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
  	        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
  	        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
  	        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
  	        {name: 'flags_' + n, type: 'USHORT', value: 0},
  	        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
  	    ];
  	}

  	function parseFvarAxis(data, start, names) {
  	    var axis = {};
  	    var p = new parse.Parser(data, start);
  	    axis.tag = p.parseTag();
  	    axis.minValue = p.parseFixed();
  	    axis.defaultValue = p.parseFixed();
  	    axis.maxValue = p.parseFixed();
  	    p.skip('uShort', 1);  // reserved for flags; no values defined
  	    axis.name = names[p.parseUShort()] || {};
  	    return axis;
  	}

  	function makeFvarInstance(n, inst, axes, names) {
  	    var nameID = addName(inst.name, names);
  	    var fields = [
  	        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
  	        {name: 'flags_' + n, type: 'USHORT', value: 0}
  	    ];

  	    for (var i = 0; i < axes.length; ++i) {
  	        var axisTag = axes[i].tag;
  	        fields.push({
  	            name: 'axis_' + n + ' ' + axisTag,
  	            type: 'FIXED',
  	            value: inst.coordinates[axisTag] << 16
  	        });
  	    }

  	    return fields;
  	}

  	function parseFvarInstance(data, start, axes, names) {
  	    var inst = {};
  	    var p = new parse.Parser(data, start);
  	    inst.name = names[p.parseUShort()] || {};
  	    p.skip('uShort', 1);  // reserved for flags; no values defined

  	    inst.coordinates = {};
  	    for (var i = 0; i < axes.length; ++i) {
  	        inst.coordinates[axes[i].tag] = p.parseFixed();
  	    }

  	    return inst;
  	}

  	function makeFvarTable(fvar, names) {
  	    var result = new table.Table('fvar', [
  	        {name: 'version', type: 'ULONG', value: 0x10000},
  	        {name: 'offsetToData', type: 'USHORT', value: 0},
  	        {name: 'countSizePairs', type: 'USHORT', value: 2},
  	        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
  	        {name: 'axisSize', type: 'USHORT', value: 20},
  	        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
  	        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
  	    ]);
  	    result.offsetToData = result.sizeOf();

  	    for (var i = 0; i < fvar.axes.length; i++) {
  	        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
  	    }

  	    for (var j = 0; j < fvar.instances.length; j++) {
  	        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
  	    }

  	    return result;
  	}

  	function parseFvarTable(data, start, names) {
  	    var p = new parse.Parser(data, start);
  	    var tableVersion = p.parseULong();
  	    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
  	    var offsetToData = p.parseOffset16();
  	    // Skip countSizePairs.
  	    p.skip('uShort', 1);
  	    var axisCount = p.parseUShort();
  	    var axisSize = p.parseUShort();
  	    var instanceCount = p.parseUShort();
  	    var instanceSize = p.parseUShort();

  	    var axes = [];
  	    for (var i = 0; i < axisCount; i++) {
  	        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
  	    }

  	    var instances = [];
  	    var instanceStart = start + offsetToData + axisCount * axisSize;
  	    for (var j = 0; j < instanceCount; j++) {
  	        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
  	    }

  	    return {axes: axes, instances: instances};
  	}

  	var fvar = { make: makeFvarTable, parse: parseFvarTable };

  	// The `GPOS` table contains kerning pairs, among other things.

  	var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused

  	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
  	// this = Parser instance
  	subtableParsers$1[1] = function parseLookup1() {
  	    var start = this.offset + this.relativeOffset;
  	    var posformat = this.parseUShort();
  	    if (posformat === 1) {
  	        return {
  	            posFormat: 1,
  	            coverage: this.parsePointer(Parser.coverage),
  	            value: this.parseValueRecord()
  	        };
  	    } else if (posformat === 2) {
  	        return {
  	            posFormat: 2,
  	            coverage: this.parsePointer(Parser.coverage),
  	            values: this.parseValueRecordList()
  	        };
  	    }
  	    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
  	};

  	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
  	subtableParsers$1[2] = function parseLookup2() {
  	    var start = this.offset + this.relativeOffset;
  	    var posFormat = this.parseUShort();
  	    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
  	    var coverage = this.parsePointer(Parser.coverage);
  	    var valueFormat1 = this.parseUShort();
  	    var valueFormat2 = this.parseUShort();
  	    if (posFormat === 1) {
  	        // Adjustments for Glyph Pairs
  	        return {
  	            posFormat: posFormat,
  	            coverage: coverage,
  	            valueFormat1: valueFormat1,
  	            valueFormat2: valueFormat2,
  	            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
  	                return {        // pairValueRecord
  	                    secondGlyph: this.parseUShort(),
  	                    value1: this.parseValueRecord(valueFormat1),
  	                    value2: this.parseValueRecord(valueFormat2)
  	                };
  	            })))
  	        };
  	    } else if (posFormat === 2) {
  	        var classDef1 = this.parsePointer(Parser.classDef);
  	        var classDef2 = this.parsePointer(Parser.classDef);
  	        var class1Count = this.parseUShort();
  	        var class2Count = this.parseUShort();
  	        return {
  	            // Class Pair Adjustment
  	            posFormat: posFormat,
  	            coverage: coverage,
  	            valueFormat1: valueFormat1,
  	            valueFormat2: valueFormat2,
  	            classDef1: classDef1,
  	            classDef2: classDef2,
  	            class1Count: class1Count,
  	            class2Count: class2Count,
  	            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
  	                return {
  	                    value1: this.parseValueRecord(valueFormat1),
  	                    value2: this.parseValueRecord(valueFormat2)
  	                };
  	            }))
  	        };
  	    }
  	};

  	subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
  	subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
  	subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
  	subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
  	subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
  	subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
  	subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };

  	// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
  	function parseGposTable(data, start) {
  	    start = start || 0;
  	    var p = new Parser(data, start);
  	    var tableVersion = p.parseVersion(1);
  	    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);

  	    if (tableVersion === 1) {
  	        return {
  	            version: tableVersion,
  	            scripts: p.parseScriptList(),
  	            features: p.parseFeatureList(),
  	            lookups: p.parseLookupList(subtableParsers$1)
  	        };
  	    } else {
  	        return {
  	            version: tableVersion,
  	            scripts: p.parseScriptList(),
  	            features: p.parseFeatureList(),
  	            lookups: p.parseLookupList(subtableParsers$1),
  	            variations: p.parseFeatureVariationsList()
  	        };
  	    }

  	}

  	// GPOS Writing //////////////////////////////////////////////
  	// NOT SUPPORTED
  	var subtableMakers$1 = new Array(10);

  	function makeGposTable(gpos) {
  	    return new table.Table('GPOS', [
  	        {name: 'version', type: 'ULONG', value: 0x10000},
  	        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
  	        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
  	        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
  	    ]);
  	}

  	var gpos = { parse: parseGposTable, make: makeGposTable };

  	// The `kern` table contains kerning pairs.

  	function parseWindowsKernTable(p) {
  	    var pairs = {};
  	    // Skip nTables.
  	    p.skip('uShort');
  	    var subtableVersion = p.parseUShort();
  	    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
  	    // Skip subtableLength, subtableCoverage
  	    p.skip('uShort', 2);
  	    var nPairs = p.parseUShort();
  	    // Skip searchRange, entrySelector, rangeShift.
  	    p.skip('uShort', 3);
  	    for (var i = 0; i < nPairs; i += 1) {
  	        var leftIndex = p.parseUShort();
  	        var rightIndex = p.parseUShort();
  	        var value = p.parseShort();
  	        pairs[leftIndex + ',' + rightIndex] = value;
  	    }
  	    return pairs;
  	}

  	function parseMacKernTable(p) {
  	    var pairs = {};
  	    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
  	    // Skip the rest.
  	    p.skip('uShort');
  	    var nTables = p.parseULong();
  	    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
  	    if (nTables > 1) {
  	        console.warn('Only the first kern subtable is supported.');
  	    }
  	    p.skip('uLong');
  	    var coverage = p.parseUShort();
  	    var subtableVersion = coverage & 0xFF;
  	    p.skip('uShort');
  	    if (subtableVersion === 0) {
  	        var nPairs = p.parseUShort();
  	        // Skip searchRange, entrySelector, rangeShift.
  	        p.skip('uShort', 3);
  	        for (var i = 0; i < nPairs; i += 1) {
  	            var leftIndex = p.parseUShort();
  	            var rightIndex = p.parseUShort();
  	            var value = p.parseShort();
  	            pairs[leftIndex + ',' + rightIndex] = value;
  	        }
  	    }
  	    return pairs;
  	}

  	// Parse the `kern` table which contains kerning pairs.
  	function parseKernTable(data, start) {
  	    var p = new parse.Parser(data, start);
  	    var tableVersion = p.parseUShort();
  	    if (tableVersion === 0) {
  	        return parseWindowsKernTable(p);
  	    } else if (tableVersion === 1) {
  	        return parseMacKernTable(p);
  	    } else {
  	        throw new Error('Unsupported kern table version (' + tableVersion + ').');
  	    }
  	}

  	var kern = { parse: parseKernTable };

  	// The `loca` table stores the offsets to the locations of the glyphs in the font.

  	// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
  	// relative to the beginning of the glyphData table.
  	// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
  	// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
  	// version where offsets are stored as uLongs. The `head` table specifies which version to use
  	// (under indexToLocFormat).
  	function parseLocaTable(data, start, numGlyphs, shortVersion) {
  	    var p = new parse.Parser(data, start);
  	    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
  	    // There is an extra entry after the last index element to compute the length of the last glyph.
  	    // That's why we use numGlyphs + 1.
  	    var glyphOffsets = [];
  	    for (var i = 0; i < numGlyphs + 1; i += 1) {
  	        var glyphOffset = parseFn.call(p);
  	        if (shortVersion) {
  	            // The short table version stores the actual offset divided by 2.
  	            glyphOffset *= 2;
  	        }

  	        glyphOffsets.push(glyphOffset);
  	    }

  	    return glyphOffsets;
  	}

  	var loca = { parse: parseLocaTable };

  	// opentype.js

  	/**
  	 * The opentype library.
  	 * @namespace opentype
  	 */

  	// File loaders /////////////////////////////////////////////////////////
  	/**
  	 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
  	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
  	 * @param  {string} path - The path of the file
  	 * @param  {Function} callback - The function to call when the font load completes
  	 */
  	function loadFromFile(path, callback) {
  	    var fs = require$$0;
  	    fs.readFile(path, function(err, buffer) {
  	        if (err) {
  	            return callback(err.message);
  	        }

  	        callback(null, nodeBufferToArrayBuffer(buffer));
  	    });
  	}
  	/**
  	 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
  	 * and the font as an ArrayBuffer in the second parameter if it succeeds.
  	 * @param  {string} url - The URL of the font file.
  	 * @param  {Function} callback - The function to call when the font load completes
  	 */
  	function loadFromUrl(url, callback) {
  	    var request = new XMLHttpRequest();
  	    request.open('get', url, true);
  	    request.responseType = 'arraybuffer';
  	    request.onload = function() {
  	        if (request.response) {
  	            return callback(null, request.response);
  	        } else {
  	            return callback('Font could not be loaded: ' + request.statusText);
  	        }
  	    };

  	    request.onerror = function () {
  	        callback('Font could not be loaded');
  	    };

  	    request.send();
  	}

  	// Table Directory Entries //////////////////////////////////////////////
  	/**
  	 * Parses OpenType table entries.
  	 * @param  {DataView}
  	 * @param  {Number}
  	 * @return {Object[]}
  	 */
  	function parseOpenTypeTableEntries(data, numTables) {
  	    var tableEntries = [];
  	    var p = 12;
  	    for (var i = 0; i < numTables; i += 1) {
  	        var tag = parse.getTag(data, p);
  	        var checksum = parse.getULong(data, p + 4);
  	        var offset = parse.getULong(data, p + 8);
  	        var length = parse.getULong(data, p + 12);
  	        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
  	        p += 16;
  	    }

  	    return tableEntries;
  	}

  	/**
  	 * Parses WOFF table entries.
  	 * @param  {DataView}
  	 * @param  {Number}
  	 * @return {Object[]}
  	 */
  	function parseWOFFTableEntries(data, numTables) {
  	    var tableEntries = [];
  	    var p = 44; // offset to the first table directory entry.
  	    for (var i = 0; i < numTables; i += 1) {
  	        var tag = parse.getTag(data, p);
  	        var offset = parse.getULong(data, p + 4);
  	        var compLength = parse.getULong(data, p + 8);
  	        var origLength = parse.getULong(data, p + 12);
  	        var compression = (void 0);
  	        if (compLength < origLength) {
  	            compression = 'WOFF';
  	        } else {
  	            compression = false;
  	        }

  	        tableEntries.push({tag: tag, offset: offset, compression: compression,
  	            compressedLength: compLength, length: origLength});
  	        p += 20;
  	    }

  	    return tableEntries;
  	}

  	/**
  	 * @typedef TableData
  	 * @type Object
  	 * @property {DataView} data - The DataView
  	 * @property {number} offset - The data offset.
  	 */

  	/**
  	 * @param  {DataView}
  	 * @param  {Object}
  	 * @return {TableData}
  	 */
  	function uncompressTable(data, tableEntry) {
  	    if (tableEntry.compression === 'WOFF') {
  	        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
  	        var outBuffer = new Uint8Array(tableEntry.length);
  	        tinyInflate(inBuffer, outBuffer);
  	        if (outBuffer.byteLength !== tableEntry.length) {
  	            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
  	        }

  	        var view = new DataView(outBuffer.buffer, 0);
  	        return {data: view, offset: 0};
  	    } else {
  	        return {data: data, offset: tableEntry.offset};
  	    }
  	}

  	// Public API ///////////////////////////////////////////////////////////

  	/**
  	 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
  	 * Throws an error if the font could not be parsed.
  	 * @param  {ArrayBuffer}
  	 * @return {opentype.Font}
  	 */
  	function parseBuffer(buffer) {
  	    var indexToLocFormat;
  	    var ltagTable;

  	    // Since the constructor can also be called to create new fonts from scratch, we indicate this
  	    // should be an empty font that we'll fill with our own data.
  	    var font = new Font({empty: true});

  	    // OpenType fonts use big endian byte ordering.
  	    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
  	    // Instead we use DataViews where we can specify endianness.
  	    var data = new DataView(buffer, 0);
  	    var numTables;
  	    var tableEntries = [];
  	    var signature = parse.getTag(data, 0);
  	    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
  	        font.outlinesFormat = 'truetype';
  	        numTables = parse.getUShort(data, 4);
  	        tableEntries = parseOpenTypeTableEntries(data, numTables);
  	    } else if (signature === 'OTTO') {
  	        font.outlinesFormat = 'cff';
  	        numTables = parse.getUShort(data, 4);
  	        tableEntries = parseOpenTypeTableEntries(data, numTables);
  	    } else if (signature === 'wOFF') {
  	        var flavor = parse.getTag(data, 4);
  	        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
  	            font.outlinesFormat = 'truetype';
  	        } else if (flavor === 'OTTO') {
  	            font.outlinesFormat = 'cff';
  	        } else {
  	            throw new Error('Unsupported OpenType flavor ' + signature);
  	        }

  	        numTables = parse.getUShort(data, 12);
  	        tableEntries = parseWOFFTableEntries(data, numTables);
  	    } else {
  	        throw new Error('Unsupported OpenType signature ' + signature);
  	    }

  	    var cffTableEntry;
  	    var fvarTableEntry;
  	    var glyfTableEntry;
  	    var gposTableEntry;
  	    var gsubTableEntry;
  	    var hmtxTableEntry;
  	    var kernTableEntry;
  	    var locaTableEntry;
  	    var nameTableEntry;
  	    var metaTableEntry;
  	    var p;

  	    for (var i = 0; i < numTables; i += 1) {
  	        var tableEntry = tableEntries[i];
  	        var table = (void 0);
  	        switch (tableEntry.tag) {
  	            case 'cmap':
  	                table = uncompressTable(data, tableEntry);
  	                font.tables.cmap = cmap.parse(table.data, table.offset);
  	                font.encoding = new CmapEncoding(font.tables.cmap);
  	                break;
  	            case 'cvt ' :
  	                table = uncompressTable(data, tableEntry);
  	                p = new parse.Parser(table.data, table.offset);
  	                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
  	                break;
  	            case 'fvar':
  	                fvarTableEntry = tableEntry;
  	                break;
  	            case 'fpgm' :
  	                table = uncompressTable(data, tableEntry);
  	                p = new parse.Parser(table.data, table.offset);
  	                font.tables.fpgm = p.parseByteList(tableEntry.length);
  	                break;
  	            case 'head':
  	                table = uncompressTable(data, tableEntry);
  	                font.tables.head = head.parse(table.data, table.offset);
  	                font.unitsPerEm = font.tables.head.unitsPerEm;
  	                indexToLocFormat = font.tables.head.indexToLocFormat;
  	                break;
  	            case 'hhea':
  	                table = uncompressTable(data, tableEntry);
  	                font.tables.hhea = hhea.parse(table.data, table.offset);
  	                font.ascender = font.tables.hhea.ascender;
  	                font.descender = font.tables.hhea.descender;
  	                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
  	                break;
  	            case 'hmtx':
  	                hmtxTableEntry = tableEntry;
  	                break;
  	            case 'ltag':
  	                table = uncompressTable(data, tableEntry);
  	                ltagTable = ltag.parse(table.data, table.offset);
  	                break;
  	            case 'maxp':
  	                table = uncompressTable(data, tableEntry);
  	                font.tables.maxp = maxp.parse(table.data, table.offset);
  	                font.numGlyphs = font.tables.maxp.numGlyphs;
  	                break;
  	            case 'name':
  	                nameTableEntry = tableEntry;
  	                break;
  	            case 'OS/2':
  	                table = uncompressTable(data, tableEntry);
  	                font.tables.os2 = os2.parse(table.data, table.offset);
  	                break;
  	            case 'post':
  	                table = uncompressTable(data, tableEntry);
  	                font.tables.post = post.parse(table.data, table.offset);
  	                font.glyphNames = new GlyphNames(font.tables.post);
  	                break;
  	            case 'prep' :
  	                table = uncompressTable(data, tableEntry);
  	                p = new parse.Parser(table.data, table.offset);
  	                font.tables.prep = p.parseByteList(tableEntry.length);
  	                break;
  	            case 'glyf':
  	                glyfTableEntry = tableEntry;
  	                break;
  	            case 'loca':
  	                locaTableEntry = tableEntry;
  	                break;
  	            case 'CFF ':
  	                cffTableEntry = tableEntry;
  	                break;
  	            case 'kern':
  	                kernTableEntry = tableEntry;
  	                break;
  	            case 'GPOS':
  	                gposTableEntry = tableEntry;
  	                break;
  	            case 'GSUB':
  	                gsubTableEntry = tableEntry;
  	                break;
  	            case 'meta':
  	                metaTableEntry = tableEntry;
  	                break;
  	        }
  	    }

  	    var nameTable = uncompressTable(data, nameTableEntry);
  	    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
  	    font.names = font.tables.name;

  	    if (glyfTableEntry && locaTableEntry) {
  	        var shortVersion = indexToLocFormat === 0;
  	        var locaTable = uncompressTable(data, locaTableEntry);
  	        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
  	        var glyfTable = uncompressTable(data, glyfTableEntry);
  	        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
  	    } else if (cffTableEntry) {
  	        var cffTable = uncompressTable(data, cffTableEntry);
  	        cff.parse(cffTable.data, cffTable.offset, font);
  	    } else {
  	        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
  	    }

  	    var hmtxTable = uncompressTable(data, hmtxTableEntry);
  	    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
  	    addGlyphNames(font);

  	    if (kernTableEntry) {
  	        var kernTable = uncompressTable(data, kernTableEntry);
  	        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
  	    } else {
  	        font.kerningPairs = {};
  	    }

  	    if (gposTableEntry) {
  	        var gposTable = uncompressTable(data, gposTableEntry);
  	        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
  	        font.position.init();
  	    }

  	    if (gsubTableEntry) {
  	        var gsubTable = uncompressTable(data, gsubTableEntry);
  	        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
  	    }

  	    if (fvarTableEntry) {
  	        var fvarTable = uncompressTable(data, fvarTableEntry);
  	        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
  	    }

  	    if (metaTableEntry) {
  	        var metaTable = uncompressTable(data, metaTableEntry);
  	        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
  	        font.metas = font.tables.meta;
  	    }

  	    return font;
  	}

  	/**
  	 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
  	 * with two arguments `(err, font)`. The `err` will be null on success,
  	 * the `font` is a Font object.
  	 * We use the node.js callback convention so that
  	 * opentype.js can integrate with frameworks like async.js.
  	 * @alias opentype.load
  	 * @param  {string} url - The URL of the font to load.
  	 * @param  {Function} callback - The callback.
  	 */
  	function load(url, callback) {
  	    var isNode$$1 = typeof window === 'undefined';
  	    var loadFn = isNode$$1 ? loadFromFile : loadFromUrl;
  	    loadFn(url, function(err, arrayBuffer) {
  	        if (err) {
  	            return callback(err);
  	        }
  	        var font;
  	        try {
  	            font = parseBuffer(arrayBuffer);
  	        } catch (e) {
  	            return callback(e, null);
  	        }
  	        return callback(null, font);
  	    });
  	}

  	/**
  	 * Synchronously load the font from a URL or file.
  	 * When done, returns the font object or throws an error.
  	 * @alias opentype.loadSync
  	 * @param  {string} url - The URL of the font to load.
  	 * @return {opentype.Font}
  	 */
  	function loadSync(url) {
  	    var fs = require$$0;
  	    var buffer = fs.readFileSync(url);
  	    return parseBuffer(nodeBufferToArrayBuffer(buffer));
  	}

  	exports.Font = Font;
  	exports.Glyph = Glyph;
  	exports.Path = Path;
  	exports.BoundingBox = BoundingBox;
  	exports._parse = parse;
  	exports.parse = parseBuffer;
  	exports.load = load;
  	exports.loadSync = loadSync;

  	Object.defineProperty(exports, '__esModule', { value: true });

  })));

  });

  unwrapExports(opentype);
  var opentype_1 = opentype.parse;

  const toFont = (options = {}, data) => {
    // Unfortunately opentype.js wants a buffer but doesn't take an offset.
    // Trim the buffer back so that we get one where offset 0 is the start of data.
    const fontData = opentype_1(data.buffer.slice(data.byteOffset));

    const font = (options, text) => {
      const { emSize = 1, curveSegments = 32, size = 72, kerning = true, features, hinting = false } = options;
      const renderingOptions = { kerning, features, hinting };
      const svgPaths = [];
      const factor = emSize * 10 / fontData.unitsPerEm;
      fontData.forEachGlyph(text, 0, 0, size, renderingOptions,
                            (glyph, x, y, fontSize) => {
                              svgPaths.push(glyph.getPath(x, y, fontSize, options).toPathData());
                            });
      const pathsets = [];
      for (let { paths } of svgPaths.map(svgPath => fromSvgPath(new TextEncoder('utf8').encode(svgPath), { curveSegments: curveSegments }))) {
        // Outlining forces re-orientation.
        pathsets.push(reorient(paths));
      }
      return scale$3([factor, factor, factor], { z0Surface: union(...pathsets) });
    };

    return font;
  };

  // TODO: (await readFont(...))({ emSize: 16 })("CA");

  /**
   *
   * # Read Font
   *
   * readFont reads in a font and produces a function that renders text as a surface with that font.
   *
   * The rendering function takes an option defaulting to { emSize = 10 } and a string of text.
   * This means that one M is 10 mm in height.
   *
   * ::: illustration { "view": { "position": [-50, -50, 50] } }
   * ```
   * const greatVibes = await readFont('font/great-vibes/GreatVibes-Regular.ttf');
   * greatVibes(20)("M").extrude(5).rotateX(90).above().center()
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, -1, 100] } }
   * ```
   * const greatVibes = await readFont('font/great-vibes/GreatVibes-Regular.ttf');
   * greatVibes(10)("M").center()
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, -1, 100] } }
   * ```
   * const greatVibes = await readFont('font/great-vibes/GreatVibes-Regular.ttf');
   * greatVibes(20)("M").center()
   * ```
   * :::
   * ::: illustration { "view": { "position": [0, -1, 50] } }
   * ```
   * const greatVibes = await readFont('font/great-vibes/GreatVibes-Regular.ttf');
   * greatVibes(16)("CA").center()
   * ```
   * :::
   *
   **/

  const toEmSizeFromMm = (mm) => mm * 1.5;

  const readFont = async (path, { src } = {}) => {
    let data = await readFile({ doSerialize: false }, `source/${path}`);
    if (data === undefined) {
      data = await readFile({ sources: [src] }, `cache/${path}`);
    }
    const font = toFont({ path }, data);
    const fontFactory = (size = 1) => (text) => Shape.fromGeometry(font({ emSize: toEmSizeFromMm(size) }, text));
    return fontFactory;
  };

  const ofSize$3 = (size) => Hershey.ofSize(size);

  const Font = (size) => ofSize$3(size);

  Font.Hershey = Hershey;
  Font.ofSize = ofSize$3;
  Font.read = async (...args) => readFont(...args);

  Font.Hershey.signature = 'Font.Hershey(size:number) -> Font';
  Font.ofSize.signature = 'Font.ofSize(size:number) -> Font';
  Font.read.signature = 'Font.read(path:string, { flip:boolean = false }) -> Font';

  const Plan = ({ plan, marks = [], planes = [], tags = [], visualization, content }, context) => {
    let visualizationGeometry = visualization === undefined ? { assembly: [] } : visualization.toKeptGeometry();
    let contentGeometry = content === undefined ? { assembly: [] } : content.toKeptGeometry();
    const shape = Shape.fromGeometry({
      plan,
      marks,
      planes,
      tags,
      content: contentGeometry,
      visualization: visualizationGeometry
    },
                                     context);
    return shape;
  };

  var binPacking = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
     factory(exports) ;
  }(commonjsGlobal, (function (exports) {
  /******************************************************************************

  This is a binary tree based bin packing algorithm that is more complex than
  the simple Packer (packer.js). Instead of starting off with a fixed width and
  height, it starts with the width and height of the first block passed and then
  grows as necessary to accomodate each subsequent block. As it grows it attempts
  to maintain a roughly square ratio by making 'smart' choices about whether to
  grow right or down.

  When growing, the algorithm can only grow to the right OR down. Therefore, if
  the new block is BOTH wider and taller than the current target then it will be
  rejected. This makes it very important to initialize with a sensible starting
  width and height. If you are providing sorted input (largest first) then this
  will not be an issue.

  A potential way to solve this limitation would be to allow growth in BOTH
  directions at once, but this requires maintaining a more complex tree
  with 3 children (down, right and center) and that complexity can be avoided
  by simply chosing a sensible starting block.

  Best results occur when the input blocks are sorted by height, or even better
  when sorted by max(width,height).

  Inputs:
  ------

    blocks: array of any objects that have .w and .h attributes

  Outputs:
  -------

    marks each block that fits with a .fit attribute pointing to a
    node with .x and .y coordinates

  Example:
  -------

    var blocks = [
      { w: 100, h: 100 },
      { w: 100, h: 100 },
      { w:  80, h:  80 },
      { w:  80, h:  80 },
      etc
      etc
    ];

    var packer = new GrowingPacker();
    packer.fit(blocks);

    for(var n = 0 ; n < blocks.length ; n++) {
      var block = blocks[n];
      if (block.fit) {
        Draw(block.fit.x, block.fit.y, block.w, block.h);
      }
    }


  ******************************************************************************/

  function GrowingPacker() {}

  GrowingPacker.prototype = {

    fit: function fit(blocks) {
      var n,
          node,
          block,
          len = blocks.length;
      var w = len > 0 ? blocks[0].w : 0;
      var h = len > 0 ? blocks[0].h : 0;
      this.root = { x: 0, y: 0, w: w, h: h };
      for (n = 0; n < len; n++) {
        block = blocks[n];
        if (node = this.findNode(this.root, block.w, block.h)) block.fit = this.splitNode(node, block.w, block.h);else block.fit = this.growNode(block.w, block.h);
      }
    },

    findNode: function findNode(root, w, h) {
      if (root.used) return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);else if (w <= root.w && h <= root.h) return root;else return null;
    },

    splitNode: function splitNode(node, w, h) {
      node.used = true;
      node.down = { x: node.x, y: node.y + h, w: node.w, h: node.h - h };
      node.right = { x: node.x + w, y: node.y, w: node.w - w, h: h };
      return node;
    },

    growNode: function growNode(w, h) {
      var canGrowDown = w <= this.root.w;
      var canGrowRight = h <= this.root.h;

      var shouldGrowRight = canGrowRight && this.root.h >= this.root.w + w; // attempt to keep square-ish by growing right when height is much greater than width
      var shouldGrowDown = canGrowDown && this.root.w >= this.root.h + h; // attempt to keep square-ish by growing down  when width  is much greater than height

      if (shouldGrowRight) return this.growRight(w, h);else if (shouldGrowDown) return this.growDown(w, h);else if (canGrowRight) return this.growRight(w, h);else if (canGrowDown) return this.growDown(w, h);else return null; // need to ensure sensible root starting size to avoid this happening
    },

    growRight: function growRight(w, h) {
      var node;
      this.root = {
        used: true,
        x: 0,
        y: 0,
        w: this.root.w + w,
        h: this.root.h,
        down: this.root,
        right: { x: this.root.w, y: 0, w: w, h: this.root.h }
      };
      if (node = this.findNode(this.root, w, h)) return this.splitNode(node, w, h);else return null;
    },

    growDown: function growDown(w, h) {
      var node;
      this.root = {
        used: true,
        x: 0,
        y: 0,
        w: this.root.w,
        h: this.root.h + h,
        down: { x: 0, y: this.root.h, w: this.root.w, h: h },
        right: this.root
      };
      if (node = this.findNode(this.root, w, h)) return this.splitNode(node, w, h);else return null;
    }

  };

  /******************************************************************************

  This is a very simple binary tree based bin packing algorithm that is initialized
  with a fixed width and height and will fit each block into the first node where
  it fits and then split that node into 2 parts (down and right) to track the
  remaining whitespace.

  Best results occur when the input blocks are sorted by height, or even better
  when sorted by max(width,height).

  Inputs:
  ------

    w:       width of target rectangle
    h:      height of target rectangle
    blocks: array of any objects that have .w and .h attributes

  Outputs:
  -------

    marks each block that fits with a .fit attribute pointing to a
    node with .x and .y coordinates

  Example:
  -------

    var blocks = [
      { w: 100, h: 100 },
      { w: 100, h: 100 },
      { w:  80, h:  80 },
      { w:  80, h:  80 },
      etc
      etc
    ];

    var packer = new Packer(500, 500);
    packer.fit(blocks);

    for(var n = 0 ; n < blocks.length ; n++) {
      var block = blocks[n];
      if (block.fit) {
        Draw(block.fit.x, block.fit.y, block.w, block.h);
      }
    }


  ******************************************************************************/

  function Packer(w, h) {
    this.init(w, h);
  }

  Packer.prototype = {

    init: function init(w, h) {
      this.root = { x: 0, y: 0, w: w, h: h };
    },

    fit: function fit(blocks) {
      var n, node, block;
      for (n = 0; n < blocks.length; n++) {
        block = blocks[n];
        if (node = this.findNode(this.root, block.w, block.h)) block.fit = this.splitNode(node, block.w, block.h);
      }
    },

    findNode: function findNode(root, w, h) {
      if (root.used) return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);else if (w <= root.w && h <= root.h) return root;else return null;
    },

    splitNode: function splitNode(node, w, h) {
      node.used = true;
      node.down = { x: node.x, y: node.y + h, w: node.w, h: node.h - h };
      node.right = { x: node.x + w, y: node.y, w: node.w - w, h: h };
      return node;
    }

  };

  exports.GrowingPacker = GrowingPacker;
  exports.Packer = Packer;

  Object.defineProperty(exports, '__esModule', { value: true });

  })));

  });

  unwrapExports(binPacking);
  var binPacking_1 = binPacking.GrowingPacker;
  var binPacking_2 = binPacking.Packer;

  const X$h = 0;
  const Y$h = 1;

  const measureSize = (geometry) => {
    const [min, max] = measureBoundingBox$5(geometry);
    const width = max[X$h] - min[X$h];
    const height = max[Y$h] - min[Y$h];
    return [width, height];
  };

  const measureOrigin = (geometry) => {
    const [min] = measureBoundingBox$5(geometry);
    const [x, y] = min;
    return [x, y];
  };

  const measureOffsets = (size, pageMargin) => {
    if (size) {
      const [width, height] = size;

      // Center the output to match pages.
      const xOffset = width / -2;
      const yOffset = height / -2;
      const packer = new binPacking_2(width - pageMargin * 2, height - pageMargin * 2);

      return [xOffset, yOffset, packer];
    } else {
      const packer = new binPacking_1();
      return [0, 0, packer];
    }
  };

  const pack = ({ size, itemMargin = 1, pageMargin = 5 }, ...geometries) => {
    const [xOffset, yOffset, packer] = measureOffsets(size, pageMargin);

    const packedGeometries = [];
    const unpackedGeometries = [];

    const blocks = [];

    for (const geometry of geometries) {
      const [width, height] = measureSize(geometry);
      if (!isFinite(width) || !isFinite(height)) {
        continue;
      }
      const [w, h] = [width + itemMargin * 2, height + itemMargin * 2];
      blocks.push({ w, h, geometry });
    }

    // Place largest cells first
    blocks.sort((a, b) => 0 - Math.max(a.w, a.h) + Math.max(b.w, b.h));

    packer.fit(blocks);

    let minPoint = [Infinity, Infinity, 0];
    let maxPoint = [-Infinity, -Infinity, 0];

    for (const { geometry, fit } of blocks) {
      if (fit && fit.used) {
        const [x, y] = measureOrigin(geometry);
        const xo = 0 + xOffset + (fit.x - x + itemMargin + pageMargin);
        const yo = 0 + yOffset + (fit.y - y + itemMargin + pageMargin);
        minPoint = min([fit.x + xOffset, fit.y + yOffset, 0], minPoint);
        maxPoint = max([fit.x + xOffset + fit.w, fit.y + yOffset + fit.h, 0], maxPoint);
        const transformed = toTransformedGeometry(translate$4([xo, yo, 0], geometry));
        packedGeometries.push(transformed);
      } else {
        unpackedGeometries.push(geometry);
      }
    }

    return [packedGeometries, unpackedGeometries, minPoint, maxPoint];
  };

  const pack$1 = (shape, { size, pageMargin = 5, itemMargin = 1, perLayout = Infinity, packSize = [] }) => {
    if (perLayout === 0) {
      // Packing was disabled -- do nothing.
      return shape;
    }

    let todo = [];
    for (const leaf of getLeafs(shape.toKeptGeometry())) {
      todo.push(leaf);
    }
    const packedLayers = [];
    while (todo.length > 0) {
      const input = [];
      while (todo.length > 0 && input.length < perLayout) {
        input.push(todo.shift());
      }
      const [packed, unpacked, minPoint, maxPoint] = pack({ size, pageMargin, itemMargin }, ...input);
      packSize[0] = minPoint;
      packSize[1] = maxPoint;
      if (packed.length === 0) {
        break;
      } else {
        packedLayers.push({ item: { disjointAssembly: packed } });
      }
      todo.unshift(...unpacked);
    }
    let packedShape = Shape.fromGeometry({ layers: packedLayers });
    if (size === undefined) {
      packedShape = packedShape.center();
    }
    return packedShape;
  };

  const packMethod = function (...args) { return pack$1(this, ...args); };
  Shape.prototype.pack = packMethod;

  pack$1.signature = 'pack({ size, margin = 5 }, ...shapes:Shape) -> [packed:Shapes, unpacked:Shapes]';

  const MIN$3 = 0;
  const MAX = 1;
  const X$i = 0;
  const Y$i = 1;

  const Page = ({ size, pageMargin = 5, itemMargin = 1, itemsPerPage = Infinity }, ...shapes) => {
    const layers = [];
    for (const shape of shapes) {
      for (const leaf of getLeafs(shape.toKeptGeometry())) {
        layers.push(leaf);
      }
    }
    const r = (v) => Math.floor(v * 100) / 100;
    if (size) {
      // Content fits to page size.
      const packSize = [];
      const content = pack$1(Shape.fromGeometry({ layers }), { size, pageMargin, itemMargin, perLayout: itemsPerPage, packSize });
      const pageWidth = packSize[MAX][X$i] - packSize[MIN$3][X$i];
      const pageLength = packSize[MAX][Y$i] - packSize[MIN$3][Y$i];
      const plans = [];
      for (const layer of content.toKeptGeometry().layers) {
        plans.push(Plan({
          plan: { page: { size, margin: pageMargin } },
          marks: packSize,
          content: Shape.fromGeometry(layer),
          visualization:
                        Square(pageWidth, pageLength)
                            .outline()
                            .with(Hershey(max$1(pageWidth, pageLength) * 0.0125)(`Page ${r(pageWidth)} x ${r(pageLength)}`).move(pageWidth / -2, (pageLength * 1.0125) / 2))
                            .color('red')
        }).Item());
      }
      return Layers(...plans);
    } else {
      const packSize = [];
      // Page fits to content size.
      const content = pack$1(Shape.fromGeometry({ layers }), { pageMargin, itemMargin, perLayout: itemsPerPage, packSize });
      // FIX: Using content.size() loses the margin, which is a problem for repacking.
      // Probably page plans should be generated by pack and count toward the size.
      const pageWidth = packSize[MAX][X$i] - packSize[MIN$3][X$i];
      const pageLength = packSize[MAX][Y$i] - packSize[MIN$3][Y$i];
      if (isFinite(pageWidth) && isFinite(pageLength)) {
        const plans = [];
        for (const layer of content.toKeptGeometry().layers) {
          plans.push(Plan({
            plan: { page: { size, margin: pageMargin } },
            content: Shape.fromGeometry(layer).center(),
            marks: packSize,
            visualization:
                          Square(pageWidth, pageLength)
                              .outline()
                              .with(Hershey(max$1(pageWidth, pageLength) * 0.0125)(`Page ${r(pageWidth)} x ${r(pageLength)}`).move(pageWidth / -2, (pageLength * 1.0125) / 2))
                              .color('red')
          }).Item());
        }
        return Layers(...plans);
      } else {
        return Empty();
      }
    }
  };

  Plan.Page = Page;

  const PageMethod = function (options = {}) { return Page(options, this); };
  Shape.prototype.Page = PageMethod;

  const ensurePages = (geometry) => {
    const pages = getPlans(geometry).filter(entry => entry.plan.page);
    if (pages.length === 0) {
      return ensurePages(Page({}, Shape.fromGeometry(geometry)).toGeometry());
    } else {
      return pages;
    }
  };

  const dp2 = (number) => Math.round(number * 100) / 100;

  const Apothem = (apothem = 1, sides = 32, center = [0, 0, 0]) => {
    const radius = Polygon.toRadiusFromApothem(apothem, sides);
    return Plan({
      plan: { apothem },
      marks: [center],
      visualization:
        Circle.ofRadius(radius)
            .outline()
            .add(Path([0, 0, 0], [0, radius, 0]))
            .add(Hershey(radius / 10)(`A${dp2(apothem)}`).moveY(radius / 2))
            .color('red')
    });
  };

  Plan.Apothem = Apothem;

  const Diameter = (diameter = 1, center = [0, 0, 0]) => {
    const radius = diameter / 2;
    return Plan({
      plan: { diameter },
      marks: [center],
      visualization:
        Circle.ofDiameter(diameter)
            .outline()
            .add(Path([0, -radius, 0], [0, +radius, 0]))
            .add(Hershey(radius / 10)(`D${dp2(diameter)}`))
            .color('red')
    });
  };
  Plan.Diameter = Diameter;

  const Label = (label, mark = [0, 0, 0]) => Plan({ plan: { label }, marks: [mark] });
  Plan.Label = Label;

  const withLabelMethod = function (...args) { return assemble$1(this, Plan.Label(...args)); };
  Shape.prototype.withLabel = withLabelMethod;

  const Length = (length) => {
    return Plan({
      plan: { length },
      visualization: Path([0, 0, 0], [0, length, 0])
          .add(Hershey(length / 10)(`L${dp2(length)}`).moveY(length / 2))
          .color('red')
    });
  };
  Plan.Length = Length;

  // Radius

  const Radius = (radius = 1, center = [0, 0, 0]) =>
    Plan({
      plan: { radius },
      marks: [center],
      visualization:
        Circle.ofRadius(radius)
            .outline()
            .add(Path([0, 0, 0], [0, radius, 0]))
            .add(Hershey(radius / 10)(`R${dp2(radius)}`).moveY(radius / 2))
            .color('red')
    });
  Plan.Radius = Radius;

  const Sketch = (shape) => {
    return Plan({
      plan: { sketch: 'shape' },
      visualization: shape.outline().color('red')
    });
  };
  Plan.Sketch = Sketch;

  Shape.prototype.sketch = function (...args) { return Sketch(this); };
  Shape.prototype.withSketch = function (...args) { return assemble$1(this, Sketch(this)); };

  // FIX: We shouldn't need to supply a path to this.
  const view = (shape, { width = 1024, height = 512, position = [100, -100, 100] } = {}) => {
    for (const entry of ensurePages(shape.toKeptGeometry())) {
      for (let leaf of getLeafs(entry.content)) {
        emit$1({ geometry: { width, height, position, geometry: leaf } });
      }
    }
    return shape;
  };

  Shape.prototype.view = function ({ width = 512, height = 256, position = [100, -100, 100] } = {}) {
    return view(this, { width, height, position });
  };

  Shape.prototype.smallView = function ({ width = 256, height = 128, position = [100, -100, 100] } = {}) {
    return view(this, { width, height, position });
  };

  Shape.prototype.bigView = function ({ width = 1024, height = 512, position = [100, -100, 100] } = {}) {
    return view(this, { width, height, position });
  };

  Shape.prototype.topView = function ({ width = 512, height = 256, position = [0, 0, 100] } = {}) {
    return view(this, { width, height, position });
  };

  Shape.prototype.smallTopView = function ({ width = 256, height = 128, position = [0, 0, 100] } = {}) {
    return view(this, { width, height, position });
  };

  Shape.prototype.bigTopView = function ({ width = 1024, height = 512, position = [0, 0, 100] } = {}) {
    return view(this, { width, height, position });
  };

  Shape.prototype.frontView = function ({ width = 512, height = 256, position = [0, -100, 0] } = {}) {
    return view(this, { width, height, position });
  };

  Shape.prototype.smallFrontView = function ({ width = 256, height = 128, position = [0, -100, 0] } = {}) {
    return view(this, { width, height, position });
  };

  Shape.prototype.bigFrontView = function ({ width = 1024, height = 512, position = [0, -100, 0] } = {}) {
    return view(this, { width, height, position });
  };

  const Z$c = 2;

  // TODO: Radial distortion rather than just lift?
  const arch = (shape, factor, { resolution = 1 } = {}) => {
    const assembly = [];
    for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
      const [min, max] = measureBoundingBox$4(solid);
      const maxZ = max[Z$c];
      const minZ = min[Z$c];
      const height = maxZ - minZ;
      const liftAt = z => factor * Math.sin((z - minZ) / height * Math.PI);
      const lift = ([x, y, z]) => [x + liftAt(z), y, z];
      assembly.push({ solid: deform(makeWatertight(solid), lift, min, max, resolution), tags });
    }

    return Shape.fromGeometry({ assembly });
  };

  const archMethod = function (...args) { return arch(this, ...args); };
  Shape.prototype.arch = archMethod;

  var constants$1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NORM_2D = 1.0 / 47.0;
  exports.NORM_3D = 1.0 / 103.0;
  exports.NORM_4D = 1.0 / 30.0;
  exports.SQUISH_2D = (Math.sqrt(2 + 1) - 1) / 2;
  exports.SQUISH_3D = (Math.sqrt(3 + 1) - 1) / 3;
  exports.SQUISH_4D = (Math.sqrt(4 + 1) - 1) / 4;
  exports.STRETCH_2D = (1 / Math.sqrt(2 + 1) - 1) / 2;
  exports.STRETCH_3D = (1 / Math.sqrt(3 + 1) - 1) / 3;
  exports.STRETCH_4D = (1 / Math.sqrt(4 + 1) - 1) / 4;
  exports.base2D = [
      [1, 1, 0, 1, 0, 1, 0, 0, 0],
      [1, 1, 0, 1, 0, 1, 2, 1, 1]
  ];
  exports.base3D = [
      [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1],
      [2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1, 3, 1, 1, 1],
      [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1]
  ];
  exports.base4D = [
      [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
      [3, 1, 1, 1, 0, 3, 1, 1, 0, 1, 3, 1, 0, 1, 1, 3, 0, 1, 1, 1, 4, 1, 1, 1, 1],
      [
          1,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          1,
          2,
          1,
          1,
          0,
          0,
          2,
          1,
          0,
          1,
          0,
          2,
          1,
          0,
          0,
          1,
          2,
          0,
          1,
          1,
          0,
          2,
          0,
          1,
          0,
          1,
          2,
          0,
          0,
          1,
          1
      ],
      [
          3,
          1,
          1,
          1,
          0,
          3,
          1,
          1,
          0,
          1,
          3,
          1,
          0,
          1,
          1,
          3,
          0,
          1,
          1,
          1,
          2,
          1,
          1,
          0,
          0,
          2,
          1,
          0,
          1,
          0,
          2,
          1,
          0,
          0,
          1,
          2,
          0,
          1,
          1,
          0,
          2,
          0,
          1,
          0,
          1,
          2,
          0,
          0,
          1,
          1
      ]
  ];
  exports.gradients2D = [
      5,
      2,
      2,
      5,
      -5,
      2,
      -2,
      5,
      5,
      -2,
      2,
      -5,
      -5,
      -2,
      -2,
      -5
  ];
  exports.gradients3D = [
      -11,
      4,
      4,
      -4,
      11,
      4,
      -4,
      4,
      11,
      11,
      4,
      4,
      4,
      11,
      4,
      4,
      4,
      11,
      -11,
      -4,
      4,
      -4,
      -11,
      4,
      -4,
      -4,
      11,
      11,
      -4,
      4,
      4,
      -11,
      4,
      4,
      -4,
      11,
      -11,
      4,
      -4,
      -4,
      11,
      -4,
      -4,
      4,
      -11,
      11,
      4,
      -4,
      4,
      11,
      -4,
      4,
      4,
      -11,
      -11,
      -4,
      -4,
      -4,
      -11,
      -4,
      -4,
      -4,
      -11,
      11,
      -4,
      -4,
      4,
      -11,
      -4,
      4,
      -4,
      -11
  ];
  exports.gradients4D = [
      3,
      1,
      1,
      1,
      1,
      3,
      1,
      1,
      1,
      1,
      3,
      1,
      1,
      1,
      1,
      3,
      -3,
      1,
      1,
      1,
      -1,
      3,
      1,
      1,
      -1,
      1,
      3,
      1,
      -1,
      1,
      1,
      3,
      3,
      -1,
      1,
      1,
      1,
      -3,
      1,
      1,
      1,
      -1,
      3,
      1,
      1,
      -1,
      1,
      3,
      -3,
      -1,
      1,
      1,
      -1,
      -3,
      1,
      1,
      -1,
      -1,
      3,
      1,
      -1,
      -1,
      1,
      3,
      3,
      1,
      -1,
      1,
      1,
      3,
      -1,
      1,
      1,
      1,
      -3,
      1,
      1,
      1,
      -1,
      3,
      -3,
      1,
      -1,
      1,
      -1,
      3,
      -1,
      1,
      -1,
      1,
      -3,
      1,
      -1,
      1,
      -1,
      3,
      3,
      -1,
      -1,
      1,
      1,
      -3,
      -1,
      1,
      1,
      -1,
      -3,
      1,
      1,
      -1,
      -1,
      3,
      -3,
      -1,
      -1,
      1,
      -1,
      -3,
      -1,
      1,
      -1,
      -1,
      -3,
      1,
      -1,
      -1,
      -1,
      3,
      3,
      1,
      1,
      -1,
      1,
      3,
      1,
      -1,
      1,
      1,
      3,
      -1,
      1,
      1,
      1,
      -3,
      -3,
      1,
      1,
      -1,
      -1,
      3,
      1,
      -1,
      -1,
      1,
      3,
      -1,
      -1,
      1,
      1,
      -3,
      3,
      -1,
      1,
      -1,
      1,
      -3,
      1,
      -1,
      1,
      -1,
      3,
      -1,
      1,
      -1,
      1,
      -3,
      -3,
      -1,
      1,
      -1,
      -1,
      -3,
      1,
      -1,
      -1,
      -1,
      3,
      -1,
      -1,
      -1,
      1,
      -3,
      3,
      1,
      -1,
      -1,
      1,
      3,
      -1,
      -1,
      1,
      1,
      -3,
      -1,
      1,
      1,
      -1,
      -3,
      -3,
      1,
      -1,
      -1,
      -1,
      3,
      -1,
      -1,
      -1,
      1,
      -3,
      -1,
      -1,
      1,
      -1,
      -3,
      3,
      -1,
      -1,
      -1,
      1,
      -3,
      -1,
      -1,
      1,
      -1,
      -3,
      -1,
      1,
      -1,
      -1,
      -3,
      -3,
      -1,
      -1,
      -1,
      -1,
      -3,
      -1,
      -1,
      -1,
      -1,
      -3,
      -1,
      -1,
      -1,
      -1,
      -3
  ];
  exports.lookupPairs2D = [
      0,
      1,
      1,
      0,
      4,
      1,
      17,
      0,
      20,
      2,
      21,
      2,
      22,
      5,
      23,
      5,
      26,
      4,
      39,
      3,
      42,
      4,
      43,
      3
  ];
  exports.lookupPairs3D = [
      0,
      2,
      1,
      1,
      2,
      2,
      5,
      1,
      6,
      0,
      7,
      0,
      32,
      2,
      34,
      2,
      129,
      1,
      133,
      1,
      160,
      5,
      161,
      5,
      518,
      0,
      519,
      0,
      546,
      4,
      550,
      4,
      645,
      3,
      647,
      3,
      672,
      5,
      673,
      5,
      674,
      4,
      677,
      3,
      678,
      4,
      679,
      3,
      680,
      13,
      681,
      13,
      682,
      12,
      685,
      14,
      686,
      12,
      687,
      14,
      712,
      20,
      714,
      18,
      809,
      21,
      813,
      23,
      840,
      20,
      841,
      21,
      1198,
      19,
      1199,
      22,
      1226,
      18,
      1230,
      19,
      1325,
      23,
      1327,
      22,
      1352,
      15,
      1353,
      17,
      1354,
      15,
      1357,
      17,
      1358,
      16,
      1359,
      16,
      1360,
      11,
      1361,
      10,
      1362,
      11,
      1365,
      10,
      1366,
      9,
      1367,
      9,
      1392,
      11,
      1394,
      11,
      1489,
      10,
      1493,
      10,
      1520,
      8,
      1521,
      8,
      1878,
      9,
      1879,
      9,
      1906,
      7,
      1910,
      7,
      2005,
      6,
      2007,
      6,
      2032,
      8,
      2033,
      8,
      2034,
      7,
      2037,
      6,
      2038,
      7,
      2039,
      6
  ];
  exports.lookupPairs4D = [
      0,
      3,
      1,
      2,
      2,
      3,
      5,
      2,
      6,
      1,
      7,
      1,
      8,
      3,
      9,
      2,
      10,
      3,
      13,
      2,
      16,
      3,
      18,
      3,
      22,
      1,
      23,
      1,
      24,
      3,
      26,
      3,
      33,
      2,
      37,
      2,
      38,
      1,
      39,
      1,
      41,
      2,
      45,
      2,
      54,
      1,
      55,
      1,
      56,
      0,
      57,
      0,
      58,
      0,
      59,
      0,
      60,
      0,
      61,
      0,
      62,
      0,
      63,
      0,
      256,
      3,
      258,
      3,
      264,
      3,
      266,
      3,
      272,
      3,
      274,
      3,
      280,
      3,
      282,
      3,
      2049,
      2,
      2053,
      2,
      2057,
      2,
      2061,
      2,
      2081,
      2,
      2085,
      2,
      2089,
      2,
      2093,
      2,
      2304,
      9,
      2305,
      9,
      2312,
      9,
      2313,
      9,
      16390,
      1,
      16391,
      1,
      16406,
      1,
      16407,
      1,
      16422,
      1,
      16423,
      1,
      16438,
      1,
      16439,
      1,
      16642,
      8,
      16646,
      8,
      16658,
      8,
      16662,
      8,
      18437,
      6,
      18439,
      6,
      18469,
      6,
      18471,
      6,
      18688,
      9,
      18689,
      9,
      18690,
      8,
      18693,
      6,
      18694,
      8,
      18695,
      6,
      18696,
      9,
      18697,
      9,
      18706,
      8,
      18710,
      8,
      18725,
      6,
      18727,
      6,
      131128,
      0,
      131129,
      0,
      131130,
      0,
      131131,
      0,
      131132,
      0,
      131133,
      0,
      131134,
      0,
      131135,
      0,
      131352,
      7,
      131354,
      7,
      131384,
      7,
      131386,
      7,
      133161,
      5,
      133165,
      5,
      133177,
      5,
      133181,
      5,
      133376,
      9,
      133377,
      9,
      133384,
      9,
      133385,
      9,
      133400,
      7,
      133402,
      7,
      133417,
      5,
      133421,
      5,
      133432,
      7,
      133433,
      5,
      133434,
      7,
      133437,
      5,
      147510,
      4,
      147511,
      4,
      147518,
      4,
      147519,
      4,
      147714,
      8,
      147718,
      8,
      147730,
      8,
      147734,
      8,
      147736,
      7,
      147738,
      7,
      147766,
      4,
      147767,
      4,
      147768,
      7,
      147770,
      7,
      147774,
      4,
      147775,
      4,
      149509,
      6,
      149511,
      6,
      149541,
      6,
      149543,
      6,
      149545,
      5,
      149549,
      5,
      149558,
      4,
      149559,
      4,
      149561,
      5,
      149565,
      5,
      149566,
      4,
      149567,
      4,
      149760,
      9,
      149761,
      9,
      149762,
      8,
      149765,
      6,
      149766,
      8,
      149767,
      6,
      149768,
      9,
      149769,
      9,
      149778,
      8,
      149782,
      8,
      149784,
      7,
      149786,
      7,
      149797,
      6,
      149799,
      6,
      149801,
      5,
      149805,
      5,
      149814,
      4,
      149815,
      4,
      149816,
      7,
      149817,
      5,
      149818,
      7,
      149821,
      5,
      149822,
      4,
      149823,
      4,
      149824,
      37,
      149825,
      37,
      149826,
      36,
      149829,
      34,
      149830,
      36,
      149831,
      34,
      149832,
      37,
      149833,
      37,
      149842,
      36,
      149846,
      36,
      149848,
      35,
      149850,
      35,
      149861,
      34,
      149863,
      34,
      149865,
      33,
      149869,
      33,
      149878,
      32,
      149879,
      32,
      149880,
      35,
      149881,
      33,
      149882,
      35,
      149885,
      33,
      149886,
      32,
      149887,
      32,
      150080,
      49,
      150082,
      48,
      150088,
      49,
      150098,
      48,
      150104,
      47,
      150106,
      47,
      151873,
      46,
      151877,
      45,
      151881,
      46,
      151909,
      45,
      151913,
      44,
      151917,
      44,
      152128,
      49,
      152129,
      46,
      152136,
      49,
      152137,
      46,
      166214,
      43,
      166215,
      42,
      166230,
      43,
      166247,
      42,
      166262,
      41,
      166263,
      41,
      166466,
      48,
      166470,
      43,
      166482,
      48,
      166486,
      43,
      168261,
      45,
      168263,
      42,
      168293,
      45,
      168295,
      42,
      168512,
      31,
      168513,
      28,
      168514,
      31,
      168517,
      28,
      168518,
      25,
      168519,
      25,
      280952,
      40,
      280953,
      39,
      280954,
      40,
      280957,
      39,
      280958,
      38,
      280959,
      38,
      281176,
      47,
      281178,
      47,
      281208,
      40,
      281210,
      40,
      282985,
      44,
      282989,
      44,
      283001,
      39,
      283005,
      39,
      283208,
      30,
      283209,
      27,
      283224,
      30,
      283241,
      27,
      283256,
      22,
      283257,
      22,
      297334,
      41,
      297335,
      41,
      297342,
      38,
      297343,
      38,
      297554,
      29,
      297558,
      24,
      297562,
      29,
      297590,
      24,
      297594,
      21,
      297598,
      21,
      299365,
      26,
      299367,
      23,
      299373,
      26,
      299383,
      23,
      299389,
      20,
      299391,
      20,
      299584,
      31,
      299585,
      28,
      299586,
      31,
      299589,
      28,
      299590,
      25,
      299591,
      25,
      299592,
      30,
      299593,
      27,
      299602,
      29,
      299606,
      24,
      299608,
      30,
      299610,
      29,
      299621,
      26,
      299623,
      23,
      299625,
      27,
      299629,
      26,
      299638,
      24,
      299639,
      23,
      299640,
      22,
      299641,
      22,
      299642,
      21,
      299645,
      20,
      299646,
      21,
      299647,
      20,
      299648,
      61,
      299649,
      60,
      299650,
      61,
      299653,
      60,
      299654,
      59,
      299655,
      59,
      299656,
      58,
      299657,
      57,
      299666,
      55,
      299670,
      54,
      299672,
      58,
      299674,
      55,
      299685,
      52,
      299687,
      51,
      299689,
      57,
      299693,
      52,
      299702,
      54,
      299703,
      51,
      299704,
      56,
      299705,
      56,
      299706,
      53,
      299709,
      50,
      299710,
      53,
      299711,
      50,
      299904,
      61,
      299906,
      61,
      299912,
      58,
      299922,
      55,
      299928,
      58,
      299930,
      55,
      301697,
      60,
      301701,
      60,
      301705,
      57,
      301733,
      52,
      301737,
      57,
      301741,
      52,
      301952,
      79,
      301953,
      79,
      301960,
      76,
      301961,
      76,
      316038,
      59,
      316039,
      59,
      316054,
      54,
      316071,
      51,
      316086,
      54,
      316087,
      51,
      316290,
      78,
      316294,
      78,
      316306,
      73,
      316310,
      73,
      318085,
      77,
      318087,
      77,
      318117,
      70,
      318119,
      70,
      318336,
      79,
      318337,
      79,
      318338,
      78,
      318341,
      77,
      318342,
      78,
      318343,
      77,
      430776,
      56,
      430777,
      56,
      430778,
      53,
      430781,
      50,
      430782,
      53,
      430783,
      50,
      431000,
      75,
      431002,
      72,
      431032,
      75,
      431034,
      72,
      432809,
      74,
      432813,
      69,
      432825,
      74,
      432829,
      69,
      433032,
      76,
      433033,
      76,
      433048,
      75,
      433065,
      74,
      433080,
      75,
      433081,
      74,
      447158,
      71,
      447159,
      68,
      447166,
      71,
      447167,
      68,
      447378,
      73,
      447382,
      73,
      447386,
      72,
      447414,
      71,
      447418,
      72,
      447422,
      71,
      449189,
      70,
      449191,
      70,
      449197,
      69,
      449207,
      68,
      449213,
      69,
      449215,
      68,
      449408,
      67,
      449409,
      67,
      449410,
      66,
      449413,
      64,
      449414,
      66,
      449415,
      64,
      449416,
      67,
      449417,
      67,
      449426,
      66,
      449430,
      66,
      449432,
      65,
      449434,
      65,
      449445,
      64,
      449447,
      64,
      449449,
      63,
      449453,
      63,
      449462,
      62,
      449463,
      62,
      449464,
      65,
      449465,
      63,
      449466,
      65,
      449469,
      63,
      449470,
      62,
      449471,
      62,
      449472,
      19,
      449473,
      19,
      449474,
      18,
      449477,
      16,
      449478,
      18,
      449479,
      16,
      449480,
      19,
      449481,
      19,
      449490,
      18,
      449494,
      18,
      449496,
      17,
      449498,
      17,
      449509,
      16,
      449511,
      16,
      449513,
      15,
      449517,
      15,
      449526,
      14,
      449527,
      14,
      449528,
      17,
      449529,
      15,
      449530,
      17,
      449533,
      15,
      449534,
      14,
      449535,
      14,
      449728,
      19,
      449729,
      19,
      449730,
      18,
      449734,
      18,
      449736,
      19,
      449737,
      19,
      449746,
      18,
      449750,
      18,
      449752,
      17,
      449754,
      17,
      449784,
      17,
      449786,
      17,
      451520,
      19,
      451521,
      19,
      451525,
      16,
      451527,
      16,
      451528,
      19,
      451529,
      19,
      451557,
      16,
      451559,
      16,
      451561,
      15,
      451565,
      15,
      451577,
      15,
      451581,
      15,
      451776,
      19,
      451777,
      19,
      451784,
      19,
      451785,
      19,
      465858,
      18,
      465861,
      16,
      465862,
      18,
      465863,
      16,
      465874,
      18,
      465878,
      18,
      465893,
      16,
      465895,
      16,
      465910,
      14,
      465911,
      14,
      465918,
      14,
      465919,
      14,
      466114,
      18,
      466118,
      18,
      466130,
      18,
      466134,
      18,
      467909,
      16,
      467911,
      16,
      467941,
      16,
      467943,
      16,
      468160,
      13,
      468161,
      13,
      468162,
      13,
      468163,
      13,
      468164,
      13,
      468165,
      13,
      468166,
      13,
      468167,
      13,
      580568,
      17,
      580570,
      17,
      580585,
      15,
      580589,
      15,
      580598,
      14,
      580599,
      14,
      580600,
      17,
      580601,
      15,
      580602,
      17,
      580605,
      15,
      580606,
      14,
      580607,
      14,
      580824,
      17,
      580826,
      17,
      580856,
      17,
      580858,
      17,
      582633,
      15,
      582637,
      15,
      582649,
      15,
      582653,
      15,
      582856,
      12,
      582857,
      12,
      582872,
      12,
      582873,
      12,
      582888,
      12,
      582889,
      12,
      582904,
      12,
      582905,
      12,
      596982,
      14,
      596983,
      14,
      596990,
      14,
      596991,
      14,
      597202,
      11,
      597206,
      11,
      597210,
      11,
      597214,
      11,
      597234,
      11,
      597238,
      11,
      597242,
      11,
      597246,
      11,
      599013,
      10,
      599015,
      10,
      599021,
      10,
      599023,
      10,
      599029,
      10,
      599031,
      10,
      599037,
      10,
      599039,
      10,
      599232,
      13,
      599233,
      13,
      599234,
      13,
      599235,
      13,
      599236,
      13,
      599237,
      13,
      599238,
      13,
      599239,
      13,
      599240,
      12,
      599241,
      12,
      599250,
      11,
      599254,
      11,
      599256,
      12,
      599257,
      12,
      599258,
      11,
      599262,
      11,
      599269,
      10,
      599271,
      10,
      599272,
      12,
      599273,
      12,
      599277,
      10,
      599279,
      10,
      599282,
      11,
      599285,
      10,
      599286,
      11,
      599287,
      10,
      599288,
      12,
      599289,
      12,
      599290,
      11,
      599293,
      10,
      599294,
      11,
      599295,
      10
  ];
  exports.p2D = [
      0,
      0,
      1,
      -1,
      0,
      0,
      -1,
      1,
      0,
      2,
      1,
      1,
      1,
      2,
      2,
      0,
      1,
      2,
      0,
      2,
      1,
      0,
      0,
      0
  ];
  exports.p3D = [
      0,
      0,
      1,
      -1,
      0,
      0,
      1,
      0,
      -1,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      1,
      -1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      -1,
      1,
      0,
      2,
      1,
      1,
      0,
      1,
      1,
      1,
      -1,
      0,
      2,
      1,
      0,
      1,
      1,
      1,
      -1,
      1,
      0,
      2,
      0,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      3,
      2,
      1,
      0,
      3,
      1,
      2,
      0,
      1,
      3,
      2,
      0,
      1,
      3,
      1,
      0,
      2,
      1,
      3,
      0,
      2,
      1,
      3,
      0,
      1,
      2,
      1,
      1,
      1,
      0,
      0,
      2,
      2,
      0,
      0,
      1,
      1,
      0,
      1,
      0,
      2,
      0,
      2,
      0,
      1,
      1,
      0,
      0,
      1,
      2,
      0,
      0,
      2,
      2,
      0,
      0,
      0,
      0,
      1,
      1,
      -1,
      1,
      2,
      0,
      0,
      0,
      0,
      1,
      -1,
      1,
      1,
      2,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      -1,
      2,
      3,
      1,
      1,
      1,
      2,
      0,
      0,
      2,
      2,
      3,
      1,
      1,
      1,
      2,
      2,
      0,
      0,
      2,
      3,
      1,
      1,
      1,
      2,
      0,
      2,
      0,
      2,
      1,
      1,
      -1,
      1,
      2,
      0,
      0,
      2,
      2,
      1,
      1,
      -1,
      1,
      2,
      2,
      0,
      0,
      2,
      1,
      -1,
      1,
      1,
      2,
      0,
      0,
      2,
      2,
      1,
      -1,
      1,
      1,
      2,
      0,
      2,
      0,
      2,
      1,
      1,
      1,
      -1,
      2,
      2,
      0,
      0,
      2,
      1,
      1,
      1,
      -1,
      2,
      0,
      2,
      0
  ];
  exports.p4D = [
      0,
      0,
      1,
      -1,
      0,
      0,
      0,
      1,
      0,
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      -1,
      0,
      0,
      0,
      1,
      0,
      -1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      -1,
      0,
      0,
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      2,
      1,
      1,
      0,
      0,
      1,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      0,
      2,
      1,
      0,
      1,
      0,
      1,
      1,
      -1,
      1,
      0,
      1,
      1,
      0,
      1,
      -1,
      0,
      2,
      0,
      1,
      1,
      0,
      1,
      -1,
      1,
      1,
      0,
      1,
      0,
      1,
      1,
      -1,
      0,
      2,
      1,
      0,
      0,
      1,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      1,
      0,
      2,
      0,
      1,
      0,
      1,
      1,
      -1,
      1,
      0,
      1,
      1,
      0,
      1,
      -1,
      1,
      0,
      2,
      0,
      0,
      1,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      1,
      1,
      1,
      4,
      2,
      1,
      1,
      0,
      4,
      1,
      2,
      1,
      0,
      4,
      1,
      1,
      2,
      0,
      1,
      4,
      2,
      1,
      0,
      1,
      4,
      1,
      2,
      0,
      1,
      4,
      1,
      1,
      0,
      2,
      1,
      4,
      2,
      0,
      1,
      1,
      4,
      1,
      0,
      2,
      1,
      4,
      1,
      0,
      1,
      2,
      1,
      4,
      0,
      2,
      1,
      1,
      4,
      0,
      1,
      2,
      1,
      4,
      0,
      1,
      1,
      2,
      1,
      2,
      1,
      1,
      0,
      0,
      3,
      2,
      1,
      0,
      0,
      3,
      1,
      2,
      0,
      0,
      1,
      2,
      1,
      0,
      1,
      0,
      3,
      2,
      0,
      1,
      0,
      3,
      1,
      0,
      2,
      0,
      1,
      2,
      0,
      1,
      1,
      0,
      3,
      0,
      2,
      1,
      0,
      3,
      0,
      1,
      2,
      0,
      1,
      2,
      1,
      0,
      0,
      1,
      3,
      2,
      0,
      0,
      1,
      3,
      1,
      0,
      0,
      2,
      1,
      2,
      0,
      1,
      0,
      1,
      3,
      0,
      2,
      0,
      1,
      3,
      0,
      1,
      0,
      2,
      1,
      2,
      0,
      0,
      1,
      1,
      3,
      0,
      0,
      2,
      1,
      3,
      0,
      0,
      1,
      2,
      2,
      3,
      1,
      1,
      1,
      0,
      2,
      1,
      1,
      1,
      -1,
      2,
      2,
      0,
      0,
      0,
      2,
      3,
      1,
      1,
      0,
      1,
      2,
      1,
      1,
      -1,
      1,
      2,
      2,
      0,
      0,
      0,
      2,
      3,
      1,
      0,
      1,
      1,
      2,
      1,
      -1,
      1,
      1,
      2,
      2,
      0,
      0,
      0,
      2,
      3,
      1,
      1,
      1,
      0,
      2,
      1,
      1,
      1,
      -1,
      2,
      0,
      2,
      0,
      0,
      2,
      3,
      1,
      1,
      0,
      1,
      2,
      1,
      1,
      -1,
      1,
      2,
      0,
      2,
      0,
      0,
      2,
      3,
      0,
      1,
      1,
      1,
      2,
      -1,
      1,
      1,
      1,
      2,
      0,
      2,
      0,
      0,
      2,
      3,
      1,
      1,
      1,
      0,
      2,
      1,
      1,
      1,
      -1,
      2,
      0,
      0,
      2,
      0,
      2,
      3,
      1,
      0,
      1,
      1,
      2,
      1,
      -1,
      1,
      1,
      2,
      0,
      0,
      2,
      0,
      2,
      3,
      0,
      1,
      1,
      1,
      2,
      -1,
      1,
      1,
      1,
      2,
      0,
      0,
      2,
      0,
      2,
      3,
      1,
      1,
      0,
      1,
      2,
      1,
      1,
      -1,
      1,
      2,
      0,
      0,
      0,
      2,
      2,
      3,
      1,
      0,
      1,
      1,
      2,
      1,
      -1,
      1,
      1,
      2,
      0,
      0,
      0,
      2,
      2,
      3,
      0,
      1,
      1,
      1,
      2,
      -1,
      1,
      1,
      1,
      2,
      0,
      0,
      0,
      2,
      2,
      1,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      0,
      0,
      0,
      0,
      0,
      2,
      1,
      1,
      -1,
      1,
      0,
      1,
      1,
      0,
      1,
      -1,
      0,
      0,
      0,
      0,
      0,
      2,
      1,
      -1,
      1,
      1,
      0,
      1,
      0,
      1,
      1,
      -1,
      0,
      0,
      0,
      0,
      0,
      2,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      0,
      2,
      1,
      -1,
      1,
      0,
      1,
      1,
      0,
      1,
      -1,
      1,
      0,
      0,
      0,
      0,
      0,
      2,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      2,
      1,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      2,
      2,
      0,
      0,
      0,
      2,
      1,
      1,
      -1,
      1,
      0,
      1,
      1,
      0,
      1,
      -1,
      2,
      2,
      0,
      0,
      0,
      2,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      1,
      2,
      2,
      0,
      0,
      0,
      2,
      1,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      2,
      0,
      2,
      0,
      0,
      2,
      1,
      -1,
      1,
      1,
      0,
      1,
      0,
      1,
      1,
      -1,
      2,
      0,
      2,
      0,
      0,
      2,
      1,
      -1,
      1,
      0,
      1,
      1,
      0,
      1,
      -1,
      1,
      2,
      0,
      2,
      0,
      0,
      2,
      1,
      1,
      -1,
      1,
      0,
      1,
      1,
      0,
      1,
      -1,
      2,
      0,
      0,
      2,
      0,
      2,
      1,
      -1,
      1,
      1,
      0,
      1,
      0,
      1,
      1,
      -1,
      2,
      0,
      0,
      2,
      0,
      2,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      1,
      1,
      2,
      0,
      0,
      2,
      0,
      2,
      1,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      1,
      2,
      0,
      0,
      0,
      2,
      2,
      1,
      -1,
      1,
      0,
      1,
      1,
      0,
      1,
      -1,
      1,
      2,
      0,
      0,
      0,
      2,
      2,
      1,
      -1,
      0,
      1,
      1,
      1,
      0,
      -1,
      1,
      1,
      2,
      0,
      0,
      0,
      2,
      3,
      1,
      1,
      0,
      0,
      0,
      2,
      2,
      0,
      0,
      0,
      2,
      1,
      1,
      1,
      -1,
      3,
      1,
      0,
      1,
      0,
      0,
      2,
      0,
      2,
      0,
      0,
      2,
      1,
      1,
      1,
      -1,
      3,
      1,
      0,
      0,
      1,
      0,
      2,
      0,
      0,
      2,
      0,
      2,
      1,
      1,
      1,
      -1,
      3,
      1,
      1,
      0,
      0,
      0,
      2,
      2,
      0,
      0,
      0,
      2,
      1,
      1,
      -1,
      1,
      3,
      1,
      0,
      1,
      0,
      0,
      2,
      0,
      2,
      0,
      0,
      2,
      1,
      1,
      -1,
      1,
      3,
      1,
      0,
      0,
      0,
      1,
      2,
      0,
      0,
      0,
      2,
      2,
      1,
      1,
      -1,
      1,
      3,
      1,
      1,
      0,
      0,
      0,
      2,
      2,
      0,
      0,
      0,
      2,
      1,
      -1,
      1,
      1,
      3,
      1,
      0,
      0,
      1,
      0,
      2,
      0,
      0,
      2,
      0,
      2,
      1,
      -1,
      1,
      1,
      3,
      1,
      0,
      0,
      0,
      1,
      2,
      0,
      0,
      0,
      2,
      2,
      1,
      -1,
      1,
      1,
      3,
      1,
      0,
      1,
      0,
      0,
      2,
      0,
      2,
      0,
      0,
      2,
      -1,
      1,
      1,
      1,
      3,
      1,
      0,
      0,
      1,
      0,
      2,
      0,
      0,
      2,
      0,
      2,
      -1,
      1,
      1,
      1,
      3,
      1,
      0,
      0,
      0,
      1,
      2,
      0,
      0,
      0,
      2,
      2,
      -1,
      1,
      1,
      1,
      3,
      3,
      2,
      1,
      0,
      0,
      3,
      1,
      2,
      0,
      0,
      4,
      1,
      1,
      1,
      1,
      3,
      3,
      2,
      0,
      1,
      0,
      3,
      1,
      0,
      2,
      0,
      4,
      1,
      1,
      1,
      1,
      3,
      3,
      0,
      2,
      1,
      0,
      3,
      0,
      1,
      2,
      0,
      4,
      1,
      1,
      1,
      1,
      3,
      3,
      2,
      0,
      0,
      1,
      3,
      1,
      0,
      0,
      2,
      4,
      1,
      1,
      1,
      1,
      3,
      3,
      0,
      2,
      0,
      1,
      3,
      0,
      1,
      0,
      2,
      4,
      1,
      1,
      1,
      1,
      3,
      3,
      0,
      0,
      2,
      1,
      3,
      0,
      0,
      1,
      2,
      4,
      1,
      1,
      1,
      1,
      3,
      3,
      2,
      1,
      0,
      0,
      3,
      1,
      2,
      0,
      0,
      2,
      1,
      1,
      1,
      -1,
      3,
      3,
      2,
      0,
      1,
      0,
      3,
      1,
      0,
      2,
      0,
      2,
      1,
      1,
      1,
      -1,
      3,
      3,
      0,
      2,
      1,
      0,
      3,
      0,
      1,
      2,
      0,
      2,
      1,
      1,
      1,
      -1,
      3,
      3,
      2,
      1,
      0,
      0,
      3,
      1,
      2,
      0,
      0,
      2,
      1,
      1,
      -1,
      1,
      3,
      3,
      2,
      0,
      0,
      1,
      3,
      1,
      0,
      0,
      2,
      2,
      1,
      1,
      -1,
      1,
      3,
      3,
      0,
      2,
      0,
      1,
      3,
      0,
      1,
      0,
      2,
      2,
      1,
      1,
      -1,
      1,
      3,
      3,
      2,
      0,
      1,
      0,
      3,
      1,
      0,
      2,
      0,
      2,
      1,
      -1,
      1,
      1,
      3,
      3,
      2,
      0,
      0,
      1,
      3,
      1,
      0,
      0,
      2,
      2,
      1,
      -1,
      1,
      1,
      3,
      3,
      0,
      0,
      2,
      1,
      3,
      0,
      0,
      1,
      2,
      2,
      1,
      -1,
      1,
      1,
      3,
      3,
      0,
      2,
      1,
      0,
      3,
      0,
      1,
      2,
      0,
      2,
      -1,
      1,
      1,
      1,
      3,
      3,
      0,
      2,
      0,
      1,
      3,
      0,
      1,
      0,
      2,
      2,
      -1,
      1,
      1,
      1,
      3,
      3,
      0,
      0,
      2,
      1,
      3,
      0,
      0,
      1,
      2,
      2,
      -1,
      1,
      1,
      1
  ];
  });

  unwrapExports(constants$1);
  var constants_1$1 = constants$1.NORM_2D;
  var constants_2 = constants$1.NORM_3D;
  var constants_3 = constants$1.NORM_4D;
  var constants_4 = constants$1.SQUISH_2D;
  var constants_5 = constants$1.SQUISH_3D;
  var constants_6 = constants$1.SQUISH_4D;
  var constants_7 = constants$1.STRETCH_2D;
  var constants_8 = constants$1.STRETCH_3D;
  var constants_9 = constants$1.STRETCH_4D;
  var constants_10 = constants$1.base2D;
  var constants_11 = constants$1.base3D;
  var constants_12 = constants$1.base4D;
  var constants_13 = constants$1.gradients2D;
  var constants_14 = constants$1.gradients3D;
  var constants_15 = constants$1.gradients4D;
  var constants_16 = constants$1.lookupPairs2D;
  var constants_17 = constants$1.lookupPairs3D;
  var constants_18 = constants$1.lookupPairs4D;
  var constants_19 = constants$1.p2D;
  var constants_20 = constants$1.p3D;
  var constants_21 = constants$1.p4D;

  var lib = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });

  function contribution2D(multiplier, xsb, ysb) {
      return {
          dx: -xsb - multiplier * constants$1.SQUISH_2D,
          dy: -ysb - multiplier * constants$1.SQUISH_2D,
          xsb: xsb,
          ysb: ysb
      };
  }
  function contribution3D(multiplier, xsb, ysb, zsb) {
      return {
          dx: -xsb - multiplier * constants$1.SQUISH_3D,
          dy: -ysb - multiplier * constants$1.SQUISH_3D,
          dz: -zsb - multiplier * constants$1.SQUISH_3D,
          xsb: xsb,
          ysb: ysb,
          zsb: zsb
      };
  }
  function contribution4D(multiplier, xsb, ysb, zsb, wsb) {
      return {
          dx: -xsb - multiplier * constants$1.SQUISH_4D,
          dy: -ysb - multiplier * constants$1.SQUISH_4D,
          dz: -zsb - multiplier * constants$1.SQUISH_4D,
          dw: -wsb - multiplier * constants$1.SQUISH_4D,
          xsb: xsb,
          ysb: ysb,
          zsb: zsb,
          wsb: wsb
      };
  }
  function makeNoise2D(clientSeed) {
      var contributions = [];
      for (var i = 0; i < constants$1.p2D.length; i += 4) {
          var baseSet = constants$1.base2D[constants$1.p2D[i]];
          var previous = null;
          var current = null;
          for (var k = 0; k < baseSet.length; k += 3) {
              current = contribution2D(baseSet[k], baseSet[k + 1], baseSet[k + 2]);
              if (previous === null)
                  contributions[i / 4] = current;
              else
                  previous.next = current;
              previous = current;
          }
          current.next = contribution2D(constants$1.p2D[i + 1], constants$1.p2D[i + 2], constants$1.p2D[i + 3]);
      }
      var lookup = [];
      for (var i = 0; i < constants$1.lookupPairs2D.length; i += 2) {
          lookup[constants$1.lookupPairs2D[i]] = contributions[constants$1.lookupPairs2D[i + 1]];
      }
      var perm = new Uint8Array(256);
      var perm2D = new Uint8Array(256);
      var source = new Uint8Array(256);
      for (var i = 0; i < 256; i++)
          source[i] = i;
      var seed = new Uint32Array(1);
      seed[0] = clientSeed;
      seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
      for (var i = 255; i >= 0; i--) {
          seed = shuffleSeed(seed);
          var r = new Uint32Array(1);
          r[0] = (seed[0] + 31) % (i + 1);
          if (r[0] < 0)
              r[0] += i + 1;
          perm[i] = source[r[0]];
          perm2D[i] = perm[i] & 0x0e;
          source[r[0]] = source[i];
      }
      return function (x, y) {
          var stretchOffset = (x + y) * constants$1.STRETCH_2D;
          var xs = x + stretchOffset;
          var ys = y + stretchOffset;
          var xsb = Math.floor(xs);
          var ysb = Math.floor(ys);
          var squishOffset = (xsb + ysb) * constants$1.SQUISH_2D;
          var dx0 = x - (xsb + squishOffset);
          var dy0 = y - (ysb + squishOffset);
          var xins = xs - xsb;
          var yins = ys - ysb;
          var inSum = xins + yins;
          var hash = (xins - yins + 1) |
              (inSum << 1) |
              ((inSum + yins) << 2) |
              ((inSum + xins) << 4);
          var value = 0;
          for (var c = lookup[hash]; c !== undefined; c = c.next) {
              var dx = dx0 + c.dx;
              var dy = dy0 + c.dy;
              var attn = 2 - dx * dx - dy * dy;
              if (attn > 0) {
                  var px = xsb + c.xsb;
                  var py = ysb + c.ysb;
                  var indexPartA = perm[px & 0xff];
                  var index = perm2D[(indexPartA + py) & 0xff];
                  var valuePart = constants$1.gradients2D[index] * dx + constants$1.gradients2D[index + 1] * dy;
                  value += attn * attn * attn * attn * valuePart;
              }
          }
          return value * constants$1.NORM_2D;
      };
  }
  exports.makeNoise2D = makeNoise2D;
  function makeNoise3D(clientSeed) {
      var contributions = [];
      for (var i = 0; i < constants$1.p3D.length; i += 9) {
          var baseSet = constants$1.base3D[constants$1.p3D[i]];
          var previous = null;
          var current = null;
          for (var k = 0; k < baseSet.length; k += 4) {
              current = contribution3D(baseSet[k], baseSet[k + 1], baseSet[k + 2], baseSet[k + 3]);
              if (previous === null)
                  contributions[i / 9] = current;
              else
                  previous.next = current;
              previous = current;
          }
          current.next = contribution3D(constants$1.p3D[i + 1], constants$1.p3D[i + 2], constants$1.p3D[i + 3], constants$1.p3D[i + 4]);
          current.next.next = contribution3D(constants$1.p3D[i + 5], constants$1.p3D[i + 6], constants$1.p3D[i + 7], constants$1.p3D[i + 8]);
      }
      var lookup = [];
      for (var i = 0; i < constants$1.lookupPairs3D.length; i += 2) {
          lookup[constants$1.lookupPairs3D[i]] = contributions[constants$1.lookupPairs3D[i + 1]];
      }
      var perm = new Uint8Array(256);
      var perm3D = new Uint8Array(256);
      var source = new Uint8Array(256);
      for (var i = 0; i < 256; i++)
          source[i] = i;
      var seed = new Uint32Array(1);
      seed[0] = clientSeed;
      seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
      for (var i = 255; i >= 0; i--) {
          seed = shuffleSeed(seed);
          var r = new Uint32Array(1);
          r[0] = (seed[0] + 31) % (i + 1);
          if (r[0] < 0)
              r[0] += i + 1;
          perm[i] = source[r[0]];
          perm3D[i] = (perm[i] % 24) * 3;
          source[r[0]] = source[i];
      }
      return function (x, y, z) {
          var stretchOffset = (x + y + z) * constants$1.STRETCH_3D;
          var xs = x + stretchOffset;
          var ys = y + stretchOffset;
          var zs = z + stretchOffset;
          var xsb = Math.floor(xs);
          var ysb = Math.floor(ys);
          var zsb = Math.floor(zs);
          var squishOffset = (xsb + ysb + zsb) * constants$1.SQUISH_3D;
          var dx0 = x - (xsb + squishOffset);
          var dy0 = y - (ysb + squishOffset);
          var dz0 = z - (zsb + squishOffset);
          var xins = xs - xsb;
          var yins = ys - ysb;
          var zins = zs - zsb;
          var inSum = xins + yins + zins;
          var hash = (yins - zins + 1) |
              ((xins - yins + 1) << 1) |
              ((xins - zins + 1) << 2) |
              (inSum << 3) |
              ((inSum + zins) << 5) |
              ((inSum + yins) << 7) |
              ((inSum + xins) << 9);
          var value = 0;
          for (var c = lookup[hash]; c !== undefined; c = c.next) {
              var dx = dx0 + c.dx;
              var dy = dy0 + c.dy;
              var dz = dz0 + c.dz;
              var attn = 2 - dx * dx - dy * dy - dz * dz;
              if (attn > 0) {
                  var px = xsb + c.xsb;
                  var py = ysb + c.ysb;
                  var pz = zsb + c.zsb;
                  var indexPartA = perm[px & 0xff];
                  var indexPartB = perm[(indexPartA + py) & 0xff];
                  var index = perm3D[(indexPartB + pz) & 0xff];
                  var valuePart = constants$1.gradients3D[index] * dx +
                      constants$1.gradients3D[index + 1] * dy +
                      constants$1.gradients3D[index + 2] * dz;
                  value += attn * attn * attn * attn * valuePart;
              }
          }
          return value * constants$1.NORM_3D;
      };
  }
  exports.makeNoise3D = makeNoise3D;
  function makeNoise4D(clientSeed) {
      var contributions = [];
      for (var i = 0; i < constants$1.p4D.length; i += 16) {
          var baseSet = constants$1.base4D[constants$1.p4D[i]];
          var previous = null;
          var current = null;
          for (var k = 0; k < baseSet.length; k += 5) {
              current = contribution4D(baseSet[k], baseSet[k + 1], baseSet[k + 2], baseSet[k + 3], baseSet[k + 4]);
              if (previous === null)
                  contributions[i / 16] = current;
              else
                  previous.next = current;
              previous = current;
          }
          current.next = contribution4D(constants$1.p4D[i + 1], constants$1.p4D[i + 2], constants$1.p4D[i + 3], constants$1.p4D[i + 4], constants$1.p4D[i + 5]);
          current.next.next = contribution4D(constants$1.p4D[i + 6], constants$1.p4D[i + 7], constants$1.p4D[i + 8], constants$1.p4D[i + 9], constants$1.p4D[i + 10]);
          current.next.next.next = contribution4D(constants$1.p4D[i + 11], constants$1.p4D[i + 12], constants$1.p4D[i + 13], constants$1.p4D[i + 14], constants$1.p4D[i + 15]);
      }
      var lookup = [];
      for (var i = 0; i < constants$1.lookupPairs4D.length; i += 2) {
          lookup[constants$1.lookupPairs4D[i]] = contributions[constants$1.lookupPairs4D[i + 1]];
      }
      var perm = new Uint8Array(256);
      var perm4D = new Uint8Array(256);
      var source = new Uint8Array(256);
      for (var i = 0; i < 256; i++)
          source[i] = i;
      var seed = new Uint32Array(1);
      seed[0] = clientSeed;
      seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
      for (var i = 255; i >= 0; i--) {
          seed = shuffleSeed(seed);
          var r = new Uint32Array(1);
          r[0] = (seed[0] + 31) % (i + 1);
          if (r[0] < 0)
              r[0] += i + 1;
          perm[i] = source[r[0]];
          perm4D[i] = perm[i] & 0xfc;
          source[r[0]] = source[i];
      }
      return function (x, y, z, w) {
          var stretchOffset = (x + y + z + w) * constants$1.STRETCH_4D;
          var xs = x + stretchOffset;
          var ys = y + stretchOffset;
          var zs = z + stretchOffset;
          var ws = w + stretchOffset;
          var xsb = Math.floor(xs);
          var ysb = Math.floor(ys);
          var zsb = Math.floor(zs);
          var wsb = Math.floor(ws);
          var squishOffset = (xsb + ysb + zsb + wsb) * constants$1.SQUISH_4D;
          var dx0 = x - (xsb + squishOffset);
          var dy0 = y - (ysb + squishOffset);
          var dz0 = z - (zsb + squishOffset);
          var dw0 = w - (wsb + squishOffset);
          var xins = xs - xsb;
          var yins = ys - ysb;
          var zins = zs - zsb;
          var wins = ws - wsb;
          var inSum = xins + yins + zins + wins;
          var hash = (zins - wins + 1) |
              ((yins - zins + 1) << 1) |
              ((yins - wins + 1) << 2) |
              ((xins - yins + 1) << 3) |
              ((xins - zins + 1) << 4) |
              ((xins - wins + 1) << 5) |
              (inSum << 6) |
              ((inSum + wins) << 8) |
              ((inSum + zins) << 11) |
              ((inSum + yins) << 14) |
              ((inSum + xins) << 17);
          var value = 0;
          for (var c = lookup[hash]; c !== undefined; c = c.next) {
              var dx = dx0 + c.dx;
              var dy = dy0 + c.dy;
              var dz = dz0 + c.dz;
              var dw = dw0 + c.dw;
              var attn = 2 - dx * dx - dy * dy - dz * dz - dw * dw;
              if (attn > 0) {
                  var px = xsb + c.xsb;
                  var py = ysb + c.ysb;
                  var pz = zsb + c.zsb;
                  var pw = wsb + c.wsb;
                  var indexPartA = perm[px & 0xff];
                  var indexPartB = perm[(indexPartA + py) & 0xff];
                  var indexPartC = perm[(indexPartB + pz) & 0xff];
                  var index = perm4D[(indexPartC + pw) & 0xff];
                  var valuePart = constants$1.gradients4D[index] * dx +
                      constants$1.gradients4D[index + 1] * dy +
                      constants$1.gradients4D[index + 2] * dz +
                      constants$1.gradients4D[index + 3] * dw;
                  value += attn * attn * attn * attn * valuePart;
              }
          }
          return value * constants$1.NORM_4D;
      };
  }
  exports.makeNoise4D = makeNoise4D;
  function shuffleSeed(seed) {
      var newSeed = new Uint32Array(1);
      newSeed[0] = seed[0] * 1664525 + 1013904223;
      return newSeed;
  }
  });

  unwrapExports(lib);
  var lib_1 = lib.makeNoise2D;
  var lib_2 = lib.makeNoise3D;
  var lib_3 = lib.makeNoise4D;

  const X$j = 0;
  const Y$j = 1;
  const Z$d = 2;

  const crumple = (shape, amount = 0.1, { resolution = 1, seed = 1 } = {}) => {
    const scale = amount / 2;

    const noiseX = lib_2(seed + 0);
    const noiseY = lib_2(seed + 1);
    const noiseZ = lib_2(seed + 2);

    const perturb = (point) => [point[X$j] + noiseX(...point) * scale,
                                point[Y$j] + noiseY(...point) * scale,
                                point[Z$d] + noiseZ(...point) * scale];

    const assembly = [];
    for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
      const [min, max] = measureBoundingBox$4(solid);
      assembly.push({ solid: deform(makeWatertight(solid), perturb, min, max, resolution), tags });
    }

    return Shape.fromGeometry({ assembly });
  };

  const crumpleMethod = function (...args) { return crumple(this, ...args); };
  Shape.prototype.crumple = crumpleMethod;

  const Z$e = 0;

  const skew$1 = (shape, factor, { resolution = 1 } = {}) => {
    const assembly = [];
    for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
      const [min, max] = measureBoundingBox$4(solid);
      const maxZ = max[Z$e];
      const minZ = min[Z$e];
      const height = maxZ - minZ;
      const shiftAt = z => 1 - (z - minZ) / height * (1 - factor);
      const shift = ([x, y, z]) => [x + shiftAt(z), y + shiftAt(z), z];
      assembly.push({ solid: deform(makeWatertight(solid), shift, min, max, resolution), tags });
    }

    return Shape.fromGeometry({ assembly });
  };

  const skewMethod = function (...args) { return skew$1(this, ...args); };
  Shape.prototype.skew = skewMethod;

  const Z$f = 2;

  const scaleXY = (factor, [x, y, z]) => [...scale$1(factor, [x, y]), z];

  // TODO: Support different factors for x and y.
  const taper = (shape, factor, { resolution = 1 } = {}) => {
    const assembly = [];
    for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
      const [min, max] = measureBoundingBox$4(solid);
      const maxZ = max[Z$f];
      const minZ = min[Z$f];
      const height = maxZ - minZ;
      const widthAt = z => 1 - (z - minZ) / height * (1 - factor);
      const squeeze = ([x, y, z]) => scaleXY(widthAt(z), [x, y, z]);
      assembly.push({ solid: deform(makeWatertight(solid), squeeze, min, max, resolution), tags });
    }

    return Shape.fromGeometry({ assembly });
  };

  const taperMethod = function (...args) { return taper(this, ...args); };
  Shape.prototype.taper = taperMethod;

  const Z$g = 2;

  const twist = (shape, angle = 0, { resolution = 1 } = {}) => {
    const assembly = [];
    for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
      const [min, max] = measureBoundingBox$4(solid);
      const height = max[Z$g] - min[Z$g];
      const radians = (angle / height) * (Math.PI / 180);
      const rotate = point => rotateZ(point, radians * (point[Z$g] - min[Z$g]));
      assembly.push({ solid: deform(makeWatertight(solid), rotate, min, max, resolution), tags });
    }

    return Shape.fromGeometry({ assembly });
  };

  const twistMethod = function (...args) { return twist(this, ...args); };
  Shape.prototype.twist = twistMethod;

  const toFillColor = (rgb) => `${(rgb[0] / 255).toFixed(9)} ${(rgb[1] / 255).toFixed(9)} ${(rgb[2] / 255).toFixed(9)} rg`;
  const toStrokeColor = (rgb) => `${(rgb[0] / 255).toFixed(9)} ${(rgb[1] / 255).toFixed(9)} ${(rgb[2] / 255).toFixed(9)} RG`;

  const black = [0, 0, 0];

  // Not entirely sure how conformant this is, but it seems to work for simple
  // cases.

  // Width and height are in post-script points.
  const header = ({ scale = 1, width = 210, height = 297, trim = 5, lineWidth = 0.096 }) => {
    const mediaX1 = 0 * scale;
    const mediaY1 = 0 * scale;
    const mediaX2 = width * scale;
    const mediaY2 = height * scale;
    const trimX1 = trim * scale;
    const trimY1 = trim * scale;
    const trimX2 = (width - trim) * scale;
    const trimY2 = (height - trim) * scale;
    return [
      `%PDF-1.5`,
      `1 0 obj << /Pages 2 0 R /Type /Catalog >> endobj`,
      `2 0 obj << /Count 1 /Kids [ 3 0 R ] /Type /Pages >> endobj`,
      `3 0 obj <<`,
      `  /Contents 4 0 R`,
      `  /MediaBox [ ${mediaX1.toFixed(9)} ${mediaY1.toFixed(9)} ${mediaX2.toFixed(9)} ${mediaY2.toFixed(9)} ]`,
      `  /TrimBox [ ${trimX1.toFixed(9)} ${trimY1.toFixed(9)} ${trimX2.toFixed(9)} ${trimY2.toFixed(9)} ]`,
      `  /Parent 2 0 R`,
      `  /Type /Page`,
      `>>`,
      `endobj`,
      `4 0 obj << >>`,
      `stream`,
      `${lineWidth.toFixed(9)} w`
    ];
  };

  const footer =
     [`endstream`,
      `endobj`,
      `trailer << /Root 1 0 R /Size 4 >>`,
      `%%EOF`];

  const toPdf = async (geometry, { lineWidth = 0.096, size = [210, 297] } = {}) => {
    geometry = await geometry;

    // This is the size of a post-script point in mm.
    const pointSize = 0.352777778;
    const scale = 1 / pointSize;
    const [width, height] = size;
    const lines = [];
    const matrix = multiply$1(fromTranslation([width * scale / 2, height * scale / 2, 0]),
                            fromScaling([scale, scale, scale]));
    const keptGeometry = toKeptGeometry(transform$a(matrix, geometry));
    for (const { tags, surface } of getSurfaces(keptGeometry)) {
      lines.push(toFillColor(toRgbFromTags(tags, black)));
      lines.push(toStrokeColor(toRgbFromTags(tags, black)));
      for (const path of outline$1(surface)) {
        let nth = (path[0] === null) ? 1 : 0;
        const [x1, y1] = path[nth];
        lines.push(`${x1.toFixed(9)} ${y1.toFixed(9)} m`); // move-to.
        for (nth++; nth < path.length; nth++) {
          const [x2, y2] = path[nth];
          lines.push(`${x2.toFixed(9)} ${y2.toFixed(9)} l`); // line-to.
        }
        lines.push(`h`); // Surface paths are always closed.
      }
      lines.push(`f`); // Surface paths are always filled.
    }
    for (const { tags, z0Surface } of getZ0Surfaces(keptGeometry)) {
      lines.push(toFillColor(toRgbFromTags(tags, black)));
      lines.push(toStrokeColor(toRgbFromTags(tags, black)));
      // FIX: Avoid making the surface convex.
      for (const path of outline$1(z0Surface)) {
        let nth = (path[0] === null) ? 1 : 0;
        const [x1, y1] = path[nth];
        lines.push(`${x1.toFixed(9)} ${y1.toFixed(9)} m`); // move-to.
        for (nth++; nth < path.length; nth++) {
          const [x2, y2] = path[nth];
          lines.push(`${x2.toFixed(9)} ${y2.toFixed(9)} l`); // line-to.
        }
        lines.push(`h`); // Surface paths are always closed.
      }
      lines.push(`f`); // Surface paths are always filled.
    }
    for (const { tags, paths } of getPaths(keptGeometry)) {
      lines.push(toStrokeColor(toRgbFromTags(tags, black)));
      for (const path of paths) {
        let nth = (path[0] === null) ? 1 : 0;
        const [x1, y1] = path[nth];
        lines.push(`${x1.toFixed(9)} ${y1.toFixed(9)} m`); // move-to.
        for (nth++; nth < path.length; nth++) {
          const [x2, y2] = path[nth];
          lines.push(`${x2.toFixed(9)} ${y2.toFixed(9)} l`); // line-to.
        }
        if (path[0] !== null) {
          // A leading null indicates an open path.
          lines.push(`h`); // close path.
        }
        lines.push(`S`); // stroke.
      }
    }

    const output = [].concat(header({ scale, width, height, lineWidth }),
                             lines,
                             footer).join('\n');
    return new TextEncoder('utf8').encode(output);
  };

  const downloadPdf = (shape, name, { lineWidth = 0.096 } = {}) => {
    // CHECK: Should this be limited to Page plans?
    let index = 0;
    const entries = [];
    for (const entry of ensurePages(shape.toKeptGeometry())) {
      const { size } = entry.plan.page;
      for (let leaf of getLeafs(entry.content)) {
        const op = toPdf(leaf, { lineWidth, size });
        entries.push({ data: op, filename: `${name}_${++index}.pdf`, type: 'application/pdf' });
      }
    }
    emit$1({ download: { entries } });
    return shape;
  };

  const downloadPdfMethod = function (...args) { return downloadPdf(this, ...args); };
  Shape.prototype.downloadPdf = downloadPdfMethod;

  // FIX: Support multi-page pdf, and multi-page preview.

  const toPdf$1 = async (shape, { lineWidth = 0.096 } = {}) => {
    const pages = [];
    // CHECK: Should this be limited to Page plans?
    const geometry = shape.toKeptGeometry();
    for (const entry of getPlans(geometry)) {
      if (entry.plan.page) {
        const { size } = entry.plan.page;
        for (let leaf of getLeafs(entry.content)) {
          const pdf = await toPdf(leaf, { lineWidth, size });
          pages.push({ pdf, leaf: { ...entry, content: leaf }, index: pages.length });
        }
      }
    }
    return pages;
  };

  const writePdf = async (shape, name, { lineWidth = 0.096 } = {}) => {
    for (const { pdf, leaf, index } of await toPdf$1(shape, { lineWidth })) {
      await writeFile({ doSerialize: false }, `output/${name}_${index}.pdf`, pdf);
      await writeFile({}, `geometry/${name}_${index}.pdf`, toKeptGeometry(leaf));
    }
  };

  const writePdfMethod = function (...args) { return writePdf(this, ...args); };
  Shape.prototype.writePdf = writePdfMethod;

  /**
   *
   * # Chained Hull
   *
   * Builds a convex hull between adjacent pairs in a sequence of shapes.
   *
   * ::: illustration { "view": { "position": [30, 30, 30] } }
   * ```
   * chainHull(Cube(3).move(-5, 5),
   *           Sphere(3).move(5, -5),
   *           Cylinder(3, 10).move(-10, -10))
   *   .move(10, 10)
   * ```
   * :::
   * ::: illustration { "view": { "position": [80, 80, 0] } }
   * ```
   * chainHull(Circle(20).moveZ(-10),
   *           Circle(10),
   *           Circle(20).moveZ(10))
   * ```
   * :::
   *
   **/

  const Z$h = 2;

  const ChainedHull = (...shapes) => {
    const pointsets = shapes.map(shape => shape.toPoints());
    const chain = [];
    for (let nth = 1; nth < pointsets.length; nth++) {
      const points = [...pointsets[nth - 1], ...pointsets[nth]];
      if (points.every(point => point[Z$h] === 0)) {
        chain.push(Shape.fromGeometry(buildConvexSurfaceHull(points)));
      } else {
        chain.push(Shape.fromGeometry(buildConvexHull(points)));
      }
    }
    return union$5(...chain);
  };

  const ChainedHullMethod = function (...args) { return ChainedHull(this, ...args); };
  Shape.prototype.ChainedHull = ChainedHullMethod;

  ChainedHull.signature = 'ChainedHull(...shapes:Shape) -> Shape';

  /**
   *
   * # Hull
   *
   * Builds the convex hull of a set of shapes.
   *
   * ::: illustration { "view": { "position": [30, 30, 30] } }
   * ```
   * hull(Point([0, 0, 10]),
   *      Circle(10))
   * ```
   * :::
   * ::: illustration { "view": { "position": [30, 30, 30] } }
   * ```
   * assemble(Point([0, 0, 10]),
   *          Circle(10))
   *   .hull()
   * ```
   * :::
   * ::: illustration { "view": { "position": [30, 30, 30] } }
   * ```
   * Point([0, 0, 10]).hull(Circle(10))
   * ```
   * :::
   * ::: illustration { "view": { "position": [30, 30, 30] } }
   * ```
   * hull(Circle(4),
   *      Circle(2).move(8));
   * ```
   * :::
   *
   **/

  const Z$i = 2;

  const Hull = (...shapes) => {
    const points = [];
    shapes.forEach(shape => shape.eachPoint(point => points.push(point)));
    // FIX: Detect planar hulls properly.
    if (points.every(point => point[Z$i] === 0)) {
      return Shape.fromGeometry(buildConvexSurfaceHull(points));
    } else {
      return Shape.fromGeometry(buildConvexHull(points));
    }
  };

  const HullMethod = function (...shapes) { return Hull(this, ...shapes); };
  Shape.prototype.Hull = HullMethod;

  Hull.signature = 'Hull(shape:Shape, ...shapes:Shape) -> Shape';
  HullMethod.signature = 'Shape -> Hull(...shapes:Shape) -> Shape';

  /**
   *
   * # Connector
   *
   * Returns a connector plan.
   * See connect().
   *
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Cube(10).with(Connector('top').move(5))
   * ```
   * :::
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Cube(10).Connector('top').moveZ(5).connect(Sphere(5).Connector('bottom').flip().moveZ(-5))
   * ```
   * :::
   **/

  const shapeToConnect = Symbol('shapeToConnect');

  // A connector expresses a joint-of-connection extending from origin along axis to end.
  // The orientation expresses the direction of facing orthogonal to that axis.
  // The joint may have a zero length (origin and end are equal), but axis must not equal origin.
  // Note: axis must be further than end from origin.

  const Connector = (connector, { plane = [0, 0, 1, 0], center = [0, 0, 0], right = [1, 0, 0], start = [0, 0, 0], end = [0, 0, 0], shape, visualization } = {}) => {
    const plan = Plan(// Geometry
      {
        plan: { connector },
        marks: [center, right, start, end],
        planes: [plane],
        tags: [`connector/${connector}`],
        visualization
      },
      // Context
      {
        [shapeToConnect]: shape
      });
    return plan;
  };

  Plan.Connector = Connector;

  const ConnectorMethod = function (connector, options) { return Connector(connector, { ...options, [shapeToConnect]: this }); };
  Shape.prototype.Connector = ConnectorMethod;

  Connector.signature = 'Connector(id:string, { plane:Plane, center:Point, right:Point, start:Point, end:Point, shape:Shape, visualization:Shape }) -> Shape';

  // Associates an existing connector with a shape.
  const toConnectorMethod = function (connector, options) { return Shape.fromGeometry(connector.toKeptGeometry(), { ...options, [shapeToConnect]: this }); };
  Shape.prototype.toConnector = toConnectorMethod;

  /**
   *
   * # connectors
   *
   * Returns the set of connectors in an assembly by tag.
   * See connect().
   *
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Cube(10).with(Connector('top').moveZ(5))
   *         .connectors()['top']
   *         .connect(Prism(10, 10).with(Connector('bottom').flip().moveZ(-5))
   *                               .connectors()['bottom']);
   * ```
   * :::
   **/

  const connectors = (shape) => {
    const connectors = [];
    for (const entry of getPlans(shape.toKeptGeometry())) {
      if (entry.plan.connector && (entry.tags === undefined || !entry.tags.includes('compose/non-positive'))) {
        connectors.push(Shape.fromGeometry(entry, { [shapeToConnect]: shape }));
      }
    }
    return connectors;
  };

  const connectorsMethod = function () { return connectors(this); };
  Shape.prototype.connectors = connectorsMethod;

  /**
   *
   * # connector
   *
   * Returns a connector from an assembly.
   * See connect().
   *
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Prism(10, 10).with(Connector('top').moveZ(5))
   *              .connector('top')
   *              .connect(Cube(10).with(Connector('bottom').flip().moveZ(-5))
   *                               .connector('bottom'));
   * ```
   * :::
   **/

  const connector = (shape, id) => {
    for (const connector of connectors(shape)) {
      if (connector.toGeometry().plan.connector === id) {
        return connector;
      }
    }
  };

  const connectorMethod = function (id) { return connector(this, id); };
  Shape.prototype.connector = connectorMethod;

  const connection = (shape, id) => {
    const shapeGeometry = shape.toKeptGeometry();
    const connections = getConnections(shapeGeometry);
    for (const geometry of connections) {
      if (geometry.connection === id) {
        return Shape.fromGeometry(geometry);
      }
    }
  };

  const connectionMethod = function (id) { return connection(this, id); };
  Shape.prototype.connection = connectionMethod;

  // FIX:
  // This will produce the average position, but that's probably not what we
  // want, since it will include interior points produced by breaking up
  // convexity.
  const toPosition = (surface) => {
    let sum = [0, 0, 0];
    let count = 0;
    for (const path of surface) {
      for (const point of path) {
        sum = add(sum, point);
        count += 1;
      }
    }
    const position = scale(1 / count, sum);
    return position;
  };

  const faceConnector = (shape, id, scoreOrientation, scorePosition) => {
    let bestSurface;
    let bestPosition;
    let bestOrientationScore = -Infinity;
    let bestPositionScore = -Infinity;

    // FIX: This may be sensitive to noise.
    const geometry = shape.toKeptGeometry();
    for (const { solid } of getSolids(geometry)) {
      for (const surface of solid) {
        const orientationScore = scoreOrientation(surface);
        if (orientationScore > bestOrientationScore) {
          bestSurface = surface;
          bestOrientationScore = orientationScore;
          bestPosition = toPosition(surface);
          bestPositionScore = scorePosition(bestPosition);
        } else if (orientationScore === bestOrientationScore) {
          const position = toPosition(surface);
          const positionScore = scorePosition(position);
          if (positionScore > bestPositionScore) {
            bestSurface = surface;
            bestPosition = position;
            bestPositionScore = positionScore;
          }
        }
      }
    }

    // FIX: We should have a consistent rule for deciding the rotational position of the connector.
    const plane = toPlane$1(bestSurface);
    return shape.toConnector(Connector(id, { plane, center: bestPosition, right: add(bestPosition, random(plane)) }));
  };

  const toConnector = (shape, surface, id) => {
    const center = toPosition(surface);
    // FIX: Adding y + 1 is not always correct.
    const plane = toPlane$1(surface);
    return Connector(id, { plane, center, right: random(plane) });
  };

  const withConnector = (shape, surface, id) => {
    return shape.toConnector(toConnector(shape, surface, id));
  };

  const Y$k = 1;

  const back = (shape) =>
    shape.connector('back') || faceConnector(shape, 'back', (surface) => dot(toPlane$1(surface), [0, 1, 0, 0]), (point) => point[Y$k]);

  const backMethod = function () { return back(this); };
  Shape.prototype.back = backMethod;

  back.signature = 'back(shape:Shape) -> Shape';
  backMethod.signature = 'Shape -> back() -> Shape';

  const Z$j = 2;

  const bottom = (shape) =>
    shape.connector('bottom') || faceConnector(shape, 'bottom', (surface) => dot(toPlane$1(surface), [0, 0, -1, 0]), (point) => -point[Z$j]);

  const bottomMethod = function () { return bottom(this); };
  Shape.prototype.bottom = bottomMethod;

  bottom.signature = 'bottom(shape:Shape) -> Shape';
  bottomMethod.signature = 'Shape -> bottom() -> Shape';

  // Ideally this would be a plane of infinite extent.
  // Unfortunately this makes things like interpolation tricky,
  // so we approximate it with a very large polygon instead.

  const Z$k = (z = 0) => {
    const size = 1e5;
    const min = -size;
    const max = size;
    // FIX: Why aren't we createing the connector directly?
    const sheet = Shape.fromPathToZ0Surface([[max, min, z], [max, max, z], [min, max, z], [min, min, z]]);
    return toConnector(sheet, sheet.toGeometry().z0Surface, 'top');
  };

  /**
   *
   * # Chop
   *
   * Remove the parts of a shape above surface, defaulting to Z(0).
   *
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Cube(10).with(Cube(10).moveX(10).chop(Z(0)));
   * ```
   * :::
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Cube(10).with(Cube(10).moveX(10).chop(Z(0).flip()));
   * ```
   * :::
   *
   **/

  const toPlane$3 = (connector) => {
    for (const entry of getPlans(connector.toKeptGeometry())) {
      if (entry.plan && entry.plan.connector) {
        return entry.planes[0];
      }
    }
  };

  const toSurface$1 = (plane) => {
    const max = +1e5;
    const min = -1e5;
    const [, from] = toXYPlaneTransforms(plane);
    const path = [[max, max, 0], [min, max, 0], [min, min, 0], [max, min, 0]];
    const polygon = transform$1(from, path);
    return [polygon];
  };

  const chop = (shape, connector = Z$k()) => {
    const cuts = [];
    const planeSurface = toSurface$1(toPlane$3(connector));
    for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
      const cutResult = cut$1(solid, planeSurface);
      cuts.push(Shape.fromGeometry({ solid: cutResult, tags }));
    }
    for (const { surface, z0Surface, tags } of getAnySurfaces(shape.toKeptGeometry())) {
      const cutSurface = surface || z0Surface;
      const cutResult = cut(planeSurface, cutSurface);
      cuts.push(Shape.fromGeometry({ surface: cutResult, tags }));
    }

    return assemble$1(...cuts);
  };

  const chopMethod = function (surface) { return chop(this, surface); };
  Shape.prototype.chop = chopMethod;

  chop.signature = 'chop(shape:Shape, surface:Shape) -> Shape';
  chopMethod.signature = 'Shape -> chop(surface:Shape) -> Shape';

  const Z$l = 2;

  const findFlatTransforms = (shape) => {
    let bestDepth = Infinity;
    let bestTo;
    let bestFrom;
    let bestSurface;

    const assay = (surface) => {
      const plane = toPlane$1(surface);
      if (plane !== undefined) {
        const [to, from] = toXYPlaneTransforms(plane);
        const flatShape = shape.transform(to);
        const [min, max] = flatShape.measureBoundingBox();
        const depth = max[Z$l] - min[Z$l];
        if (depth < bestDepth) {
          bestDepth = depth;
          bestTo = to;
          bestFrom = from;
          bestSurface = surface;
        }
      }
    };

    const geometry = shape.toKeptGeometry();
    for (const { solid } of getSolids(geometry)) {
      for (const surface of solid) {
        assay(surface);
      }
    }
    for (const { surface } of getSurfaces(geometry)) {
      assay(surface);
    }
    for (const { z0Surface } of getZ0Surfaces(geometry)) {
      assay(z0Surface);
    }

    return [bestTo, bestFrom, bestSurface];
  };

  const flat = (shape) => {
    const [, , bestSurface] = findFlatTransforms(shape);
    return withConnector(shape, bestSurface, 'flat');
  };

  const flatMethod = function () { return flat(this); };
  Shape.prototype.flat = flatMethod;

  flat.signature = 'flat(shape:Shape) -> Connector';
  flatMethod.signature = 'Shape -> flat() -> Connector';

  // Perform an operation on the shape in its best flat orientation,
  // returning the result in the original orientation.

  const inFlat = (shape, op) => {
    const [to, from] = findFlatTransforms(shape);
    return op(shape.transform(to)).transform(from);
  };

  const inFlatMethod = function (op = (_ => _)) { return inFlat(this, op); };
  Shape.prototype.inFlat = inFlatMethod;

  const Y$l = 1;

  const front = (shape) =>
    shape.connector('front') || faceConnector(shape, 'front', (surface) => dot(toPlane$1(surface), [0, -1, 0, 0]), (point) => -point[Y$l]);

  const frontMethod = function () { return front(this); };
  Shape.prototype.front = frontMethod;

  front.signature = 'front(shape:Shape) -> Shape';
  frontMethod.signature = 'Shape -> front() -> Shape';

  const X$k = 0;

  const left = (shape) =>
    shape.connector('left') || faceConnector(shape, 'left', (surface) => dot(toPlane$1(surface), [-1, 0, 0, 0]), (point) => -point[X$k]);

  const leftMethod = function () { return left(this); };
  Shape.prototype.left = leftMethod;

  left.signature = 'left(shape:Shape) -> Shape';
  leftMethod.signature = 'Shape -> left() -> Shape';

  const on$1 = (above, below, op = _ => _) => above.bottom().from(below.top().op(op));
  const onMethod = function (below, op) { return on$1(this, below, op); };

  Shape.prototype.on = onMethod;

  const X$l = 0;

  const right = (shape) =>
    shape.connector('right') || faceConnector(shape, 'right', (surface) => dot(toPlane$1(surface), [1, 0, 0, 0]), (point) => point[X$l]);

  const rightMethod = function () { return right(this); };
  Shape.prototype.right = rightMethod;

  right.signature = 'right(shape:Shape) -> Shape';
  rightMethod.signature = 'Shape -> right() -> Shape';

  const Z$m = 2;

  const top = (shape) =>
    shape.connector('top') || faceConnector(shape, 'top', (surface) => dot(toPlane$1(surface), [0, 0, 1, 0]), (point) => point[Z$m]);

  const topMethod = function () { return top(this); };
  Shape.prototype.top = topMethod;

  top.signature = 'top(shape:Shape) -> Shape';
  topMethod.signature = 'Shape -> top() -> Shape';

  /**
   *
   * # Unfold
   *
   **/

  // FIX: Does not handle convex solids.
  const unfold = (shape) => {
    const faces = shape.faces(f => f);
    log$2(`Face count is ${faces.length}`);
    const faceByEdge = new Map();

    for (const face of faces) {
      for (const edge of face.faceEdges()) {
        faceByEdge.set(edge, face);
      }
    }

    const reverseEdge = (edge) => {
      const [a, b] = edge.split(':');
      const reversedEdge = `${b}:${a}`;
      return reversedEdge;
    };

    const seen = new Set();
    const queue = [];

    const enqueueNeighbors = (face) => {
      for (const edge of face.faceEdges()) {
        const redge = reverseEdge(edge);
        const neighbor = faceByEdge.get(redge);
        if (neighbor === undefined || seen.has(neighbor)) continue;
        seen.add(neighbor);
        queue.push({
          face: neighbor,
          to: `face/edge:${edge}`,
          from: `face/edge:${redge}`
        });
      }
    };

    let root = faces[0];
    enqueueNeighbors(root);

    while (queue.length > 0) {
      const { face, from, to } = queue.shift();
      seen.add(face);
      const fromConnector = face.connector(from);
      const toConnector = root.connector(to);
      if (fromConnector === undefined) {
        log$2('bad from');
        continue;
      }
      if (toConnector === undefined) {
        log$2('bad to');
        continue;
      }
      root = fromConnector.to(toConnector);
      if (root === undefined) break;
      enqueueNeighbors(face);
    }

    return root;
  };

  const method$3 = function (...args) { return unfold(this); };
  Shape.prototype.unfold = method$3;

  // Ideally this would be a plane of infinite extent.
  // Unfortunately this makes things like interpolation tricky,
  // so we approximate it with a very large polygon instead.

  const X$m = (x = 0) => {
    const size = 1e5;
    const min = -size;
    const max = size;
    const sheet = Shape.fromPathToZ0Surface([[x, max, min], [x, max, max], [x, min, max], [x, min, min]]);
    return toConnector(sheet, sheet.toGeometry().z0Surface, 'top');
  };

  // Ideally this would be a plane of infinite extent.
  // Unfortunately this makes things like interpolation tricky,
  // so we approximate it with a very large polygon instead.

  const Y$m = (y = 0) => {
    const size = 1e5;
    const min = -size;
    const max = size;
    const sheet = Shape.fromPathToZ0Surface([[max, y, min], [max, y, max], [min, y, max], [min, y, min]]);
    return toConnector(sheet, sheet.toGeometry().z0Surface, 'top');
  };

  /**
   *
   * # Connect
   *
   * Connects two connectors.
   *
   * ::: illustration { "view": { "position": [60, -60, 0], "target": [0, 0, 0] } }
   * ```
   * Cube(10).Connector('top').moveZ(5)
   *         .connect(Sphere(10).Connector('bottom').flip().moveZ(-9))
   * ```
   * :::
   **/

  const toShape = (connector) => connector.getContext(shapeToConnect);

  const dropConnector = (shape, ...connectors) => {
    if (shape !== undefined) {
      return Shape.fromGeometry(drop(connectors.map(connector => `connector/${connector}`), shape.toGeometry()));
    }
  };

  const dropConnectorMethod = function (...connectors) { return dropConnector(this, ...connectors); };
  Shape.prototype.dropConnector = dropConnectorMethod;

  const CENTER = 0;
  const RIGHT = 1;

  const measureAngle = ([aX, aY], [bX, bY]) => {
    const a2 = Math.atan2(aX, aY);
    const a1 = Math.atan2(bX, bY);
    const sign = a1 > a2 ? 1 : -1;
    const angle = a1 - a2;
    const K = -sign * Math.PI * 2;
    const absoluteAngle = (Math.abs(K + angle) < Math.abs(angle)) ? K + angle : angle;
    return absoluteAngle * 180 / Math.PI;
  };

  // FIX: Separate the doConnect dispatched interfaces.
  // Connect two shapes at the specified connector.
  const connect = (aConnectorShape, bConnectorShape, { doConnect = true, doAssemble = true } = {}) => {
    const aConnector = toTransformedGeometry(aConnectorShape.toGeometry());
    const aShape = toShape(aConnectorShape);
    const [aTo] = toXYPlaneTransforms(aConnector.planes[0], subtract(aConnector.marks[RIGHT], aConnector.marks[CENTER]));

    const bConnector = toTransformedGeometry(bConnectorShape.flip().toGeometry());
    const bShape = toShape(bConnectorShape);
    const [bTo, bFrom] = toXYPlaneTransforms(bConnector.planes[0], subtract(bConnector.marks[RIGHT], bConnector.marks[CENTER]));

    // Flatten a.
    const aFlatShape = aShape.transform(aTo);
    const aFlatConnector = aConnectorShape.transform(aTo);
    const aMarks = aFlatConnector.toKeptGeometry().marks;
    const aFlatOriginShape = aFlatShape.move(...negate(aMarks[CENTER]));
    // const aFlatOriginConnector = aFlatConnector.move(...negate(aMarks[CENTER]));

    // Flatten b's connector.
    const bFlatConnector = toTransformedGeometry(bConnectorShape.transform(bTo).toGeometry());
    const bMarks = bFlatConnector.marks;

    // Rotate into alignment.
    const aOrientation = subtract(aMarks[RIGHT], aMarks[CENTER]);
    const bOrientation = subtract(bMarks[RIGHT], bMarks[CENTER]);
    const angle = measureAngle(aOrientation, bOrientation);
    const aFlatOriginRotatedShape = aFlatOriginShape.rotateZ(-angle);
    // const aFlatOriginRotatedConnector = aFlatOriginConnector.rotateZ(-angle);

    // Move a to the flat position of b.
    const aFlatBShape = aFlatOriginRotatedShape.move(...bMarks[CENTER]);
    // const aFlatBConnector = aFlatOriginRotatedConnector.move(...bMarks[CENTER]);
    // Move a to the oriented position of b.
    const aMovedShape = aFlatBShape.transform(bFrom);
    // const aMovedConnector = aFlatBConnector.transform(bFrom);

    if (doConnect) {
      if (doAssemble) {
        return dropConnector(aMovedShape, aConnector.plan.connector)
            .Item()
            .with(dropConnector(bShape, bConnector.plan.connector))
            .Item();
      } else {
        return dropConnector(aMovedShape, aConnector.plan.connector)
            .Item()
            .layer(dropConnector(bShape, bConnector.plan.connector))
            .Item();
      }
      /*
      return Shape.fromGeometry(
        {
          connection: `${aConnector.plan.connector}-${bConnector.plan.connector}`,
          connectors: [aMovedConnector.toKeptGeometry(), bConnector],
          geometries: [dropConnector(aMovedShape, aConnector.plan.connector).toGeometry()]
              .concat(bShape === undefined
                ? []
                : [dropConnector(bShape, bConnector.plan.connector).toGeometry()])
        });
      */
    } else {
      return aMovedShape;
    }
  };

  const toMethod = function (connector, options) { return connect(this, connector, options); };
  Shape.prototype.to = toMethod;
  toMethod.signature = 'Connector -> to(from:Connector) -> Shape';

  const fromMethod = function (connector, options) { return connect(connector, this, options); };
  Shape.prototype.from = fromMethod;
  fromMethod.signature = 'Connector -> from(from:Connector) -> Shape';

  const atMethod = function (connector, options) { return connect(this, connector, { ...options, doConnect: false }); };
  Shape.prototype.at = atMethod;
  atMethod.signature = 'Connector -> at(target:Connector) -> Shape';

  connect.signature = 'connect(to:Connector, from:Connector) -> Shape';

  // FIX: The toKeptGeometry is almost certainly wrong.
  const joinLeft = (leftArm, joinId, leftArmConnectorId, rightJointConnectorId, joint, leftJointConnectorId, rightArmConnectorId, rightArm) => {
    // leftArm will remain stationary.
    const leftArmConnector = leftArm.connector(leftArmConnectorId);
    const rightJointConnector = joint.connector(rightJointConnectorId);
    const [joinedJointShape, joinedJointConnector] = rightJointConnector.connectTo(leftArmConnector, { doConnect: false });
    const rightArmConnector = rightArm.connector(rightArmConnectorId, { doConnect: false });
    const [joinedRightShape, joinedRightConnector] = rightArmConnector.connectTo(joinedJointShape.connector(leftJointConnectorId), { doConnect: false });
    const result = Shape.fromGeometry(
      {
        connection: joinId,
        connectors: [leftArmConnector.toKeptGeometry(),
                     joinedJointConnector.toKeptGeometry(),
                     joinedRightConnector.toKeptGeometry()],
        geometries: [leftArm.dropConnector(leftArmConnectorId).toKeptGeometry(),
                     joinedJointShape.dropConnector(rightJointConnectorId, leftJointConnectorId).toKeptGeometry(),
                     joinedRightShape.dropConnector(rightArmConnectorId).toKeptGeometry()],
        tags: [`joinLeft/${joinId}`]
      });
    return result;
  };

  const joinLeftMethod = function (a, ...rest) { return joinLeft(this, a, ...rest); };
  Shape.prototype.joinLeft = joinLeftMethod;

  /**
   *
   * # Lathe
   *
   * ::: illustration { "view": { "position": [-80, -80, 80] } }
   * ```
   * ```
   * :::
   *
   **/

  const Loop = (shape, endDegrees = 360, { sides = 32, pitch = 0 } = {}) => {
    const profile = shape.chop(Y$m(0));
    const outline = profile.outline();
    const solids = [];
    for (const geometry of getPaths(outline.toKeptGeometry())) {
      for (const path of geometry.paths) {
        for (let startDegrees = 0; startDegrees < endDegrees; startDegrees += 360) {
          solids.push(Shape.fromGeometry(loop(path, Math.min(360, endDegrees - startDegrees) * Math.PI / 180, sides, pitch)).moveX(pitch * startDegrees / 360));
        }
      }
    }
    return assemble$1(...solids);
  };

  const LoopMethod = function (...args) { return Loop(this, ...args); };
  Shape.prototype.Loop = LoopMethod;

  /**
   *
   * # Extrude
   *
   * Generates a solid from a surface by linear extrusion.
   *
   * ```
   * shape.extrude(height, depth, { twist = 0, steps = 1 })
   * ```
   *
   * ::: illustration
   * ```
   * Circle(10).cut(Circle(8))
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 60] } }
   * ```
   * Circle(10).cut(Circle(8)).extrude(10)
   * ```
   * :::
   *
   * ::: illustration { "view": { "position": [40, 40, 60] } }
   * ```
   * Triangle(10).extrude(5, -2)
   * ```
   * :::
   * ::: illustration { "view": { "position": [40, 40, 60] } }
   * ```
   * Triangle(10).extrude(10, 0, { twist: 90, steps: 10 })
   * ```
   * :::
   *
   **/

  const extrude$1 = (shape, height = 1, depth = 0) => {
    if (height < depth) {
      [height, depth] = [depth, height];
    }
    // FIX: Handle extrusion along a vector properly.
    const solids = [];
    const keptGeometry = shape.toKeptGeometry();
    for (const { z0Surface, tags } of getZ0Surfaces(keptGeometry)) {
      if (z0Surface.length > 0) {
        const solid = alignVertices(extrude(z0Surface, height, depth));
        solids.push(Shape.fromGeometry({ solid, tags }));
      }
    }
    for (const { surface, tags } of getSurfaces(keptGeometry)) {
      if (surface.length > 0) {
        const plane = toPlane$1(surface);
        if (plane[0] === 0 && plane[1] === 0 && plane[2] === 1 && plane[3] === 0) {
          // Detect Z0.
          // const solid = alignVertices(extrudeAlgorithm(surface, height, depth));
          const solid = extrude(surface, height, depth);
          solids.push(Shape.fromGeometry({ solid, tags }));
        } else {
          const [toZ0, fromZ0] = toXYPlaneTransforms(toPlane$1(surface));
          const z0SolidGeometry = extrude(transform$4(toZ0, surface), height, depth);
          const solid = alignVertices(transform$6(fromZ0, z0SolidGeometry));
          solids.push(Shape.fromGeometry({ solid, tags }));
        }
      }
    }
    // Keep plans.
    for (const entry of getPlans(keptGeometry)) {
      solids.push(entry);
    }
    return assemble$1(...solids);
  };

  const extrudeMethod = function (...args) { return extrude$1(this, ...args); };
  Shape.prototype.extrude = extrudeMethod;

  extrude$1.signature = 'extrude(shape:Shape, height:number = 1, depth:number = 1) -> Shape';
  extrudeMethod.signature = 'Shape -> extrude(height:number = 1, depth:number = 1) -> Shape';

  const fill = (shape, pathsShape) => {
    const fills = [];
    for (const { surface, z0Surface } of getAnySurfaces(shape.toKeptGeometry())) {
      const anySurface = surface || z0Surface;
      const plane = toPlane$1(anySurface);
      const [to, from] = toXYPlaneTransforms(plane);
      const flatSurface = transform$4(to, anySurface);
      for (const { paths } of getPaths(pathsShape.toKeptGeometry())) {
        const flatPaths = transform$7(to, paths);
        const flatFill = intersectionOfPathsBySurfaces(flatPaths, flatSurface);
        const fill = transform$7(from, flatFill);
        fills.push(...fill);
      }
    }
    return Shape.fromGeometry({ paths: fills });
  };

  const fillMethod = function (...args) { return fill(this, ...args); };
  Shape.prototype.fill = fillMethod;

  const withFillMethod = function (...args) { return assemble$1(this, fill(this, ...args)); };
  Shape.prototype.withFill = withFillMethod;

  fill.signature = 'interior(shape:Surface, paths:Paths) -> Paths';
  fillMethod.signature = 'Surface -> interior(paths:Paths) -> Paths';
  withFillMethod.signature = 'Surface -> interior(paths:Paths) -> Shape';

  /**
   *
   * # Interior
   *
   * Generates a surface from the interior of a simple closed path.
   *
   * ::: illustration
   * ```
   * Circle(10)
   * ```
   * :::
   * ::: illustration
   * ```
   * Circle(10)
   *   .outline()
   * ```
   * :::
   * ::: illustration
   * ```
   * Circle(10)
   *   .outline()
   *   .interior()
   * ```
   * :::
   *
   **/

  const interior = (shape) => {
    const surfaces = [];
    for (const { paths } of getPaths(shape.toKeptGeometry())) {
      // FIX: Check paths for coplanarity.
      surfaces.push(Shape.fromPathsToSurface(paths.filter(isClosed).filter(path => path.length >= 3)));
    }
    return assemble$1(...surfaces);
  };

  const interiorMethod = function (...args) { return interior(this); };
  Shape.prototype.interior = interiorMethod;

  interior.signature = 'interior(shape:Shape) -> Shape';
  interiorMethod.signature = 'Shape -> interior() -> Shape';

  /**
   *
   * # Minkowski (convex)
   *
   * Generates the minkowski sum of a two convex shapes.
   *
   * ::: illustration { "view": { "position": [40, 40, 40] } }
   * ```
   * minkowski(Cube(10),
   *           Sphere(3));
   * ```
   * :::
   *
   **/

  // TODO: Generalize for more operands?
  const minkowski = (a, b) => {
    const aPoints = [];
    const bPoints = [];
    a.eachPoint(point => aPoints.push(point));
    b.eachPoint(point => bPoints.push(point));
    return Shape.fromGeometry(buildConvexMinkowskiSum(aPoints, bPoints));
  };

  const minkowskiMethod = function (shape) { return minkowski(this, shape); };
  Shape.prototype.minkowski = minkowskiMethod;

  minkowski.signature = 'minkowski(a:Shape, b:Shape) -> Shape';

  /**
   *
   * # Outline
   *
   * Generates the outline of a surface.
   *
   * ::: illustration
   * ```
   * difference(Circle(10),
   *            Circle(2).move([-4]),
   *            Circle(2).move([4]))
   * ```
   * :::
   * ::: illustration
   * ```
   * difference(Circle(10),
   *            Circle(2).move([-4]),
   *            Circle(2).move([4]))
   *   .outline()
   * ```
   * :::
   *
   **/

  const outline$4 = (shape) =>
    assemble$1(...outline$3(shape.toGeometry()).map(outline => Shape.fromGeometry(outline)));

  const outlineMethod = function (options) { return outline$4(this); };
  const withOutlineMethod = function (options) { return assemble$1(this, outline$4(this)); };

  Shape.prototype.outline = outlineMethod;
  Shape.prototype.withOutline = withOutlineMethod;

  outline$4.signature = 'outline(shape:Surface) -> Shape';
  outlineMethod.signature = 'Shape -> outline() -> Shape';
  withOutlineMethod.signature = 'Shape -> outline() -> Shape';

  /**
   *
   * # Section
   *
   * Produces a cross-section of a solid as a surface.
   *
   * ::: illustration { "view": { "position": [40, 40, 60] } }
   * ```
   * difference(Cylinder(10, 10),
   *            Cylinder(8, 10))
   * ```
   * :::
   * ::: illustration
   * ```
   * difference(Sphere(10),
   *            Sphere(8))
   *   .section()
   * ```
   * :::
   * ::: illustration
   * ```
   * difference(Sphere(10),
   *            Sphere(8))
   *   .section()
   *   .outline()
   * ```
   * :::
   *
   **/

  const toPlane$4 = (connector) => {
    for (const entry of getPlans(connector.toKeptGeometry())) {
      if (entry.plan && entry.plan.connector) {
        return entry.planes[0];
      }
    }
  };

  const toSurface$2 = (plane) => {
    const max = +1e5;
    const min = -1e5;
    const [, from] = toXYPlaneTransforms(plane);
    const path = [[max, max, 0], [min, max, 0], [min, min, 0], [max, min, 0]];
    const polygon = transform$1(from, path);
    return [polygon];
  };

  const section$1 = (solidShape, ...connectors) => {
    if (connectors.length === 0) {
      connectors.push(Z$k(0));
    }
    const planes = connectors.map(toPlane$4);
    const planeSurfaces = planes.map(toSurface$2);
    const shapes = [];
    const normalize = createNormalize3();
    for (const { solid } of getSolids(solidShape.toKeptGeometry())) {
      const sections = section(solid, planeSurfaces, normalize);
      const surfaces = sections.map(section => makeConvex$1(section, normalize));
      // const surfaces = sections.map(section => outlineSurface(section, normalize));
      // const surfaces = sections.map(section => section);
      // const surfaces = sections;
      for (let i = 0; i < surfaces.length; i++) {
        surfaces[i].plane = planes[i];
        shapes.push(Shape.fromGeometry({ surface: surfaces[i] }));
      }
    }
    return layer(...shapes);
  };

  const sectionMethod = function (...args) { return section$1(this, ...args); };
  Shape.prototype.section = sectionMethod;

  const squash = (shape) => {
    const geometry = shape.toKeptGeometry();
    const result = { layers: [] };
    for (const { solid, tags } of getSolids(geometry)) {
      const polygons = [];
      for (const surface of solid) {
        for (const path of surface) {
          const flat = path.map(([x, y]) => [x, y, 0]);
          if (toPlane(flat) === undefined) continue;
          polygons.push(isCounterClockwise(flat) ? flat : flip(flat));
        }
      }
      result.layers.push({ z0Surface: outline(polygons), tags });
    }
    for (const { surface, tags } of getSurfaces(geometry)) {
      const polygons = [];
      for (const path of surface) {
        const flat = path.map(([x, y]) => [x, y, 0]);
        if (toPlane(flat) === undefined) continue;
        polygons.push(isCounterClockwise(flat) ? flat : flip(flat));
      }
      result.layers.push({ z0Surface: polygons, tags });
    }
    for (const { z0Surface, tags } of getZ0Surfaces(geometry)) {
      const polygons = [];
      for (const path of z0Surface) {
        polygons.push(path);
      }
      result.layers.push({ z0Surface: polygons, tags });
    }
    for (const { paths, tags } of getPaths(geometry)) {
      const flatPaths = [];
      for (const path of paths) {
        flatPaths.push(path.map(([x, y]) => [x, y, 0]));
      }
      result.layers.push({ paths: flatPaths, tags });
    }
    return Shape.fromGeometry(result);
  };

  const squashMethod = function () { return squash(this); };
  Shape.prototype.squash = squashMethod;

  /**
   *
   * # Stretch
   *
   **/

  const toPlaneFromConnector = (connector) => {
    for (const entry of getPlans(connector.toKeptGeometry())) {
      if (entry.plan && entry.plan.connector) {
        return entry.planes[0];
      }
    }
  };

  const toSurface$3 = (plane) => {
    const max = +1e5;
    const min = -1e5;
    const [, from] = toXYPlaneTransforms(plane);
    const path = [[max, max, 0], [min, max, 0], [min, min, 0], [max, min, 0]];
    const polygon = transform$1(from, path);
    return [polygon];
  };

  const stretch = (shape, length, connector = Z$k()) => {
    const normalize = createNormalize3();
    const stretches = [];
    const planeSurface = toSurface$3(toPlaneFromConnector(connector));
    for (const { solid, tags } of getSolids(shape.toKeptGeometry())) {
      if (solid.length === 0) {
        continue;
      }
      const bottom = cutOpen(solid, planeSurface, normalize);
      const [profile] = section(solid, [planeSurface], normalize);
      const top = cutOpen(solid, flip$4(planeSurface), normalize);
      const [toZ0, fromZ0] = toXYPlaneTransforms(toPlane$1(profile));
      const z0SolidGeometry = extrude(transform$4(toZ0, profile), length, 0, false);
      const middle = transform$6(fromZ0, z0SolidGeometry);
      const topMoved = transform$6(fromTranslation(scale(length, toPlane$1(profile))), top);
      stretches.push(Shape.fromGeometry({ solid: alignVertices([...bottom, ...middle, ...topMoved], normalize), tags }));
    }

    return assemble$1(...stretches);
  };

  const method$4 = function (...args) { return stretch(this, ...args); };
  Shape.prototype.stretch = method$4;

  /**
   *
   * # Sweep
   *
   * Sweep a tool profile along a path, to produce a surface.
   *
   **/

  // FIX: This is a weak approximation assuming a 1d profile -- it will need to be redesigned.
  const sweep = (toolpath, tool) => {
    const chains = [];
    for (const { paths } of getPaths(toolpath.toKeptGeometry())) {
      for (const path of paths) {
        chains.push(ChainedHull(...path.map(point => tool.move(...point))));
      }
    }
    return union$5(...chains);
  };

  const sweepMethod = function (tool) { return sweep(this, tool); };

  Shape.prototype.sweep = sweepMethod;
  Shape.prototype.withSweep = function (tool) { return assemble$1(this, sweep(this, tool)); };

  const intersectionPoints = (cuts, overcut = 0) => {
    cuts.push(cuts[0]);
    var intersectionPointsList = [];
    var i = 0;
    while (i < cuts.length - 1) {
      const point = intersectPointOfLines(fromPoints$2(...cuts[i]), fromPoints$2(...cuts[i + 1]));
      point.push(cuts[i][0][2]);
      if (overcut) {
        intersectionPointsList.push(cuts[i][1]);
      }
      intersectionPointsList.push(point);
      i++;
    }
    return intersectionPointsList;
  };

  const overcutPathEdges = (path, radius = 1, overcut = 0, joinPaths = false) => {
    var cuts = [];
    for (const [start, end] of getEdges(path)) {
      const direction = normalize(subtract(start, end));
      const angleRadians = Math.PI / 2;
      const offsetDirection = rotateZ(direction, angleRadians);
      const offset = scale(radius, offsetDirection);
      const frontcut = scale(-overcut, direction);
      const backcut = scale(overcut, direction);
      const startCut = add(start, add(backcut, offset));
      const endCut = add(end, add(frontcut, offset));
      cuts.push([startCut, endCut]);
    }
    if (joinPaths) {
      cuts = [intersectionPoints(cuts, overcut)];
    }
    return cuts;
  };

  const overcut = (geometry, radius = 1, overcut = 0, joinPaths = false) => {
    const cuts = [];
    for (const { paths } of getPaths(geometry)) {
      for (const path of paths) {
        cuts.push(...overcutPathEdges(path, radius, overcut, joinPaths));
      }
    }
    return cuts;
  };

  // Return an assembly of paths so that each toolpath can have its own tag.
  const toolpath = (shape, radius = 1, { overcut: overcut$1 = 0, joinPaths = false } = {}) =>
    Shape.fromGeometry({ paths: overcut(shape.outline().toKeptGeometry(), radius, overcut$1, joinPaths) });

  const method$5 = function (...options) { return toolpath(this, ...options); };

  Shape.prototype.toolpath = method$5;
  Shape.prototype.withToolpath = function (...args) { return assemble$1(this, toolpath(this, ...args)); };

  const X$n = 0;
  const Y$n = 1;
  const Z$n = 2;

  const floor$1 = (value, resolution) => Math.floor(value / resolution) * resolution;
  const ceil$1 = (value, resolution) => Math.ceil(value / resolution) * resolution;

  const floorPoint = ([x, y, z], resolution) => [floor$1(x, resolution), floor$1(y, resolution), floor$1(z, resolution)];
  const ceilPoint = ([x, y, z], resolution) => [ceil$1(x, resolution), ceil$1(y, resolution), ceil$1(z, resolution)];

  const voxels = (shape, resolution = 1) => {
    const offset = resolution / 2;
    const geometry = shape.toKeptGeometry();
    const normalize = createNormalize3();
    const [boxMin, boxMax] = measureBoundingBox$5(geometry);
    const min = floorPoint(boxMin, resolution);
    const max = ceilPoint(boxMax, resolution);
    const classifiers = [];
    for (const { solid } of getSolids(shape.toKeptGeometry())) {
      classifiers.push({ bsp: fromSolid(solid, normalize) });
    }
    const test = (point) => {
      for (const { bsp } of classifiers) {
        if (containsPoint(bsp, point)) {
          return true;
        }
      }
      return false;
    };
    const polygons = [];
    for (let x = min[X$n] - offset; x <= max[X$n] + offset; x += resolution) {
      for (let y = min[Y$n] - offset; y <= max[Y$n] + offset; y += resolution) {
        for (let z = min[Z$n] - offset; z <= max[Z$n] + offset; z += resolution) {
          const state = test([x, y, z]);
          if (state !== test([x + resolution, y, z])) {
            const face = [[x + offset, y - offset, z - offset],
                          [x + offset, y + offset, z - offset],
                          [x + offset, y + offset, z + offset],
                          [x + offset, y - offset, z + offset]];
            polygons.push(state ? face : face.reverse());
          }
          if (state !== test([x, y + resolution, z])) {
            const face = [[x - offset, y + offset, z - offset],
                          [x + offset, y + offset, z - offset],
                          [x + offset, y + offset, z + offset],
                          [x - offset, y + offset, z + offset]];
            polygons.push(state ? face.reverse() : face);
          }
          if (state !== test([x, y, z + resolution])) {
            const face = [[x - offset, y - offset, z + offset],
                          [x + offset, y - offset, z + offset],
                          [x + offset, y + offset, z + offset],
                          [x - offset, y + offset, z + offset]];
            polygons.push(state ? face : face.reverse());
          }
        }
      }
    }
    return Shape.fromGeometry({ solid: fromPolygons({}, polygons) });
  };

  const voxelsMethod = function (...args) { return voxels(this, ...args); };
  Shape.prototype.voxels = voxelsMethod;

  const surfaceCloud = (shape, resolution = 1) => {
    const offset = resolution / 2;
    const geometry = shape.toKeptGeometry();
    const normalize = createNormalize3();
    const [boxMin, boxMax] = measureBoundingBox$5(geometry);
    const min = floorPoint(boxMin, resolution);
    const max = ceilPoint(boxMax, resolution);
    const classifiers = [];
    for (const { solid } of getSolids(shape.toKeptGeometry())) {
      classifiers.push({ bsp: fromSolid(solid, normalize) });
    }
    const test = (point) => {
      for (const { bsp } of classifiers) {
        if (containsPoint(bsp, point)) {
          return true;
        }
      }
      return false;
    };
    const paths = [];
    for (let x = min[X$n] - offset; x <= max[X$n] + offset; x += resolution) {
      for (let y = min[Y$n] - offset; y <= max[Y$n] + offset; y += resolution) {
        for (let z = min[Z$n] - offset; z <= max[Z$n] + offset; z += resolution) {
          const state = test([x, y, z]);
          if (state !== test([x + resolution, y, z])) {
            paths.push([null, [x, y, z], [x + resolution, y, z]]);
          }
          if (state !== test([x, y + resolution, z])) {
            paths.push([null, [x, y, z], [x, y + resolution, z]]);
          }
          if (state !== test([x, y, z + resolution])) {
            paths.push([null, [x, y, z], [x, y, z + resolution]]);
          }
        }
      }
    }
    return Shape.fromGeometry({ paths });
  };

  const surfaceCloudMethod = function (...args) { return surfaceCloud(this, ...args); };
  Shape.prototype.surfaceCloud = surfaceCloudMethod;

  const withSurfaceCloudMethod = function (...args) { return assemble$1(this, surfaceCloud(this, ...args)); };
  Shape.prototype.withSurfaceCloud = withSurfaceCloudMethod;

  const orderPoints = ([aX, aY, aZ], [bX, bY, bZ]) => {
    const dX = aX - bX;
    if (dX !== 0) {
      return dX;
    }
    const dY = aY - bY;
    if (dY !== 0) {
      return dY;
    }
    const dZ = aZ - bZ;
    return dZ;
  };

  const cloud = (shape, resolution = 1) => {
    const offset = resolution / 2;
    const geometry = shape.toKeptGeometry();
    const normalize = createNormalize3();
    const [boxMin, boxMax] = measureBoundingBox$5(geometry);
    const min = floorPoint(boxMin, resolution);
    const max = ceilPoint(boxMax, resolution);
    const classifiers = [];
    for (const { solid } of getSolids(shape.toKeptGeometry())) {
      classifiers.push({ bsp: fromSolid(solid, normalize) });
    }
    const test = (point) => {
      for (const { bsp } of classifiers) {
        if (containsPoint(bsp, point)) {
          return true;
        }
      }
      return false;
    };
    const points = [];
    for (let x = min[X$n] - offset; x <= max[X$n] + offset; x += resolution) {
      for (let y = min[Y$n] - offset; y <= max[Y$n] + offset; y += resolution) {
        for (let z = min[Z$n] - offset; z <= max[Z$n] + offset; z += resolution) {
          if (test([x, y, z])) {
            points.push([x, y, z]);
          }
        }
      }
    }
    points.sort(orderPoints);
    return Shape.fromGeometry({ points });
  };

  const cloudMethod = function (...args) { return cloud(this, ...args); };
  Shape.prototype.cloud = cloudMethod;

  // FIX: move this
  const containsPoint$1 = (shape, point) => {
    for (const { solid } of getSolids(shape.toKeptGeometry())) {
      const bsp = fromSolid(solid, createNormalize3());
      if (containsPoint(bsp, point)) {
        return true;
      }
    }
    return false;
  };

  const containsPointMethod = function (point) { return containsPoint$1(this, point); };
  Shape.prototype.containsPoint = containsPointMethod;

  /**
   *
   * # Shell
   *
   * Converts a solid into a hollow shell of a given thickness.
   *
   * ::: illustration
   * ```
   * Cube(10).shell(1);
   * ```
   * :::
   *
   **/

  const shell = (shape, radius = 1, resolution = 8) => {
    resolution = Math.max(resolution, 3);
    const keptGeometry = shape.toKeptGeometry();
    const assembly = [];

    // Handle solid aspects.
    const shells = [];
    for (const { solid, tags = [] } of getSolids(keptGeometry)) {
      const pieces = [];
      for (const surface of solid) {
        for (const polygon of surface) {
          pieces.push(Hull(...polygon.map(point => Sphere(radius, resolution).move(...point))));
        }
      }
      shells.push(union$5(...pieces).as(...tags));
    }
    assembly.push(union$5(...shells));

    // Handle surface aspects.
    for (const geometry of getAnySurfaces(keptGeometry)) {
      const anySurface = geometry.surface || geometry.z0Surface;
      const plane = toPlane$1(anySurface);
      if (plane === undefined) {
        continue;
      }
      const [to, from] = toXYPlaneTransforms(plane);
      const pieces = [];
      for (const { paths } of outline$3(transform$a(to, geometry))) {
        for (const path of paths) {
          for (const edge of getEdges(path)) {
            // FIX: Handle non-z0-surfaces properly.
            pieces.push(Hull(...edge.map(([x, y]) => Circle(radius, resolution).move(x, y))));
          }
        }
      }
      assembly.push(assemble$1(...pieces.map(piece => piece.transform(from))).as(...(geometry.tags || [])));
    }

    return assemble$1(...assembly);
  };

  const method$6 = function (radius, resolution) { return shell(this, radius, resolution); };
  Shape.prototype.shell = method$6;

  /**
   *
   * # grow
   *
   * Moves the edges of the shape inward by the specified amount.
   *
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Cube(10).with(Cube(10).moveX(10).grow(2))
   * ```
   * :::
   **/

  const grow = (shape, amount = 1, { resolution = 16 } = {}) =>
    (amount >= 0)
      ? shape.union(shell(shape, amount, resolution))
      : shape.cut(shell(shape, -amount, resolution));

  const growMethod = function (...args) { return grow(this, ...args); };
  Shape.prototype.grow = growMethod;

  grow.signature = 'grow(shape:Shape, amount:number = 1, { resolution:number = 16 }) -> Shape';
  growMethod.signature = 'Shape -> grow(amount:number = 1, { resolution:number = 16 }) -> Shape';

  const offset = (shape, radius = 1, resolution = 16) => outline$4(grow(shape, radius, resolution));

  const offsetMethod = function (radius, resolution) { return offset(this, radius, resolution); };
  Shape.prototype.offset = offsetMethod;

  offset.signature = 'offset(shape:Shape, radius:number = 1, resolution:number = 16) -> Shape';
  offsetMethod.signature = 'Shape -> offset(radius:number = 1, resolution:number = 16) -> Shape';

  /**
   *
   * # shrink
   *
   * Moves the edges of the shape inward by the specified amount.
   *
   * ::: illustration { "view": { "position": [60, -60, 60], "target": [0, 0, 0] } }
   * ```
   * Cube(10).wireframe().with(Cube(10).shrink(2))
   * ```
   * :::
   **/

  const byRadius = (shape, amount = 1, { resolution = 16 } = {}) => grow(shape, -amount, resolution);

  const shrink = (...args) => byRadius(...args);

  shrink.byRadius = byRadius;

  const shrinkMethod = function (radius, resolution) { return shrink(this, radius, resolution); };
  Shape.prototype.shrink = shrinkMethod;

  shrink.signature = 'shrink(shape:Shape, amount:number = 1, { resolution:number = 16 }) -> Shape';
  shrinkMethod.signature = 'Shape -> shrink(amount:number = 1, { resolution:number = 16 }) -> Shape';

  const downloadSvg = (shape, name, options = {}) => {
    let index = 0;
    const entries = [];
    for (const entry of ensurePages(shape.toKeptGeometry())) {
      for (let leaf of getLeafs(entry.content)) {
        const op = toSvg(leaf, options);
        entries.push({ data: op, filename: `${name}_${++index}.svg`, type: 'image/svg+xml' });
      }
    }
    emit$1({ download: { entries } });
    return shape;
  };

  const downloadSvgMethod = function (...args) { return downloadSvg(this, ...args); };
  Shape.prototype.downloadSvg = downloadSvgMethod;

  const toSvg$1 = async (shape, options = {}) => {
    const pages = [];
    // CHECK: Should this be limited to Page plans?
    const geometry = shape.toKeptGeometry();
    for (const entry of getPlans(geometry)) {
      if (entry.plan.page) {
        for (let leaf of getLeafs(entry.content)) {
          const svg = await toSvg(leaf);
          pages.push({ svg, leaf: { ...entry, content: leaf }, index: pages.length });
        }
      }
    }
    return pages;
  };

  const writeSvg = async (shape, name, options = {}) => {
    for (const { svg, leaf, index } of await toSvg$1(shape, options)) {
      await writeFile({ doSerialize: false }, `output/${name}_${index}.svg`, svg);
      await writeFile({}, `geometry/${name}_${index}.svg`, toKeptGeometry(leaf));
    }
  };

  const method$7 = function (...args) { return writeSvg(this, ...args); };
  Shape.prototype.writeSvg = method$7;

  /**
   * Translates a polygon array [[[x, y, z], [x, y, z], ...]] to ascii STL.
   * The exterior side of a polygon is determined by a CCW point ordering.
   *
   * @param {Object} options.
   * @param {Polygon Array} polygons - An array of arrays of points.
   * @returns {String} - the ascii STL output.
   */

  const fromSolidToTriangles = (solid) => {
    const triangles = [];
    for (const surface of makeWatertight(solid)) {
      for (const triangle of toTriangles({}, surface)) {
        triangles.push(triangle);
      }
    }
    return triangles;
  };

  const toStl = async (geometry, options = {}) => {
    const keptGeometry = toKeptGeometry(geometry);
    let solids = getSolids(keptGeometry).map(({ solid }) => solid);
    const triangles = fromSolidToTriangles(union$2(...solids));
    const output = `solid JSxCAD\n${convertToFacets(options, canonicalize$4(triangles))}\nendsolid JSxCAD\n`;
    return new TextEncoder('utf8').encode(output);
  };

  const convertToFacets = (options, polygons) =>
    polygons.map(convertToFacet).filter(facet => facet !== undefined).join('\n');

  const toStlVector = vector =>
    `${vector[0]} ${vector[1]} ${vector[2]}`;

  const toStlVertex = vertex =>
    `vertex ${toStlVector(vertex)}`;

  const convertToFacet = (polygon) => {
    const plane = toPlane(polygon);
    if (plane !== undefined) {
      return `facet normal ${toStlVector(toPlane(polygon))}\n` +
             `outer loop\n` +
             `${toStlVertex(polygon[0])}\n` +
             `${toStlVertex(polygon[1])}\n` +
             `${toStlVertex(polygon[2])}\n` +
             `endloop\n` +
             `endfacet`;
    }
  };

  /**
   *
   * # Write STL
   *
   * ::: illustration { "view": { "position": [5, 5, 5] } }
   * ```
   * await Cube().writeStl('cube.stl');
   * await readStl({ path: 'cube.stl' });
   * ```
   * :::
   *
   **/

  const downloadStl = (shape, name, options = {}) => {
    // CHECK: Should this be limited to Page plans?
    let index = 0;
    const entries = [];
    for (const entry of ensurePages(shape.toKeptGeometry())) {
      for (let leaf of getLeafs(entry.content)) {
        const op = toStl(leaf, options);
        entries.push({ data: op, filename: `${name}_${++index}.stl`, type: 'application/sla' });
      }
    }
    emit$1({ download: { entries } });
    return shape;
  };

  const downloadStlMethod = function (...args) { return downloadStl(this, ...args); };
  Shape.prototype.downloadStl = downloadStlMethod;

  const toStl$1 = async (shape, options = {}) => {
    const pages = [];
    // CHECK: Should this be limited to Page plans?
    const geometry = shape.toKeptGeometry();
    for (const entry of getPlans(geometry)) {
      if (entry.plan.page) {
        for (let leaf of getLeafs(entry.content)) {
          const stl = await toStl(leaf, {});
          pages.push({ stl, leaf: { ...entry, content: leaf }, index: pages.length });
        }
      }
    }
    return pages;
  };

  const writeStl = async (shape, name, options = {}) => {
    const start = new Date();
    log$2(`writeStl start: ${start}`, 'serious');
    for (const { stl, leaf, index } of await toStl$1(shape, {})) {
      await writeFile({ doSerialize: false }, `output/${name}_${index}.stl`, stl);
      await writeFile({}, `geometry/${name}_${index}.stl`, toKeptGeometry(leaf));
    }
    const end = new Date();
    log$2(`writeStl end: ${end - start}`, 'serious');
  };

  const method$8 = function (...args) { return writeStl(this, ...args); };
  Shape.prototype.writeStl = method$8;

  const source = (path, source) => addSource(`cache/${path}`, source);

  const ofPoints$1 = (a, b) => fromPoints$2(a, b);
  const meet = (a, b) => intersectPointOfLines(a, b);

  const Line2 = (...args) => ofPoints$1(...args);

  Line2.ofPoints = ofPoints$1;
  Line2.meet = meet;

  const foot = 304.8;
  const inch = 25.4;
  const mm = 1;
  const mil = 0.0254;
  const cm = 10;
  const m$1 = 1000;
  const thou = 0.0254;
  const yard = 914.4;

  function Parsimmon(action) {
    if (!(this instanceof Parsimmon)) {
      return new Parsimmon(action);
    }
    this._ = action;
  }

  var _ = Parsimmon.prototype;

  function times(n, f) {
    var i = 0;
    for (i; i < n; i++) {
      f(i);
    }
  }

  function forEach(f, arr) {
    times(arr.length, function(i) {
      f(arr[i], i, arr);
    });
  }

  function reduce(f, seed, arr) {
    forEach(function(elem, i, arr) {
      seed = f(seed, elem, i, arr);
    }, arr);
    return seed;
  }

  function map$5(f, arr) {
    return reduce(
      function(acc, elem, i, a) {
        return acc.concat([f(elem, i, a)]);
      },
      [],
      arr
    );
  }

  function lshiftBuffer(input) {
    var asTwoBytes = reduce(
      function(a, v, i, b) {
        return a.concat(
          i === b.length - 1
            ? Buffer.from([v, 0]).readUInt16BE(0)
            : b.readUInt16BE(i)
        );
      },
      [],
      input
    );
    return Buffer.from(
      map$5(function(x) {
        return ((x << 1) & 0xffff) >> 8;
      }, asTwoBytes)
    );
  }

  function consumeBitsFromBuffer(n, input) {
    var state = { v: 0, buf: input };
    times(n, function() {
      state = {
        v: (state.v << 1) | bitPeekBuffer(state.buf),
        buf: lshiftBuffer(state.buf)
      };
    });
    return state;
  }

  function bitPeekBuffer(input) {
    return input[0] >> 7;
  }

  function sum(numArr) {
    return reduce(
      function(x, y) {
        return x + y;
      },
      0,
      numArr
    );
  }

  function find(pred, arr) {
    return reduce(
      function(found, elem) {
        return found || (pred(elem) ? elem : found);
      },
      null,
      arr
    );
  }

  function bufferExists() {
    return typeof Buffer !== "undefined";
  }

  function ensureBuffer() {
    if (!bufferExists()) {
      throw new Error(
        "Buffer global does not exist; please use webpack if you need to parse Buffers in the browser."
      );
    }
  }

  function bitSeq(alignments) {
    ensureBuffer();
    var totalBits = sum(alignments);
    if (totalBits % 8 !== 0) {
      throw new Error(
        "The bits [" +
          alignments.join(", ") +
          "] add up to " +
          totalBits +
          " which is not an even number of bytes; the total should be divisible by 8"
      );
    }
    var bytes = totalBits / 8;

    var tooBigRange = find(function(x) {
      return x > 48;
    }, alignments);
    if (tooBigRange) {
      throw new Error(
        tooBigRange + " bit range requested exceeds 48 bit (6 byte) Number max."
      );
    }

    return new Parsimmon(function(input, i) {
      var newPos = bytes + i;
      if (newPos > input.length) {
        return makeFailure(i, bytes.toString() + " bytes");
      }
      return makeSuccess(
        newPos,
        reduce(
          function(acc, bits) {
            var state = consumeBitsFromBuffer(bits, acc.buf);
            return {
              coll: acc.coll.concat(state.v),
              buf: state.buf
            };
          },
          { coll: [], buf: input.slice(i, newPos) },
          alignments
        ).coll
      );
    });
  }

  function bitSeqObj(namedAlignments) {
    ensureBuffer();
    var seenKeys = {};
    var totalKeys = 0;
    var fullAlignments = map$5(function(item) {
      if (isArray$3(item)) {
        var pair = item;
        if (pair.length !== 2) {
          throw new Error(
            "[" +
              pair.join(", ") +
              "] should be length 2, got length " +
              pair.length
          );
        }
        assertString(pair[0]);
        assertNumber(pair[1]);
        if (Object.prototype.hasOwnProperty.call(seenKeys, pair[0])) {
          throw new Error("duplicate key in bitSeqObj: " + pair[0]);
        }
        seenKeys[pair[0]] = true;
        totalKeys++;
        return pair;
      } else {
        assertNumber(item);
        return [null, item];
      }
    }, namedAlignments);
    if (totalKeys < 1) {
      throw new Error(
        "bitSeqObj expects at least one named pair, got [" +
          namedAlignments.join(", ") +
          "]"
      );
    }
    var namesOnly = map$5(function(pair) {
      return pair[0];
    }, fullAlignments);
    var alignmentsOnly = map$5(function(pair) {
      return pair[1];
    }, fullAlignments);

    return bitSeq(alignmentsOnly).map(function(parsed) {
      var namedParsed = map$5(function(name, i) {
        return [name, parsed[i]];
      }, namesOnly);

      return reduce(
        function(obj, kv) {
          if (kv[0] !== null) {
            obj[kv[0]] = kv[1];
          }
          return obj;
        },
        {},
        namedParsed
      );
    });
  }

  function parseBufferFor(other, length) {
    return new Parsimmon(function(input, i) {
      ensureBuffer();
      if (i + length > input.length) {
        return makeFailure(i, length + " bytes for " + other);
      }
      return makeSuccess(i + length, input.slice(i, i + length));
    });
  }

  function parseBuffer(length) {
    return parseBufferFor("buffer", length).map(function(unsafe) {
      return Buffer.from(unsafe);
    });
  }

  function encodedString(encoding, length) {
    return parseBufferFor("string", length).map(function(buff) {
      return buff.toString(encoding);
    });
  }

  function isInteger(value) {
    return typeof value === "number" && Math.floor(value) === value;
  }

  function assertValidIntegerByteLengthFor(who, length) {
    if (!isInteger(length) || length < 0 || length > 6) {
      throw new Error(who + " requires integer length in range [0, 6].");
    }
  }

  function uintBE(length) {
    assertValidIntegerByteLengthFor("uintBE", length);
    return parseBufferFor("uintBE(" + length + ")", length).map(function(buff) {
      return buff.readUIntBE(0, length);
    });
  }

  function uintLE(length) {
    assertValidIntegerByteLengthFor("uintLE", length);
    return parseBufferFor("uintLE(" + length + ")", length).map(function(buff) {
      return buff.readUIntLE(0, length);
    });
  }

  function intBE(length) {
    assertValidIntegerByteLengthFor("intBE", length);
    return parseBufferFor("intBE(" + length + ")", length).map(function(buff) {
      return buff.readIntBE(0, length);
    });
  }

  function intLE(length) {
    assertValidIntegerByteLengthFor("intLE", length);
    return parseBufferFor("intLE(" + length + ")", length).map(function(buff) {
      return buff.readIntLE(0, length);
    });
  }

  function floatBE() {
    return parseBufferFor("floatBE", 4).map(function(buff) {
      return buff.readFloatBE(0);
    });
  }

  function floatLE() {
    return parseBufferFor("floatLE", 4).map(function(buff) {
      return buff.readFloatLE(0);
    });
  }

  function doubleBE() {
    return parseBufferFor("doubleBE", 8).map(function(buff) {
      return buff.readDoubleBE(0);
    });
  }

  function doubleLE() {
    return parseBufferFor("doubleLE", 8).map(function(buff) {
      return buff.readDoubleLE(0);
    });
  }

  function toArray(arrLike) {
    return Array.prototype.slice.call(arrLike);
  }
  // -*- Helpers -*-

  function isParser(obj) {
    return obj instanceof Parsimmon;
  }

  function isArray$3(x) {
    return {}.toString.call(x) === "[object Array]";
  }

  function isBuffer$2(x) {
    /* global Buffer */
    return bufferExists() && isBuffer(x);
  }

  function makeSuccess(index, value) {
    return {
      status: true,
      index: index,
      value: value,
      furthest: -1,
      expected: []
    };
  }

  function makeFailure(index, expected) {
    if (!isArray$3(expected)) {
      expected = [expected];
    }
    return {
      status: false,
      index: -1,
      value: null,
      furthest: index,
      expected: expected
    };
  }

  function mergeReplies(result, last) {
    if (!last) {
      return result;
    }
    if (result.furthest > last.furthest) {
      return result;
    }
    var expected =
      result.furthest === last.furthest
        ? union$6(result.expected, last.expected)
        : last.expected;
    return {
      status: result.status,
      index: result.index,
      value: result.value,
      furthest: last.furthest,
      expected: expected
    };
  }

  function makeLineColumnIndex(input, i) {
    if (isBuffer$2(input)) {
      return {
        offset: i,
        line: -1,
        column: -1
      };
    }
    var lines = input.slice(0, i).split("\n");
    // Note that unlike the character offset, the line and column offsets are
    // 1-based.
    var lineWeAreUpTo = lines.length;
    var columnWeAreUpTo = lines[lines.length - 1].length + 1;
    return {
      offset: i,
      line: lineWeAreUpTo,
      column: columnWeAreUpTo
    };
  }

  // Returns the sorted set union of two arrays of strings
  function union$6(xs, ys) {
    var obj = {};
    for (var i = 0; i < xs.length; i++) {
      obj[xs[i]] = true;
    }
    for (var j = 0; j < ys.length; j++) {
      obj[ys[j]] = true;
    }
    var keys = [];
    for (var k in obj) {
      if ({}.hasOwnProperty.call(obj, k)) {
        keys.push(k);
      }
    }
    keys.sort();
    return keys;
  }

  function assertParser(p) {
    if (!isParser(p)) {
      throw new Error("not a parser: " + p);
    }
  }

  function get(input, i) {
    if (typeof input === "string") {
      return input.charAt(i);
    }
    return input[i];
  }

  // TODO[ES5]: Switch to Array.isArray eventually.
  function assertArray(x) {
    if (!isArray$3(x)) {
      throw new Error("not an array: " + x);
    }
  }

  function assertNumber(x) {
    if (typeof x !== "number") {
      throw new Error("not a number: " + x);
    }
  }

  function assertRegexp(x) {
    if (!(x instanceof RegExp)) {
      throw new Error("not a regexp: " + x);
    }
    var f = flags(x);
    for (var i = 0; i < f.length; i++) {
      var c = f.charAt(i);
      // Only allow regexp flags [imu] for now, since [g] and [y] specifically
      // mess up Parsimmon. If more non-stateful regexp flags are added in the
      // future, this will need to be revisited.
      if (c !== "i" && c !== "m" && c !== "u") {
        throw new Error('unsupported regexp flag "' + c + '": ' + x);
      }
    }
  }

  function assertFunction(x) {
    if (typeof x !== "function") {
      throw new Error("not a function: " + x);
    }
  }

  function assertString(x) {
    if (typeof x !== "string") {
      throw new Error("not a string: " + x);
    }
  }

  // -*- Error Formatting -*-

  var linesBeforeStringError = 2;
  var linesAfterStringError = 3;
  var bytesPerLine = 8;
  var bytesBefore = bytesPerLine * 5;
  var bytesAfter = bytesPerLine * 4;
  var defaultLinePrefix = "  ";

  function repeat(string, amount) {
    return new Array(amount + 1).join(string);
  }

  function formatExpected(expected) {
    if (expected.length === 1) {
      return "Expected:\n\n" + expected[0];
    }
    return "Expected one of the following: \n\n" + expected.join(", ");
  }

  function leftPad(str, pad, char) {
    var add = pad - str.length;
    if (add <= 0) {
      return str;
    }
    return repeat(char, add) + str;
  }

  function toChunks(arr, chunkSize) {
    var length = arr.length;
    var chunks = [];
    var chunkIndex = 0;

    if (length <= chunkSize) {
      return [arr.slice()];
    }

    for (var i = 0; i < length; i++) {
      if (!chunks[chunkIndex]) {
        chunks.push([]);
      }

      chunks[chunkIndex].push(arr[i]);

      if ((i + 1) % chunkSize === 0) {
        chunkIndex++;
      }
    }

    return chunks;
  }

  // Get a range of indexes including `i`-th element and `before` and `after` amount of elements from `arr`.
  function rangeFromIndexAndOffsets(i, before, after, length) {
    return {
      // Guard against the negative upper bound for lines included in the output.
      from: i - before > 0 ? i - before : 0,
      to: i + after > length ? length : i + after
    };
  }

  function byteRangeToRange(byteRange) {
    // Exception for inputs smaller than `bytesPerLine`
    if (byteRange.from === 0 && byteRange.to === 1) {
      return {
        from: byteRange.from,
        to: byteRange.to
      };
    }

    return {
      from: byteRange.from / bytesPerLine,
      // Round `to`, so we don't get float if the amount of bytes is not divisible by `bytesPerLine`
      to: Math.floor(byteRange.to / bytesPerLine)
    };
  }

  function formatGot(input, error) {
    var index = error.index;
    var i = index.offset;

    var verticalMarkerLength = 1;
    var column;
    var lineWithErrorIndex;
    var lines;
    var lineRange;
    var lastLineNumberLabelLength;

    if (i === input.length) {
      return "Got the end of the input";
    }

    if (isBuffer$2(input)) {
      var byteLineWithErrorIndex = i - (i % bytesPerLine);
      var columnByteIndex = i - byteLineWithErrorIndex;
      var byteRange = rangeFromIndexAndOffsets(
        byteLineWithErrorIndex,
        bytesBefore,
        bytesAfter + bytesPerLine,
        input.length
      );
      var bytes = input.slice(byteRange.from, byteRange.to);
      var bytesInChunks = toChunks(bytes.toJSON().data, bytesPerLine);

      var byteLines = map$5(function(byteRow) {
        return map$5(function(byteValue) {
          // Prefix byte values with a `0` if they are shorter than 2 characters.
          return leftPad(byteValue.toString(16), 2, "0");
        }, byteRow);
      }, bytesInChunks);

      lineRange = byteRangeToRange(byteRange);
      lineWithErrorIndex = byteLineWithErrorIndex / bytesPerLine;
      column = columnByteIndex * 3;

      // Account for an extra space.
      if (columnByteIndex >= 4) {
        column += 1;
      }

      verticalMarkerLength = 2;
      lines = map$5(function(byteLine) {
        return byteLine.length <= 4
          ? byteLine.join(" ")
          : byteLine.slice(0, 4).join(" ") + "  " + byteLine.slice(4).join(" ");
      }, byteLines);
      lastLineNumberLabelLength = (
        (lineRange.to > 0 ? lineRange.to - 1 : lineRange.to) * 8
      ).toString(16).length;

      if (lastLineNumberLabelLength < 2) {
        lastLineNumberLabelLength = 2;
      }
    } else {
      var inputLines = input.split(/\r\n|[\n\r\u2028\u2029]/);
      column = index.column - 1;
      lineWithErrorIndex = index.line - 1;
      lineRange = rangeFromIndexAndOffsets(
        lineWithErrorIndex,
        linesBeforeStringError,
        linesAfterStringError,
        inputLines.length
      );

      lines = inputLines.slice(lineRange.from, lineRange.to);
      lastLineNumberLabelLength = lineRange.to.toString().length;
    }

    var lineWithErrorCurrentIndex = lineWithErrorIndex - lineRange.from;

    if (isBuffer$2(input)) {
      lastLineNumberLabelLength = (
        (lineRange.to > 0 ? lineRange.to - 1 : lineRange.to) * 8
      ).toString(16).length;

      if (lastLineNumberLabelLength < 2) {
        lastLineNumberLabelLength = 2;
      }
    }

    var linesWithLineNumbers = reduce(
      function(acc, lineSource, index) {
        var isLineWithError = index === lineWithErrorCurrentIndex;
        var prefix = isLineWithError ? "> " : defaultLinePrefix;
        var lineNumberLabel;

        if (isBuffer$2(input)) {
          lineNumberLabel = leftPad(
            ((lineRange.from + index) * 8).toString(16),
            lastLineNumberLabelLength,
            "0"
          );
        } else {
          lineNumberLabel = leftPad(
            (lineRange.from + index + 1).toString(),
            lastLineNumberLabelLength,
            " "
          );
        }

        return [].concat(
          acc,
          [prefix + lineNumberLabel + " | " + lineSource],
          isLineWithError
            ? [
                defaultLinePrefix +
                  repeat(" ", lastLineNumberLabelLength) +
                  " | " +
                  leftPad("", column, " ") +
                  repeat("^", verticalMarkerLength)
              ]
            : []
        );
      },
      [],
      lines
    );

    return linesWithLineNumbers.join("\n");
  }

  function formatError$1(input, error) {
    return [
      "\n",
      "-- PARSING FAILED " + repeat("-", 50),
      "\n\n",
      formatGot(input, error),
      "\n\n",
      formatExpected(error.expected),
      "\n"
    ].join("");
  }

  function flags(re) {
    var s = "" + re;
    return s.slice(s.lastIndexOf("/") + 1);
  }

  function anchoredRegexp(re) {
    return RegExp("^(?:" + re.source + ")", flags(re));
  }

  // -*- Combinators -*-

  function seq() {
    var parsers = [].slice.call(arguments);
    var numParsers = parsers.length;
    for (var j = 0; j < numParsers; j += 1) {
      assertParser(parsers[j]);
    }
    return Parsimmon(function(input, i) {
      var result;
      var accum = new Array(numParsers);
      for (var j = 0; j < numParsers; j += 1) {
        result = mergeReplies(parsers[j]._(input, i), result);
        if (!result.status) {
          return result;
        }
        accum[j] = result.value;
        i = result.index;
      }
      return mergeReplies(makeSuccess(i, accum), result);
    });
  }

  function seqObj() {
    var seenKeys = {};
    var totalKeys = 0;
    var parsers = toArray(arguments);
    var numParsers = parsers.length;
    for (var j = 0; j < numParsers; j += 1) {
      var p = parsers[j];
      if (isParser(p)) {
        continue;
      }
      if (isArray$3(p)) {
        var isWellFormed =
          p.length === 2 && typeof p[0] === "string" && isParser(p[1]);
        if (isWellFormed) {
          var key = p[0];
          if (Object.prototype.hasOwnProperty.call(seenKeys, key)) {
            throw new Error("seqObj: duplicate key " + key);
          }
          seenKeys[key] = true;
          totalKeys++;
          continue;
        }
      }
      throw new Error(
        "seqObj arguments must be parsers or [string, parser] array pairs."
      );
    }
    if (totalKeys === 0) {
      throw new Error("seqObj expects at least one named parser, found zero");
    }
    return Parsimmon(function(input, i) {
      var result;
      var accum = {};
      for (var j = 0; j < numParsers; j += 1) {
        var name;
        var parser;
        if (isArray$3(parsers[j])) {
          name = parsers[j][0];
          parser = parsers[j][1];
        } else {
          name = null;
          parser = parsers[j];
        }
        result = mergeReplies(parser._(input, i), result);
        if (!result.status) {
          return result;
        }
        if (name) {
          accum[name] = result.value;
        }
        i = result.index;
      }
      return mergeReplies(makeSuccess(i, accum), result);
    });
  }

  function seqMap() {
    var args = [].slice.call(arguments);
    if (args.length === 0) {
      throw new Error("seqMap needs at least one argument");
    }
    var mapper = args.pop();
    assertFunction(mapper);
    return seq.apply(null, args).map(function(results) {
      return mapper.apply(null, results);
    });
  }

  // TODO[ES5]: Revisit this with Object.keys and .bind.
  function createLanguage(parsers) {
    var language = {};
    for (var key in parsers) {
      if ({}.hasOwnProperty.call(parsers, key)) {
        (function(key) {
          var func = function() {
            return parsers[key](language);
          };
          language[key] = lazy(func);
        })(key);
      }
    }
    return language;
  }

  function alt() {
    var parsers = [].slice.call(arguments);
    var numParsers = parsers.length;
    if (numParsers === 0) {
      return fail("zero alternates");
    }
    for (var j = 0; j < numParsers; j += 1) {
      assertParser(parsers[j]);
    }
    return Parsimmon(function(input, i) {
      var result;
      for (var j = 0; j < parsers.length; j += 1) {
        result = mergeReplies(parsers[j]._(input, i), result);
        if (result.status) {
          return result;
        }
      }
      return result;
    });
  }

  function sepBy(parser, separator) {
    // Argument asserted by sepBy1
    return sepBy1(parser, separator).or(succeed([]));
  }

  function sepBy1(parser, separator) {
    assertParser(parser);
    assertParser(separator);
    var pairs = separator.then(parser).many();
    return seqMap(parser, pairs, function(r, rs) {
      return [r].concat(rs);
    });
  }

  // -*- Core Parsing Methods -*-

  _.parse = function(input) {
    if (typeof input !== "string" && !isBuffer$2(input)) {
      throw new Error(
        ".parse must be called with a string or Buffer as its argument"
      );
    }
    var result = this.skip(eof)._(input, 0);
    if (result.status) {
      return {
        status: true,
        value: result.value
      };
    }
    return {
      status: false,
      index: makeLineColumnIndex(input, result.furthest),
      expected: result.expected
    };
  };

  // -*- Other Methods -*-

  _.tryParse = function(str) {
    var result = this.parse(str);
    if (result.status) {
      return result.value;
    } else {
      var msg = formatError$1(str, result);
      var err = new Error(msg);
      err.type = "ParsimmonError";
      err.result = result;
      throw err;
    }
  };

  _.assert = function(condition, errorMessage) {
    return this.chain(function(value) {
      return condition(value) ? succeed(value) : fail(errorMessage);
    });
  };

  _.or = function(alternative) {
    return alt(this, alternative);
  };

  _.trim = function(parser) {
    return this.wrap(parser, parser);
  };

  _.wrap = function(leftParser, rightParser) {
    return seqMap(leftParser, this, rightParser, function(left, middle) {
      return middle;
    });
  };

  _.thru = function(wrapper) {
    return wrapper(this);
  };

  _.then = function(next) {
    assertParser(next);
    return seq(this, next).map(function(results) {
      return results[1];
    });
  };

  _.many = function() {
    var self = this;

    return Parsimmon(function(input, i) {
      var accum = [];
      var result = undefined;

      for (;;) {
        result = mergeReplies(self._(input, i), result);
        if (result.status) {
          if (i === result.index) {
            throw new Error(
              "infinite loop detected in .many() parser --- calling .many() on " +
                "a parser which can accept zero characters is usually the cause"
            );
          }
          i = result.index;
          accum.push(result.value);
        } else {
          return mergeReplies(makeSuccess(i, accum), result);
        }
      }
    });
  };

  _.tieWith = function(separator) {
    assertString(separator);
    return this.map(function(args) {
      assertArray(args);
      if (args.length) {
        assertString(args[0]);
        var s = args[0];
        for (var i = 1; i < args.length; i++) {
          assertString(args[i]);
          s += separator + args[i];
        }
        return s;
      } else {
        return "";
      }
    });
  };

  _.tie = function() {
    return this.tieWith("");
  };

  _.times = function(min, max) {
    var self = this;
    if (arguments.length < 2) {
      max = min;
    }
    assertNumber(min);
    assertNumber(max);
    return Parsimmon(function(input, i) {
      var accum = [];
      var result = undefined;
      var prevResult = undefined;
      for (var times = 0; times < min; times += 1) {
        result = self._(input, i);
        prevResult = mergeReplies(result, prevResult);
        if (result.status) {
          i = result.index;
          accum.push(result.value);
        } else {
          return prevResult;
        }
      }
      for (; times < max; times += 1) {
        result = self._(input, i);
        prevResult = mergeReplies(result, prevResult);
        if (result.status) {
          i = result.index;
          accum.push(result.value);
        } else {
          break;
        }
      }
      return mergeReplies(makeSuccess(i, accum), prevResult);
    });
  };

  _.result = function(res) {
    return this.map(function() {
      return res;
    });
  };

  _.atMost = function(n) {
    return this.times(0, n);
  };

  _.atLeast = function(n) {
    return seqMap(this.times(n), this.many(), function(init, rest) {
      return init.concat(rest);
    });
  };

  _.map = function(fn) {
    assertFunction(fn);
    var self = this;
    return Parsimmon(function(input, i) {
      var result = self._(input, i);
      if (!result.status) {
        return result;
      }
      return mergeReplies(makeSuccess(result.index, fn(result.value)), result);
    });
  };

  _.contramap = function(fn) {
    assertFunction(fn);
    var self = this;
    return Parsimmon(function(input, i) {
      var result = self.parse(fn(input.slice(i)));
      if (!result.status) {
        return result;
      }
      return makeSuccess(i + input.length, result.value);
    });
  };

  _.promap = function(f, g) {
    assertFunction(f);
    assertFunction(g);
    return this.contramap(f).map(g);
  };

  _.skip = function(next) {
    return seq(this, next).map(function(results) {
      return results[0];
    });
  };

  _.mark = function() {
    return seqMap(index, this, index, function(start, value, end) {
      return {
        start: start,
        value: value,
        end: end
      };
    });
  };

  _.node = function(name) {
    return seqMap(index, this, index, function(start, value, end) {
      return {
        name: name,
        value: value,
        start: start,
        end: end
      };
    });
  };

  _.sepBy = function(separator) {
    return sepBy(this, separator);
  };

  _.sepBy1 = function(separator) {
    return sepBy1(this, separator);
  };

  _.lookahead = function(x) {
    return this.skip(lookahead(x));
  };

  _.notFollowedBy = function(x) {
    return this.skip(notFollowedBy(x));
  };

  _.desc = function(expected) {
    if (!isArray$3(expected)) {
      expected = [expected];
    }
    var self = this;
    return Parsimmon(function(input, i) {
      var reply = self._(input, i);
      if (!reply.status) {
        reply.expected = expected;
      }
      return reply;
    });
  };

  _.fallback = function(result) {
    return this.or(succeed(result));
  };

  _.ap = function(other) {
    return seqMap(other, this, function(f, x) {
      return f(x);
    });
  };

  _.chain = function(f) {
    var self = this;
    return Parsimmon(function(input, i) {
      var result = self._(input, i);
      if (!result.status) {
        return result;
      }
      var nextParser = f(result.value);
      return mergeReplies(nextParser._(input, result.index), result);
    });
  };

  // -*- Constructors -*-

  function string(str) {
    assertString(str);
    var expected = "'" + str + "'";
    return Parsimmon(function(input, i) {
      var j = i + str.length;
      var head = input.slice(i, j);
      if (head === str) {
        return makeSuccess(j, head);
      } else {
        return makeFailure(i, expected);
      }
    });
  }

  function byte(b) {
    ensureBuffer();
    assertNumber(b);
    if (b > 0xff) {
      throw new Error(
        "Value specified to byte constructor (" +
          b +
          "=0x" +
          b.toString(16) +
          ") is larger in value than a single byte."
      );
    }
    var expected = (b > 0xf ? "0x" : "0x0") + b.toString(16);
    return Parsimmon(function(input, i) {
      var head = get(input, i);
      if (head === b) {
        return makeSuccess(i + 1, head);
      } else {
        return makeFailure(i, expected);
      }
    });
  }

  function regexp(re, group) {
    assertRegexp(re);
    if (arguments.length >= 2) {
      assertNumber(group);
    } else {
      group = 0;
    }
    var anchored = anchoredRegexp(re);
    var expected = "" + re;
    return Parsimmon(function(input, i) {
      var match = anchored.exec(input.slice(i));
      if (match) {
        if (0 <= group && group <= match.length) {
          var fullMatch = match[0];
          var groupMatch = match[group];
          return makeSuccess(i + fullMatch.length, groupMatch);
        }
        var message =
          "valid match group (0 to " + match.length + ") in " + expected;
        return makeFailure(i, message);
      }
      return makeFailure(i, expected);
    });
  }

  function succeed(value) {
    return Parsimmon(function(input, i) {
      return makeSuccess(i, value);
    });
  }

  function fail(expected) {
    return Parsimmon(function(input, i) {
      return makeFailure(i, expected);
    });
  }

  function lookahead(x) {
    if (isParser(x)) {
      return Parsimmon(function(input, i) {
        var result = x._(input, i);
        result.index = i;
        result.value = "";
        return result;
      });
    } else if (typeof x === "string") {
      return lookahead(string(x));
    } else if (x instanceof RegExp) {
      return lookahead(regexp(x));
    }
    throw new Error("not a string, regexp, or parser: " + x);
  }

  function notFollowedBy(parser) {
    assertParser(parser);
    return Parsimmon(function(input, i) {
      var result = parser._(input, i);
      var text = input.slice(i, result.index);
      return result.status
        ? makeFailure(i, 'not "' + text + '"')
        : makeSuccess(i, null);
    });
  }

  function test(predicate) {
    assertFunction(predicate);
    return Parsimmon(function(input, i) {
      var char = get(input, i);
      if (i < input.length && predicate(char)) {
        return makeSuccess(i + 1, char);
      } else {
        return makeFailure(i, "a character/byte matching " + predicate);
      }
    });
  }

  function oneOf(str) {
    var expected = str.split("");
    for (var idx = 0; idx < expected.length; idx++) {
      expected[idx] = "'" + expected[idx] + "'";
    }
    return test(function(ch) {
      return str.indexOf(ch) >= 0;
    }).desc(expected);
  }

  function noneOf(str) {
    return test(function(ch) {
      return str.indexOf(ch) < 0;
    }).desc("none of '" + str + "'");
  }

  function custom(parsingFunction) {
    return Parsimmon(parsingFunction(makeSuccess, makeFailure));
  }

  // TODO[ES5]: Improve error message using JSON.stringify eventually.
  function range(begin, end) {
    return test(function(ch) {
      return begin <= ch && ch <= end;
    }).desc(begin + "-" + end);
  }

  function takeWhile(predicate) {
    assertFunction(predicate);

    return Parsimmon(function(input, i) {
      var j = i;
      while (j < input.length && predicate(get(input, j))) {
        j++;
      }
      return makeSuccess(j, input.slice(i, j));
    });
  }

  function lazy(desc, f) {
    if (arguments.length < 2) {
      f = desc;
      desc = undefined;
    }

    var parser = Parsimmon(function(input, i) {
      parser._ = f()._;
      return parser._(input, i);
    });

    if (desc) {
      return parser.desc(desc);
    } else {
      return parser;
    }
  }

  // -*- Fantasy Land Extras -*-

  function empty() {
    return fail("fantasy-land/empty");
  }

  _.concat = _.or;
  _.empty = empty;
  _.of = succeed;
  _["fantasy-land/ap"] = _.ap;
  _["fantasy-land/chain"] = _.chain;
  _["fantasy-land/concat"] = _.concat;
  _["fantasy-land/empty"] = _.empty;
  _["fantasy-land/of"] = _.of;
  _["fantasy-land/map"] = _.map;

  // -*- Base Parsers -*-

  var index = Parsimmon(function(input, i) {
    return makeSuccess(i, makeLineColumnIndex(input, i));
  });

  var any = Parsimmon(function(input, i) {
    if (i >= input.length) {
      return makeFailure(i, "any character/byte");
    }
    return makeSuccess(i + 1, get(input, i));
  });

  var all = Parsimmon(function(input, i) {
    return makeSuccess(input.length, input.slice(i));
  });

  var eof = Parsimmon(function(input, i) {
    if (i < input.length) {
      return makeFailure(i, "EOF");
    }
    return makeSuccess(i, null);
  });

  var digit = regexp(/[0-9]/).desc("a digit");
  var digits = regexp(/[0-9]*/).desc("optional digits");
  var letter = regexp(/[a-z]/i).desc("a letter");
  var letters = regexp(/[a-z]*/i).desc("optional letters");
  var optWhitespace = regexp(/\s*/).desc("optional whitespace");
  var whitespace = regexp(/\s+/).desc("whitespace");
  var cr$1 = string("\r");
  var lf = string("\n");
  var crlf = string("\r\n");
  var newline = alt(crlf, lf, cr$1).desc("newline");
  var end = alt(newline, eof);

  Parsimmon.all = all;
  Parsimmon.alt = alt;
  Parsimmon.any = any;
  Parsimmon.cr = cr$1;
  Parsimmon.createLanguage = createLanguage;
  Parsimmon.crlf = crlf;
  Parsimmon.custom = custom;
  Parsimmon.digit = digit;
  Parsimmon.digits = digits;
  Parsimmon.empty = empty;
  Parsimmon.end = end;
  Parsimmon.eof = eof;
  Parsimmon.fail = fail;
  Parsimmon.formatError = formatError$1;
  Parsimmon.index = index;
  Parsimmon.isParser = isParser;
  Parsimmon.lazy = lazy;
  Parsimmon.letter = letter;
  Parsimmon.letters = letters;
  Parsimmon.lf = lf;
  Parsimmon.lookahead = lookahead;
  Parsimmon.makeFailure = makeFailure;
  Parsimmon.makeSuccess = makeSuccess;
  Parsimmon.newline = newline;
  Parsimmon.noneOf = noneOf;
  Parsimmon.notFollowedBy = notFollowedBy;
  Parsimmon.of = succeed;
  Parsimmon.oneOf = oneOf;
  Parsimmon.optWhitespace = optWhitespace;
  Parsimmon.Parser = Parsimmon;
  Parsimmon.range = range;
  Parsimmon.regex = regexp;
  Parsimmon.regexp = regexp;
  Parsimmon.sepBy = sepBy;
  Parsimmon.sepBy1 = sepBy1;
  Parsimmon.seq = seq;
  Parsimmon.seqMap = seqMap;
  Parsimmon.seqObj = seqObj;
  Parsimmon.string = string;
  Parsimmon.succeed = succeed;
  Parsimmon.takeWhile = takeWhile;
  Parsimmon.test = test;
  Parsimmon.whitespace = whitespace;
  Parsimmon["fantasy-land/empty"] = empty;
  Parsimmon["fantasy-land/of"] = succeed;

  Parsimmon.Binary = {
    bitSeq: bitSeq,
    bitSeqObj: bitSeqObj,
    byte: byte,
    buffer: parseBuffer,
    encodedString: encodedString,
    uintBE: uintBE,
    uint8BE: uintBE(1),
    uint16BE: uintBE(2),
    uint32BE: uintBE(4),
    uintLE: uintLE,
    uint8LE: uintLE(1),
    uint16LE: uintLE(2),
    uint32LE: uintLE(4),
    intBE: intBE,
    int8BE: intBE(1),
    int16BE: intBE(2),
    int32BE: intBE(4),
    intLE: intLE,
    int8LE: intLE(1),
    int16LE: intLE(2),
    int32LE: intLE(4),
    floatBE: floatBE(),
    floatLE: floatLE(),
    doubleBE: doubleBE(),
    doubleLE: doubleLE()
  };

  var parsimmon = Parsimmon;

  const { alt: alt$1, regexp: regexp$1, seq: seq$1, string: string$1 } = parsimmon;

  const whitespace$1 = regexp$1(/\s*/m);
  const token = (parser) => parser.skip(whitespace$1);
  const skipWhitespace = (parser) => parser.skip(whitespace$1);
  const letter$1 = (text) => string$1(text).thru(skipWhitespace);
  const word$1 = (text) => string$1(text).thru(skipWhitespace);
  const number$1 = () => token(regexp$1(/-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/)).map(Number).desc('number');

  const nominalSize = seq$1(word$1('#'), number$1()).map(([, inchDiameter]) => ({ inchDiameter }));
  const length$3 = seq$1(number$1()).map(([feetLength]) => ({ feetLength }));

  // FIX: Should be 'M'
  const metricSize = seq$1(letter$1('m'), number$1()).map(([, mmDiameter]) => ({ mmDiameter }));
  const metricLength = alt$1(number$1().skip(word$1('mm')), number$1()).map(mmLength => ({ mmLength }));

  const nominalSizeAndLength = seq$1(nominalSize.skip(word$1('x')), length$3).map(([nominalSize, length]) => ({ ...nominalSize, ...length }));
  const metricSizeAndLength = seq$1(metricSize.skip(word$1('x')), metricLength).map(([nominalSize, length]) => ({ ...nominalSize, ...length }));

  const size$1 = alt$1(nominalSizeAndLength, metricSizeAndLength);

  const driveStyle = alt$1(word$1('slotted'),
                         word$1('phillips'), // Phillips
                         word$1('square')
  ).map((driveStyle) => ({ driveStyle }));

  const headType = alt$1(word$1('flat head'),
                       word$1('oval countersunk head'),
                       word$1('round head')
  ).map(headType => ({ headType }));

  const fastenerName = alt$1(word$1('wood screw')).map(fastenerName => ({ fastenerName: fastenerName }));

  const material$1 = alt$1(word$1('steel'),
                       word$1('stainless steel'),
                       word$1('brass'),
                       word$1('silicon bronze')).map((material) => ({ material }));

  const protectiveFinish = alt$1(word$1('zinc plated')).map(protectiveFinish => ({ protectiveFinish }));

  const WoodScrewDesignator = alt$1(seq$1(size$1, driveStyle, headType, fastenerName.skip(word$1(',')), material$1, protectiveFinish),
                                  seq$1(size$1, driveStyle, headType, fastenerName.skip(word$1(',')), material$1),
                                  seq$1(size$1, driveStyle, headType, fastenerName.skip(word$1(',')), protectiveFinish),
                                  seq$1(size$1, driveStyle, headType, fastenerName));

  /*
  From: https://www.fastenermart.com/wood-screws.html

  DESIGNATION
  Wood screws are typically described as follows:

  Nominal Size (a number from #0 to #24; #0 is smallest)
  Screw Length (in inches; see above for instructions on how to measure)
  Drive Style (slotted, Phillips or square)
  Head Type (flat or oval countersunk, or round)
  Fastener Name (wood screw)
  Material (steel, stainless steel, brass and silicon bronze)
  Protective Finish (zinc plated if steel)
  Examples:

  #10 x 1 1/2" Slotted Round Head Wood Screw, Brass
  #4 x 7/8" Phillips Flat Head Wood Screw, Zinc Plated (because zinc plating usually means that the fastener is made of steel, the word "steel" is often omitted in the description)
  */

  const decode = (designator) => {
    return WoodScrewDesignator
        .tryParse(designator.toLowerCase())
        .reduce((value, object) => ({ ...object, ...value, designator }), {});
  };

  const WoodScrew = ({
    fastenerName = 'wood screw',
    headType,
    driveStyle,
    inchDiameter,
    feetLength,
    material = 'steel',
    mmDiameter,
    mmLength,
    protectiveFinish,
    designator
  }) => {
    if (feetLength) { mmLength = feetLength * foot; }
    if (inchDiameter) { mmDiameter = inchDiameter * inch; }
    return Cylinder(mmDiameter, mmLength).material('thread').Item(designator);
  };

  registerDesignator(decode, WoodScrew);

  /**
   *
   * Defines the interface used by the api to access the rest of the system on
   * behalf of a user. e.g., algorithms and geometries.
   *
   * A user can destructively update this mapping in their code to change what
   * the api uses.
   */

  var api = /*#__PURE__*/Object.freeze({
    __proto__: null,
    emit: emit$1,
    source: source,
    Connector: Connector,
    X: X$m,
    Y: Y$m,
    Z: Z$k,
    ChainedHull: ChainedHull,
    Hull: Hull,
    Loop: Loop,
    Shape: Shape,
    log: log$2,
    make: make,
    pack: pack$1,
    Line2: Line2,
    Plan: Plan,
    Page: Page,
    Arc: Arc,
    Assembly: Assembly,
    Circle: Circle,
    Cone: Cone,
    Cube: Cube,
    Cylinder: Cylinder,
    Difference: Difference,
    Empty: Empty,
    Hexagon: Hexagon,
    Icosahedron: Icosahedron,
    Intersection: Intersection,
    Layers: Layers,
    Line: Line,
    Path: Path,
    Point: Point,
    Points: Points,
    Polygon: Polygon,
    Polyhedron: Polyhedron,
    Prism: Prism,
    Sphere: Sphere,
    Spiral: Spiral,
    Square: Square,
    Tetrahedron: Tetrahedron,
    Torus: Torus,
    Triangle: Triangle,
    Union: Union,
    Void: Void,
    Wave: Wave,
    Item: Item$1,
    WoodScrew: WoodScrew,
    Random: Random,
    acos: acos,
    cos: cos,
    ease: ease,
    max: max$1,
    min: min$1,
    numbers: numbers,
    sin: sin,
    sqrt: sqrt,
    vec: vec,
    foot: foot,
    inch: inch,
    mm: mm,
    mil: mil,
    cm: cm,
    m: m$1,
    thou: thou,
    yard: yard
  });

  var astring = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.generate = generate;
  exports.baseGenerator = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var stringify = JSON.stringify;

  if (!String.prototype.repeat) {
    throw new Error('String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation');
  }

  if (!String.prototype.endsWith) {
    throw new Error('String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation');
  }

  var OPERATOR_PRECEDENCE = {
    '||': 3,
    '&&': 4,
    '|': 5,
    '^': 6,
    '&': 7,
    '==': 8,
    '!=': 8,
    '===': 8,
    '!==': 8,
    '<': 9,
    '>': 9,
    '<=': 9,
    '>=': 9,
    "in": 9,
    "instanceof": 9,
    '<<': 10,
    '>>': 10,
    '>>>': 10,
    '+': 11,
    '-': 11,
    '*': 12,
    '%': 12,
    '/': 12,
    '**': 13
  };
  var NEEDS_PARENTHESES = 17;
  var EXPRESSIONS_PRECEDENCE = {
    ArrayExpression: 20,
    TaggedTemplateExpression: 20,
    ThisExpression: 20,
    Identifier: 20,
    Literal: 18,
    TemplateLiteral: 20,
    Super: 20,
    SequenceExpression: 20,
    MemberExpression: 19,
    CallExpression: 19,
    NewExpression: 19,
    ArrowFunctionExpression: NEEDS_PARENTHESES,
    ClassExpression: NEEDS_PARENTHESES,
    FunctionExpression: NEEDS_PARENTHESES,
    ObjectExpression: NEEDS_PARENTHESES,
    UpdateExpression: 16,
    UnaryExpression: 15,
    BinaryExpression: 14,
    LogicalExpression: 13,
    ConditionalExpression: 4,
    AssignmentExpression: 3,
    AwaitExpression: 2,
    YieldExpression: 2,
    RestElement: 1
  };

  function formatSequence(state, nodes) {
    var generator = state.generator;
    state.write('(');

    if (nodes != null && nodes.length > 0) {
      generator[nodes[0].type](nodes[0], state);
      var length = nodes.length;

      for (var i = 1; i < length; i++) {
        var param = nodes[i];
        state.write(', ');
        generator[param.type](param, state);
      }
    }

    state.write(')');
  }

  function expressionNeedsParenthesis(node, parentNode, isRightHand) {
    var nodePrecedence = EXPRESSIONS_PRECEDENCE[node.type];

    if (nodePrecedence === NEEDS_PARENTHESES) {
      return true;
    }

    var parentNodePrecedence = EXPRESSIONS_PRECEDENCE[parentNode.type];

    if (nodePrecedence !== parentNodePrecedence) {
      return !isRightHand && nodePrecedence === 15 && parentNodePrecedence === 14 && parentNode.operator === '**' || nodePrecedence < parentNodePrecedence;
    }

    if (nodePrecedence !== 13 && nodePrecedence !== 14) {
      return false;
    }

    if (node.operator === '**' && parentNode.operator === '**') {
      return !isRightHand;
    }

    if (isRightHand) {
      return OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parentNode.operator];
    }

    return OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parentNode.operator];
  }

  function formatBinaryExpressionPart(state, node, parentNode, isRightHand) {
    var generator = state.generator;

    if (expressionNeedsParenthesis(node, parentNode, isRightHand)) {
      state.write('(');
      generator[node.type](node, state);
      state.write(')');
    } else {
      generator[node.type](node, state);
    }
  }

  function reindent(state, text, indent, lineEnd) {
    var lines = text.split('\n');
    var end = lines.length - 1;
    state.write(lines[0].trim());

    if (end > 0) {
      state.write(lineEnd);

      for (var i = 1; i < end; i++) {
        state.write(indent + lines[i].trim() + lineEnd);
      }

      state.write(indent + lines[end].trim());
    }
  }

  function formatComments(state, comments, indent, lineEnd) {
    var length = comments.length;

    for (var i = 0; i < length; i++) {
      var comment = comments[i];
      state.write(indent);

      if (comment.type[0] === 'L') {
        state.write('// ' + comment.value.trim() + '\n');
      } else {
        state.write('/*');
        reindent(state, comment.value, indent, lineEnd);
        state.write('*/' + lineEnd);
      }
    }
  }

  function hasCallExpression(node) {
    var currentNode = node;

    while (currentNode != null) {
      var _currentNode = currentNode,
          type = _currentNode.type;

      if (type[0] === 'C' && type[1] === 'a') {
        return true;
      } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {
        currentNode = currentNode.object;
      } else {
        return false;
      }
    }
  }

  function formatVariableDeclaration(state, node) {
    var generator = state.generator;
    var declarations = node.declarations;
    state.write(node.kind + ' ');
    var length = declarations.length;

    if (length > 0) {
      generator.VariableDeclarator(declarations[0], state);

      for (var i = 1; i < length; i++) {
        state.write(', ');
        generator.VariableDeclarator(declarations[i], state);
      }
    }
  }

  var ForInStatement, FunctionDeclaration, RestElement, BinaryExpression, ArrayExpression, BlockStatement;
  var baseGenerator = {
    Program: function Program(node, state) {
      var indent = state.indent.repeat(state.indentLevel);
      var lineEnd = state.lineEnd,
          writeComments = state.writeComments;

      if (writeComments && node.comments != null) {
        formatComments(state, node.comments, indent, lineEnd);
      }

      var statements = node.body;
      var length = statements.length;

      for (var i = 0; i < length; i++) {
        var statement = statements[i];

        if (writeComments && statement.comments != null) {
          formatComments(state, statement.comments, indent, lineEnd);
        }

        state.write(indent);
        this[statement.type](statement, state);
        state.write(lineEnd);
      }

      if (writeComments && node.trailingComments != null) {
        formatComments(state, node.trailingComments, indent, lineEnd);
      }
    },
    BlockStatement: BlockStatement = function BlockStatement(node, state) {
      var indent = state.indent.repeat(state.indentLevel++);
      var lineEnd = state.lineEnd,
          writeComments = state.writeComments;
      var statementIndent = indent + state.indent;
      state.write('{');
      var statements = node.body;

      if (statements != null && statements.length > 0) {
        state.write(lineEnd);

        if (writeComments && node.comments != null) {
          formatComments(state, node.comments, statementIndent, lineEnd);
        }

        var length = statements.length;

        for (var i = 0; i < length; i++) {
          var statement = statements[i];

          if (writeComments && statement.comments != null) {
            formatComments(state, statement.comments, statementIndent, lineEnd);
          }

          state.write(statementIndent);
          this[statement.type](statement, state);
          state.write(lineEnd);
        }

        state.write(indent);
      } else {
        if (writeComments && node.comments != null) {
          state.write(lineEnd);
          formatComments(state, node.comments, statementIndent, lineEnd);
          state.write(indent);
        }
      }

      if (writeComments && node.trailingComments != null) {
        formatComments(state, node.trailingComments, statementIndent, lineEnd);
      }

      state.write('}');
      state.indentLevel--;
    },
    ClassBody: BlockStatement,
    EmptyStatement: function EmptyStatement(node, state) {
      state.write(';');
    },
    ExpressionStatement: function ExpressionStatement(node, state) {
      var precedence = EXPRESSIONS_PRECEDENCE[node.expression.type];

      if (precedence === NEEDS_PARENTHESES || precedence === 3 && node.expression.left.type[0] === 'O') {
        state.write('(');
        this[node.expression.type](node.expression, state);
        state.write(')');
      } else {
        this[node.expression.type](node.expression, state);
      }

      state.write(';');
    },
    IfStatement: function IfStatement(node, state) {
      state.write('if (');
      this[node.test.type](node.test, state);
      state.write(') ');
      this[node.consequent.type](node.consequent, state);

      if (node.alternate != null) {
        state.write(' else ');
        this[node.alternate.type](node.alternate, state);
      }
    },
    LabeledStatement: function LabeledStatement(node, state) {
      this[node.label.type](node.label, state);
      state.write(': ');
      this[node.body.type](node.body, state);
    },
    BreakStatement: function BreakStatement(node, state) {
      state.write('break');

      if (node.label != null) {
        state.write(' ');
        this[node.label.type](node.label, state);
      }

      state.write(';');
    },
    ContinueStatement: function ContinueStatement(node, state) {
      state.write('continue');

      if (node.label != null) {
        state.write(' ');
        this[node.label.type](node.label, state);
      }

      state.write(';');
    },
    WithStatement: function WithStatement(node, state) {
      state.write('with (');
      this[node.object.type](node.object, state);
      state.write(') ');
      this[node.body.type](node.body, state);
    },
    SwitchStatement: function SwitchStatement(node, state) {
      var indent = state.indent.repeat(state.indentLevel++);
      var lineEnd = state.lineEnd,
          writeComments = state.writeComments;
      state.indentLevel++;
      var caseIndent = indent + state.indent;
      var statementIndent = caseIndent + state.indent;
      state.write('switch (');
      this[node.discriminant.type](node.discriminant, state);
      state.write(') {' + lineEnd);
      var occurences = node.cases;
      var occurencesCount = occurences.length;

      for (var i = 0; i < occurencesCount; i++) {
        var occurence = occurences[i];

        if (writeComments && occurence.comments != null) {
          formatComments(state, occurence.comments, caseIndent, lineEnd);
        }

        if (occurence.test) {
          state.write(caseIndent + 'case ');
          this[occurence.test.type](occurence.test, state);
          state.write(':' + lineEnd);
        } else {
          state.write(caseIndent + 'default:' + lineEnd);
        }

        var consequent = occurence.consequent;
        var consequentCount = consequent.length;

        for (var _i = 0; _i < consequentCount; _i++) {
          var statement = consequent[_i];

          if (writeComments && statement.comments != null) {
            formatComments(state, statement.comments, statementIndent, lineEnd);
          }

          state.write(statementIndent);
          this[statement.type](statement, state);
          state.write(lineEnd);
        }
      }

      state.indentLevel -= 2;
      state.write(indent + '}');
    },
    ReturnStatement: function ReturnStatement(node, state) {
      state.write('return');

      if (node.argument) {
        state.write(' ');
        this[node.argument.type](node.argument, state);
      }

      state.write(';');
    },
    ThrowStatement: function ThrowStatement(node, state) {
      state.write('throw ');
      this[node.argument.type](node.argument, state);
      state.write(';');
    },
    TryStatement: function TryStatement(node, state) {
      state.write('try ');
      this[node.block.type](node.block, state);

      if (node.handler) {
        var handler = node.handler;

        if (handler.param == null) {
          state.write(' catch ');
        } else {
          state.write(' catch (');
          this[handler.param.type](handler.param, state);
          state.write(') ');
        }

        this[handler.body.type](handler.body, state);
      }

      if (node.finalizer) {
        state.write(' finally ');
        this[node.finalizer.type](node.finalizer, state);
      }
    },
    WhileStatement: function WhileStatement(node, state) {
      state.write('while (');
      this[node.test.type](node.test, state);
      state.write(') ');
      this[node.body.type](node.body, state);
    },
    DoWhileStatement: function DoWhileStatement(node, state) {
      state.write('do ');
      this[node.body.type](node.body, state);
      state.write(' while (');
      this[node.test.type](node.test, state);
      state.write(');');
    },
    ForStatement: function ForStatement(node, state) {
      state.write('for (');

      if (node.init != null) {
        var init = node.init;

        if (init.type[0] === 'V') {
          formatVariableDeclaration(state, init);
        } else {
          this[init.type](init, state);
        }
      }

      state.write('; ');

      if (node.test) {
        this[node.test.type](node.test, state);
      }

      state.write('; ');

      if (node.update) {
        this[node.update.type](node.update, state);
      }

      state.write(') ');
      this[node.body.type](node.body, state);
    },
    ForInStatement: ForInStatement = function ForInStatement(node, state) {
      state.write("for ".concat(node["await"] ? 'await ' : '', "("));
      var left = node.left;

      if (left.type[0] === 'V') {
        formatVariableDeclaration(state, left);
      } else {
        this[left.type](left, state);
      }

      state.write(node.type[3] === 'I' ? ' in ' : ' of ');
      this[node.right.type](node.right, state);
      state.write(') ');
      this[node.body.type](node.body, state);
    },
    ForOfStatement: ForInStatement,
    DebuggerStatement: function DebuggerStatement(node, state) {
      state.write('debugger;' + state.lineEnd);
    },
    FunctionDeclaration: FunctionDeclaration = function FunctionDeclaration(node, state) {
      state.write((node.async ? 'async ' : '') + (node.generator ? 'function* ' : 'function ') + (node.id ? node.id.name : ''), node);
      formatSequence(state, node.params);
      state.write(' ');
      this[node.body.type](node.body, state);
    },
    FunctionExpression: FunctionDeclaration,
    VariableDeclaration: function VariableDeclaration(node, state) {
      formatVariableDeclaration(state, node);
      state.write(';');
    },
    VariableDeclarator: function VariableDeclarator(node, state) {
      this[node.id.type](node.id, state);

      if (node.init != null) {
        state.write(' = ');
        this[node.init.type](node.init, state);
      }
    },
    ClassDeclaration: function ClassDeclaration(node, state) {
      state.write('class ' + (node.id ? "".concat(node.id.name, " ") : ''), node);

      if (node.superClass) {
        state.write('extends ');
        this[node.superClass.type](node.superClass, state);
        state.write(' ');
      }

      this.ClassBody(node.body, state);
    },
    ImportDeclaration: function ImportDeclaration(node, state) {
      state.write('import ');
      var specifiers = node.specifiers;
      var length = specifiers.length;
      var i = 0;

      if (length > 0) {
        for (; i < length;) {
          if (i > 0) {
            state.write(', ');
          }

          var specifier = specifiers[i];
          var type = specifier.type[6];

          if (type === 'D') {
            state.write(specifier.local.name, specifier);
            i++;
          } else if (type === 'N') {
            state.write('* as ' + specifier.local.name, specifier);
            i++;
          } else {
            break;
          }
        }

        if (i < length) {
          state.write('{');

          for (;;) {
            var _specifier = specifiers[i];
            var name = _specifier.imported.name;
            state.write(name, _specifier);

            if (name !== _specifier.local.name) {
              state.write(' as ' + _specifier.local.name);
            }

            if (++i < length) {
              state.write(', ');
            } else {
              break;
            }
          }

          state.write('}');
        }

        state.write(' from ');
      }

      this.Literal(node.source, state);
      state.write(';');
    },
    ExportDefaultDeclaration: function ExportDefaultDeclaration(node, state) {
      state.write('export default ');
      this[node.declaration.type](node.declaration, state);

      if (EXPRESSIONS_PRECEDENCE[node.declaration.type] && node.declaration.type[0] !== 'F') {
        state.write(';');
      }
    },
    ExportNamedDeclaration: function ExportNamedDeclaration(node, state) {
      state.write('export ');

      if (node.declaration) {
        this[node.declaration.type](node.declaration, state);
      } else {
        state.write('{');
        var specifiers = node.specifiers,
            length = specifiers.length;

        if (length > 0) {
          for (var i = 0;;) {
            var specifier = specifiers[i];
            var name = specifier.local.name;
            state.write(name, specifier);

            if (name !== specifier.exported.name) {
              state.write(' as ' + specifier.exported.name);
            }

            if (++i < length) {
              state.write(', ');
            } else {
              break;
            }
          }
        }

        state.write('}');

        if (node.source) {
          state.write(' from ');
          this.Literal(node.source, state);
        }

        state.write(';');
      }
    },
    ExportAllDeclaration: function ExportAllDeclaration(node, state) {
      state.write('export * from ');
      this.Literal(node.source, state);
      state.write(';');
    },
    MethodDefinition: function MethodDefinition(node, state) {
      if (node["static"]) {
        state.write('static ');
      }

      var kind = node.kind[0];

      if (kind === 'g' || kind === 's') {
        state.write(node.kind + ' ');
      }

      if (node.value.async) {
        state.write('async ');
      }

      if (node.value.generator) {
        state.write('*');
      }

      if (node.computed) {
        state.write('[');
        this[node.key.type](node.key, state);
        state.write(']');
      } else {
        this[node.key.type](node.key, state);
      }

      formatSequence(state, node.value.params);
      state.write(' ');
      this[node.value.body.type](node.value.body, state);
    },
    ClassExpression: function ClassExpression(node, state) {
      this.ClassDeclaration(node, state);
    },
    ArrowFunctionExpression: function ArrowFunctionExpression(node, state) {
      state.write(node.async ? 'async ' : '', node);
      var params = node.params;

      if (params != null) {
        if (params.length === 1 && params[0].type[0] === 'I') {
          state.write(params[0].name, params[0]);
        } else {
          formatSequence(state, node.params);
        }
      }

      state.write(' => ');

      if (node.body.type[0] === 'O') {
        state.write('(');
        this.ObjectExpression(node.body, state);
        state.write(')');
      } else {
        this[node.body.type](node.body, state);
      }
    },
    ThisExpression: function ThisExpression(node, state) {
      state.write('this', node);
    },
    Super: function Super(node, state) {
      state.write('super', node);
    },
    RestElement: RestElement = function RestElement(node, state) {
      state.write('...');
      this[node.argument.type](node.argument, state);
    },
    SpreadElement: RestElement,
    YieldExpression: function YieldExpression(node, state) {
      state.write(node.delegate ? 'yield*' : 'yield');

      if (node.argument) {
        state.write(' ');
        this[node.argument.type](node.argument, state);
      }
    },
    AwaitExpression: function AwaitExpression(node, state) {
      state.write('await ');

      if (node.argument) {
        this[node.argument.type](node.argument, state);
      }
    },
    TemplateLiteral: function TemplateLiteral(node, state) {
      var quasis = node.quasis,
          expressions = node.expressions;
      state.write('`');
      var length = expressions.length;

      for (var i = 0; i < length; i++) {
        var expression = expressions[i];
        this.TemplateElement(quasis[i], state);
        state.write('${');
        this[expression.type](expression, state);
        state.write('}');
      }

      state.write(quasis[quasis.length - 1].value.raw);
      state.write('`');
    },
    TemplateElement: function TemplateElement(node, state) {
      state.write(node.value.raw);
    },
    TaggedTemplateExpression: function TaggedTemplateExpression(node, state) {
      this[node.tag.type](node.tag, state);
      this[node.quasi.type](node.quasi, state);
    },
    ArrayExpression: ArrayExpression = function ArrayExpression(node, state) {
      state.write('[');

      if (node.elements.length > 0) {
        var elements = node.elements,
            length = elements.length;

        for (var i = 0;;) {
          var element = elements[i];

          if (element != null) {
            this[element.type](element, state);
          }

          if (++i < length) {
            state.write(', ');
          } else {
            if (element == null) {
              state.write(', ');
            }

            break;
          }
        }
      }

      state.write(']');
    },
    ArrayPattern: ArrayExpression,
    ObjectExpression: function ObjectExpression(node, state) {
      var indent = state.indent.repeat(state.indentLevel++);
      var lineEnd = state.lineEnd,
          writeComments = state.writeComments;
      var propertyIndent = indent + state.indent;
      state.write('{');

      if (node.properties.length > 0) {
        state.write(lineEnd);

        if (writeComments && node.comments != null) {
          formatComments(state, node.comments, propertyIndent, lineEnd);
        }

        var comma = ',' + lineEnd;
        var properties = node.properties,
            length = properties.length;

        for (var i = 0;;) {
          var property = properties[i];

          if (writeComments && property.comments != null) {
            formatComments(state, property.comments, propertyIndent, lineEnd);
          }

          state.write(propertyIndent);
          this[property.type](property, state);

          if (++i < length) {
            state.write(comma);
          } else {
            break;
          }
        }

        state.write(lineEnd);

        if (writeComments && node.trailingComments != null) {
          formatComments(state, node.trailingComments, propertyIndent, lineEnd);
        }

        state.write(indent + '}');
      } else if (writeComments) {
        if (node.comments != null) {
          state.write(lineEnd);
          formatComments(state, node.comments, propertyIndent, lineEnd);

          if (node.trailingComments != null) {
            formatComments(state, node.trailingComments, propertyIndent, lineEnd);
          }

          state.write(indent + '}');
        } else if (node.trailingComments != null) {
          state.write(lineEnd);
          formatComments(state, node.trailingComments, propertyIndent, lineEnd);
          state.write(indent + '}');
        } else {
          state.write('}');
        }
      } else {
        state.write('}');
      }

      state.indentLevel--;
    },
    Property: function Property(node, state) {
      if (node.method || node.kind[0] !== 'i') {
        this.MethodDefinition(node, state);
      } else {
        if (!node.shorthand) {
          if (node.computed) {
            state.write('[');
            this[node.key.type](node.key, state);
            state.write(']');
          } else {
            this[node.key.type](node.key, state);
          }

          state.write(': ');
        }

        this[node.value.type](node.value, state);
      }
    },
    ObjectPattern: function ObjectPattern(node, state) {
      state.write('{');

      if (node.properties.length > 0) {
        var properties = node.properties,
            length = properties.length;

        for (var i = 0;;) {
          this[properties[i].type](properties[i], state);

          if (++i < length) {
            state.write(', ');
          } else {
            break;
          }
        }
      }

      state.write('}');
    },
    SequenceExpression: function SequenceExpression(node, state) {
      formatSequence(state, node.expressions);
    },
    UnaryExpression: function UnaryExpression(node, state) {
      if (node.prefix) {
        state.write(node.operator);

        if (node.operator.length > 1) {
          state.write(' ');
        }

        if (EXPRESSIONS_PRECEDENCE[node.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
          state.write('(');
          this[node.argument.type](node.argument, state);
          state.write(')');
        } else {
          this[node.argument.type](node.argument, state);
        }
      } else {
        this[node.argument.type](node.argument, state);
        state.write(node.operator);
      }
    },
    UpdateExpression: function UpdateExpression(node, state) {
      if (node.prefix) {
        state.write(node.operator);
        this[node.argument.type](node.argument, state);
      } else {
        this[node.argument.type](node.argument, state);
        state.write(node.operator);
      }
    },
    AssignmentExpression: function AssignmentExpression(node, state) {
      this[node.left.type](node.left, state);
      state.write(' ' + node.operator + ' ');
      this[node.right.type](node.right, state);
    },
    AssignmentPattern: function AssignmentPattern(node, state) {
      this[node.left.type](node.left, state);
      state.write(' = ');
      this[node.right.type](node.right, state);
    },
    BinaryExpression: BinaryExpression = function BinaryExpression(node, state) {
      var isIn = node.operator === 'in';

      if (isIn) {
        state.write('(');
      }

      formatBinaryExpressionPart(state, node.left, node, false);
      state.write(' ' + node.operator + ' ');
      formatBinaryExpressionPart(state, node.right, node, true);

      if (isIn) {
        state.write(')');
      }
    },
    LogicalExpression: BinaryExpression,
    ConditionalExpression: function ConditionalExpression(node, state) {
      if (EXPRESSIONS_PRECEDENCE[node.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
        this[node.test.type](node.test, state);
      } else {
        state.write('(');
        this[node.test.type](node.test, state);
        state.write(')');
      }

      state.write(' ? ');
      this[node.consequent.type](node.consequent, state);
      state.write(' : ');
      this[node.alternate.type](node.alternate, state);
    },
    NewExpression: function NewExpression(node, state) {
      state.write('new ');

      if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || hasCallExpression(node.callee)) {
        state.write('(');
        this[node.callee.type](node.callee, state);
        state.write(')');
      } else {
        this[node.callee.type](node.callee, state);
      }

      formatSequence(state, node['arguments']);
    },
    CallExpression: function CallExpression(node, state) {
      if (EXPRESSIONS_PRECEDENCE[node.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
        state.write('(');
        this[node.callee.type](node.callee, state);
        state.write(')');
      } else {
        this[node.callee.type](node.callee, state);
      }

      formatSequence(state, node['arguments']);
    },
    MemberExpression: function MemberExpression(node, state) {
      if (EXPRESSIONS_PRECEDENCE[node.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
        state.write('(');
        this[node.object.type](node.object, state);
        state.write(')');
      } else {
        this[node.object.type](node.object, state);
      }

      if (node.computed) {
        state.write('[');
        this[node.property.type](node.property, state);
        state.write(']');
      } else {
        state.write('.');
        this[node.property.type](node.property, state);
      }
    },
    MetaProperty: function MetaProperty(node, state) {
      state.write(node.meta.name + '.' + node.property.name, node);
    },
    Identifier: function Identifier(node, state) {
      state.write(node.name, node);
    },
    Literal: function Literal(node, state) {
      if (node.raw != null) {
        state.write(node.raw, node);
      } else if (node.regex != null) {
        this.RegExpLiteral(node, state);
      } else {
        state.write(stringify(node.value), node);
      }
    },
    RegExpLiteral: function RegExpLiteral(node, state) {
      var regex = node.regex;
      state.write("/".concat(regex.pattern, "/").concat(regex.flags), node);
    }
  };
  exports.baseGenerator = baseGenerator;
  var EMPTY_OBJECT = {};

  var State = function () {
    function State(options) {
      _classCallCheck(this, State);

      var setup = options == null ? EMPTY_OBJECT : options;
      this.output = '';

      if (setup.output != null) {
        this.output = setup.output;
        this.write = this.writeToStream;
      } else {
        this.output = '';
      }

      this.generator = setup.generator != null ? setup.generator : baseGenerator;
      this.indent = setup.indent != null ? setup.indent : '  ';
      this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\n';
      this.indentLevel = setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
      this.writeComments = setup.comments ? setup.comments : false;

      if (setup.sourceMap != null) {
        this.write = setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
        this.sourceMap = setup.sourceMap;
        this.line = 1;
        this.column = 0;
        this.lineEndSize = this.lineEnd.split('\n').length - 1;
        this.mapping = {
          original: null,
          generated: this,
          name: undefined,
          source: setup.sourceMap.file || setup.sourceMap._file
        };
      }
    }

    _createClass(State, [{
      key: "write",
      value: function write(code) {
        this.output += code;
      }
    }, {
      key: "writeToStream",
      value: function writeToStream(code) {
        this.output.write(code);
      }
    }, {
      key: "writeAndMap",
      value: function writeAndMap(code, node) {
        this.output += code;
        this.map(code, node);
      }
    }, {
      key: "writeToStreamAndMap",
      value: function writeToStreamAndMap(code, node) {
        this.output.write(code);
        this.map(code, node);
      }
    }, {
      key: "map",
      value: function map(code, node) {
        if (node != null && node.loc != null) {
          var mapping = this.mapping;
          mapping.original = node.loc.start;
          mapping.name = node.name;
          this.sourceMap.addMapping(mapping);
        }

        if (code.length > 0) {
          if (this.lineEndSize > 0) {
            if (code.endsWith(this.lineEnd)) {
              this.line += this.lineEndSize;
              this.column = 0;
            } else if (code[code.length - 1] === '\n') {
              this.line++;
              this.column = 0;
            } else {
              this.column += code.length;
            }
          } else {
            if (code[code.length - 1] === '\n') {
              this.line++;
              this.column = 0;
            } else {
              this.column += code.length;
            }
          }
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.output;
      }
    }]);

    return State;
  }();

  function generate(node, options) {
    var state = new State(options);
    state.generator[node.type](node, state);
    return state.output;
  }


  });

  unwrapExports(astring);
  var astring_1 = astring.generate;
  var astring_2 = astring.baseGenerator;

  var acorn = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
     factory(exports) ;
  }(commonjsGlobal, function (exports) {
    // Reserved word lists for various dialects of the language

    var reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };

    // And the keywords

    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

    var keywords = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };

    var keywordRelationalOperator = /^in(stanceof)?$/;

    // ## Character categories

    // Big ugly regular expressions that match characters in the
    // whitespace, identifier, and identifier-start categories. These
    // are only applied when a character is found to actually have a
    // code point above 128.
    // Generated by `bin/generate-identifier-regex.js`.
    var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
    var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range. They were
    // generated by bin/generate-identifier-regex.js

    // eslint-disable-next-line comma-spacing
    var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

    // eslint-disable-next-line comma-spacing
    var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
      var pos = 0x10000;
      for (var i = 0; i < set.length; i += 2) {
        pos += set[i];
        if (pos > code) { return false }
        pos += set[i + 1];
        if (pos >= code) { return true }
      }
    }

    // Test whether a given character code starts an identifier.

    function isIdentifierStart(code, astral) {
      if (code < 65) { return code === 36 }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes)
    }

    // Test whether a given character is part of an identifier.

    function isIdentifierChar(code, astral) {
      if (code < 48) { return code === 36 }
      if (code < 58) { return true }
      if (code < 65) { return false }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
    }

    // ## Token types

    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.

    // All token type variables start with an underscore, to make them
    // easy to recognize.

    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // The `startsExpr` property is used to check if the token ends a
    // `yield` expression. It is set on all token types that either can
    // directly start an expression (like a quotation mark) or can
    // continue an expression (like the body of a string).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.

    var TokenType = function TokenType(label, conf) {
      if ( conf === void 0 ) conf = {};

      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };

    function binop(name, prec) {
      return new TokenType(name, {beforeExpr: true, binop: prec})
    }
    var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

    // Map keyword names to token types.

    var keywords$1 = {};

    // Succinct definitions of keyword token types
    function kw(name, options) {
      if ( options === void 0 ) options = {};

      options.keyword = name;
      return keywords$1[name] = new TokenType(name, options)
    }

    var types = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      eof: new TokenType("eof"),

      // Punctuation token types.
      bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.

      eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
      assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
      incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
      prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", {beforeExpr: true}),

      // Keyword token types.
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", {isLoop: true, beforeExpr: true}),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", {isLoop: true}),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", {isLoop: true}),
      _with: kw("with"),
      _new: kw("new", {beforeExpr: true, startsExpr: true}),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", {beforeExpr: true, binop: 7}),
      _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
      _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
      _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
      _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
    };

    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.

    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");

    function isNewLine(code, ecma2019String) {
      return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
    }

    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

    var ref = Object.prototype;
    var hasOwnProperty = ref.hasOwnProperty;
    var toString = ref.toString;

    // Checks if an object has a property.

    function has(obj, propName) {
      return hasOwnProperty.call(obj, propName)
    }

    var isArray = Array.isArray || (function (obj) { return (
      toString.call(obj) === "[object Array]"
    ); });

    function wordsRegexp(words) {
      return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
    }

    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.

    var Position = function Position(line, col) {
      this.line = line;
      this.column = col;
    };

    Position.prototype.offset = function offset (n) {
      return new Position(this.line, this.column + n)
    };

    var SourceLocation = function SourceLocation(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) { this.source = p.sourceFile; }
    };

    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.

    function getLineInfo(input, offset) {
      for (var line = 1, cur = 0;;) {
        lineBreakG.lastIndex = cur;
        var match = lineBreakG.exec(input);
        if (match && match.index < offset) {
          ++line;
          cur = match.index + match[0].length;
        } else {
          return new Position(line, offset - cur)
        }
      }
    }

    // A second optional argument can be given to further configure
    // the parser process. These options are recognized:

    var defaultOptions = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must be
      // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
      // (2019). This influences support for strict mode, the set of
      // reserved words, and support for new syntax features. The default
      // is 10.
      ecmaVersion: 10,
      // `sourceType` indicates the mode the code should be parsed in.
      // Can be either `"script"` or `"module"`. This influences global
      // strict mode and parsing of `import` and `export` declarations.
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called
      // when a semicolon is automatically inserted. It will be passed
      // the position of the comma as an offset, and if `locations` is
      // enabled, it is given the location as a `{line, column}` object
      // as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are only enforced if ecmaVersion >= 5.
      // Set `allowReserved` to a boolean value to explicitly turn this on
      // an off. When this option has the value "never", reserved words
      // and keywords can also not be used as property names.
      allowReserved: null,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program.
      allowImportExportEverywhere: false,
      // When enabled, await identifiers are allowed to appear at the top-level scope,
      // but they are still not allowed in non-async functions.
      allowAwaitOutsideFunction: false,
      // When enabled, hashbang directive in the beginning of file
      // is allowed and treated as a line comment.
      allowHashBang: false,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokens returned from `tokenizer().getToken()`. Note
      // that you are not allowed to call the parser from the
      // callbackâ€”that will corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callbackâ€”that will corrupt its internal state.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false
    };

    // Interpret and default an options object

    function getOptions(opts) {
      var options = {};

      for (var opt in defaultOptions)
        { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

      if (options.ecmaVersion >= 2015)
        { options.ecmaVersion -= 2009; }

      if (options.allowReserved == null)
        { options.allowReserved = options.ecmaVersion < 5; }

      if (isArray(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function (token) { return tokens.push(token); };
      }
      if (isArray(options.onComment))
        { options.onComment = pushComment(options, options.onComment); }

      return options
    }

    function pushComment(options, array) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start: start,
          end: end
        };
        if (options.locations)
          { comment.loc = new SourceLocation(this, startLoc, endLoc); }
        if (options.ranges)
          { comment.range = [start, end]; }
        array.push(comment);
      }
    }

    // Each scope gets a bitset that may contain these flags
    var
        SCOPE_TOP = 1,
        SCOPE_FUNCTION = 2,
        SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
        SCOPE_ASYNC = 4,
        SCOPE_GENERATOR = 8,
        SCOPE_ARROW = 16,
        SCOPE_SIMPLE_CATCH = 32,
        SCOPE_SUPER = 64,
        SCOPE_DIRECT_SUPER = 128;

    function functionFlags(async, generator) {
      return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
    }

    // Used in checkLVal and declareName to determine the type of a binding
    var
        BIND_NONE = 0, // Not a binding
        BIND_VAR = 1, // Var-style binding
        BIND_LEXICAL = 2, // Let- or const-style binding
        BIND_FUNCTION = 3, // Function declaration
        BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
        BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

    var Parser = function Parser(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        for (var v = options.ecmaVersion;; v--)
          { if (reserved = reservedWords[v]) { break } }
        if (options.sourceType === "module") { reserved += " await"; }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);

      // Used to signal to callers of `readWord1` whether the word
      // contained any escape sequences. This is needed because words with
      // escape sequences must not be interpreted as keywords.
      this.containsEsc = false;

      // Set up token state

      // The current position of the tokenizer in the input.
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }

      // Properties of the current token:
      // Its type
      this.type = types.eof;
      // For tokens that include more information than their type, the value
      this.value = null;
      // Its start and end offset
      this.start = this.end = this.pos;
      // And, if locations are used, the {line, column} object
      // corresponding to those offsets
      this.startLoc = this.endLoc = this.curPosition();

      // Position information for the previous token
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;

      // The context stack is used to superficially track syntactic
      // context to predict whether a regular expression is allowed in a
      // given position.
      this.context = this.initialContext();
      this.exprAllowed = true;

      // Figure out if it's a module code.
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);

      // Used to signify the start of a potential arrow function
      this.potentialArrowAt = -1;

      // Positions to delayed-check that yield/await does not exist in default parameters.
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      // Labels in scope.
      this.labels = [];
      // Thus-far undefined exports.
      this.undefinedExports = {};

      // If enabled, skip leading hashbang line.
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
        { this.skipLineComment(2); }

      // Scope tracking for duplicate variable names (see scope.js)
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);

      // For RegExp validation
      this.regexpState = null;
    };

    var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

    Parser.prototype.parse = function parse () {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node)
    };

    prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
    prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
    prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
    prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
    prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
    prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

    // Switch to a getter for 7.0.0.
    Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

    Parser.extend = function extend () {
        var plugins = [], len = arguments.length;
        while ( len-- ) plugins[ len ] = arguments[ len ];

      var cls = this;
      for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
      return cls
    };

    Parser.parse = function parse (input, options) {
      return new this(options, input).parse()
    };

    Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression()
    };

    Parser.tokenizer = function tokenizer (input, options) {
      return new this(options, input)
    };

    Object.defineProperties( Parser.prototype, prototypeAccessors );

    var pp = Parser.prototype;

    // ## Parser utilities

    var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
    pp.strictDirective = function(start) {
      for (;;) {
        // Try to find string literal.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) { return false }
        if ((match[1] || match[2]) === "use strict") { return true }
        start += match[0].length;

        // Skip semicolon, if any.
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";")
          { start++; }
      }
    };

    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.

    pp.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true
      } else {
        return false
      }
    };

    // Tests whether parsed token is a contextual keyword.

    pp.isContextual = function(name) {
      return this.type === types.name && this.value === name && !this.containsEsc
    };

    // Consumes contextual keyword if possible.

    pp.eatContextual = function(name) {
      if (!this.isContextual(name)) { return false }
      this.next();
      return true
    };

    // Asserts that following token is given contextual keyword.

    pp.expectContextual = function(name) {
      if (!this.eatContextual(name)) { this.unexpected(); }
    };

    // Test whether a semicolon can be inserted at the current position.

    pp.canInsertSemicolon = function() {
      return this.type === types.eof ||
        this.type === types.braceR ||
        lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };

    pp.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon)
          { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
        return true
      }
    };

    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.

    pp.semicolon = function() {
      if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
    };

    pp.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma)
          { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
        if (!notNext)
          { this.next(); }
        return true
      }
    };

    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.

    pp.expect = function(type) {
      this.eat(type) || this.unexpected();
    };

    // Raise an unexpected token error.

    pp.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };

    function DestructuringErrors() {
      this.shorthandAssign =
      this.trailingComma =
      this.parenthesizedAssign =
      this.parenthesizedBind =
      this.doubleProto =
        -1;
    }

    pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) { return }
      if (refDestructuringErrors.trailingComma > -1)
        { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
    };

    pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) { return false }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
      if (shorthandAssign >= 0)
        { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
      if (doubleProto >= 0)
        { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
    };

    pp.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
        { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
      if (this.awaitPos)
        { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
    };

    pp.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression")
        { return this.isSimpleAssignTarget(expr.expression) }
      return expr.type === "Identifier" || expr.type === "MemberExpression"
    };

    var pp$1 = Parser.prototype;

    // ### Statement parsing

    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.

    pp$1.parseTopLevel = function(node) {
      var exports = {};
      if (!node.body) { node.body = []; }
      while (this.type !== types.eof) {
        var stmt = this.parseStatement(null, true, exports);
        node.body.push(stmt);
      }
      if (this.inModule)
        { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
          {
            var name = list[i];

            this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
          } }
      this.adaptDirectivePrologue(node.body);
      this.next();
      node.sourceType = this.options.sourceType;
      return this.finishNode(node, "Program")
    };

    var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

    pp$1.isLet = function(context) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      // For ambiguous cases, determine if a LexicalDeclaration (or only a
      // Statement) is allowed here. If context is not empty then only a Statement
      // is allowed. However, `let [` is an explicit negative lookahead for
      // ExpressionStatement, so special-case it first.
      if (nextCh === 91) { return true } // '['
      if (context) { return false }

      if (nextCh === 123) { return true } // '{'
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) { return true }
      }
      return false
    };

    // check 'async [no LineTerminator here] function'
    // - 'async /*foo*/ function' is OK.
    // - 'async /*\n*/ function' is invalid.
    pp$1.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
        { return false }

      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length;
      return !lineBreak.test(this.input.slice(this.pos, next)) &&
        this.input.slice(next, next + 8) === "function" &&
        (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
    };

    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.

    pp$1.parseStatement = function(context, topLevel, exports) {
      var starttype = this.type, node = this.startNode(), kind;

      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }

      // Most types of statements are recognized by the keyword they
      // start with. Many are trivial to parse, some require a bit of
      // complexity.

      switch (starttype) {
      case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
      case types._debugger: return this.parseDebuggerStatement(node)
      case types._do: return this.parseDoStatement(node)
      case types._for: return this.parseForStatement(node)
      case types._function:
        // Function as sole body of either an if statement or a labeled statement
        // works, but not when it is part of a labeled statement that is the sole
        // body of an if statement.
        if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
        return this.parseFunctionStatement(node, false, !context)
      case types._class:
        if (context) { this.unexpected(); }
        return this.parseClass(node, true)
      case types._if: return this.parseIfStatement(node)
      case types._return: return this.parseReturnStatement(node)
      case types._switch: return this.parseSwitchStatement(node)
      case types._throw: return this.parseThrowStatement(node)
      case types._try: return this.parseTryStatement(node)
      case types._const: case types._var:
        kind = kind || this.value;
        if (context && kind !== "var") { this.unexpected(); }
        return this.parseVarStatement(node, kind)
      case types._while: return this.parseWhileStatement(node)
      case types._with: return this.parseWithStatement(node)
      case types.braceL: return this.parseBlock(true, node)
      case types.semi: return this.parseEmptyStatement(node)
      case types._export:
      case types._import:
        if (this.options.ecmaVersion > 10 && starttype === types._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 40) // '('
            { return this.parseExpressionStatement(node, this.parseExpression()) }
        }

        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel)
            { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
          if (!this.inModule)
            { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
        }
        return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
      default:
        if (this.isAsyncFunction()) {
          if (context) { this.unexpected(); }
          this.next();
          return this.parseFunctionStatement(node, true, !context)
        }

        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
          { return this.parseLabeledStatement(node, maybeName, expr, context) }
        else { return this.parseExpressionStatement(node, expr) }
      }
    };

    pp$1.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
      else if (this.type !== types.name) { this.unexpected(); }
      else {
        node.label = this.parseIdent();
        this.semicolon();
      }

      // Verify that there is an actual destination to break or
      // continue to.
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
          if (node.label && isBreak) { break }
        }
      }
      if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
    };

    pp$1.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement")
    };

    pp$1.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6)
        { this.eat(types.semi); }
      else
        { this.semicolon(); }
      return this.finishNode(node, "DoWhileStatement")
    };

    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.

    pp$1.parseForStatement = function(node) {
      this.next();
      var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types.parenL);
      if (this.type === types.semi) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, null)
      }
      var isLet = this.isLet();
      if (this.type === types._var || this.type === types._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
              if (awaitAt > -1) { this.unexpected(awaitAt); }
            } else { node.await = awaitAt > -1; }
          }
          return this.parseForIn(node, init$1)
        }
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, init$1)
      }
      var refDestructuringErrors = new DestructuringErrors;
      var init = this.parseExpression(true, refDestructuringErrors);
      if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLVal(init);
        return this.parseForIn(node, init)
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init)
    };

    pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
    };

    pp$1.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      // allow function declarations in branches, but only in non-strict mode
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement")
    };

    pp$1.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction)
        { this.raise(this.start, "'return' outside of function"); }
      this.next();

      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.

      if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
      else { node.argument = this.parseExpression(); this.semicolon(); }
      return this.finishNode(node, "ReturnStatement")
    };

    pp$1.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);

      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.

      var cur;
      for (var sawDefault = false; this.type !== types.braceR;) {
        if (this.type === types._case || this.type === types._default) {
          var isCase = this.type === types._case;
          if (cur) { this.finishNode(cur, "SwitchCase"); }
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types.colon);
        } else {
          if (!cur) { this.unexpected(); }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      this.next(); // Closing brace
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement")
    };

    pp$1.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
        { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement")
    };

    // Reused empty array added for node fields that are always empty.

    var empty = [];

    pp$1.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types.parenL)) {
          clause.param = this.parseBindingAtom();
          var simple = clause.param.type === "Identifier";
          this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
          this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
          this.expect(types.parenR);
        } else {
          if (this.options.ecmaVersion < 10) { this.unexpected(); }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer)
        { this.raise(node.start, "Missing catch or finally clause"); }
      return this.finishNode(node, "TryStatement")
    };

    pp$1.parseVarStatement = function(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration")
    };

    pp$1.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node, "WhileStatement")
    };

    pp$1.parseWithStatement = function(node) {
      if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement("with");
      return this.finishNode(node, "WithStatement")
    };

    pp$1.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement")
    };

    pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
        {
        var label = list[i$1];

        if (label.name === maybeName)
          { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      } }
      var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this.labels[i];
        if (label$1.statementStart === node.start) {
          // Update information about previous labels on this node
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else { break }
      }
      this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement")
    };

    pp$1.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement")
    };

    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).

    pp$1.parseBlock = function(createNewLexicalScope, node) {
      if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
      if ( node === void 0 ) node = this.startNode();

      node.body = [];
      this.expect(types.braceL);
      if (createNewLexicalScope) { this.enterScope(0); }
      while (!this.eat(types.braceR)) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      if (createNewLexicalScope) { this.exitScope(); }
      return this.finishNode(node, "BlockStatement")
    };

    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.

    pp$1.parseFor = function(node, init) {
      node.init = init;
      this.expect(types.semi);
      node.test = this.type === types.semi ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.type === types.parenR ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, "ForStatement")
    };

    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.

    pp$1.parseForIn = function(node, init) {
      var isForIn = this.type === types._in;
      this.next();

      if (
        init.type === "VariableDeclaration" &&
        init.declarations[0].init != null &&
        (
          !isForIn ||
          this.options.ecmaVersion < 8 ||
          this.strict ||
          init.kind !== "var" ||
          init.declarations[0].id.type !== "Identifier"
        )
      ) {
        this.raise(
          init.start,
          ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
        );
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, "Invalid left-hand side in for-loop");
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
    };

    // Parse a list of variable declarations.

    pp$1.parseVar = function(node, isFor, kind) {
      node.declarations = [];
      node.kind = kind;
      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) { break }
      }
      return node
    };

    pp$1.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };

    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

    // Parse a function declaration or literal (depending on the
    // `statement & FUNC_STATEMENT`).

    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
    pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
          { this.unexpected(); }
        node.generator = this.eat(types.star);
      }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }

      if (statement & FUNC_STATEMENT) {
        node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT))
          // If it is a regular function declaration in sloppy mode, then it is
          // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
          // mode depends on properties of the current scope (see
          // treatFunctionsAsVar).
          { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
      }

      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node.async, node.generator));

      if (!(statement & FUNC_STATEMENT))
        { node.id = this.type === types.name ? this.parseIdent() : null; }

      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody, false);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
    };

    pp$1.parseFunctionParams = function(node) {
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };

    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).

    pp$1.parseClass = function(node, isStatement) {
      this.next();

      // ecma-262 14.6 Class Definitions
      // A class definition is always strict mode code.
      var oldStrict = this.strict;
      this.strict = true;

      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
            hadConstructor = true;
          }
        }
      }
      node.body = this.finishNode(classBody, "ClassBody");
      this.strict = oldStrict;
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
    };

    pp$1.parseClassElement = function(constructorAllowsSuper) {
      var this$1 = this;

      if (this.eat(types.semi)) { return null }

      var method = this.startNode();
      var tryContextual = function (k, noLineBreak) {
        if ( noLineBreak === void 0 ) noLineBreak = false;

        var start = this$1.start, startLoc = this$1.startLoc;
        if (!this$1.eatContextual(k)) { return false }
        if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
        if (method.key) { this$1.unexpected(); }
        method.computed = false;
        method.key = this$1.startNodeAt(start, startLoc);
        method.key.name = k;
        this$1.finishNode(method.key, "Identifier");
        return false
      };

      method.kind = "method";
      method.static = tryContextual("static");
      var isGenerator = this.eat(types.star);
      var isAsync = false;
      if (!isGenerator) {
        if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        } else if (tryContextual("get")) {
          method.kind = "get";
        } else if (tryContextual("set")) {
          method.kind = "set";
        }
      }
      if (!method.key) { this.parsePropertyName(method); }
      var key = method.key;
      var allowsDirectSuper = false;
      if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
          key.type === "Literal" && key.value === "constructor")) {
        if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
        if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
        if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
        method.kind = "constructor";
        allowsDirectSuper = constructorAllowsSuper;
      } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && method.value.params.length !== 0)
        { this.raiseRecoverable(method.value.start, "getter should have no params"); }
      if (method.kind === "set" && method.value.params.length !== 1)
        { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
      if (method.kind === "set" && method.value.params[0].type === "RestElement")
        { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
      return method
    };

    pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      return this.finishNode(method, "MethodDefinition")
    };

    pp$1.parseClassId = function(node, isStatement) {
      if (this.type === types.name) {
        node.id = this.parseIdent();
        if (isStatement)
          { this.checkLVal(node.id, BIND_LEXICAL, false); }
      } else {
        if (isStatement === true)
          { this.unexpected(); }
        node.id = null;
      }
    };

    pp$1.parseClassSuper = function(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    };

    // Parses module export declaration.

    pp$1.parseExport = function(node, exports) {
      this.next();
      // export * from '...'
      if (this.eat(types.star)) {
        this.expectContextual("from");
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration")
      }
      if (this.eat(types._default)) { // export default ...
        this.checkExport(exports, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) { this.next(); }
          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types._class) {
          var cNode = this.startNode();
          node.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration")
      }
      // export var|const|let|function|class ...
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(null);
        if (node.declaration.type === "VariableDeclaration")
          { this.checkVariableExport(exports, node.declaration.declarations); }
        else
          { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
        node.specifiers = [];
        node.source = null;
      } else { // export { x, y as z } [from '...']
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
          if (this.type !== types.string) { this.unexpected(); }
          node.source = this.parseExprAtom();
        } else {
          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
            // check for keywords used as local names
            var spec = list[i];

            this.checkUnreserved(spec.local);
            // check if export is defined
            this.checkLocalExport(spec.local);
          }

          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration")
    };

    pp$1.checkExport = function(exports, name, pos) {
      if (!exports) { return }
      if (has(exports, name))
        { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
      exports[name] = true;
    };

    pp$1.checkPatternExport = function(exports, pat) {
      var type = pat.type;
      if (type === "Identifier")
        { this.checkExport(exports, pat.name, pat.start); }
      else if (type === "ObjectPattern")
        { for (var i = 0, list = pat.properties; i < list.length; i += 1)
          {
            var prop = list[i];

            this.checkPatternExport(exports, prop);
          } }
      else if (type === "ArrayPattern")
        { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];

            if (elt) { this.checkPatternExport(exports, elt); }
        } }
      else if (type === "Property")
        { this.checkPatternExport(exports, pat.value); }
      else if (type === "AssignmentPattern")
        { this.checkPatternExport(exports, pat.left); }
      else if (type === "RestElement")
        { this.checkPatternExport(exports, pat.argument); }
      else if (type === "ParenthesizedExpression")
        { this.checkPatternExport(exports, pat.expression); }
    };

    pp$1.checkVariableExport = function(exports, decls) {
      if (!exports) { return }
      for (var i = 0, list = decls; i < list.length; i += 1)
        {
        var decl = list[i];

        this.checkPatternExport(exports, decl.id);
      }
    };

    pp$1.shouldParseExportStatement = function() {
      return this.type.keyword === "var" ||
        this.type.keyword === "const" ||
        this.type.keyword === "class" ||
        this.type.keyword === "function" ||
        this.isLet() ||
        this.isAsyncFunction()
    };

    // Parses a comma-separated list of module exports.

    pp$1.parseExportSpecifiers = function(exports) {
      var nodes = [], first = true;
      // export { x, y as z } [from '...']
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }

        var node = this.startNode();
        node.local = this.parseIdent(true);
        node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
        this.checkExport(exports, node.exported.name, node.exported.start);
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes
    };

    // Parses import declaration.

    pp$1.parseImport = function(node) {
      this.next();
      // import '...'
      if (this.type === types.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration")
    };

    // Parses a comma-separated list of module imports.

    pp$1.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types.name) {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(types.comma)) { return nodes }
      }
      if (this.type === types.star) {
        var node$1 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$1.local = this.parseIdent();
        this.checkLVal(node$1.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
        return nodes
      }
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }

        var node$2 = this.startNode();
        node$2.imported = this.parseIdent(true);
        if (this.eatContextual("as")) {
          node$2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this.checkLVal(node$2.local, BIND_LEXICAL);
        nodes.push(this.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes
    };

    // Set `ExpressionStatement#directive` property for directive prologues.
    pp$1.adaptDirectivePrologue = function(statements) {
      for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
        statements[i].directive = statements[i].expression.raw.slice(1, -1);
      }
    };
    pp$1.isDirectiveCandidate = function(statement) {
      return (
        statement.type === "ExpressionStatement" &&
        statement.expression.type === "Literal" &&
        typeof statement.expression.value === "string" &&
        // Reject parenthesized strings.
        (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
      )
    };

    var pp$2 = Parser.prototype;

    // Convert existing expression atom to assignable pattern
    // if possible.

    pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
        case "Identifier":
          if (this.inAsync && node.name === "await")
            { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
          break

        case "ObjectPattern":
        case "ArrayPattern":
        case "RestElement":
          break

        case "ObjectExpression":
          node.type = "ObjectPattern";
          if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          for (var i = 0, list = node.properties; i < list.length; i += 1) {
            var prop = list[i];

          this.toAssignable(prop, isBinding);
            // Early error:
            //   AssignmentRestProperty[Yield, Await] :
            //     `...` DestructuringAssignmentTarget[Yield, Await]
            //
            //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
            if (
              prop.type === "RestElement" &&
              (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
            ) {
              this.raise(prop.argument.start, "Unexpected token");
            }
          }
          break

        case "Property":
          // AssignmentProperty has type === "Property"
          if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
          this.toAssignable(node.value, isBinding);
          break

        case "ArrayExpression":
          node.type = "ArrayPattern";
          if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          this.toAssignableList(node.elements, isBinding);
          break

        case "SpreadElement":
          node.type = "RestElement";
          this.toAssignable(node.argument, isBinding);
          if (node.argument.type === "AssignmentPattern")
            { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
          break

        case "AssignmentExpression":
          if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isBinding);
          // falls through to AssignmentPattern

        case "AssignmentPattern":
          break

        case "ParenthesizedExpression":
          this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          break

        case "MemberExpression":
          if (!isBinding) { break }

        default:
          this.raise(node.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      return node
    };

    // Convert list of expression atoms to binding list.

    pp$2.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) { this.toAssignable(elt, isBinding); }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
          { this.unexpected(last.argument.start); }
      }
      return exprList
    };

    // Parses spread element.

    pp$2.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement")
    };

    pp$2.parseRestBinding = function() {
      var node = this.startNode();
      this.next();

      // RestElement inside of a function parameter must be an identifier
      if (this.options.ecmaVersion === 6 && this.type !== types.name)
        { this.unexpected(); }

      node.argument = this.parseBindingAtom();

      return this.finishNode(node, "RestElement")
    };

    // Parses lvalue (assignable) atom.

    pp$2.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
        case types.bracketL:
          var node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types.bracketR, true, true);
          return this.finishNode(node, "ArrayPattern")

        case types.braceL:
          return this.parseObj(true)
        }
      }
      return this.parseIdent()
    };

    pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) { first = false; }
        else { this.expect(types.comma); }
        if (allowEmpty && this.type === types.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break
        } else if (this.type === types.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          this.expect(close);
          break
        } else {
          var elem = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts
    };

    pp$2.parseBindingListItem = function(param) {
      return param
    };

    // Parses assignment pattern around given atom if possible.

    pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern")
    };

    // Verify that a node is an lval â€” something that can be assigned
    // to.
    // bindingType can be either:
    // 'var' indicating that the lval creates a 'var' binding
    // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
    // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

    pp$2.checkLVal = function(expr, bindingType, checkClashes) {
      if ( bindingType === void 0 ) bindingType = BIND_NONE;

      switch (expr.type) {
      case "Identifier":
        if (bindingType === BIND_LEXICAL && expr.name === "let")
          { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
        if (this.strict && this.reservedWordsStrictBind.test(expr.name))
          { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
        if (checkClashes) {
          if (has(checkClashes, expr.name))
            { this.raiseRecoverable(expr.start, "Argument name clash"); }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
        break

      case "MemberExpression":
        if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
        break

      case "ObjectPattern":
        for (var i = 0, list = expr.properties; i < list.length; i += 1)
          {
        var prop = list[i];

        this.checkLVal(prop, bindingType, checkClashes);
      }
        break

      case "Property":
        // AssignmentProperty has type === "Property"
        this.checkLVal(expr.value, bindingType, checkClashes);
        break

      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];

        if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
        }
        break

      case "AssignmentPattern":
        this.checkLVal(expr.left, bindingType, checkClashes);
        break

      case "RestElement":
        this.checkLVal(expr.argument, bindingType, checkClashes);
        break

      case "ParenthesizedExpression":
        this.checkLVal(expr.expression, bindingType, checkClashes);
        break

      default:
        this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
      }
    };

    // A recursive descent parser operates by defining functions for all

    var pp$3 = Parser.prototype;

    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash â€”
    // either with each other or with an init property â€” and in
    // strict mode, init properties are also not allowed to be repeated.

    pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
        { return }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
        { return }
      var key = prop.key;
      var name;
      switch (key.type) {
      case "Identifier": name = key.name; break
      case "Literal": name = String(key.value); break
      default: return
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
            // Backwards-compat kludge. Can be removed in version 6.0
            else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
          }
          propHash.proto = true;
        }
        return
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition)
          { this.raiseRecoverable(key.start, "Redefinition of property"); }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };

    // ### Expression parsing

    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.

    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).

    pp$3.parseExpression = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
      if (this.type === types.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
        return this.finishNode(node, "SequenceExpression")
      }
      return expr
    };

    // Parse an assignment expression. This includes applications of
    // operators like `+=`.

    pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) { return this.parseYield(noIn) }
        // The tokenizer will assume an expression is allowed after
        // `yield`, but this isn't that kind of yield
        else { this.exprAllowed = false; }
      }

      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldShorthandAssign = refDestructuringErrors.shorthandAssign;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors;
        ownDestructuringErrors = true;
      }

      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types.parenL || this.type === types.name)
        { this.potentialArrowAt = this.start; }
      var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
      if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
        if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
        refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression")
      } else {
        if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
      }
      if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
      if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
      if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
      return left
    };

    // Parse a ternary conditional (`?:`) operator.

    pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(noIn, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression")
      }
      return expr
    };

    // Start the precedence parser.

    pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
    };

    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.

    pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.type.binop;
      if (prec != null && (!noIn || this.type !== types._in)) {
        if (prec > minPrec) {
          var logical = this.type === types.logicalOR || this.type === types.logicalAND;
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
        }
      }
      return left
    };

    pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
    };

    // Parse unary operators, both prefix and postfix.

    pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
        expr = this.parseAwait();
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) { this.checkLVal(node.argument); }
        else if (this.strict && node.operator === "delete" &&
                 node.argument.type === "Identifier")
          { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
        else { sawUnary = true; }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.operator = this.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this.checkLVal(expr);
          this.next();
          expr = this.finishNode(node$1, "UpdateExpression");
        }
      }

      if (!sawUnary && this.eat(types.starstar))
        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
      else
        { return expr }
    };

    // Parse call, dot, and `[]`-subscript expressions.

    pp$3.parseExprSubscripts = function(refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors);
      var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
      if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
      var result = this.parseSubscripts(expr, startPos, startLoc);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
        if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
      }
      return result
    };

    pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
          this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
      while (true) {
        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
        if (element === base || element.type === "ArrowFunctionExpression") { return element }
        base = element;
      }
    };

    pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
      var computed = this.eat(types.bracketL);
      if (computed || this.eat(types.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
        node.computed = !!computed;
        if (computed) { this.expect(types.bracketR); }
        base = this.finishNode(node, "MemberExpression");
      } else if (!noCalls && this.eat(types.parenL)) {
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0)
            { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base;
        node$1.arguments = exprList;
        base = this.finishNode(node$1, "CallExpression");
      } else if (this.type === types.backQuote) {
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base;
        node$2.quasi = this.parseTemplate({isTagged: true});
        base = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base
    };

    // Parse an atomic expression â€” either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.

    pp$3.parseExprAtom = function(refDestructuringErrors) {
      // If a division operator appears in an expression position, the
      // tokenizer got confused, and we force it to read a regexp instead.
      if (this.type === types.slash) { this.readRegexp(); }

      var node, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
      case types._super:
        if (!this.allowSuper)
          { this.raise(this.start, "'super' keyword outside a method"); }
        node = this.startNode();
        this.next();
        if (this.type === types.parenL && !this.allowDirectSuper)
          { this.raise(node.start, "super() call outside constructor of a subclass"); }
        // The `super` keyword can appear at below:
        // SuperProperty:
        //     super [ Expression ]
        //     super . IdentifierName
        // SuperCall:
        //     super ( Arguments )
        if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
          { this.unexpected(); }
        return this.finishNode(node, "Super")

      case types._this:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression")

      case types.name:
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var id = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
          { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types.arrow))
            { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
          if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
            id = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types.arrow))
              { this.unexpected(); }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
          }
        }
        return id

      case types.regexp:
        var value = this.value;
        node = this.parseLiteral(value.value);
        node.regex = {pattern: value.pattern, flags: value.flags};
        return node

      case types.num: case types.string:
        return this.parseLiteral(this.value)

      case types._null: case types._true: case types._false:
        node = this.startNode();
        node.value = this.type === types._null ? null : this.type === types._true;
        node.raw = this.type.keyword;
        this.next();
        return this.finishNode(node, "Literal")

      case types.parenL:
        var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
            { refDestructuringErrors.parenthesizedAssign = start; }
          if (refDestructuringErrors.parenthesizedBind < 0)
            { refDestructuringErrors.parenthesizedBind = start; }
        }
        return expr

      case types.bracketL:
        node = this.startNode();
        this.next();
        node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node, "ArrayExpression")

      case types.braceL:
        return this.parseObj(false, refDestructuringErrors)

      case types._function:
        node = this.startNode();
        this.next();
        return this.parseFunction(node, 0)

      case types._class:
        return this.parseClass(this.startNode(), false)

      case types._new:
        return this.parseNew()

      case types.backQuote:
        return this.parseTemplate()

      case types._import:
        if (this.options.ecmaVersion >= 11) {
          return this.parseExprImport()
        } else {
          return this.unexpected()
        }

      default:
        this.unexpected();
      }
    };

    pp$3.parseExprImport = function() {
      var node = this.startNode();
      this.next(); // skip `import`
      switch (this.type) {
      case types.parenL:
        return this.parseDynamicImport(node)
      default:
        this.unexpected();
      }
    };

    pp$3.parseDynamicImport = function(node) {
      this.next(); // skip `(`

      // Parse node.source.
      node.source = this.parseMaybeAssign();

      // Verify ending.
      if (!this.eat(types.parenR)) {
        var errorPos = this.start;
        if (this.eat(types.comma) && this.eat(types.parenR)) {
          this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
        } else {
          this.unexpected(errorPos);
        }
      }

      return this.finishNode(node, "ImportExpression")
    };

    pp$3.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
      this.next();
      return this.finishNode(node, "Literal")
    };

    pp$3.parseParenExpression = function() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val
    };

    pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();

        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        // Do not save awaitIdentPos to allow checking awaits nested in parameters
        while (this.type !== types.parenR) {
          first ? first = false : this.expect(types.comma);
          if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
            lastIsComma = true;
            break
          } else if (this.type === types.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
            break
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.start, innerEndLoc = this.startLoc;
        this.expect(types.parenR);

        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList)
        }

        if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
        if (spreadStart) { this.unexpected(spreadStart); }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;

        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }

      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression")
      } else {
        return val
      }
    };

    pp$3.parseParenItem = function(item) {
      return item
    };

    pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
    };

    // New's precedence is slightly tricky. It must allow its argument to
    // be a `[]` or dot subscript expression, but not a call â€” at least,
    // not without wrapping it in parentheses. Thus, it uses the noCalls
    // argument to parseSubscripts to prevent it from consuming the
    // argument list.

    var empty$1 = [];

    pp$3.parseNew = function() {
      var node = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
        node.meta = meta;
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target" || containsEsc)
          { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
        if (!this.inNonArrowFunction())
          { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
        return this.finishNode(node, "MetaProperty")
      }
      var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
      node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      if (isImport && node.callee.type === "ImportExpression") {
        this.raise(startPos, "Cannot use new with import()");
      }
      if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
      else { node.arguments = empty$1; }
      return this.finishNode(node, "NewExpression")
    };

    // Parse template expression.

    pp$3.parseTemplateElement = function(ref) {
      var isTagged = ref.isTagged;

      var elem = this.startNode();
      if (this.type === types.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types.backQuote;
      return this.finishNode(elem, "TemplateElement")
    };

    pp$3.parseTemplate = function(ref) {
      if ( ref === void 0 ) ref = {};
      var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({isTagged: isTagged});
      node.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral")
    };

    pp$3.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
        (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
        !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };

    // Parse an object literal or binding pattern.

    pp$3.parseObj = function(isPattern, refDestructuringErrors) {
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types.braceR)) {
        if (!first) {
          this.expect(types.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }

        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
        node.properties.push(prop);
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
    };

    pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement")
        }
        // To disallow parenthesized identifier via `this.toAssignable()`.
        if (this.type === types.parenL && refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0) {
            refDestructuringErrors.parenthesizedAssign = this.start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = this.start;
          }
        }
        // Parse argument.
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        // To disallow trailing comma via `this.toAssignable()`.
        if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        // Finish
        return this.finishNode(prop, "SpreadElement")
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern)
          { isGenerator = this.eat(types.star); }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
        this.parsePropertyName(prop, refDestructuringErrors);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property")
    };

    pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types.colon)
        { this.unexpected(); }

      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
        if (isPattern) { this.unexpected(); }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (!isPattern && !containsEsc &&
                 this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set") &&
                 (this.type !== types.comma && this.type !== types.braceR)) {
        if (isGenerator || isAsync) { this.unexpected(); }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get")
            { this.raiseRecoverable(start, "getter should have no params"); }
          else
            { this.raiseRecoverable(start, "setter should have exactly one param"); }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
            { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) { this.unexpected(); }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos)
          { this.awaitIdentPos = startPos; }
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else if (this.type === types.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0)
            { refDestructuringErrors.shorthandAssign = this.start; }
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else { this.unexpected(); }
    };

    pp$3.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types.bracketR);
          return prop.key
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
    };

    // Initialize empty function node.

    pp$3.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
      if (this.options.ecmaVersion >= 8) { node.async = false; }
    };

    // Parse object or class method.

    pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

      this.initFunction(node);
      if (this.options.ecmaVersion >= 6)
        { node.generator = isGenerator; }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }

      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false, true);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "FunctionExpression")
    };

    // Parse arrow function expression with given parameters.

    pp$3.parseArrowExpression = function(node, params, isAsync) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;

      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true, false);

      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "ArrowFunctionExpression")
    };

    // Parse function body and check parameters.

    pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
      var isExpression = isArrowFunction && this.type !== types.braceL;
      var oldStrict = this.strict, useStrict = false;

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          // If this is a strict mode function, verify that argument names
          // are not repeated, and it does not try to bind the words `eval`
          // or `arguments`.
          if (useStrict && nonSimple)
            { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
        }
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) { this.strict = true; }

        // Add the params to varDeclaredNames to ensure that an error is thrown
        // if a let/const declaration in the function clashes with one of the params.
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        node.body = this.parseBlock(false);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();

      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
      if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
      this.strict = oldStrict;
    };

    pp$3.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1)
        {
        var param = list[i];

        if (param.type !== "Identifier") { return false
      } }
      return true
    };

    // Checks function params for various disallowed patterns such as using "eval"
    // or "arguments" and duplicate parameters.

    pp$3.checkParams = function(node, allowDuplicates) {
      var nameHash = {};
      for (var i = 0, list = node.params; i < list.length; i += 1)
        {
        var param = list[i];

        this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };

    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).

    pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(types.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) { break }
        } else { first = false; }

        var elt = (void 0);
        if (allowEmpty && this.type === types.comma)
          { elt = null; }
        else if (this.type === types.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
            { refDestructuringErrors.trailingComma = this.start; }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts
    };

    pp$3.checkUnreserved = function(ref) {
      var start = ref.start;
      var end = ref.end;
      var name = ref.name;

      if (this.inGenerator && name === "yield")
        { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
      if (this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
      if (this.keywords.test(name))
        { this.raise(start, ("Unexpected keyword '" + name + "'")); }
      if (this.options.ecmaVersion < 6 &&
        this.input.slice(start, end).indexOf("\\") !== -1) { return }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name)) {
        if (!this.inAsync && name === "await")
          { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
        this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
      }
    };

    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.

    pp$3.parseIdent = function(liberal, isBinding) {
      var node = this.startNode();
      if (this.type === types.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;

        // To fix https://github.com/acornjs/acorn/issues/575
        // `class` and `function` keywords push new context into this.context.
        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
        if ((node.name === "class" || node.name === "function") &&
            (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos)
          { this.awaitIdentPos = node.start; }
      }
      return node
    };

    // Parses yield expression inside generator.

    pp$3.parseYield = function(noIn) {
      if (!this.yieldPos) { this.yieldPos = this.start; }

      var node = this.startNode();
      this.next();
      if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign(noIn);
      }
      return this.finishNode(node, "YieldExpression")
    };

    pp$3.parseAwait = function() {
      if (!this.awaitPos) { this.awaitPos = this.start; }

      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      return this.finishNode(node, "AwaitExpression")
    };

    var pp$4 = Parser.prototype;

    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.

    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
      throw err
    };

    pp$4.raiseRecoverable = pp$4.raise;

    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart)
      }
    };

    var pp$5 = Parser.prototype;

    var Scope = function Scope(flags) {
      this.flags = flags;
      // A list of var-declared names in the current lexical scope
      this.var = [];
      // A list of lexically-declared names in the current lexical scope
      this.lexical = [];
      // A list of lexically-declared FunctionDeclaration names in the current lexical scope
      this.functions = [];
    };

    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

    pp$5.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };

    pp$5.exitScope = function() {
      this.scopeStack.pop();
    };

    // The spec says:
    // > At the top level of a function, or script, function declarations are
    // > treated like var declarations rather than like lexical declarations.
    pp$5.treatFunctionsAsVarInScope = function(scope) {
      return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
    };

    pp$5.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && (scope.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar)
          { redeclared = scope$2.lexical.indexOf(name) > -1; }
        else
          { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
        scope$2.functions.push(name);
      } else {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          var scope$3 = this.scopeStack[i];
          if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
              !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break
          }
          scope$3.var.push(name);
          if (this.inModule && (scope$3.flags & SCOPE_TOP))
            { delete this.undefinedExports[name]; }
          if (scope$3.flags & SCOPE_VAR) { break }
        }
      }
      if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
    };

    pp$5.checkLocalExport = function(id) {
      // scope.functions must be empty as Module code is always strict.
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
          this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };

    pp$5.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1]
    };

    pp$5.currentVarScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR) { return scope }
      }
    };

    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
    pp$5.currentThisScope = function() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];
        if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
      }
    };

    var Node = function Node(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations)
        { this.loc = new SourceLocation(parser, loc); }
      if (parser.options.directSourceFile)
        { this.sourceFile = parser.options.directSourceFile; }
      if (parser.options.ranges)
        { this.range = [pos, 0]; }
    };

    // Start an AST node, attaching a start offset.

    var pp$6 = Parser.prototype;

    pp$6.startNode = function() {
      return new Node(this, this.start, this.startLoc)
    };

    pp$6.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc)
    };

    // Finish an AST node, adding `type` and `end` properties.

    function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      if (this.options.locations)
        { node.loc.end = loc; }
      if (this.options.ranges)
        { node.range[1] = pos; }
      return node
    }

    pp$6.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
    };

    // Finish node at given position

    pp$6.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc)
    };

    // The algorithm used to determine whether a regexp can appear at a

    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };

    var types$1 = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };

    var pp$7 = Parser.prototype;

    pp$7.initialContext = function() {
      return [types$1.b_stat]
    };

    pp$7.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types$1.f_expr || parent === types$1.f_stat)
        { return true }
      if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
        { return !parent.isExpr }

      // The check for `tt.name && exprAllowed` detects whether we are
      // after a `yield` or `of` construct. See the `updateContext` for
      // `tt.name`.
      if (prevType === types._return || prevType === types.name && this.exprAllowed)
        { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
        { return true }
      if (prevType === types.braceL)
        { return parent === types$1.b_stat }
      if (prevType === types._var || prevType === types._const || prevType === types.name)
        { return false }
      return !this.exprAllowed
    };

    pp$7.inGeneratorContext = function() {
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this.context[i];
        if (context.token === "function")
          { return context.generator }
      }
      return false
    };

    pp$7.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types.dot)
        { this.exprAllowed = false; }
      else if (update = type.updateContext)
        { update.call(this, prevType); }
      else
        { this.exprAllowed = type.beforeExpr; }
    };

    // Token-specific context update code

    types.parenR.updateContext = types.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return
      }
      var out = this.context.pop();
      if (out === types$1.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };

    types.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
      this.exprAllowed = true;
    };

    types.dollarBraceL.updateContext = function() {
      this.context.push(types$1.b_tmpl);
      this.exprAllowed = true;
    };

    types.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
      this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
      this.exprAllowed = true;
    };

    types.incDec.updateContext = function() {
      // tokExprAllowed stays unchanged
    };

    types._function.updateContext = types._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
          !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
          !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
        { this.context.push(types$1.f_expr); }
      else
        { this.context.push(types$1.f_stat); }
      this.exprAllowed = false;
    };

    types.backQuote.updateContext = function() {
      if (this.curContext() === types$1.q_tmpl)
        { this.context.pop(); }
      else
        { this.context.push(types$1.q_tmpl); }
      this.exprAllowed = false;
    };

    types.star.updateContext = function(prevType) {
      if (prevType === types._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types$1.f_expr)
          { this.context[index] = types$1.f_expr_gen; }
        else
          { this.context[index] = types$1.f_gen; }
      }
      this.exprAllowed = true;
    };

    types.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
        if (this.value === "of" && !this.exprAllowed ||
            this.value === "yield" && this.inGeneratorContext())
          { allowed = true; }
      }
      this.exprAllowed = allowed;
    };

    // This file contains Unicode properties extracted from the ECMAScript
    // specification. The lists are extracted like so:
    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

    // #table-binary-unicode-properties
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties
    };

    // #table-unicode-general-category-values
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

    // #table-unicode-script-values
    var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues
    };

    var data = {};
    function buildUnicodeData(ecmaVersion) {
      var d = data[ecmaVersion] = {
        binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
        nonBinary: {
          General_Category: wordsRegexp(unicodeGeneralCategoryValues),
          Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
        }
      };
      d.nonBinary.Script_Extensions = d.nonBinary.Script;

      d.nonBinary.gc = d.nonBinary.General_Category;
      d.nonBinary.sc = d.nonBinary.Script;
      d.nonBinary.scx = d.nonBinary.Script_Extensions;
    }
    buildUnicodeData(9);
    buildUnicodeData(10);
    buildUnicodeData(11);

    var pp$8 = Parser.prototype;

    var RegExpValidationState = function RegExpValidationState(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = [];
      this.backReferenceNames = [];
    };

    RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
      this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
    };

    RegExpValidationState.prototype.raise = function raise (message) {
      this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
    };

    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
    RegExpValidationState.prototype.at = function at (i) {
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return -1
      }
      var c = s.charCodeAt(i);
      if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
        return c
      }
      return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00
    };

    RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
      var s = this.source;
      var l = s.length;
      if (i >= l) {
        return l
      }
      var c = s.charCodeAt(i);
      if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
        return i + 1
      }
      return i + 2
    };

    RegExpValidationState.prototype.current = function current () {
      return this.at(this.pos)
    };

    RegExpValidationState.prototype.lookahead = function lookahead () {
      return this.at(this.nextIndex(this.pos))
    };

    RegExpValidationState.prototype.advance = function advance () {
      this.pos = this.nextIndex(this.pos);
    };

    RegExpValidationState.prototype.eat = function eat (ch) {
      if (this.current() === ch) {
        this.advance();
        return true
      }
      return false
    };

    function codePointToString(ch) {
      if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
      ch -= 0x10000;
      return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
    }

    /**
     * Validate the flags part of a given RegExpLiteral.
     *
     * @param {RegExpValidationState} state The state to validate RegExp.
     * @returns {void}
     */
    pp$8.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;

      for (var i = 0; i < flags.length; i++) {
        var flag = flags.charAt(i);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
      }
    };

    /**
     * Validate the pattern part of a given RegExpLiteral.
     *
     * @param {RegExpValidationState} state The state to validate RegExp.
     * @returns {void}
     */
    pp$8.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);

      // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
      // parsing contains a |GroupName|, reparse with the goal symbol
      // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
      // exception if _P_ did not conform to the grammar, if any elements of _P_
      // were not matched by the parse, or if any Early Error conditions exist.
      if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
    pp$8.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames.length = 0;
      state.backReferenceNames.length = 0;

      this.regexp_disjunction(state);

      if (state.pos !== state.source.length) {
        // Make the same messages as V8.
        if (state.eat(0x29 /* ) */)) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
        var name = list[i];

        if (state.groupNames.indexOf(name) === -1) {
          state.raise("Invalid named capture referenced");
        }
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
    pp$8.regexp_disjunction = function(state) {
      this.regexp_alternative(state);
      while (state.eat(0x7C /* | */)) {
        this.regexp_alternative(state);
      }

      // Make the same message as V8.
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(0x7B /* { */)) {
        state.raise("Lone quantifier brackets");
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
    pp$8.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state))
        { }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
    pp$8.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        // Handle `QuantifiableAssertion Quantifier` alternative.
        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
        // is a QuantifiableAssertion.
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          // Make the same message as V8.
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true
      }

      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
    pp$8.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;

      // ^, $
      if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
        return true
      }

      // \b \B
      if (state.eat(0x5C /* \ */)) {
        if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
          return true
        }
        state.pos = start;
      }

      // Lookahead / Lookbehind
      if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(0x3C /* < */);
        }
        if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
          this.regexp_disjunction(state);
          if (!state.eat(0x29 /* ) */)) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true
        }
      }

      state.pos = start;
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
    pp$8.regexp_eatQuantifier = function(state, noError) {
      if ( noError === void 0 ) noError = false;

      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(0x3F /* ? */);
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
    pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
      return (
        state.eat(0x2A /* * */) ||
        state.eat(0x2B /* + */) ||
        state.eat(0x3F /* ? */) ||
        this.regexp_eatBracedQuantifier(state, noError)
      )
    };
    pp$8.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(0x7B /* { */)) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(0x7D /* } */)) {
            // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
    pp$8.regexp_eatAtom = function(state) {
      return (
        this.regexp_eatPatternCharacters(state) ||
        state.eat(0x2E /* . */) ||
        this.regexp_eatReverseSolidusAtomEscape(state) ||
        this.regexp_eatCharacterClass(state) ||
        this.regexp_eatUncapturingGroup(state) ||
        this.regexp_eatCapturingGroup(state)
      )
    };
    pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(0x5C /* \ */)) {
        if (this.regexp_eatAtomEscape(state)) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$8.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(0x28 /* ( */)) {
        if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
          this.regexp_disjunction(state);
          if (state.eat(0x29 /* ) */)) {
            return true
          }
          state.raise("Unterminated group");
        }
        state.pos = start;
      }
      return false
    };
    pp$8.regexp_eatCapturingGroup = function(state) {
      if (state.eat(0x28 /* ( */)) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 0x3F /* ? */) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          state.numCapturingParens += 1;
          return true
        }
        state.raise("Unterminated group");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
    pp$8.regexp_eatExtendedAtom = function(state) {
      return (
        state.eat(0x2E /* . */) ||
        this.regexp_eatReverseSolidusAtomEscape(state) ||
        this.regexp_eatCharacterClass(state) ||
        this.regexp_eatUncapturingGroup(state) ||
        this.regexp_eatCapturingGroup(state) ||
        this.regexp_eatInvalidBracedQuantifier(state) ||
        this.regexp_eatExtendedPatternCharacter(state)
      )
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
    pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
    pp$8.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }
      return false
    };
    function isSyntaxCharacter(ch) {
      return (
        ch === 0x24 /* $ */ ||
        ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
        ch === 0x2E /* . */ ||
        ch === 0x3F /* ? */ ||
        ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
        ch >= 0x7B /* { */ && ch <= 0x7D /* } */
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
    // But eat eager.
    pp$8.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
    pp$8.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (
        ch !== -1 &&
        ch !== 0x24 /* $ */ &&
        !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
        ch !== 0x2E /* . */ &&
        ch !== 0x3F /* ? */ &&
        ch !== 0x5B /* [ */ &&
        ch !== 0x5E /* ^ */ &&
        ch !== 0x7C /* | */
      ) {
        state.advance();
        return true
      }
      return false
    };

    // GroupSpecifier[U] ::
    //   [empty]
    //   `?` GroupName[?U]
    pp$8.regexp_groupSpecifier = function(state) {
      if (state.eat(0x3F /* ? */)) {
        if (this.regexp_eatGroupName(state)) {
          if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
            state.raise("Duplicate capture group name");
          }
          state.groupNames.push(state.lastStringValue);
          return
        }
        state.raise("Invalid group");
      }
    };

    // GroupName[U] ::
    //   `<` RegExpIdentifierName[?U] `>`
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$8.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(0x3C /* < */)) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
          return true
        }
        state.raise("Invalid capture group name");
      }
      return false
    };

    // RegExpIdentifierName[U] ::
    //   RegExpIdentifierStart[?U]
    //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$8.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
        }
        return true
      }
      return false
    };

    // RegExpIdentifierStart[U] ::
    //   UnicodeIDStart
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[?U]
    pp$8.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var ch = state.current();
      state.advance();

      if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true
      }

      state.pos = start;
      return false
    };
    function isRegExpIdentifierStart(ch) {
      return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
    }

    // RegExpIdentifierPart[U] ::
    //   UnicodeIDContinue
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[?U]
    //   <ZWNJ>
    //   <ZWJ>
    pp$8.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var ch = state.current();
      state.advance();

      if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true
      }

      state.pos = start;
      return false
    };
    function isRegExpIdentifierPart(ch) {
      return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
    pp$8.regexp_eatAtomEscape = function(state) {
      if (
        this.regexp_eatBackReference(state) ||
        this.regexp_eatCharacterClassEscape(state) ||
        this.regexp_eatCharacterEscape(state) ||
        (state.switchN && this.regexp_eatKGroupName(state))
      ) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        if (state.current() === 0x63 /* c */) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false
    };
    pp$8.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
          // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
          if (n > state.maxBackReference) {
            state.maxBackReference = n;
          }
          return true
        }
        if (n <= state.numCapturingParens) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$8.regexp_eatKGroupName = function(state) {
      if (state.eat(0x6B /* k */)) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true
        }
        state.raise("Invalid named reference");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
    pp$8.regexp_eatCharacterEscape = function(state) {
      return (
        this.regexp_eatControlEscape(state) ||
        this.regexp_eatCControlLetter(state) ||
        this.regexp_eatZero(state) ||
        this.regexp_eatHexEscapeSequence(state) ||
        this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
        (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
        this.regexp_eatIdentityEscape(state)
      )
    };
    pp$8.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(0x63 /* c */)) {
        if (this.regexp_eatControlLetter(state)) {
          return true
        }
        state.pos = start;
      }
      return false
    };
    pp$8.regexp_eatZero = function(state) {
      if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
    pp$8.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 0x74 /* t */) {
        state.lastIntValue = 0x09; /* \t */
        state.advance();
        return true
      }
      if (ch === 0x6E /* n */) {
        state.lastIntValue = 0x0A; /* \n */
        state.advance();
        return true
      }
      if (ch === 0x76 /* v */) {
        state.lastIntValue = 0x0B; /* \v */
        state.advance();
        return true
      }
      if (ch === 0x66 /* f */) {
        state.lastIntValue = 0x0C; /* \f */
        state.advance();
        return true
      }
      if (ch === 0x72 /* r */) {
        state.lastIntValue = 0x0D; /* \r */
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
    pp$8.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true
      }
      return false
    };
    function isControlLetter(ch) {
      return (
        (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
        (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
      )
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
    pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
      var start = state.pos;

      if (state.eat(0x75 /* u */)) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 0xDC00 && trail <= 0xDFFF) {
                state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                return true
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true
        }
        if (
          state.switchU &&
          state.eat(0x7B /* { */) &&
          this.regexp_eatHexDigits(state) &&
          state.eat(0x7D /* } */) &&
          isValidUnicode(state.lastIntValue)
        ) {
          return true
        }
        if (state.switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }

      return false
    };
    function isValidUnicode(ch) {
      return ch >= 0 && ch <= 0x10FFFF
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
    pp$8.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true
        }
        if (state.eat(0x2F /* / */)) {
          state.lastIntValue = 0x2F; /* / */
          return true
        }
        return false
      }

      var ch = state.current();
      if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
    pp$8.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
          state.advance();
        } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
    pp$8.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();

      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return true
      }

      if (
        state.switchU &&
        this.options.ecmaVersion >= 9 &&
        (ch === 0x50 /* P */ || ch === 0x70 /* p */)
      ) {
        state.lastIntValue = -1;
        state.advance();
        if (
          state.eat(0x7B /* { */) &&
          this.regexp_eatUnicodePropertyValueExpression(state) &&
          state.eat(0x7D /* } */)
        ) {
          return true
        }
        state.raise("Invalid property name");
      }

      return false
    };
    function isCharacterClassEscape(ch) {
      return (
        ch === 0x64 /* d */ ||
        ch === 0x44 /* D */ ||
        ch === 0x73 /* s */ ||
        ch === 0x53 /* S */ ||
        ch === 0x77 /* w */ ||
        ch === 0x57 /* W */
      )
    }

    // UnicodePropertyValueExpression ::
    //   UnicodePropertyName `=` UnicodePropertyValue
    //   LoneUnicodePropertyNameOrValue
    pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;

      // UnicodePropertyName `=` UnicodePropertyValue
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return true
        }
      }
      state.pos = start;

      // LoneUnicodePropertyNameOrValue
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        return true
      }
      return false
    };
    pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!has(state.unicodeProperties.nonBinary, name))
        { state.raise("Invalid property name"); }
      if (!state.unicodeProperties.nonBinary[name].test(value))
        { state.raise("Invalid property value"); }
    };
    pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (!state.unicodeProperties.binary.test(nameOrValue))
        { state.raise("Invalid property name"); }
    };

    // UnicodePropertyName ::
    //   UnicodePropertyNameCharacters
    pp$8.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== ""
    };
    function isUnicodePropertyNameCharacter(ch) {
      return isControlLetter(ch) || ch === 0x5F /* _ */
    }

    // UnicodePropertyValue ::
    //   UnicodePropertyValueCharacters
    pp$8.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== ""
    };
    function isUnicodePropertyValueCharacter(ch) {
      return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
    }

    // LoneUnicodePropertyNameOrValue ::
    //   UnicodePropertyValueCharacters
    pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state)
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
    pp$8.regexp_eatCharacterClass = function(state) {
      if (state.eat(0x5B /* [ */)) {
        state.eat(0x5E /* ^ */);
        this.regexp_classRanges(state);
        if (state.eat(0x5D /* [ */)) {
          return true
        }
        // Unreachable since it threw "unterminated regular expression" error before.
        state.raise("Unterminated character class");
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
    pp$8.regexp_classRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
    pp$8.regexp_eatClassAtom = function(state) {
      var start = state.pos;

      if (state.eat(0x5C /* \ */)) {
        if (this.regexp_eatClassEscape(state)) {
          return true
        }
        if (state.switchU) {
          // Make the same message as V8.
          var ch$1 = state.current();
          if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }

      var ch = state.current();
      if (ch !== 0x5D /* [ */) {
        state.lastIntValue = ch;
        state.advance();
        return true
      }

      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
    pp$8.regexp_eatClassEscape = function(state) {
      var start = state.pos;

      if (state.eat(0x62 /* b */)) {
        state.lastIntValue = 0x08; /* <BS> */
        return true
      }

      if (state.switchU && state.eat(0x2D /* - */)) {
        state.lastIntValue = 0x2D; /* - */
        return true
      }

      if (!state.switchU && state.eat(0x63 /* c */)) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true
        }
        state.pos = start;
      }

      return (
        this.regexp_eatCharacterClassEscape(state) ||
        this.regexp_eatCharacterEscape(state)
      )
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
    pp$8.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
        state.lastIntValue = ch % 0x20;
        state.advance();
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$8.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(0x78 /* x */)) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
    pp$8.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      }
      return state.pos !== start
    };
    function isDecimalDigit(ch) {
      return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
    pp$8.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start
    };
    function isHexDigit(ch) {
      return (
        (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
        (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
        (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
      )
    }
    function hexToInt(ch) {
      if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
        return 10 + (ch - 0x41 /* A */)
      }
      if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
        return 10 + (ch - 0x61 /* a */)
      }
      return ch - 0x30 /* 0 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
    // Allows only 0-377(octal) i.e. 0-255(decimal).
    pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true
      }
      return false
    };

    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
    pp$8.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 0x30; /* 0 */
        state.advance();
        return true
      }
      state.lastIntValue = 0;
      return false
    };
    function isOctalDigit(ch) {
      return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
    }

    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$8.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i = 0; i < length; ++i) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true
    };

    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.

    var Token = function Token(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations)
        { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
      if (p.options.ranges)
        { this.range = [p.start, p.end]; }
    };

    // ## Tokenizer

    var pp$9 = Parser.prototype;

    // Move to the next token

    pp$9.next = function() {
      if (this.options.onToken)
        { this.options.onToken(new Token(this)); }

      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };

    pp$9.getToken = function() {
      this.next();
      return new Token(this)
    };

    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined")
      { pp$9[Symbol.iterator] = function() {
        var this$1 = this;

        return {
          next: function () {
            var token = this$1.getToken();
            return {
              done: token.type === types.eof,
              value: token
            }
          }
        }
      }; }

    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).

    pp$9.curContext = function() {
      return this.context[this.context.length - 1]
    };

    // Read a single token, updating the parser object's token-related
    // properties.

    pp$9.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

      this.start = this.pos;
      if (this.options.locations) { this.startLoc = this.curPosition(); }
      if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

      if (curContext.override) { return curContext.override(this) }
      else { this.readToken(this.fullCharCodeAtPos()); }
    };

    pp$9.readToken = function(code) {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
        { return this.readWord() }

      return this.getTokenFromCode(code)
    };

    pp$9.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 0xd7ff || code >= 0xe000) { return code }
      var next = this.input.charCodeAt(this.pos + 1);
      return (code << 10) + next - 0x35fdc00
    };

    pp$9.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
      this.pos = end + 2;
      if (this.options.locations) {
        lineBreakG.lastIndex = start;
        var match;
        while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
          ++this.curLine;
          this.lineStart = match.index + match[0].length;
        }
      }
      if (this.options.onComment)
        { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                               startLoc, this.curPosition()); }
    };

    pp$9.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment)
        { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                               startLoc, this.curPosition()); }
    };

    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.

    pp$9.skipSpace = function() {
      loop: while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        switch (ch) {
        case 32: case 160: // ' '
          ++this.pos;
          break
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10: case 8232: case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break
        case 47: // '/'
          switch (this.input.charCodeAt(this.pos + 1)) {
          case 42: // '*'
            this.skipBlockComment();
            break
          case 47:
            this.skipLineComment(2);
            break
          default:
            break loop
          }
          break
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop
          }
        }
      }
    };

    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.

    pp$9.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) { this.endLoc = this.curPosition(); }
      var prevType = this.type;
      this.type = type;
      this.value = val;

      this.updateContext(prevType);
    };

    // ### Token reading

    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp$9.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) { return this.readNumber(true) }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
        this.pos += 3;
        return this.finishToken(types.ellipsis)
      } else {
        ++this.pos;
        return this.finishToken(types.dot)
      }
    };

    pp$9.readToken_slash = function() { // '/'
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.slash, 1)
    };

    pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types.star : types.modulo;

      // exponentiation operator ** and **=
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }

      if (next === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(tokentype, size)
    };

    pp$9.readToken_pipe_amp = function(code) { // '|&'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
    };

    pp$9.readToken_caret = function() { // '^'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.bitwiseXOR, 1)
    };

    pp$9.readToken_plus_min = function(code) { // '+-'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
            (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          // A `-->` line comment
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken()
        }
        return this.finishOp(types.incDec, 2)
      }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.plusMin, 1)
    };

    pp$9.readToken_lt_gt = function(code) { // '<>'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
        return this.finishOp(types.bitShift, size)
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
          this.input.charCodeAt(this.pos + 3) === 45) {
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken()
      }
      if (next === 61) { size = 2; }
      return this.finishOp(types.relational, size)
    };

    pp$9.readToken_eq_excl = function(code) { // '=!'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
        this.pos += 2;
        return this.finishToken(types.arrow)
      }
      return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
    };

    pp$9.getTokenFromCode = function(code) {
      switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46: // '.'
        return this.readToken_dot()

      // Punctuation tokens.
      case 40: ++this.pos; return this.finishToken(types.parenL)
      case 41: ++this.pos; return this.finishToken(types.parenR)
      case 59: ++this.pos; return this.finishToken(types.semi)
      case 44: ++this.pos; return this.finishToken(types.comma)
      case 91: ++this.pos; return this.finishToken(types.bracketL)
      case 93: ++this.pos; return this.finishToken(types.bracketR)
      case 123: ++this.pos; return this.finishToken(types.braceL)
      case 125: ++this.pos; return this.finishToken(types.braceR)
      case 58: ++this.pos; return this.finishToken(types.colon)
      case 63: ++this.pos; return this.finishToken(types.question)

      case 96: // '`'
        if (this.options.ecmaVersion < 6) { break }
        ++this.pos;
        return this.finishToken(types.backQuote)

      case 48: // '0'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
          if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
        }

      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
        return this.readNumber(false)

      // Quotes produce strings.
      case 34: case 39: // '"', "'"
        return this.readString(code)

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.

      case 47: // '/'
        return this.readToken_slash()

      case 37: case 42: // '%*'
        return this.readToken_mult_modulo_exp(code)

      case 124: case 38: // '|&'
        return this.readToken_pipe_amp(code)

      case 94: // '^'
        return this.readToken_caret()

      case 43: case 45: // '+-'
        return this.readToken_plus_min(code)

      case 60: case 62: // '<>'
        return this.readToken_lt_gt(code)

      case 61: case 33: // '=!'
        return this.readToken_eq_excl(code)

      case 126: // '~'
        return this.finishOp(types.prefix, 1)
      }

      this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
    };

    pp$9.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str)
    };

    pp$9.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
        if (!escaped) {
          if (ch === "[") { inClass = true; }
          else if (ch === "]" && inClass) { inClass = false; }
          else if (ch === "/" && !inClass) { break }
          escaped = ch === "\\";
        } else { escaped = false; }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) { this.unexpected(flagsStart); }

      // Validate pattern
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);

      // Create Literal#value property value.
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e) {
        // ESTree requires null if it failed to instantiate RegExp object.
        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
      }

      return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
    };

    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.

    pp$9.readInt = function(radix, len) {
      var start = this.pos, total = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.pos), val = (void 0);
        if (code >= 97) { val = code - 97 + 10; } // a
        else if (code >= 65) { val = code - 65 + 10; } // A
        else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
        else { val = Infinity; }
        if (val >= radix) { break }
        ++this.pos;
        total = total * radix + val;
      }
      if (this.pos === start || len != null && this.pos - start !== len) { return null }

      return total
    };

    pp$9.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2; // 0x
      var val = this.readInt(radix);
      if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val)
    };

    // Read an integer, octal integer, or floating-point number.

    pp$9.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) { this.raise(start, "Invalid number"); }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var str$1 = this.input.slice(start, this.pos);
        var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
        return this.finishToken(types.num, val$1)
      }
      if (next === 46 && !octal) { // '.'
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) { // 'eE'
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) { ++this.pos; } // '+-'
        if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

      var str = this.input.slice(start, this.pos);
      var val = octal ? parseInt(str, 8) : parseFloat(str);
      return this.finishToken(types.num, val)
    };

    // Read a string value, interpreting backslash-escapes.

    pp$9.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;

      if (ch === 123) { // '{'
        if (this.options.ecmaVersion < 6) { this.unexpected(); }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
      } else {
        code = this.readHexChar(4);
      }
      return code
    };

    function codePointToString$1(code) {
      // UTF-16 Decoding
      if (code <= 0xFFFF) { return String.fromCharCode(code) }
      code -= 0x10000;
      return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
    }

    pp$9.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) { break }
        if (ch === 92) { // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else {
          if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types.string, out)
    };

    // Reads template string tokens.

    var INVALID_TEMPLATE_ESCAPE_ERROR = {};

    pp$9.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err
        }
      }

      this.inTemplateElement = false;
    };

    pp$9.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR
      } else {
        this.raise(position, message);
      }
    };

    pp$9.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
          if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types.dollarBraceL)
            } else {
              ++this.pos;
              return this.finishToken(types.backQuote)
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types.template, out)
        }
        if (ch === 92) { // '\'
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
          case 10:
            out += "\n";
            break
          default:
            out += String.fromCharCode(ch);
            break
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };

    // Reads a template token to search for the end, without validating any escape sequences
    pp$9.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break

        case "$":
          if (this.input[this.pos + 1] !== "{") {
            break
          }
        // falls through

        case "`":
          return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

        // no default
        }
      }
      this.raise(this.start, "Unterminated template");
    };

    // Used to read escaped characters

    pp$9.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
      case 110: return "\n" // 'n' -> '\n'
      case 114: return "\r" // 'r' -> '\r'
      case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
      case 117: return codePointToString$1(this.readCodePoint()) // 'u'
      case 116: return "\t" // 't' -> '\t'
      case 98: return "\b" // 'b' -> '\b'
      case 118: return "\u000b" // 'v' -> '\u000b'
      case 102: return "\f" // 'f' -> '\f'
      case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
      case 10: // ' \n'
        if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
        return ""
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
            this.invalidStringToken(
              this.pos - 1 - octalStr.length,
              inTemplate
                ? "Octal literal in template string"
                : "Octal literal in strict mode"
            );
          }
          return String.fromCharCode(octal)
        }
        if (isNewLine(ch)) {
          // Unicode new line characters after \ get removed from output in both
          // template literals and strings
          return ""
        }
        return String.fromCharCode(ch)
      }
    };

    // Used to read character escape sequences ('\x', '\u', '\U').

    pp$9.readHexChar = function(len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
      return n
    };

    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.

    pp$9.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) { // "\"
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) // "u"
            { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
            { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
          word += codePointToString$1(esc);
          chunkStart = this.pos;
        } else {
          break
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos)
    };

    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.

    pp$9.readWord = function() {
      var word = this.readWord1();
      var type = types.name;
      if (this.keywords.test(word)) {
        if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
        type = keywords$1[word];
      }
      return this.finishToken(type, word)
    };

    // Acorn is a tiny, fast JavaScript parser written in JavaScript.

    var version = "7.1.0";

    Parser.acorn = {
      Parser: Parser,
      version: version,
      defaultOptions: defaultOptions,
      Position: Position,
      SourceLocation: SourceLocation,
      getLineInfo: getLineInfo,
      Node: Node,
      TokenType: TokenType,
      tokTypes: types,
      keywordTypes: keywords$1,
      TokContext: TokContext,
      tokContexts: types$1,
      isIdentifierChar: isIdentifierChar,
      isIdentifierStart: isIdentifierStart,
      Token: Token,
      isNewLine: isNewLine,
      lineBreak: lineBreak,
      lineBreakG: lineBreakG,
      nonASCIIwhitespace: nonASCIIwhitespace
    };

    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and
    // returns an abstract syntax tree as specified by [Mozilla parser
    // API][api].
    //
    // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

    function parse(input, options) {
      return Parser.parse(input, options)
    }

    // This function tries to parse a single expression at a given
    // offset in a string. Useful for parsing mixed-language formats
    // that embed JavaScript expressions.

    function parseExpressionAt(input, pos, options) {
      return Parser.parseExpressionAt(input, pos, options)
    }

    // Acorn is organized as a tokenizer and a recursive-descent parser.
    // The `tokenizer` export provides an interface to the tokenizer.

    function tokenizer(input, options) {
      return Parser.tokenizer(input, options)
    }

    exports.Node = Node;
    exports.Parser = Parser;
    exports.Position = Position;
    exports.SourceLocation = SourceLocation;
    exports.TokContext = TokContext;
    exports.Token = Token;
    exports.TokenType = TokenType;
    exports.defaultOptions = defaultOptions;
    exports.getLineInfo = getLineInfo;
    exports.isIdentifierChar = isIdentifierChar;
    exports.isIdentifierStart = isIdentifierStart;
    exports.isNewLine = isNewLine;
    exports.keywordTypes = keywords$1;
    exports.lineBreak = lineBreak;
    exports.lineBreakG = lineBreakG;
    exports.nonASCIIwhitespace = nonASCIIwhitespace;
    exports.parse = parse;
    exports.parseExpressionAt = parseExpressionAt;
    exports.tokContexts = types$1;
    exports.tokTypes = types;
    exports.tokenizer = tokenizer;
    exports.version = version;

    Object.defineProperty(exports, '__esModule', { value: true });

  }));
  });

  unwrapExports(acorn);
  var acorn_1 = acorn.parse;

  // FIX: Is this specific to the v1 api? If so, move it there.

  const fromObjectExpression = ({ properties }) => {
    const object = {};
    for (const { key, value } of properties) {
      if (value.type === 'StringLiteral') {
        object[key.value] = value.value;
      } else if (value.type === 'ArrayExpression') {
        object[key.value] = value.elements.map(element => element.value);
      } else if (value.type === 'ObjectExpression') {
        object[key.value] = fromObjectExpression(value);
      } else {
        throw Error('die');
      }
    }
    return object;
  };

  const toEcmascript = (options, script) => {
    const parseOptions = {
      allowAwaitOutsideFunction: true,
      allowReturnOutsideFunction: true,
      sourceType: 'module'
    };
    let ast = acorn_1(script, parseOptions);

    const exportNames = [];
    const expressions = [];

    const body = ast.body;
    const out = [];
    const annotations = { imports: {} };

    // Separate top level exports and expressions.
    // FIX: This will reorder things unnecessarily when export main is present.
    for (let nth = 0; nth < body.length; nth++) {
      const entry = body[nth];
      if (entry.type === 'ExportNamedDeclaration') {
        // Note the names and replace the export with the declaration.
        const declaration = entry.declaration;
        if (declaration.type === 'VariableDeclaration') {
          for (const declarator of declaration.declarations) {
            if (declarator.type === 'VariableDeclarator') {
              const name = declarator.id.name;
              exportNames.push(name);
            }
          }
          out.push(declaration);
        }
      } else if (entry.type === 'ImportDeclaration') {
        const entry = body[nth];
        // Rewrite
        //   import { foo } from 'bar';
        //   import Foo from 'bar';
        // to
        //   const { foo } = importModule('bar');
        //   const Foo = importModule('bar');
        //
        // FIX: Handle other variations.
        const { specifiers, source } = entry;

        if (specifiers.length === 0) {
          out.push(acorn_1(`await importModule('${source.value}');`, parseOptions));
        } else {
          for (const { imported, local, type } of specifiers) {
            switch (type) {
              case 'ImportDefaultSpecifier':
                out.push(acorn_1(`const ${local.name} = (await importModule('${source.value}')).default;`, parseOptions));
                break;
              case 'ImportSpecifier':
                out.push(acorn_1(`const { ${imported.name} } = await importModule('${source.value}');`, parseOptions));
                break;
            }
          }
        }
      } else if (entry.type === 'ExpressionStatement' && entry.expression.type === 'ObjectExpression') {
        Object.assign(annotations, fromObjectExpression(entry.expression));
      } else if (entry.type === 'ExpressionStatement' && entry.expression.type === 'CallExpression' && entry.expression.callee.name === 'source') {
        // source('a', 'b') needs to be kept at the top level to support imports and avoid repetition.
        out.push(entry);
      } else {
        expressions.push(entry);
      }
    }

    // Set up a main.
    if (exportNames.length > 0) {
      // They export something, so assume they know what they're doing.
      out.push(...expressions);
    } else {
      // They don't export a main function, so build one for them.
      if (expressions.length >= 1) {
        // Turn any final expression into a return statement.
        const last = expressions.length - 1;
        const tail = expressions[last];
        if (tail.type === 'ExpressionStatement') {
          expressions[last] = acorn_1(`return ${astring_1(expressions[last])}`, parseOptions);
        }
      }
      const main = acorn_1(`const main = async () => { ${expressions.map(expression => astring_1(expression)).join('\n')} };`, parseOptions);
      out.push(main);
      exportNames.push('main');
    }

    // Return the exports as an object.
    out.push(acorn_1(`return { ${exportNames.join(', ')} };`, parseOptions));

    const result = astring_1(acorn_1(`return async () => { ${out.map(astring_1).join('\n')} };`, parseOptions));
    return result;
  };

  const DYNAMIC_MODULES = new Map();

  const registerDynamicModule = (bare, path) => DYNAMIC_MODULES.set(bare, path);

  const buildImportModule = (api) =>
    async (name, { src } = {}) => {
      const internalModule = DYNAMIC_MODULES.get(name);
      if (internalModule !== undefined) {
        const module = await new Promise(function (resolve, reject) { require([internalModule], function (m) { resolve(_interopNamespace(m)); }, reject) });
        return module;
      }
      let script;
      if (script === undefined) {
        const path = `source/${name}`;
        script = await readFile({ path, as: 'utf8' }, path);
      }
      if (script === undefined) {
        const path = `cache/${name}`;
        const sources = getSources(path);
        if (src) {
          sources.push(src);
        }
        script = await readFile({ path, as: 'utf8', sources }, path);
      }
      const ecmascript = toEcmascript({}, script);
      const builder = new Function(`{ ${Object.keys(api).join(', ')} }`, ecmascript);
      const constructor = await builder(api);
      const module = await constructor();
      return module;
    };

  const md = (strings, ...placeholders) => {
    const md = strings.reduce((result, string, i) => (result + placeholders[i - 1] + string));
    emit$1({ md });
    return md;
  };

  const extendedApi = { ...api, toSvg };

  const importModule = buildImportModule(extendedApi);

  extendedApi.importModule = importModule;

  // Register Dynamic libraries.

  const module = (name) => `@jsxcad/api-v1-${name}`;

  registerDynamicModule(module('armature'), '@jsxcad/api-v1-armature');
  registerDynamicModule(module('connector'), '@jsxcad/api-v1-connector');
  registerDynamicModule(module('cursor'), '@jsxcad/api-v1-cursor');
  registerDynamicModule(module('deform'), '@jsxcad/api-v1-deform');
  registerDynamicModule(module('dst'), '@jsxcad/api-v1-dst');
  registerDynamicModule(module('dxf'), '@jsxcad/api-v1-dxf');
  registerDynamicModule(module('extrude'), '@jsxcad/api-v1-extrude');
  registerDynamicModule(module('font'), '@jsxcad/api-v1-font');
  registerDynamicModule(module('gcode'), '@jsxcad/api-v1-gcode');
  registerDynamicModule(module('gear'), '@jsxcad/api-v1-gear');
  registerDynamicModule(module('item'), '@jsxcad/api-v1-item');
  registerDynamicModule(module('jscad'), '@jsxcad/api-v1-jscad');
  registerDynamicModule(module('layout'), '@jsxcad/api-v1-layout');
  registerDynamicModule(module('lego'), '@jsxcad/api-v1-lego');
  registerDynamicModule(module('math'), '@jsxcad/api-v1-math');
  registerDynamicModule(module('motor'), '@jsxcad/api-v1-motor');
  registerDynamicModule(module('pdf'), '@jsxcad/api-v1-pdf');
  registerDynamicModule(module('plan'), '@jsxcad/api-v1-plan');
  registerDynamicModule(module('plans'), '@jsxcad/api-v1-plans');
  registerDynamicModule(module('png'), '@jsxcad/api-v1-png');
  registerDynamicModule(module('shape'), '@jsxcad/api-v1-shape');
  registerDynamicModule(module('shapefile'), '@jsxcad/api-v1-shapefile');
  registerDynamicModule(module('shapes'), '@jsxcad/api-v1-shapes');
  registerDynamicModule(module('shell'), '@jsxcad/api-v1-shell');
  registerDynamicModule(module('stl'), '@jsxcad/api-v1-stl');
  registerDynamicModule(module('svg'), '@jsxcad/api-v1-svg');
  registerDynamicModule(module('thread'), '@jsxcad/api-v1-thread');
  registerDynamicModule(module('threejs'), '@jsxcad/api-v1-threejs');
  registerDynamicModule(module('units'), '@jsxcad/api-v1-units');

  var api$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    importModule: importModule,
    md: md,
    emit: emit$1,
    source: source,
    Connector: Connector,
    X: X$m,
    Y: Y$m,
    Z: Z$k,
    ChainedHull: ChainedHull,
    Hull: Hull,
    Loop: Loop,
    Shape: Shape,
    log: log$2,
    make: make,
    pack: pack$1,
    Line2: Line2,
    Plan: Plan,
    Page: Page,
    Arc: Arc,
    Assembly: Assembly,
    Circle: Circle,
    Cone: Cone,
    Cube: Cube,
    Cylinder: Cylinder,
    Difference: Difference,
    Empty: Empty,
    Hexagon: Hexagon,
    Icosahedron: Icosahedron,
    Intersection: Intersection,
    Layers: Layers,
    Line: Line,
    Path: Path,
    Point: Point,
    Points: Points,
    Polygon: Polygon,
    Polyhedron: Polyhedron,
    Prism: Prism,
    Sphere: Sphere,
    Spiral: Spiral,
    Square: Square,
    Tetrahedron: Tetrahedron,
    Torus: Torus,
    Triangle: Triangle,
    Union: Union,
    Void: Void,
    Wave: Wave,
    Item: Item$1,
    WoodScrew: WoodScrew,
    Random: Random,
    acos: acos,
    cos: cos,
    ease: ease,
    max: max$1,
    min: min$1,
    numbers: numbers,
    sin: sin,
    sqrt: sqrt,
    vec: vec,
    foot: foot,
    inch: inch,
    mm: mm,
    mil: mil,
    cm: cm,
    m: m$1,
    thou: thou,
    yard: yard
  });

  var three = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
  	 factory(exports) ;
  }(commonjsGlobal, function (exports) {
  	// Polyfills

  	if ( Number.EPSILON === undefined ) {

  		Number.EPSILON = Math.pow( 2, - 52 );

  	}

  	if ( Number.isInteger === undefined ) {

  		// Missing in IE
  		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

  		Number.isInteger = function ( value ) {

  			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

  		};

  	}

  	//

  	if ( Math.sign === undefined ) {

  		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

  		Math.sign = function ( x ) {

  			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

  		};

  	}

  	if ( 'name' in Function.prototype === false ) {

  		// Missing in IE
  		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

  		Object.defineProperty( Function.prototype, 'name', {

  			get: function () {

  				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

  			}

  		} );

  	}

  	if ( Object.assign === undefined ) {

  		// Missing in IE
  		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

  		( function () {

  			Object.assign = function ( target ) {

  				if ( target === undefined || target === null ) {

  					throw new TypeError( 'Cannot convert undefined or null to object' );

  				}

  				var output = Object( target );

  				for ( var index = 1; index < arguments.length; index ++ ) {

  					var source = arguments[ index ];

  					if ( source !== undefined && source !== null ) {

  						for ( var nextKey in source ) {

  							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

  								output[ nextKey ] = source[ nextKey ];

  							}

  						}

  					}

  				}

  				return output;

  			};

  		} )();

  	}

  	/**
  	 * https://github.com/mrdoob/eventdispatcher.js/
  	 */

  	function EventDispatcher() {}

  	Object.assign( EventDispatcher.prototype, {

  		addEventListener: function ( type, listener ) {

  			if ( this._listeners === undefined ) this._listeners = {};

  			var listeners = this._listeners;

  			if ( listeners[ type ] === undefined ) {

  				listeners[ type ] = [];

  			}

  			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

  				listeners[ type ].push( listener );

  			}

  		},

  		hasEventListener: function ( type, listener ) {

  			if ( this._listeners === undefined ) return false;

  			var listeners = this._listeners;

  			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

  		},

  		removeEventListener: function ( type, listener ) {

  			if ( this._listeners === undefined ) return;

  			var listeners = this._listeners;
  			var listenerArray = listeners[ type ];

  			if ( listenerArray !== undefined ) {

  				var index = listenerArray.indexOf( listener );

  				if ( index !== - 1 ) {

  					listenerArray.splice( index, 1 );

  				}

  			}

  		},

  		dispatchEvent: function ( event ) {

  			if ( this._listeners === undefined ) return;

  			var listeners = this._listeners;
  			var listenerArray = listeners[ event.type ];

  			if ( listenerArray !== undefined ) {

  				event.target = this;

  				var array = listenerArray.slice( 0 );

  				for ( var i = 0, l = array.length; i < l; i ++ ) {

  					array[ i ].call( this, event );

  				}

  			}

  		}

  	} );

  	var REVISION = '104';
  	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
  	var CullFaceNone = 0;
  	var CullFaceBack = 1;
  	var CullFaceFront = 2;
  	var CullFaceFrontBack = 3;
  	var FrontFaceDirectionCW = 0;
  	var FrontFaceDirectionCCW = 1;
  	var BasicShadowMap = 0;
  	var PCFShadowMap = 1;
  	var PCFSoftShadowMap = 2;
  	var FrontSide = 0;
  	var BackSide = 1;
  	var DoubleSide = 2;
  	var FlatShading = 1;
  	var SmoothShading = 2;
  	var NoColors = 0;
  	var FaceColors = 1;
  	var VertexColors = 2;
  	var NoBlending = 0;
  	var NormalBlending = 1;
  	var AdditiveBlending = 2;
  	var SubtractiveBlending = 3;
  	var MultiplyBlending = 4;
  	var CustomBlending = 5;
  	var AddEquation = 100;
  	var SubtractEquation = 101;
  	var ReverseSubtractEquation = 102;
  	var MinEquation = 103;
  	var MaxEquation = 104;
  	var ZeroFactor = 200;
  	var OneFactor = 201;
  	var SrcColorFactor = 202;
  	var OneMinusSrcColorFactor = 203;
  	var SrcAlphaFactor = 204;
  	var OneMinusSrcAlphaFactor = 205;
  	var DstAlphaFactor = 206;
  	var OneMinusDstAlphaFactor = 207;
  	var DstColorFactor = 208;
  	var OneMinusDstColorFactor = 209;
  	var SrcAlphaSaturateFactor = 210;
  	var NeverDepth = 0;
  	var AlwaysDepth = 1;
  	var LessDepth = 2;
  	var LessEqualDepth = 3;
  	var EqualDepth = 4;
  	var GreaterEqualDepth = 5;
  	var GreaterDepth = 6;
  	var NotEqualDepth = 7;
  	var MultiplyOperation = 0;
  	var MixOperation = 1;
  	var AddOperation = 2;
  	var NoToneMapping = 0;
  	var LinearToneMapping = 1;
  	var ReinhardToneMapping = 2;
  	var Uncharted2ToneMapping = 3;
  	var CineonToneMapping = 4;
  	var ACESFilmicToneMapping = 5;

  	var UVMapping = 300;
  	var CubeReflectionMapping = 301;
  	var CubeRefractionMapping = 302;
  	var EquirectangularReflectionMapping = 303;
  	var EquirectangularRefractionMapping = 304;
  	var SphericalReflectionMapping = 305;
  	var CubeUVReflectionMapping = 306;
  	var CubeUVRefractionMapping = 307;
  	var RepeatWrapping = 1000;
  	var ClampToEdgeWrapping = 1001;
  	var MirroredRepeatWrapping = 1002;
  	var NearestFilter = 1003;
  	var NearestMipMapNearestFilter = 1004;
  	var NearestMipMapLinearFilter = 1005;
  	var LinearFilter = 1006;
  	var LinearMipMapNearestFilter = 1007;
  	var LinearMipMapLinearFilter = 1008;
  	var UnsignedByteType = 1009;
  	var ByteType = 1010;
  	var ShortType = 1011;
  	var UnsignedShortType = 1012;
  	var IntType = 1013;
  	var UnsignedIntType = 1014;
  	var FloatType = 1015;
  	var HalfFloatType = 1016;
  	var UnsignedShort4444Type = 1017;
  	var UnsignedShort5551Type = 1018;
  	var UnsignedShort565Type = 1019;
  	var UnsignedInt248Type = 1020;
  	var AlphaFormat = 1021;
  	var RGBFormat = 1022;
  	var RGBAFormat = 1023;
  	var LuminanceFormat = 1024;
  	var LuminanceAlphaFormat = 1025;
  	var RGBEFormat = RGBAFormat;
  	var DepthFormat = 1026;
  	var DepthStencilFormat = 1027;
  	var RedFormat = 1028;
  	var RGB_S3TC_DXT1_Format = 33776;
  	var RGBA_S3TC_DXT1_Format = 33777;
  	var RGBA_S3TC_DXT3_Format = 33778;
  	var RGBA_S3TC_DXT5_Format = 33779;
  	var RGB_PVRTC_4BPPV1_Format = 35840;
  	var RGB_PVRTC_2BPPV1_Format = 35841;
  	var RGBA_PVRTC_4BPPV1_Format = 35842;
  	var RGBA_PVRTC_2BPPV1_Format = 35843;
  	var RGB_ETC1_Format = 36196;
  	var RGBA_ASTC_4x4_Format = 37808;
  	var RGBA_ASTC_5x4_Format = 37809;
  	var RGBA_ASTC_5x5_Format = 37810;
  	var RGBA_ASTC_6x5_Format = 37811;
  	var RGBA_ASTC_6x6_Format = 37812;
  	var RGBA_ASTC_8x5_Format = 37813;
  	var RGBA_ASTC_8x6_Format = 37814;
  	var RGBA_ASTC_8x8_Format = 37815;
  	var RGBA_ASTC_10x5_Format = 37816;
  	var RGBA_ASTC_10x6_Format = 37817;
  	var RGBA_ASTC_10x8_Format = 37818;
  	var RGBA_ASTC_10x10_Format = 37819;
  	var RGBA_ASTC_12x10_Format = 37820;
  	var RGBA_ASTC_12x12_Format = 37821;
  	var LoopOnce = 2200;
  	var LoopRepeat = 2201;
  	var LoopPingPong = 2202;
  	var InterpolateDiscrete = 2300;
  	var InterpolateLinear = 2301;
  	var InterpolateSmooth = 2302;
  	var ZeroCurvatureEnding = 2400;
  	var ZeroSlopeEnding = 2401;
  	var WrapAroundEnding = 2402;
  	var TrianglesDrawMode = 0;
  	var TriangleStripDrawMode = 1;
  	var TriangleFanDrawMode = 2;
  	var LinearEncoding = 3000;
  	var sRGBEncoding = 3001;
  	var GammaEncoding = 3007;
  	var RGBEEncoding = 3002;
  	var LogLuvEncoding = 3003;
  	var RGBM7Encoding = 3004;
  	var RGBM16Encoding = 3005;
  	var RGBDEncoding = 3006;
  	var BasicDepthPacking = 3200;
  	var RGBADepthPacking = 3201;
  	var TangentSpaceNormalMap = 0;
  	var ObjectSpaceNormalMap = 1;

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	var _Math = {

  		DEG2RAD: Math.PI / 180,
  		RAD2DEG: 180 / Math.PI,

  		generateUUID: ( function () {

  			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

  			var lut = [];

  			for ( var i = 0; i < 256; i ++ ) {

  				lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

  			}

  			return function generateUUID() {

  				var d0 = Math.random() * 0xffffffff | 0;
  				var d1 = Math.random() * 0xffffffff | 0;
  				var d2 = Math.random() * 0xffffffff | 0;
  				var d3 = Math.random() * 0xffffffff | 0;
  				var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
  					lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
  					lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
  					lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

  				// .toUpperCase() here flattens concatenated strings to save heap memory space.
  				return uuid.toUpperCase();

  			};

  		} )(),

  		clamp: function ( value, min, max ) {

  			return Math.max( min, Math.min( max, value ) );

  		},

  		// compute euclidian modulo of m % n
  		// https://en.wikipedia.org/wiki/Modulo_operation

  		euclideanModulo: function ( n, m ) {

  			return ( ( n % m ) + m ) % m;

  		},

  		// Linear mapping from range <a1, a2> to range <b1, b2>

  		mapLinear: function ( x, a1, a2, b1, b2 ) {

  			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  		},

  		// https://en.wikipedia.org/wiki/Linear_interpolation

  		lerp: function ( x, y, t ) {

  			return ( 1 - t ) * x + t * y;

  		},

  		// http://en.wikipedia.org/wiki/Smoothstep

  		smoothstep: function ( x, min, max ) {

  			if ( x <= min ) return 0;
  			if ( x >= max ) return 1;

  			x = ( x - min ) / ( max - min );

  			return x * x * ( 3 - 2 * x );

  		},

  		smootherstep: function ( x, min, max ) {

  			if ( x <= min ) return 0;
  			if ( x >= max ) return 1;

  			x = ( x - min ) / ( max - min );

  			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  		},

  		// Random integer from <low, high> interval

  		randInt: function ( low, high ) {

  			return low + Math.floor( Math.random() * ( high - low + 1 ) );

  		},

  		// Random float from <low, high> interval

  		randFloat: function ( low, high ) {

  			return low + Math.random() * ( high - low );

  		},

  		// Random float from <-range/2, range/2> interval

  		randFloatSpread: function ( range ) {

  			return range * ( 0.5 - Math.random() );

  		},

  		degToRad: function ( degrees ) {

  			return degrees * _Math.DEG2RAD;

  		},

  		radToDeg: function ( radians ) {

  			return radians * _Math.RAD2DEG;

  		},

  		isPowerOfTwo: function ( value ) {

  			return ( value & ( value - 1 ) ) === 0 && value !== 0;

  		},

  		ceilPowerOfTwo: function ( value ) {

  			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

  		},

  		floorPowerOfTwo: function ( value ) {

  			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

  		}

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author philogb / http://blog.thejit.org/
  	 * @author egraether / http://egraether.com/
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 */

  	function Vector2( x, y ) {

  		this.x = x || 0;
  		this.y = y || 0;

  	}

  	Object.defineProperties( Vector2.prototype, {

  		"width": {

  			get: function () {

  				return this.x;

  			},

  			set: function ( value ) {

  				this.x = value;

  			}

  		},

  		"height": {

  			get: function () {

  				return this.y;

  			},

  			set: function ( value ) {

  				this.y = value;

  			}

  		}

  	} );

  	Object.assign( Vector2.prototype, {

  		isVector2: true,

  		set: function ( x, y ) {

  			this.x = x;
  			this.y = y;

  			return this;

  		},

  		setScalar: function ( scalar ) {

  			this.x = scalar;
  			this.y = scalar;

  			return this;

  		},

  		setX: function ( x ) {

  			this.x = x;

  			return this;

  		},

  		setY: function ( y ) {

  			this.y = y;

  			return this;

  		},

  		setComponent: function ( index, value ) {

  			switch ( index ) {

  				case 0: this.x = value; break;
  				case 1: this.y = value; break;
  				default: throw new Error( 'index is out of range: ' + index );

  			}

  			return this;

  		},

  		getComponent: function ( index ) {

  			switch ( index ) {

  				case 0: return this.x;
  				case 1: return this.y;
  				default: throw new Error( 'index is out of range: ' + index );

  			}

  		},

  		clone: function () {

  			return new this.constructor( this.x, this.y );

  		},

  		copy: function ( v ) {

  			this.x = v.x;
  			this.y = v.y;

  			return this;

  		},

  		add: function ( v, w ) {

  			if ( w !== undefined ) {

  				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  				return this.addVectors( v, w );

  			}

  			this.x += v.x;
  			this.y += v.y;

  			return this;

  		},

  		addScalar: function ( s ) {

  			this.x += s;
  			this.y += s;

  			return this;

  		},

  		addVectors: function ( a, b ) {

  			this.x = a.x + b.x;
  			this.y = a.y + b.y;

  			return this;

  		},

  		addScaledVector: function ( v, s ) {

  			this.x += v.x * s;
  			this.y += v.y * s;

  			return this;

  		},

  		sub: function ( v, w ) {

  			if ( w !== undefined ) {

  				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  				return this.subVectors( v, w );

  			}

  			this.x -= v.x;
  			this.y -= v.y;

  			return this;

  		},

  		subScalar: function ( s ) {

  			this.x -= s;
  			this.y -= s;

  			return this;

  		},

  		subVectors: function ( a, b ) {

  			this.x = a.x - b.x;
  			this.y = a.y - b.y;

  			return this;

  		},

  		multiply: function ( v ) {

  			this.x *= v.x;
  			this.y *= v.y;

  			return this;

  		},

  		multiplyScalar: function ( scalar ) {

  			this.x *= scalar;
  			this.y *= scalar;

  			return this;

  		},

  		divide: function ( v ) {

  			this.x /= v.x;
  			this.y /= v.y;

  			return this;

  		},

  		divideScalar: function ( scalar ) {

  			return this.multiplyScalar( 1 / scalar );

  		},

  		applyMatrix3: function ( m ) {

  			var x = this.x, y = this.y;
  			var e = m.elements;

  			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
  			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

  			return this;

  		},

  		min: function ( v ) {

  			this.x = Math.min( this.x, v.x );
  			this.y = Math.min( this.y, v.y );

  			return this;

  		},

  		max: function ( v ) {

  			this.x = Math.max( this.x, v.x );
  			this.y = Math.max( this.y, v.y );

  			return this;

  		},

  		clamp: function ( min, max ) {

  			// assumes min < max, componentwise

  			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

  			return this;

  		},

  		clampScalar: function ( minVal, maxVal ) {

  			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

  			return this;

  		},

  		clampLength: function ( min, max ) {

  			var length = this.length();

  			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  		},

  		floor: function () {

  			this.x = Math.floor( this.x );
  			this.y = Math.floor( this.y );

  			return this;

  		},

  		ceil: function () {

  			this.x = Math.ceil( this.x );
  			this.y = Math.ceil( this.y );

  			return this;

  		},

  		round: function () {

  			this.x = Math.round( this.x );
  			this.y = Math.round( this.y );

  			return this;

  		},

  		roundToZero: function () {

  			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

  			return this;

  		},

  		negate: function () {

  			this.x = - this.x;
  			this.y = - this.y;

  			return this;

  		},

  		dot: function ( v ) {

  			return this.x * v.x + this.y * v.y;

  		},

  		cross: function ( v ) {

  			return this.x * v.y - this.y * v.x;

  		},

  		lengthSq: function () {

  			return this.x * this.x + this.y * this.y;

  		},

  		length: function () {

  			return Math.sqrt( this.x * this.x + this.y * this.y );

  		},

  		manhattanLength: function () {

  			return Math.abs( this.x ) + Math.abs( this.y );

  		},

  		normalize: function () {

  			return this.divideScalar( this.length() || 1 );

  		},

  		angle: function () {

  			// computes the angle in radians with respect to the positive x-axis

  			var angle = Math.atan2( this.y, this.x );

  			if ( angle < 0 ) angle += 2 * Math.PI;

  			return angle;

  		},

  		distanceTo: function ( v ) {

  			return Math.sqrt( this.distanceToSquared( v ) );

  		},

  		distanceToSquared: function ( v ) {

  			var dx = this.x - v.x, dy = this.y - v.y;
  			return dx * dx + dy * dy;

  		},

  		manhattanDistanceTo: function ( v ) {

  			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  		},

  		setLength: function ( length ) {

  			return this.normalize().multiplyScalar( length );

  		},

  		lerp: function ( v, alpha ) {

  			this.x += ( v.x - this.x ) * alpha;
  			this.y += ( v.y - this.y ) * alpha;

  			return this;

  		},

  		lerpVectors: function ( v1, v2, alpha ) {

  			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  		},

  		equals: function ( v ) {

  			return ( ( v.x === this.x ) && ( v.y === this.y ) );

  		},

  		fromArray: function ( array, offset ) {

  			if ( offset === undefined ) offset = 0;

  			this.x = array[ offset ];
  			this.y = array[ offset + 1 ];

  			return this;

  		},

  		toArray: function ( array, offset ) {

  			if ( array === undefined ) array = [];
  			if ( offset === undefined ) offset = 0;

  			array[ offset ] = this.x;
  			array[ offset + 1 ] = this.y;

  			return array;

  		},

  		fromBufferAttribute: function ( attribute, index, offset ) {

  			if ( offset !== undefined ) {

  				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

  			}

  			this.x = attribute.getX( index );
  			this.y = attribute.getY( index );

  			return this;

  		},

  		rotateAround: function ( center, angle ) {

  			var c = Math.cos( angle ), s = Math.sin( angle );

  			var x = this.x - center.x;
  			var y = this.y - center.y;

  			this.x = x * c - y * s + center.x;
  			this.y = x * s + y * c + center.y;

  			return this;

  		}

  	} );

  	/**
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 * @author bhouston / http://clara.io
  	 */

  	function Quaternion( x, y, z, w ) {

  		this._x = x || 0;
  		this._y = y || 0;
  		this._z = z || 0;
  		this._w = ( w !== undefined ) ? w : 1;

  	}

  	Object.assign( Quaternion, {

  		slerp: function ( qa, qb, qm, t ) {

  			return qm.copy( qa ).slerp( qb, t );

  		},

  		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  			// fuzz-free, array-based Quaternion SLERP operation

  			var x0 = src0[ srcOffset0 + 0 ],
  				y0 = src0[ srcOffset0 + 1 ],
  				z0 = src0[ srcOffset0 + 2 ],
  				w0 = src0[ srcOffset0 + 3 ],

  				x1 = src1[ srcOffset1 + 0 ],
  				y1 = src1[ srcOffset1 + 1 ],
  				z1 = src1[ srcOffset1 + 2 ],
  				w1 = src1[ srcOffset1 + 3 ];

  			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  				var s = 1 - t,

  					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

  					dir = ( cos >= 0 ? 1 : - 1 ),
  					sqrSin = 1 - cos * cos;

  				// Skip the Slerp for tiny steps to avoid numeric problems:
  				if ( sqrSin > Number.EPSILON ) {

  					var sin = Math.sqrt( sqrSin ),
  						len = Math.atan2( sin, cos * dir );

  					s = Math.sin( s * len ) / sin;
  					t = Math.sin( t * len ) / sin;

  				}

  				var tDir = t * dir;

  				x0 = x0 * s + x1 * tDir;
  				y0 = y0 * s + y1 * tDir;
  				z0 = z0 * s + z1 * tDir;
  				w0 = w0 * s + w1 * tDir;

  				// Normalize in case we just did a lerp:
  				if ( s === 1 - t ) {

  					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  					x0 *= f;
  					y0 *= f;
  					z0 *= f;
  					w0 *= f;

  				}

  			}

  			dst[ dstOffset ] = x0;
  			dst[ dstOffset + 1 ] = y0;
  			dst[ dstOffset + 2 ] = z0;
  			dst[ dstOffset + 3 ] = w0;

  		}

  	} );

  	Object.defineProperties( Quaternion.prototype, {

  		x: {

  			get: function () {

  				return this._x;

  			},

  			set: function ( value ) {

  				this._x = value;
  				this.onChangeCallback();

  			}

  		},

  		y: {

  			get: function () {

  				return this._y;

  			},

  			set: function ( value ) {

  				this._y = value;
  				this.onChangeCallback();

  			}

  		},

  		z: {

  			get: function () {

  				return this._z;

  			},

  			set: function ( value ) {

  				this._z = value;
  				this.onChangeCallback();

  			}

  		},

  		w: {

  			get: function () {

  				return this._w;

  			},

  			set: function ( value ) {

  				this._w = value;
  				this.onChangeCallback();

  			}

  		}

  	} );

  	Object.assign( Quaternion.prototype, {

  		isQuaternion: true,

  		set: function ( x, y, z, w ) {

  			this._x = x;
  			this._y = y;
  			this._z = z;
  			this._w = w;

  			this.onChangeCallback();

  			return this;

  		},

  		clone: function () {

  			return new this.constructor( this._x, this._y, this._z, this._w );

  		},

  		copy: function ( quaternion ) {

  			this._x = quaternion.x;
  			this._y = quaternion.y;
  			this._z = quaternion.z;
  			this._w = quaternion.w;

  			this.onChangeCallback();

  			return this;

  		},

  		setFromEuler: function ( euler, update ) {

  			if ( ! ( euler && euler.isEuler ) ) {

  				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  			}

  			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

  			// http://www.mathworks.com/matlabcentral/fileexchange/
  			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  			//	content/SpinCalc.m

  			var cos = Math.cos;
  			var sin = Math.sin;

  			var c1 = cos( x / 2 );
  			var c2 = cos( y / 2 );
  			var c3 = cos( z / 2 );

  			var s1 = sin( x / 2 );
  			var s2 = sin( y / 2 );
  			var s3 = sin( z / 2 );

  			if ( order === 'XYZ' ) {

  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;

  			} else if ( order === 'YXZ' ) {

  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;

  			} else if ( order === 'ZXY' ) {

  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;

  			} else if ( order === 'ZYX' ) {

  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;

  			} else if ( order === 'YZX' ) {

  				this._x = s1 * c2 * c3 + c1 * s2 * s3;
  				this._y = c1 * s2 * c3 + s1 * c2 * s3;
  				this._z = c1 * c2 * s3 - s1 * s2 * c3;
  				this._w = c1 * c2 * c3 - s1 * s2 * s3;

  			} else if ( order === 'XZY' ) {

  				this._x = s1 * c2 * c3 - c1 * s2 * s3;
  				this._y = c1 * s2 * c3 - s1 * c2 * s3;
  				this._z = c1 * c2 * s3 + s1 * s2 * c3;
  				this._w = c1 * c2 * c3 + s1 * s2 * s3;

  			}

  			if ( update !== false ) this.onChangeCallback();

  			return this;

  		},

  		setFromAxisAngle: function ( axis, angle ) {

  			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  			// assumes axis is normalized

  			var halfAngle = angle / 2, s = Math.sin( halfAngle );

  			this._x = axis.x * s;
  			this._y = axis.y * s;
  			this._z = axis.z * s;
  			this._w = Math.cos( halfAngle );

  			this.onChangeCallback();

  			return this;

  		},

  		setFromRotationMatrix: function ( m ) {

  			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  			var te = m.elements,

  				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  				trace = m11 + m22 + m33,
  				s;

  			if ( trace > 0 ) {

  				s = 0.5 / Math.sqrt( trace + 1.0 );

  				this._w = 0.25 / s;
  				this._x = ( m32 - m23 ) * s;
  				this._y = ( m13 - m31 ) * s;
  				this._z = ( m21 - m12 ) * s;

  			} else if ( m11 > m22 && m11 > m33 ) {

  				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  				this._w = ( m32 - m23 ) / s;
  				this._x = 0.25 * s;
  				this._y = ( m12 + m21 ) / s;
  				this._z = ( m13 + m31 ) / s;

  			} else if ( m22 > m33 ) {

  				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  				this._w = ( m13 - m31 ) / s;
  				this._x = ( m12 + m21 ) / s;
  				this._y = 0.25 * s;
  				this._z = ( m23 + m32 ) / s;

  			} else {

  				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  				this._w = ( m21 - m12 ) / s;
  				this._x = ( m13 + m31 ) / s;
  				this._y = ( m23 + m32 ) / s;
  				this._z = 0.25 * s;

  			}

  			this.onChangeCallback();

  			return this;

  		},

  		setFromUnitVectors: function ( vFrom, vTo ) {

  			// assumes direction vectors vFrom and vTo are normalized

  			var EPS = 0.000001;

  			var r = vFrom.dot( vTo ) + 1;

  			if ( r < EPS ) {

  				r = 0;

  				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  					this._x = - vFrom.y;
  					this._y = vFrom.x;
  					this._z = 0;
  					this._w = r;

  				} else {

  					this._x = 0;
  					this._y = - vFrom.z;
  					this._z = vFrom.y;
  					this._w = r;

  				}

  			} else {

  				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

  				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
  				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
  				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
  				this._w = r;

  			}

  			return this.normalize();

  		},

  		angleTo: function ( q ) {

  			return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );

  		},

  		rotateTowards: function ( q, step ) {

  			var angle = this.angleTo( q );

  			if ( angle === 0 ) return this;

  			var t = Math.min( 1, step / angle );

  			this.slerp( q, t );

  			return this;

  		},

  		inverse: function () {

  			// quaternion is assumed to have unit length

  			return this.conjugate();

  		},

  		conjugate: function () {

  			this._x *= - 1;
  			this._y *= - 1;
  			this._z *= - 1;

  			this.onChangeCallback();

  			return this;

  		},

  		dot: function ( v ) {

  			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  		},

  		lengthSq: function () {

  			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  		},

  		length: function () {

  			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  		},

  		normalize: function () {

  			var l = this.length();

  			if ( l === 0 ) {

  				this._x = 0;
  				this._y = 0;
  				this._z = 0;
  				this._w = 1;

  			} else {

  				l = 1 / l;

  				this._x = this._x * l;
  				this._y = this._y * l;
  				this._z = this._z * l;
  				this._w = this._w * l;

  			}

  			this.onChangeCallback();

  			return this;

  		},

  		multiply: function ( q, p ) {

  			if ( p !== undefined ) {

  				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
  				return this.multiplyQuaternions( q, p );

  			}

  			return this.multiplyQuaternions( this, q );

  		},

  		premultiply: function ( q ) {

  			return this.multiplyQuaternions( q, this );

  		},

  		multiplyQuaternions: function ( a, b ) {

  			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  			this.onChangeCallback();

  			return this;

  		},

  		slerp: function ( qb, t ) {

  			if ( t === 0 ) return this;
  			if ( t === 1 ) return this.copy( qb );

  			var x = this._x, y = this._y, z = this._z, w = this._w;

  			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  			if ( cosHalfTheta < 0 ) {

  				this._w = - qb._w;
  				this._x = - qb._x;
  				this._y = - qb._y;
  				this._z = - qb._z;

  				cosHalfTheta = - cosHalfTheta;

  			} else {

  				this.copy( qb );

  			}

  			if ( cosHalfTheta >= 1.0 ) {

  				this._w = w;
  				this._x = x;
  				this._y = y;
  				this._z = z;

  				return this;

  			}

  			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

  			if ( sqrSinHalfTheta <= Number.EPSILON ) {

  				var s = 1 - t;
  				this._w = s * w + t * this._w;
  				this._x = s * x + t * this._x;
  				this._y = s * y + t * this._y;
  				this._z = s * z + t * this._z;

  				return this.normalize();

  			}

  			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
  			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  			this._w = ( w * ratioA + this._w * ratioB );
  			this._x = ( x * ratioA + this._x * ratioB );
  			this._y = ( y * ratioA + this._y * ratioB );
  			this._z = ( z * ratioA + this._z * ratioB );

  			this.onChangeCallback();

  			return this;

  		},

  		equals: function ( quaternion ) {

  			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  		},

  		fromArray: function ( array, offset ) {

  			if ( offset === undefined ) offset = 0;

  			this._x = array[ offset ];
  			this._y = array[ offset + 1 ];
  			this._z = array[ offset + 2 ];
  			this._w = array[ offset + 3 ];

  			this.onChangeCallback();

  			return this;

  		},

  		toArray: function ( array, offset ) {

  			if ( array === undefined ) array = [];
  			if ( offset === undefined ) offset = 0;

  			array[ offset ] = this._x;
  			array[ offset + 1 ] = this._y;
  			array[ offset + 2 ] = this._z;
  			array[ offset + 3 ] = this._w;

  			return array;

  		},

  		onChange: function ( callback ) {

  			this.onChangeCallback = callback;

  			return this;

  		},

  		onChangeCallback: function () {}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author kile / http://kile.stravaganza.org/
  	 * @author philogb / http://blog.thejit.org/
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author egraether / http://egraether.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function Vector3( x, y, z ) {

  		this.x = x || 0;
  		this.y = y || 0;
  		this.z = z || 0;

  	}

  	Object.assign( Vector3.prototype, {

  		isVector3: true,

  		set: function ( x, y, z ) {

  			this.x = x;
  			this.y = y;
  			this.z = z;

  			return this;

  		},

  		setScalar: function ( scalar ) {

  			this.x = scalar;
  			this.y = scalar;
  			this.z = scalar;

  			return this;

  		},

  		setX: function ( x ) {

  			this.x = x;

  			return this;

  		},

  		setY: function ( y ) {

  			this.y = y;

  			return this;

  		},

  		setZ: function ( z ) {

  			this.z = z;

  			return this;

  		},

  		setComponent: function ( index, value ) {

  			switch ( index ) {

  				case 0: this.x = value; break;
  				case 1: this.y = value; break;
  				case 2: this.z = value; break;
  				default: throw new Error( 'index is out of range: ' + index );

  			}

  			return this;

  		},

  		getComponent: function ( index ) {

  			switch ( index ) {

  				case 0: return this.x;
  				case 1: return this.y;
  				case 2: return this.z;
  				default: throw new Error( 'index is out of range: ' + index );

  			}

  		},

  		clone: function () {

  			return new this.constructor( this.x, this.y, this.z );

  		},

  		copy: function ( v ) {

  			this.x = v.x;
  			this.y = v.y;
  			this.z = v.z;

  			return this;

  		},

  		add: function ( v, w ) {

  			if ( w !== undefined ) {

  				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  				return this.addVectors( v, w );

  			}

  			this.x += v.x;
  			this.y += v.y;
  			this.z += v.z;

  			return this;

  		},

  		addScalar: function ( s ) {

  			this.x += s;
  			this.y += s;
  			this.z += s;

  			return this;

  		},

  		addVectors: function ( a, b ) {

  			this.x = a.x + b.x;
  			this.y = a.y + b.y;
  			this.z = a.z + b.z;

  			return this;

  		},

  		addScaledVector: function ( v, s ) {

  			this.x += v.x * s;
  			this.y += v.y * s;
  			this.z += v.z * s;

  			return this;

  		},

  		sub: function ( v, w ) {

  			if ( w !== undefined ) {

  				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  				return this.subVectors( v, w );

  			}

  			this.x -= v.x;
  			this.y -= v.y;
  			this.z -= v.z;

  			return this;

  		},

  		subScalar: function ( s ) {

  			this.x -= s;
  			this.y -= s;
  			this.z -= s;

  			return this;

  		},

  		subVectors: function ( a, b ) {

  			this.x = a.x - b.x;
  			this.y = a.y - b.y;
  			this.z = a.z - b.z;

  			return this;

  		},

  		multiply: function ( v, w ) {

  			if ( w !== undefined ) {

  				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
  				return this.multiplyVectors( v, w );

  			}

  			this.x *= v.x;
  			this.y *= v.y;
  			this.z *= v.z;

  			return this;

  		},

  		multiplyScalar: function ( scalar ) {

  			this.x *= scalar;
  			this.y *= scalar;
  			this.z *= scalar;

  			return this;

  		},

  		multiplyVectors: function ( a, b ) {

  			this.x = a.x * b.x;
  			this.y = a.y * b.y;
  			this.z = a.z * b.z;

  			return this;

  		},

  		applyEuler: function () {

  			var quaternion = new Quaternion();

  			return function applyEuler( euler ) {

  				if ( ! ( euler && euler.isEuler ) ) {

  					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  				}

  				return this.applyQuaternion( quaternion.setFromEuler( euler ) );

  			};

  		}(),

  		applyAxisAngle: function () {

  			var quaternion = new Quaternion();

  			return function applyAxisAngle( axis, angle ) {

  				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

  			};

  		}(),

  		applyMatrix3: function ( m ) {

  			var x = this.x, y = this.y, z = this.z;
  			var e = m.elements;

  			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  			return this;

  		},

  		applyMatrix4: function ( m ) {

  			var x = this.x, y = this.y, z = this.z;
  			var e = m.elements;

  			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

  			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
  			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
  			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

  			return this;

  		},

  		applyQuaternion: function ( q ) {

  			var x = this.x, y = this.y, z = this.z;
  			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  			// calculate quat * vector

  			var ix = qw * x + qy * z - qz * y;
  			var iy = qw * y + qz * x - qx * z;
  			var iz = qw * z + qx * y - qy * x;
  			var iw = - qx * x - qy * y - qz * z;

  			// calculate result * inverse quat

  			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
  			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
  			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

  			return this;

  		},

  		project: function ( camera ) {

  			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

  		},

  		unproject: function ( camera ) {

  			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

  		},

  		transformDirection: function ( m ) {

  			// input: THREE.Matrix4 affine matrix
  			// vector interpreted as a direction

  			var x = this.x, y = this.y, z = this.z;
  			var e = m.elements;

  			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
  			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
  			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  			return this.normalize();

  		},

  		divide: function ( v ) {

  			this.x /= v.x;
  			this.y /= v.y;
  			this.z /= v.z;

  			return this;

  		},

  		divideScalar: function ( scalar ) {

  			return this.multiplyScalar( 1 / scalar );

  		},

  		min: function ( v ) {

  			this.x = Math.min( this.x, v.x );
  			this.y = Math.min( this.y, v.y );
  			this.z = Math.min( this.z, v.z );

  			return this;

  		},

  		max: function ( v ) {

  			this.x = Math.max( this.x, v.x );
  			this.y = Math.max( this.y, v.y );
  			this.z = Math.max( this.z, v.z );

  			return this;

  		},

  		clamp: function ( min, max ) {

  			// assumes min < max, componentwise

  			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

  			return this;

  		},

  		clampScalar: function ( minVal, maxVal ) {

  			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
  			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
  			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

  			return this;

  		},

  		clampLength: function ( min, max ) {

  			var length = this.length();

  			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  		},

  		floor: function () {

  			this.x = Math.floor( this.x );
  			this.y = Math.floor( this.y );
  			this.z = Math.floor( this.z );

  			return this;

  		},

  		ceil: function () {

  			this.x = Math.ceil( this.x );
  			this.y = Math.ceil( this.y );
  			this.z = Math.ceil( this.z );

  			return this;

  		},

  		round: function () {

  			this.x = Math.round( this.x );
  			this.y = Math.round( this.y );
  			this.z = Math.round( this.z );

  			return this;

  		},

  		roundToZero: function () {

  			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

  			return this;

  		},

  		negate: function () {

  			this.x = - this.x;
  			this.y = - this.y;
  			this.z = - this.z;

  			return this;

  		},

  		dot: function ( v ) {

  			return this.x * v.x + this.y * v.y + this.z * v.z;

  		},

  		// TODO lengthSquared?

  		lengthSq: function () {

  			return this.x * this.x + this.y * this.y + this.z * this.z;

  		},

  		length: function () {

  			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  		},

  		manhattanLength: function () {

  			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  		},

  		normalize: function () {

  			return this.divideScalar( this.length() || 1 );

  		},

  		setLength: function ( length ) {

  			return this.normalize().multiplyScalar( length );

  		},

  		lerp: function ( v, alpha ) {

  			this.x += ( v.x - this.x ) * alpha;
  			this.y += ( v.y - this.y ) * alpha;
  			this.z += ( v.z - this.z ) * alpha;

  			return this;

  		},

  		lerpVectors: function ( v1, v2, alpha ) {

  			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  		},

  		cross: function ( v, w ) {

  			if ( w !== undefined ) {

  				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
  				return this.crossVectors( v, w );

  			}

  			return this.crossVectors( this, v );

  		},

  		crossVectors: function ( a, b ) {

  			var ax = a.x, ay = a.y, az = a.z;
  			var bx = b.x, by = b.y, bz = b.z;

  			this.x = ay * bz - az * by;
  			this.y = az * bx - ax * bz;
  			this.z = ax * by - ay * bx;

  			return this;

  		},

  		projectOnVector: function ( vector ) {

  			var scalar = vector.dot( this ) / vector.lengthSq();

  			return this.copy( vector ).multiplyScalar( scalar );

  		},

  		projectOnPlane: function () {

  			var v1 = new Vector3();

  			return function projectOnPlane( planeNormal ) {

  				v1.copy( this ).projectOnVector( planeNormal );

  				return this.sub( v1 );

  			};

  		}(),

  		reflect: function () {

  			// reflect incident vector off plane orthogonal to normal
  			// normal is assumed to have unit length

  			var v1 = new Vector3();

  			return function reflect( normal ) {

  				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  			};

  		}(),

  		angleTo: function ( v ) {

  			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

  			// clamp, to handle numerical problems

  			return Math.acos( _Math.clamp( theta, - 1, 1 ) );

  		},

  		distanceTo: function ( v ) {

  			return Math.sqrt( this.distanceToSquared( v ) );

  		},

  		distanceToSquared: function ( v ) {

  			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  			return dx * dx + dy * dy + dz * dz;

  		},

  		manhattanDistanceTo: function ( v ) {

  			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  		},

  		setFromSpherical: function ( s ) {

  			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

  		},

  		setFromSphericalCoords: function ( radius, phi, theta ) {

  			var sinPhiRadius = Math.sin( phi ) * radius;

  			this.x = sinPhiRadius * Math.sin( theta );
  			this.y = Math.cos( phi ) * radius;
  			this.z = sinPhiRadius * Math.cos( theta );

  			return this;

  		},

  		setFromCylindrical: function ( c ) {

  			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

  		},

  		setFromCylindricalCoords: function ( radius, theta, y ) {

  			this.x = radius * Math.sin( theta );
  			this.y = y;
  			this.z = radius * Math.cos( theta );

  			return this;

  		},

  		setFromMatrixPosition: function ( m ) {

  			var e = m.elements;

  			this.x = e[ 12 ];
  			this.y = e[ 13 ];
  			this.z = e[ 14 ];

  			return this;

  		},

  		setFromMatrixScale: function ( m ) {

  			var sx = this.setFromMatrixColumn( m, 0 ).length();
  			var sy = this.setFromMatrixColumn( m, 1 ).length();
  			var sz = this.setFromMatrixColumn( m, 2 ).length();

  			this.x = sx;
  			this.y = sy;
  			this.z = sz;

  			return this;

  		},

  		setFromMatrixColumn: function ( m, index ) {

  			return this.fromArray( m.elements, index * 4 );

  		},

  		equals: function ( v ) {

  			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  		},

  		fromArray: function ( array, offset ) {

  			if ( offset === undefined ) offset = 0;

  			this.x = array[ offset ];
  			this.y = array[ offset + 1 ];
  			this.z = array[ offset + 2 ];

  			return this;

  		},

  		toArray: function ( array, offset ) {

  			if ( array === undefined ) array = [];
  			if ( offset === undefined ) offset = 0;

  			array[ offset ] = this.x;
  			array[ offset + 1 ] = this.y;
  			array[ offset + 2 ] = this.z;

  			return array;

  		},

  		fromBufferAttribute: function ( attribute, index, offset ) {

  			if ( offset !== undefined ) {

  				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

  			}

  			this.x = attribute.getX( index );
  			this.y = attribute.getY( index );
  			this.z = attribute.getZ( index );

  			return this;

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 * @author bhouston / http://clara.io
  	 * @author tschw
  	 */

  	function Matrix3() {

  		this.elements = [

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		];

  		if ( arguments.length > 0 ) {

  			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  		}

  	}

  	Object.assign( Matrix3.prototype, {

  		isMatrix3: true,

  		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  			var te = this.elements;

  			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  			return this;

  		},

  		identity: function () {

  			this.set(

  				1, 0, 0,
  				0, 1, 0,
  				0, 0, 1

  			);

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().fromArray( this.elements );

  		},

  		copy: function ( m ) {

  			var te = this.elements;
  			var me = m.elements;

  			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  			return this;

  		},

  		setFromMatrix4: function ( m ) {

  			var me = m.elements;

  			this.set(

  				me[ 0 ], me[ 4 ], me[ 8 ],
  				me[ 1 ], me[ 5 ], me[ 9 ],
  				me[ 2 ], me[ 6 ], me[ 10 ]

  			);

  			return this;

  		},

  		applyToBufferAttribute: function () {

  			var v1 = new Vector3();

  			return function applyToBufferAttribute( attribute ) {

  				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  					v1.x = attribute.getX( i );
  					v1.y = attribute.getY( i );
  					v1.z = attribute.getZ( i );

  					v1.applyMatrix3( this );

  					attribute.setXYZ( i, v1.x, v1.y, v1.z );

  				}

  				return attribute;

  			};

  		}(),

  		multiply: function ( m ) {

  			return this.multiplyMatrices( this, m );

  		},

  		premultiply: function ( m ) {

  			return this.multiplyMatrices( m, this );

  		},

  		multiplyMatrices: function ( a, b ) {

  			var ae = a.elements;
  			var be = b.elements;
  			var te = this.elements;

  			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  			return this;

  		},

  		multiplyScalar: function ( s ) {

  			var te = this.elements;

  			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  			return this;

  		},

  		determinant: function () {

  			var te = this.elements;

  			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  		},

  		getInverse: function ( matrix, throwOnDegenerate ) {

  			if ( matrix && matrix.isMatrix4 ) {

  				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

  			}

  			var me = matrix.elements,
  				te = this.elements,

  				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
  				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
  				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

  				t11 = n33 * n22 - n32 * n23,
  				t12 = n32 * n13 - n33 * n12,
  				t13 = n23 * n12 - n22 * n13,

  				det = n11 * t11 + n21 * t12 + n31 * t13;

  			if ( det === 0 ) {

  				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

  				if ( throwOnDegenerate === true ) {

  					throw new Error( msg );

  				} else {

  					console.warn( msg );

  				}

  				return this.identity();

  			}

  			var detInv = 1 / det;

  			te[ 0 ] = t11 * detInv;
  			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  			te[ 3 ] = t12 * detInv;
  			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  			te[ 6 ] = t13 * detInv;
  			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  			return this;

  		},

  		transpose: function () {

  			var tmp, m = this.elements;

  			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  			return this;

  		},

  		getNormalMatrix: function ( matrix4 ) {

  			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

  		},

  		transposeIntoArray: function ( r ) {

  			var m = this.elements;

  			r[ 0 ] = m[ 0 ];
  			r[ 1 ] = m[ 3 ];
  			r[ 2 ] = m[ 6 ];
  			r[ 3 ] = m[ 1 ];
  			r[ 4 ] = m[ 4 ];
  			r[ 5 ] = m[ 7 ];
  			r[ 6 ] = m[ 2 ];
  			r[ 7 ] = m[ 5 ];
  			r[ 8 ] = m[ 8 ];

  			return this;

  		},

  		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

  			var c = Math.cos( rotation );
  			var s = Math.sin( rotation );

  			this.set(
  				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
  				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
  				0, 0, 1
  			);

  		},

  		scale: function ( sx, sy ) {

  			var te = this.elements;

  			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
  			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

  			return this;

  		},

  		rotate: function ( theta ) {

  			var c = Math.cos( theta );
  			var s = Math.sin( theta );

  			var te = this.elements;

  			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
  			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

  			te[ 0 ] = c * a11 + s * a21;
  			te[ 3 ] = c * a12 + s * a22;
  			te[ 6 ] = c * a13 + s * a23;

  			te[ 1 ] = - s * a11 + c * a21;
  			te[ 4 ] = - s * a12 + c * a22;
  			te[ 7 ] = - s * a13 + c * a23;

  			return this;

  		},

  		translate: function ( tx, ty ) {

  			var te = this.elements;

  			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
  			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

  			return this;

  		},

  		equals: function ( matrix ) {

  			var te = this.elements;
  			var me = matrix.elements;

  			for ( var i = 0; i < 9; i ++ ) {

  				if ( te[ i ] !== me[ i ] ) return false;

  			}

  			return true;

  		},

  		fromArray: function ( array, offset ) {

  			if ( offset === undefined ) offset = 0;

  			for ( var i = 0; i < 9; i ++ ) {

  				this.elements[ i ] = array[ i + offset ];

  			}

  			return this;

  		},

  		toArray: function ( array, offset ) {

  			if ( array === undefined ) array = [];
  			if ( offset === undefined ) offset = 0;

  			var te = this.elements;

  			array[ offset ] = te[ 0 ];
  			array[ offset + 1 ] = te[ 1 ];
  			array[ offset + 2 ] = te[ 2 ];

  			array[ offset + 3 ] = te[ 3 ];
  			array[ offset + 4 ] = te[ 4 ];
  			array[ offset + 5 ] = te[ 5 ];

  			array[ offset + 6 ] = te[ 6 ];
  			array[ offset + 7 ] = te[ 7 ];
  			array[ offset + 8 ] = te[ 8 ];

  			return array;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author szimek / https://github.com/szimek/
  	 */

  	var _canvas;

  	var ImageUtils = {

  		getDataURL: function ( image ) {

  			var canvas;

  			if ( typeof HTMLCanvasElement == 'undefined' ) {

  				return image.src;

  			} else if ( image instanceof HTMLCanvasElement ) {

  				canvas = image;

  			} else {

  				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

  				_canvas.width = image.width;
  				_canvas.height = image.height;

  				var context = _canvas.getContext( '2d' );

  				if ( image instanceof ImageData ) {

  					context.putImageData( image, 0, 0 );

  				} else {

  					context.drawImage( image, 0, 0, image.width, image.height );

  				}

  				canvas = _canvas;

  			}

  			if ( canvas.width > 2048 || canvas.height > 2048 ) {

  				return canvas.toDataURL( 'image/jpeg', 0.6 );

  			} else {

  				return canvas.toDataURL( 'image/png' );

  			}

  		}

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author szimek / https://github.com/szimek/
  	 */

  	var textureId = 0;

  	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  		Object.defineProperty( this, 'id', { value: textureId ++ } );

  		this.uuid = _Math.generateUUID();

  		this.name = '';

  		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
  		this.mipmaps = [];

  		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

  		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
  		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

  		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

  		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  		this.format = format !== undefined ? format : RGBAFormat;
  		this.type = type !== undefined ? type : UnsignedByteType;

  		this.offset = new Vector2( 0, 0 );
  		this.repeat = new Vector2( 1, 1 );
  		this.center = new Vector2( 0, 0 );
  		this.rotation = 0;

  		this.matrixAutoUpdate = true;
  		this.matrix = new Matrix3();

  		this.generateMipmaps = true;
  		this.premultiplyAlpha = false;
  		this.flipY = true;
  		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  		//
  		// Also changing the encoding after already used by a Material will not automatically make the Material
  		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
  		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

  		this.version = 0;
  		this.onUpdate = null;

  	}

  	Texture.DEFAULT_IMAGE = undefined;
  	Texture.DEFAULT_MAPPING = UVMapping;

  	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  		constructor: Texture,

  		isTexture: true,

  		updateMatrix: function () {

  			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( source ) {

  			this.name = source.name;

  			this.image = source.image;
  			this.mipmaps = source.mipmaps.slice( 0 );

  			this.mapping = source.mapping;

  			this.wrapS = source.wrapS;
  			this.wrapT = source.wrapT;

  			this.magFilter = source.magFilter;
  			this.minFilter = source.minFilter;

  			this.anisotropy = source.anisotropy;

  			this.format = source.format;
  			this.type = source.type;

  			this.offset.copy( source.offset );
  			this.repeat.copy( source.repeat );
  			this.center.copy( source.center );
  			this.rotation = source.rotation;

  			this.matrixAutoUpdate = source.matrixAutoUpdate;
  			this.matrix.copy( source.matrix );

  			this.generateMipmaps = source.generateMipmaps;
  			this.premultiplyAlpha = source.premultiplyAlpha;
  			this.flipY = source.flipY;
  			this.unpackAlignment = source.unpackAlignment;
  			this.encoding = source.encoding;

  			return this;

  		},

  		toJSON: function ( meta ) {

  			var isRootObject = ( meta === undefined || typeof meta === 'string' );

  			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

  				return meta.textures[ this.uuid ];

  			}

  			var output = {

  				metadata: {
  					version: 4.5,
  					type: 'Texture',
  					generator: 'Texture.toJSON'
  				},

  				uuid: this.uuid,
  				name: this.name,

  				mapping: this.mapping,

  				repeat: [ this.repeat.x, this.repeat.y ],
  				offset: [ this.offset.x, this.offset.y ],
  				center: [ this.center.x, this.center.y ],
  				rotation: this.rotation,

  				wrap: [ this.wrapS, this.wrapT ],

  				format: this.format,
  				type: this.type,
  				encoding: this.encoding,

  				minFilter: this.minFilter,
  				magFilter: this.magFilter,
  				anisotropy: this.anisotropy,

  				flipY: this.flipY,

  				premultiplyAlpha: this.premultiplyAlpha,
  				unpackAlignment: this.unpackAlignment

  			};

  			if ( this.image !== undefined ) {

  				// TODO: Move to THREE.Image

  				var image = this.image;

  				if ( image.uuid === undefined ) {

  					image.uuid = _Math.generateUUID(); // UGH

  				}

  				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

  					var url;

  					if ( Array.isArray( image ) ) {

  						// process array of images e.g. CubeTexture

  						url = [];

  						for ( var i = 0, l = image.length; i < l; i ++ ) {

  							url.push( ImageUtils.getDataURL( image[ i ] ) );

  						}

  					} else {

  						// process single image

  						url = ImageUtils.getDataURL( image );

  					}

  					meta.images[ image.uuid ] = {
  						uuid: image.uuid,
  						url: url
  					};

  				}

  				output.image = image.uuid;

  			}

  			if ( ! isRootObject ) {

  				meta.textures[ this.uuid ] = output;

  			}

  			return output;

  		},

  		dispose: function () {

  			this.dispatchEvent( { type: 'dispose' } );

  		},

  		transformUv: function ( uv ) {

  			if ( this.mapping !== UVMapping ) return uv;

  			uv.applyMatrix3( this.matrix );

  			if ( uv.x < 0 || uv.x > 1 ) {

  				switch ( this.wrapS ) {

  					case RepeatWrapping:

  						uv.x = uv.x - Math.floor( uv.x );
  						break;

  					case ClampToEdgeWrapping:

  						uv.x = uv.x < 0 ? 0 : 1;
  						break;

  					case MirroredRepeatWrapping:

  						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  							uv.x = Math.ceil( uv.x ) - uv.x;

  						} else {

  							uv.x = uv.x - Math.floor( uv.x );

  						}
  						break;

  				}

  			}

  			if ( uv.y < 0 || uv.y > 1 ) {

  				switch ( this.wrapT ) {

  					case RepeatWrapping:

  						uv.y = uv.y - Math.floor( uv.y );
  						break;

  					case ClampToEdgeWrapping:

  						uv.y = uv.y < 0 ? 0 : 1;
  						break;

  					case MirroredRepeatWrapping:

  						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  							uv.y = Math.ceil( uv.y ) - uv.y;

  						} else {

  							uv.y = uv.y - Math.floor( uv.y );

  						}
  						break;

  				}

  			}

  			if ( this.flipY ) {

  				uv.y = 1 - uv.y;

  			}

  			return uv;

  		}

  	} );

  	Object.defineProperty( Texture.prototype, "needsUpdate", {

  		set: function ( value ) {

  			if ( value === true ) this.version ++;

  		}

  	} );

  	/**
  	 * @author supereggbert / http://www.paulbrunt.co.uk/
  	 * @author philogb / http://blog.thejit.org/
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author egraether / http://egraether.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function Vector4( x, y, z, w ) {

  		this.x = x || 0;
  		this.y = y || 0;
  		this.z = z || 0;
  		this.w = ( w !== undefined ) ? w : 1;

  	}

  	Object.assign( Vector4.prototype, {

  		isVector4: true,

  		set: function ( x, y, z, w ) {

  			this.x = x;
  			this.y = y;
  			this.z = z;
  			this.w = w;

  			return this;

  		},

  		setScalar: function ( scalar ) {

  			this.x = scalar;
  			this.y = scalar;
  			this.z = scalar;
  			this.w = scalar;

  			return this;

  		},

  		setX: function ( x ) {

  			this.x = x;

  			return this;

  		},

  		setY: function ( y ) {

  			this.y = y;

  			return this;

  		},

  		setZ: function ( z ) {

  			this.z = z;

  			return this;

  		},

  		setW: function ( w ) {

  			this.w = w;

  			return this;

  		},

  		setComponent: function ( index, value ) {

  			switch ( index ) {

  				case 0: this.x = value; break;
  				case 1: this.y = value; break;
  				case 2: this.z = value; break;
  				case 3: this.w = value; break;
  				default: throw new Error( 'index is out of range: ' + index );

  			}

  			return this;

  		},

  		getComponent: function ( index ) {

  			switch ( index ) {

  				case 0: return this.x;
  				case 1: return this.y;
  				case 2: return this.z;
  				case 3: return this.w;
  				default: throw new Error( 'index is out of range: ' + index );

  			}

  		},

  		clone: function () {

  			return new this.constructor( this.x, this.y, this.z, this.w );

  		},

  		copy: function ( v ) {

  			this.x = v.x;
  			this.y = v.y;
  			this.z = v.z;
  			this.w = ( v.w !== undefined ) ? v.w : 1;

  			return this;

  		},

  		add: function ( v, w ) {

  			if ( w !== undefined ) {

  				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  				return this.addVectors( v, w );

  			}

  			this.x += v.x;
  			this.y += v.y;
  			this.z += v.z;
  			this.w += v.w;

  			return this;

  		},

  		addScalar: function ( s ) {

  			this.x += s;
  			this.y += s;
  			this.z += s;
  			this.w += s;

  			return this;

  		},

  		addVectors: function ( a, b ) {

  			this.x = a.x + b.x;
  			this.y = a.y + b.y;
  			this.z = a.z + b.z;
  			this.w = a.w + b.w;

  			return this;

  		},

  		addScaledVector: function ( v, s ) {

  			this.x += v.x * s;
  			this.y += v.y * s;
  			this.z += v.z * s;
  			this.w += v.w * s;

  			return this;

  		},

  		sub: function ( v, w ) {

  			if ( w !== undefined ) {

  				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  				return this.subVectors( v, w );

  			}

  			this.x -= v.x;
  			this.y -= v.y;
  			this.z -= v.z;
  			this.w -= v.w;

  			return this;

  		},

  		subScalar: function ( s ) {

  			this.x -= s;
  			this.y -= s;
  			this.z -= s;
  			this.w -= s;

  			return this;

  		},

  		subVectors: function ( a, b ) {

  			this.x = a.x - b.x;
  			this.y = a.y - b.y;
  			this.z = a.z - b.z;
  			this.w = a.w - b.w;

  			return this;

  		},

  		multiplyScalar: function ( scalar ) {

  			this.x *= scalar;
  			this.y *= scalar;
  			this.z *= scalar;
  			this.w *= scalar;

  			return this;

  		},

  		applyMatrix4: function ( m ) {

  			var x = this.x, y = this.y, z = this.z, w = this.w;
  			var e = m.elements;

  			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  			return this;

  		},

  		divideScalar: function ( scalar ) {

  			return this.multiplyScalar( 1 / scalar );

  		},

  		setAxisAngleFromQuaternion: function ( q ) {

  			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  			// q is assumed to be normalized

  			this.w = 2 * Math.acos( q.w );

  			var s = Math.sqrt( 1 - q.w * q.w );

  			if ( s < 0.0001 ) {

  				this.x = 1;
  				this.y = 0;
  				this.z = 0;

  			} else {

  				this.x = q.x / s;
  				this.y = q.y / s;
  				this.z = q.z / s;

  			}

  			return this;

  		},

  		setAxisAngleFromRotationMatrix: function ( m ) {

  			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  			var angle, x, y, z,		// variables for result
  				epsilon = 0.01,		// margin to allow for rounding errors
  				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  				te = m.elements,

  				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  			     ( Math.abs( m13 - m31 ) < epsilon ) &&
  			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  				// singularity found
  				// first check for identity matrix which must have +1 for all terms
  				// in leading diagonal and zero in other terms

  				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  					// this singularity is identity matrix so angle = 0

  					this.set( 1, 0, 0, 0 );

  					return this; // zero angle, arbitrary axis

  				}

  				// otherwise this singularity is angle = 180

  				angle = Math.PI;

  				var xx = ( m11 + 1 ) / 2;
  				var yy = ( m22 + 1 ) / 2;
  				var zz = ( m33 + 1 ) / 2;
  				var xy = ( m12 + m21 ) / 4;
  				var xz = ( m13 + m31 ) / 4;
  				var yz = ( m23 + m32 ) / 4;

  				if ( ( xx > yy ) && ( xx > zz ) ) {

  					// m11 is the largest diagonal term

  					if ( xx < epsilon ) {

  						x = 0;
  						y = 0.707106781;
  						z = 0.707106781;

  					} else {

  						x = Math.sqrt( xx );
  						y = xy / x;
  						z = xz / x;

  					}

  				} else if ( yy > zz ) {

  					// m22 is the largest diagonal term

  					if ( yy < epsilon ) {

  						x = 0.707106781;
  						y = 0;
  						z = 0.707106781;

  					} else {

  						y = Math.sqrt( yy );
  						x = xy / y;
  						z = yz / y;

  					}

  				} else {

  					// m33 is the largest diagonal term so base result on this

  					if ( zz < epsilon ) {

  						x = 0.707106781;
  						y = 0.707106781;
  						z = 0;

  					} else {

  						z = Math.sqrt( zz );
  						x = xz / z;
  						y = yz / z;

  					}

  				}

  				this.set( x, y, z, angle );

  				return this; // return 180 deg rotation

  			}

  			// as we have reached here there are no singularities so we can handle normally

  			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  			                   ( m13 - m31 ) * ( m13 - m31 ) +
  			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  			if ( Math.abs( s ) < 0.001 ) s = 1;

  			// prevent divide by zero, should not happen if matrix is orthogonal and should be
  			// caught by singularity test above, but I've left it in just in case

  			this.x = ( m32 - m23 ) / s;
  			this.y = ( m13 - m31 ) / s;
  			this.z = ( m21 - m12 ) / s;
  			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  			return this;

  		},

  		min: function ( v ) {

  			this.x = Math.min( this.x, v.x );
  			this.y = Math.min( this.y, v.y );
  			this.z = Math.min( this.z, v.z );
  			this.w = Math.min( this.w, v.w );

  			return this;

  		},

  		max: function ( v ) {

  			this.x = Math.max( this.x, v.x );
  			this.y = Math.max( this.y, v.y );
  			this.z = Math.max( this.z, v.z );
  			this.w = Math.max( this.w, v.w );

  			return this;

  		},

  		clamp: function ( min, max ) {

  			// assumes min < max, componentwise

  			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
  			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

  			return this;

  		},

  		clampScalar: function () {

  			var min, max;

  			return function clampScalar( minVal, maxVal ) {

  				if ( min === undefined ) {

  					min = new Vector4();
  					max = new Vector4();

  				}

  				min.set( minVal, minVal, minVal, minVal );
  				max.set( maxVal, maxVal, maxVal, maxVal );

  				return this.clamp( min, max );

  			};

  		}(),

  		clampLength: function ( min, max ) {

  			var length = this.length();

  			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

  		},

  		floor: function () {

  			this.x = Math.floor( this.x );
  			this.y = Math.floor( this.y );
  			this.z = Math.floor( this.z );
  			this.w = Math.floor( this.w );

  			return this;

  		},

  		ceil: function () {

  			this.x = Math.ceil( this.x );
  			this.y = Math.ceil( this.y );
  			this.z = Math.ceil( this.z );
  			this.w = Math.ceil( this.w );

  			return this;

  		},

  		round: function () {

  			this.x = Math.round( this.x );
  			this.y = Math.round( this.y );
  			this.z = Math.round( this.z );
  			this.w = Math.round( this.w );

  			return this;

  		},

  		roundToZero: function () {

  			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
  			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

  			return this;

  		},

  		negate: function () {

  			this.x = - this.x;
  			this.y = - this.y;
  			this.z = - this.z;
  			this.w = - this.w;

  			return this;

  		},

  		dot: function ( v ) {

  			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  		},

  		lengthSq: function () {

  			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  		},

  		length: function () {

  			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  		},

  		manhattanLength: function () {

  			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  		},

  		normalize: function () {

  			return this.divideScalar( this.length() || 1 );

  		},

  		setLength: function ( length ) {

  			return this.normalize().multiplyScalar( length );

  		},

  		lerp: function ( v, alpha ) {

  			this.x += ( v.x - this.x ) * alpha;
  			this.y += ( v.y - this.y ) * alpha;
  			this.z += ( v.z - this.z ) * alpha;
  			this.w += ( v.w - this.w ) * alpha;

  			return this;

  		},

  		lerpVectors: function ( v1, v2, alpha ) {

  			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  		},

  		equals: function ( v ) {

  			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  		},

  		fromArray: function ( array, offset ) {

  			if ( offset === undefined ) offset = 0;

  			this.x = array[ offset ];
  			this.y = array[ offset + 1 ];
  			this.z = array[ offset + 2 ];
  			this.w = array[ offset + 3 ];

  			return this;

  		},

  		toArray: function ( array, offset ) {

  			if ( array === undefined ) array = [];
  			if ( offset === undefined ) offset = 0;

  			array[ offset ] = this.x;
  			array[ offset + 1 ] = this.y;
  			array[ offset + 2 ] = this.z;
  			array[ offset + 3 ] = this.w;

  			return array;

  		},

  		fromBufferAttribute: function ( attribute, index, offset ) {

  			if ( offset !== undefined ) {

  				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

  			}

  			this.x = attribute.getX( index );
  			this.y = attribute.getY( index );
  			this.z = attribute.getZ( index );
  			this.w = attribute.getW( index );

  			return this;

  		}

  	} );

  	/**
  	 * @author szimek / https://github.com/szimek/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author Marius Kintel / https://github.com/kintel
  	 */

  	/*
  	 In options, we can specify:
  	 * Texture parameters for an auto-generated target texture
  	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  	*/
  	function WebGLRenderTarget( width, height, options ) {

  		this.width = width;
  		this.height = height;

  		this.scissor = new Vector4( 0, 0, width, height );
  		this.scissorTest = false;

  		this.viewport = new Vector4( 0, 0, width, height );

  		options = options || {};

  		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

  		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

  		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

  	}

  	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  		constructor: WebGLRenderTarget,

  		isWebGLRenderTarget: true,

  		setSize: function ( width, height ) {

  			if ( this.width !== width || this.height !== height ) {

  				this.width = width;
  				this.height = height;

  				this.dispose();

  			}

  			this.viewport.set( 0, 0, width, height );
  			this.scissor.set( 0, 0, width, height );

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( source ) {

  			this.width = source.width;
  			this.height = source.height;

  			this.viewport.copy( source.viewport );

  			this.texture = source.texture.clone();

  			this.depthBuffer = source.depthBuffer;
  			this.stencilBuffer = source.stencilBuffer;
  			this.depthTexture = source.depthTexture;

  			return this;

  		},

  		dispose: function () {

  			this.dispatchEvent( { type: 'dispose' } );

  		}

  	} );

  	/**
  	 * @author Mugen87 / https://github.com/Mugen87
  	 * @author Matt DesLauriers / @mattdesl
  	 */

  	function WebGLMultisampleRenderTarget( width, height, options ) {

  		WebGLRenderTarget.call( this, width, height, options );

  		this.samples = 4;

  	}

  	WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

  		constructor: WebGLMultisampleRenderTarget,

  		isWebGLMultisampleRenderTarget: true,

  		copy: function ( source ) {

  			WebGLRenderTarget.prototype.copy.call( this, source );

  			this.samples = source.samples;

  			return this;

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com
  	 */

  	function WebGLRenderTargetCube( width, height, options ) {

  		WebGLRenderTarget.call( this, width, height, options );

  	}

  	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
  	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

  	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  		this.image = { data: data, width: width, height: height };

  		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

  		this.generateMipmaps = false;
  		this.flipY = false;
  		this.unpackAlignment = 1;

  	}

  	DataTexture.prototype = Object.create( Texture.prototype );
  	DataTexture.prototype.constructor = DataTexture;

  	DataTexture.prototype.isDataTexture = true;

  	/**
  	 * @author bhouston / http://clara.io
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function Box3( min, max ) {

  		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
  		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

  	}

  	Object.assign( Box3.prototype, {

  		isBox3: true,

  		set: function ( min, max ) {

  			this.min.copy( min );
  			this.max.copy( max );

  			return this;

  		},

  		setFromArray: function ( array ) {

  			var minX = + Infinity;
  			var minY = + Infinity;
  			var minZ = + Infinity;

  			var maxX = - Infinity;
  			var maxY = - Infinity;
  			var maxZ = - Infinity;

  			for ( var i = 0, l = array.length; i < l; i += 3 ) {

  				var x = array[ i ];
  				var y = array[ i + 1 ];
  				var z = array[ i + 2 ];

  				if ( x < minX ) minX = x;
  				if ( y < minY ) minY = y;
  				if ( z < minZ ) minZ = z;

  				if ( x > maxX ) maxX = x;
  				if ( y > maxY ) maxY = y;
  				if ( z > maxZ ) maxZ = z;

  			}

  			this.min.set( minX, minY, minZ );
  			this.max.set( maxX, maxY, maxZ );

  			return this;

  		},

  		setFromBufferAttribute: function ( attribute ) {

  			var minX = + Infinity;
  			var minY = + Infinity;
  			var minZ = + Infinity;

  			var maxX = - Infinity;
  			var maxY = - Infinity;
  			var maxZ = - Infinity;

  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				var x = attribute.getX( i );
  				var y = attribute.getY( i );
  				var z = attribute.getZ( i );

  				if ( x < minX ) minX = x;
  				if ( y < minY ) minY = y;
  				if ( z < minZ ) minZ = z;

  				if ( x > maxX ) maxX = x;
  				if ( y > maxY ) maxY = y;
  				if ( z > maxZ ) maxZ = z;

  			}

  			this.min.set( minX, minY, minZ );
  			this.max.set( maxX, maxY, maxZ );

  			return this;

  		},

  		setFromPoints: function ( points ) {

  			this.makeEmpty();

  			for ( var i = 0, il = points.length; i < il; i ++ ) {

  				this.expandByPoint( points[ i ] );

  			}

  			return this;

  		},

  		setFromCenterAndSize: function () {

  			var v1 = new Vector3();

  			return function setFromCenterAndSize( center, size ) {

  				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

  				this.min.copy( center ).sub( halfSize );
  				this.max.copy( center ).add( halfSize );

  				return this;

  			};

  		}(),

  		setFromObject: function ( object ) {

  			this.makeEmpty();

  			return this.expandByObject( object );

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( box ) {

  			this.min.copy( box.min );
  			this.max.copy( box.max );

  			return this;

  		},

  		makeEmpty: function () {

  			this.min.x = this.min.y = this.min.z = + Infinity;
  			this.max.x = this.max.y = this.max.z = - Infinity;

  			return this;

  		},

  		isEmpty: function () {

  			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  		},

  		getCenter: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Box3: .getCenter() target is now required' );
  				target = new Vector3();

  			}

  			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  		},

  		getSize: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Box3: .getSize() target is now required' );
  				target = new Vector3();

  			}

  			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

  		},

  		expandByPoint: function ( point ) {

  			this.min.min( point );
  			this.max.max( point );

  			return this;

  		},

  		expandByVector: function ( vector ) {

  			this.min.sub( vector );
  			this.max.add( vector );

  			return this;

  		},

  		expandByScalar: function ( scalar ) {

  			this.min.addScalar( - scalar );
  			this.max.addScalar( scalar );

  			return this;

  		},

  		expandByObject: function () {

  			// Computes the world-axis-aligned bounding box of an object (including its children),
  			// accounting for both the object's, and children's, world transforms

  			var scope, i, l;

  			var v1 = new Vector3();

  			function traverse( node ) {

  				var geometry = node.geometry;

  				if ( geometry !== undefined ) {

  					if ( geometry.isGeometry ) {

  						var vertices = geometry.vertices;

  						for ( i = 0, l = vertices.length; i < l; i ++ ) {

  							v1.copy( vertices[ i ] );
  							v1.applyMatrix4( node.matrixWorld );

  							scope.expandByPoint( v1 );

  						}

  					} else if ( geometry.isBufferGeometry ) {

  						var attribute = geometry.attributes.position;

  						if ( attribute !== undefined ) {

  							for ( i = 0, l = attribute.count; i < l; i ++ ) {

  								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

  								scope.expandByPoint( v1 );

  							}

  						}

  					}

  				}

  			}

  			return function expandByObject( object ) {

  				scope = this;

  				object.updateMatrixWorld( true );

  				object.traverse( traverse );

  				return this;

  			};

  		}(),

  		containsPoint: function ( point ) {

  			return point.x < this.min.x || point.x > this.max.x ||
  				point.y < this.min.y || point.y > this.max.y ||
  				point.z < this.min.z || point.z > this.max.z ? false : true;

  		},

  		containsBox: function ( box ) {

  			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  				this.min.y <= box.min.y && box.max.y <= this.max.y &&
  				this.min.z <= box.min.z && box.max.z <= this.max.z;

  		},

  		getParameter: function ( point, target ) {

  			// This can potentially have a divide by zero if the box
  			// has a size dimension of 0.

  			if ( target === undefined ) {

  				console.warn( 'THREE.Box3: .getParameter() target is now required' );
  				target = new Vector3();

  			}

  			return target.set(
  				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  				( point.z - this.min.z ) / ( this.max.z - this.min.z )
  			);

  		},

  		intersectsBox: function ( box ) {

  			// using 6 splitting planes to rule out intersections.
  			return box.max.x < this.min.x || box.min.x > this.max.x ||
  				box.max.y < this.min.y || box.min.y > this.max.y ||
  				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

  		},

  		intersectsSphere: ( function () {

  			var closestPoint = new Vector3();

  			return function intersectsSphere( sphere ) {

  				// Find the point on the AABB closest to the sphere center.
  				this.clampPoint( sphere.center, closestPoint );

  				// If that point is inside the sphere, the AABB and sphere intersect.
  				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  			};

  		} )(),

  		intersectsPlane: function ( plane ) {

  			// We compute the minimum and maximum dot product values. If those values
  			// are on the same side (back or front) of the plane, then there is no intersection.

  			var min, max;

  			if ( plane.normal.x > 0 ) {

  				min = plane.normal.x * this.min.x;
  				max = plane.normal.x * this.max.x;

  			} else {

  				min = plane.normal.x * this.max.x;
  				max = plane.normal.x * this.min.x;

  			}

  			if ( plane.normal.y > 0 ) {

  				min += plane.normal.y * this.min.y;
  				max += plane.normal.y * this.max.y;

  			} else {

  				min += plane.normal.y * this.max.y;
  				max += plane.normal.y * this.min.y;

  			}

  			if ( plane.normal.z > 0 ) {

  				min += plane.normal.z * this.min.z;
  				max += plane.normal.z * this.max.z;

  			} else {

  				min += plane.normal.z * this.max.z;
  				max += plane.normal.z * this.min.z;

  			}

  			return ( min <= - plane.constant && max >= - plane.constant );

  		},

  		intersectsTriangle: ( function () {

  			// triangle centered vertices
  			var v0 = new Vector3();
  			var v1 = new Vector3();
  			var v2 = new Vector3();

  			// triangle edge vectors
  			var f0 = new Vector3();
  			var f1 = new Vector3();
  			var f2 = new Vector3();

  			var testAxis = new Vector3();

  			var center = new Vector3();
  			var extents = new Vector3();

  			var triangleNormal = new Vector3();

  			function satForAxes( axes ) {

  				var i, j;

  				for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

  					testAxis.fromArray( axes, i );
  					// project the aabb onto the seperating axis
  					var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
  					// project all 3 vertices of the triangle onto the seperating axis
  					var p0 = v0.dot( testAxis );
  					var p1 = v1.dot( testAxis );
  					var p2 = v2.dot( testAxis );
  					// actual test, basically see if either of the most extreme of the triangle points intersects r
  					if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

  						// points of the projected triangle are outside the projected half-length of the aabb
  						// the axis is seperating and we can exit
  						return false;

  					}

  				}

  				return true;

  			}

  			return function intersectsTriangle( triangle ) {

  				if ( this.isEmpty() ) {

  					return false;

  				}

  				// compute box center and extents
  				this.getCenter( center );
  				extents.subVectors( this.max, center );

  				// translate triangle to aabb origin
  				v0.subVectors( triangle.a, center );
  				v1.subVectors( triangle.b, center );
  				v2.subVectors( triangle.c, center );

  				// compute edge vectors for triangle
  				f0.subVectors( v1, v0 );
  				f1.subVectors( v2, v1 );
  				f2.subVectors( v0, v2 );

  				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  				var axes = [
  					0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
  					f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
  					- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
  				];
  				if ( ! satForAxes( axes ) ) {

  					return false;

  				}

  				// test 3 face normals from the aabb
  				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
  				if ( ! satForAxes( axes ) ) {

  					return false;

  				}

  				// finally testing the face normal of the triangle
  				// use already existing triangle edge vectors here
  				triangleNormal.crossVectors( f0, f1 );
  				axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
  				return satForAxes( axes );

  			};

  		} )(),

  		clampPoint: function ( point, target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
  				target = new Vector3();

  			}

  			return target.copy( point ).clamp( this.min, this.max );

  		},

  		distanceToPoint: function () {

  			var v1 = new Vector3();

  			return function distanceToPoint( point ) {

  				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  				return clampedPoint.sub( point ).length();

  			};

  		}(),

  		getBoundingSphere: function () {

  			var v1 = new Vector3();

  			return function getBoundingSphere( target ) {

  				if ( target === undefined ) {

  					console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
  					//target = new Sphere(); // removed to avoid cyclic dependency

  				}

  				this.getCenter( target.center );

  				target.radius = this.getSize( v1 ).length() * 0.5;

  				return target;

  			};

  		}(),

  		intersect: function ( box ) {

  			this.min.max( box.min );
  			this.max.min( box.max );

  			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  			if ( this.isEmpty() ) this.makeEmpty();

  			return this;

  		},

  		union: function ( box ) {

  			this.min.min( box.min );
  			this.max.max( box.max );

  			return this;

  		},

  		applyMatrix4: function () {

  			var points = [
  				new Vector3(),
  				new Vector3(),
  				new Vector3(),
  				new Vector3(),
  				new Vector3(),
  				new Vector3(),
  				new Vector3(),
  				new Vector3()
  			];

  			return function applyMatrix4( matrix ) {

  				// transform of empty box is an empty box.
  				if ( this.isEmpty() ) return this;

  				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

  				this.setFromPoints( points );

  				return this;

  			};

  		}(),

  		translate: function ( offset ) {

  			this.min.add( offset );
  			this.max.add( offset );

  			return this;

  		},

  		equals: function ( box ) {

  			return box.min.equals( this.min ) && box.max.equals( this.max );

  		}

  	} );

  	/**
  	 * @author bhouston / http://clara.io
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function Sphere( center, radius ) {

  		this.center = ( center !== undefined ) ? center : new Vector3();
  		this.radius = ( radius !== undefined ) ? radius : 0;

  	}

  	Object.assign( Sphere.prototype, {

  		set: function ( center, radius ) {

  			this.center.copy( center );
  			this.radius = radius;

  			return this;

  		},

  		setFromPoints: function () {

  			var box = new Box3();

  			return function setFromPoints( points, optionalCenter ) {

  				var center = this.center;

  				if ( optionalCenter !== undefined ) {

  					center.copy( optionalCenter );

  				} else {

  					box.setFromPoints( points ).getCenter( center );

  				}

  				var maxRadiusSq = 0;

  				for ( var i = 0, il = points.length; i < il; i ++ ) {

  					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  				}

  				this.radius = Math.sqrt( maxRadiusSq );

  				return this;

  			};

  		}(),

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( sphere ) {

  			this.center.copy( sphere.center );
  			this.radius = sphere.radius;

  			return this;

  		},

  		empty: function () {

  			return ( this.radius <= 0 );

  		},

  		containsPoint: function ( point ) {

  			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  		},

  		distanceToPoint: function ( point ) {

  			return ( point.distanceTo( this.center ) - this.radius );

  		},

  		intersectsSphere: function ( sphere ) {

  			var radiusSum = this.radius + sphere.radius;

  			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  		},

  		intersectsBox: function ( box ) {

  			return box.intersectsSphere( this );

  		},

  		intersectsPlane: function ( plane ) {

  			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

  		},

  		clampPoint: function ( point, target ) {

  			var deltaLengthSq = this.center.distanceToSquared( point );

  			if ( target === undefined ) {

  				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
  				target = new Vector3();

  			}

  			target.copy( point );

  			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  				target.sub( this.center ).normalize();
  				target.multiplyScalar( this.radius ).add( this.center );

  			}

  			return target;

  		},

  		getBoundingBox: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
  				target = new Box3();

  			}

  			target.set( this.center, this.center );
  			target.expandByScalar( this.radius );

  			return target;

  		},

  		applyMatrix4: function ( matrix ) {

  			this.center.applyMatrix4( matrix );
  			this.radius = this.radius * matrix.getMaxScaleOnAxis();

  			return this;

  		},

  		translate: function ( offset ) {

  			this.center.add( offset );

  			return this;

  		},

  		equals: function ( sphere ) {

  			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  		}

  	} );

  	/**
  	 * @author bhouston / http://clara.io
  	 */

  	function Plane( normal, constant ) {

  		// normal is assumed to be normalized

  		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
  		this.constant = ( constant !== undefined ) ? constant : 0;

  	}

  	Object.assign( Plane.prototype, {

  		set: function ( normal, constant ) {

  			this.normal.copy( normal );
  			this.constant = constant;

  			return this;

  		},

  		setComponents: function ( x, y, z, w ) {

  			this.normal.set( x, y, z );
  			this.constant = w;

  			return this;

  		},

  		setFromNormalAndCoplanarPoint: function ( normal, point ) {

  			this.normal.copy( normal );
  			this.constant = - point.dot( this.normal );

  			return this;

  		},

  		setFromCoplanarPoints: function () {

  			var v1 = new Vector3();
  			var v2 = new Vector3();

  			return function setFromCoplanarPoints( a, b, c ) {

  				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

  				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  				this.setFromNormalAndCoplanarPoint( normal, a );

  				return this;

  			};

  		}(),

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( plane ) {

  			this.normal.copy( plane.normal );
  			this.constant = plane.constant;

  			return this;

  		},

  		normalize: function () {

  			// Note: will lead to a divide by zero if the plane is invalid.

  			var inverseNormalLength = 1.0 / this.normal.length();
  			this.normal.multiplyScalar( inverseNormalLength );
  			this.constant *= inverseNormalLength;

  			return this;

  		},

  		negate: function () {

  			this.constant *= - 1;
  			this.normal.negate();

  			return this;

  		},

  		distanceToPoint: function ( point ) {

  			return this.normal.dot( point ) + this.constant;

  		},

  		distanceToSphere: function ( sphere ) {

  			return this.distanceToPoint( sphere.center ) - sphere.radius;

  		},

  		projectPoint: function ( point, target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
  				target = new Vector3();

  			}

  			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

  		},

  		intersectLine: function () {

  			var v1 = new Vector3();

  			return function intersectLine( line, target ) {

  				if ( target === undefined ) {

  					console.warn( 'THREE.Plane: .intersectLine() target is now required' );
  					target = new Vector3();

  				}

  				var direction = line.delta( v1 );

  				var denominator = this.normal.dot( direction );

  				if ( denominator === 0 ) {

  					// line is coplanar, return origin
  					if ( this.distanceToPoint( line.start ) === 0 ) {

  						return target.copy( line.start );

  					}

  					// Unsure if this is the correct method to handle this case.
  					return undefined;

  				}

  				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  				if ( t < 0 || t > 1 ) {

  					return undefined;

  				}

  				return target.copy( direction ).multiplyScalar( t ).add( line.start );

  			};

  		}(),

  		intersectsLine: function ( line ) {

  			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  			var startSign = this.distanceToPoint( line.start );
  			var endSign = this.distanceToPoint( line.end );

  			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  		},

  		intersectsBox: function ( box ) {

  			return box.intersectsPlane( this );

  		},

  		intersectsSphere: function ( sphere ) {

  			return sphere.intersectsPlane( this );

  		},

  		coplanarPoint: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
  				target = new Vector3();

  			}

  			return target.copy( this.normal ).multiplyScalar( - this.constant );

  		},

  		applyMatrix4: function () {

  			var v1 = new Vector3();
  			var m1 = new Matrix3();

  			return function applyMatrix4( matrix, optionalNormalMatrix ) {

  				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

  				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

  				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  				this.constant = - referencePoint.dot( normal );

  				return this;

  			};

  		}(),

  		translate: function ( offset ) {

  			this.constant -= offset.dot( this.normal );

  			return this;

  		},

  		equals: function ( plane ) {

  			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author bhouston / http://clara.io
  	 */

  	function Frustum( p0, p1, p2, p3, p4, p5 ) {

  		this.planes = [

  			( p0 !== undefined ) ? p0 : new Plane(),
  			( p1 !== undefined ) ? p1 : new Plane(),
  			( p2 !== undefined ) ? p2 : new Plane(),
  			( p3 !== undefined ) ? p3 : new Plane(),
  			( p4 !== undefined ) ? p4 : new Plane(),
  			( p5 !== undefined ) ? p5 : new Plane()

  		];

  	}

  	Object.assign( Frustum.prototype, {

  		set: function ( p0, p1, p2, p3, p4, p5 ) {

  			var planes = this.planes;

  			planes[ 0 ].copy( p0 );
  			planes[ 1 ].copy( p1 );
  			planes[ 2 ].copy( p2 );
  			planes[ 3 ].copy( p3 );
  			planes[ 4 ].copy( p4 );
  			planes[ 5 ].copy( p5 );

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( frustum ) {

  			var planes = this.planes;

  			for ( var i = 0; i < 6; i ++ ) {

  				planes[ i ].copy( frustum.planes[ i ] );

  			}

  			return this;

  		},

  		setFromMatrix: function ( m ) {

  			var planes = this.planes;
  			var me = m.elements;
  			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
  			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  			return this;

  		},

  		intersectsObject: function () {

  			var sphere = new Sphere();

  			return function intersectsObject( object ) {

  				var geometry = object.geometry;

  				if ( geometry.boundingSphere === null )
  					geometry.computeBoundingSphere();

  				sphere.copy( geometry.boundingSphere )
  					.applyMatrix4( object.matrixWorld );

  				return this.intersectsSphere( sphere );

  			};

  		}(),

  		intersectsSprite: function () {

  			var sphere = new Sphere();

  			return function intersectsSprite( sprite ) {

  				sphere.center.set( 0, 0, 0 );
  				sphere.radius = 0.7071067811865476;
  				sphere.applyMatrix4( sprite.matrixWorld );

  				return this.intersectsSphere( sphere );

  			};

  		}(),

  		intersectsSphere: function ( sphere ) {

  			var planes = this.planes;
  			var center = sphere.center;
  			var negRadius = - sphere.radius;

  			for ( var i = 0; i < 6; i ++ ) {

  				var distance = planes[ i ].distanceToPoint( center );

  				if ( distance < negRadius ) {

  					return false;

  				}

  			}

  			return true;

  		},

  		intersectsBox: function () {

  			var p = new Vector3();

  			return function intersectsBox( box ) {

  				var planes = this.planes;

  				for ( var i = 0; i < 6; i ++ ) {

  					var plane = planes[ i ];

  					// corner at max distance

  					p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  					p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  					p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  					if ( plane.distanceToPoint( p ) < 0 ) {

  						return false;

  					}

  				}

  				return true;

  			};

  		}(),

  		containsPoint: function ( point ) {

  			var planes = this.planes;

  			for ( var i = 0; i < 6; i ++ ) {

  				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  					return false;

  				}

  			}

  			return true;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author supereggbert / http://www.paulbrunt.co.uk/
  	 * @author philogb / http://blog.thejit.org/
  	 * @author jordi_ros / http://plattsoft.com
  	 * @author D1plo1d / http://github.com/D1plo1d
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author timknip / http://www.floorplanner.com/
  	 * @author bhouston / http://clara.io
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function Matrix4() {

  		this.elements = [

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		];

  		if ( arguments.length > 0 ) {

  			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  		}

  	}

  	Object.assign( Matrix4.prototype, {

  		isMatrix4: true,

  		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  			var te = this.elements;

  			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  			return this;

  		},

  		identity: function () {

  			this.set(

  				1, 0, 0, 0,
  				0, 1, 0, 0,
  				0, 0, 1, 0,
  				0, 0, 0, 1

  			);

  			return this;

  		},

  		clone: function () {

  			return new Matrix4().fromArray( this.elements );

  		},

  		copy: function ( m ) {

  			var te = this.elements;
  			var me = m.elements;

  			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  			return this;

  		},

  		copyPosition: function ( m ) {

  			var te = this.elements, me = m.elements;

  			te[ 12 ] = me[ 12 ];
  			te[ 13 ] = me[ 13 ];
  			te[ 14 ] = me[ 14 ];

  			return this;

  		},

  		extractBasis: function ( xAxis, yAxis, zAxis ) {

  			xAxis.setFromMatrixColumn( this, 0 );
  			yAxis.setFromMatrixColumn( this, 1 );
  			zAxis.setFromMatrixColumn( this, 2 );

  			return this;

  		},

  		makeBasis: function ( xAxis, yAxis, zAxis ) {

  			this.set(
  				xAxis.x, yAxis.x, zAxis.x, 0,
  				xAxis.y, yAxis.y, zAxis.y, 0,
  				xAxis.z, yAxis.z, zAxis.z, 0,
  				0, 0, 0, 1
  			);

  			return this;

  		},

  		extractRotation: function () {

  			var v1 = new Vector3();

  			return function extractRotation( m ) {

  				// this method does not support reflection matrices

  				var te = this.elements;
  				var me = m.elements;

  				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
  				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
  				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

  				te[ 0 ] = me[ 0 ] * scaleX;
  				te[ 1 ] = me[ 1 ] * scaleX;
  				te[ 2 ] = me[ 2 ] * scaleX;
  				te[ 3 ] = 0;

  				te[ 4 ] = me[ 4 ] * scaleY;
  				te[ 5 ] = me[ 5 ] * scaleY;
  				te[ 6 ] = me[ 6 ] * scaleY;
  				te[ 7 ] = 0;

  				te[ 8 ] = me[ 8 ] * scaleZ;
  				te[ 9 ] = me[ 9 ] * scaleZ;
  				te[ 10 ] = me[ 10 ] * scaleZ;
  				te[ 11 ] = 0;

  				te[ 12 ] = 0;
  				te[ 13 ] = 0;
  				te[ 14 ] = 0;
  				te[ 15 ] = 1;

  				return this;

  			};

  		}(),

  		makeRotationFromEuler: function ( euler ) {

  			if ( ! ( euler && euler.isEuler ) ) {

  				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

  			}

  			var te = this.elements;

  			var x = euler.x, y = euler.y, z = euler.z;
  			var a = Math.cos( x ), b = Math.sin( x );
  			var c = Math.cos( y ), d = Math.sin( y );
  			var e = Math.cos( z ), f = Math.sin( z );

  			if ( euler.order === 'XYZ' ) {

  				var ae = a * e, af = a * f, be = b * e, bf = b * f;

  				te[ 0 ] = c * e;
  				te[ 4 ] = - c * f;
  				te[ 8 ] = d;

  				te[ 1 ] = af + be * d;
  				te[ 5 ] = ae - bf * d;
  				te[ 9 ] = - b * c;

  				te[ 2 ] = bf - ae * d;
  				te[ 6 ] = be + af * d;
  				te[ 10 ] = a * c;

  			} else if ( euler.order === 'YXZ' ) {

  				var ce = c * e, cf = c * f, de = d * e, df = d * f;

  				te[ 0 ] = ce + df * b;
  				te[ 4 ] = de * b - cf;
  				te[ 8 ] = a * d;

  				te[ 1 ] = a * f;
  				te[ 5 ] = a * e;
  				te[ 9 ] = - b;

  				te[ 2 ] = cf * b - de;
  				te[ 6 ] = df + ce * b;
  				te[ 10 ] = a * c;

  			} else if ( euler.order === 'ZXY' ) {

  				var ce = c * e, cf = c * f, de = d * e, df = d * f;

  				te[ 0 ] = ce - df * b;
  				te[ 4 ] = - a * f;
  				te[ 8 ] = de + cf * b;

  				te[ 1 ] = cf + de * b;
  				te[ 5 ] = a * e;
  				te[ 9 ] = df - ce * b;

  				te[ 2 ] = - a * d;
  				te[ 6 ] = b;
  				te[ 10 ] = a * c;

  			} else if ( euler.order === 'ZYX' ) {

  				var ae = a * e, af = a * f, be = b * e, bf = b * f;

  				te[ 0 ] = c * e;
  				te[ 4 ] = be * d - af;
  				te[ 8 ] = ae * d + bf;

  				te[ 1 ] = c * f;
  				te[ 5 ] = bf * d + ae;
  				te[ 9 ] = af * d - be;

  				te[ 2 ] = - d;
  				te[ 6 ] = b * c;
  				te[ 10 ] = a * c;

  			} else if ( euler.order === 'YZX' ) {

  				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  				te[ 0 ] = c * e;
  				te[ 4 ] = bd - ac * f;
  				te[ 8 ] = bc * f + ad;

  				te[ 1 ] = f;
  				te[ 5 ] = a * e;
  				te[ 9 ] = - b * e;

  				te[ 2 ] = - d * e;
  				te[ 6 ] = ad * f + bc;
  				te[ 10 ] = ac - bd * f;

  			} else if ( euler.order === 'XZY' ) {

  				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  				te[ 0 ] = c * e;
  				te[ 4 ] = - f;
  				te[ 8 ] = d * e;

  				te[ 1 ] = ac * f + bd;
  				te[ 5 ] = a * e;
  				te[ 9 ] = ad * f - bc;

  				te[ 2 ] = bc * f - ad;
  				te[ 6 ] = b * e;
  				te[ 10 ] = bd * f + ac;

  			}

  			// bottom row
  			te[ 3 ] = 0;
  			te[ 7 ] = 0;
  			te[ 11 ] = 0;

  			// last column
  			te[ 12 ] = 0;
  			te[ 13 ] = 0;
  			te[ 14 ] = 0;
  			te[ 15 ] = 1;

  			return this;

  		},

  		makeRotationFromQuaternion: function () {

  			var zero = new Vector3( 0, 0, 0 );
  			var one = new Vector3( 1, 1, 1 );

  			return function makeRotationFromQuaternion( q ) {

  				return this.compose( zero, q, one );

  			};

  		}(),

  		lookAt: function () {

  			var x = new Vector3();
  			var y = new Vector3();
  			var z = new Vector3();

  			return function lookAt( eye, target, up ) {

  				var te = this.elements;

  				z.subVectors( eye, target );

  				if ( z.lengthSq() === 0 ) {

  					// eye and target are in the same position

  					z.z = 1;

  				}

  				z.normalize();
  				x.crossVectors( up, z );

  				if ( x.lengthSq() === 0 ) {

  					// up and z are parallel

  					if ( Math.abs( up.z ) === 1 ) {

  						z.x += 0.0001;

  					} else {

  						z.z += 0.0001;

  					}

  					z.normalize();
  					x.crossVectors( up, z );

  				}

  				x.normalize();
  				y.crossVectors( z, x );

  				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
  				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
  				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

  				return this;

  			};

  		}(),

  		multiply: function ( m, n ) {

  			if ( n !== undefined ) {

  				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
  				return this.multiplyMatrices( m, n );

  			}

  			return this.multiplyMatrices( this, m );

  		},

  		premultiply: function ( m ) {

  			return this.multiplyMatrices( m, this );

  		},

  		multiplyMatrices: function ( a, b ) {

  			var ae = a.elements;
  			var be = b.elements;
  			var te = this.elements;

  			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  			return this;

  		},

  		multiplyScalar: function ( s ) {

  			var te = this.elements;

  			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  			return this;

  		},

  		applyToBufferAttribute: function () {

  			var v1 = new Vector3();

  			return function applyToBufferAttribute( attribute ) {

  				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  					v1.x = attribute.getX( i );
  					v1.y = attribute.getY( i );
  					v1.z = attribute.getZ( i );

  					v1.applyMatrix4( this );

  					attribute.setXYZ( i, v1.x, v1.y, v1.z );

  				}

  				return attribute;

  			};

  		}(),

  		determinant: function () {

  			var te = this.elements;

  			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  			//TODO: make this more efficient
  			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  			return (
  				n41 * (
  					+ n14 * n23 * n32
  					 - n13 * n24 * n32
  					 - n14 * n22 * n33
  					 + n12 * n24 * n33
  					 + n13 * n22 * n34
  					 - n12 * n23 * n34
  				) +
  				n42 * (
  					+ n11 * n23 * n34
  					 - n11 * n24 * n33
  					 + n14 * n21 * n33
  					 - n13 * n21 * n34
  					 + n13 * n24 * n31
  					 - n14 * n23 * n31
  				) +
  				n43 * (
  					+ n11 * n24 * n32
  					 - n11 * n22 * n34
  					 - n14 * n21 * n32
  					 + n12 * n21 * n34
  					 + n14 * n22 * n31
  					 - n12 * n24 * n31
  				) +
  				n44 * (
  					- n13 * n22 * n31
  					 - n11 * n23 * n32
  					 + n11 * n22 * n33
  					 + n13 * n21 * n32
  					 - n12 * n21 * n33
  					 + n12 * n23 * n31
  				)

  			);

  		},

  		transpose: function () {

  			var te = this.elements;
  			var tmp;

  			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  			return this;

  		},

  		setPosition: function ( v ) {

  			var te = this.elements;

  			te[ 12 ] = v.x;
  			te[ 13 ] = v.y;
  			te[ 14 ] = v.z;

  			return this;

  		},

  		getInverse: function ( m, throwOnDegenerate ) {

  			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  			var te = this.elements,
  				me = m.elements,

  				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
  				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
  				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
  				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

  				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  			if ( det === 0 ) {

  				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

  				if ( throwOnDegenerate === true ) {

  					throw new Error( msg );

  				} else {

  					console.warn( msg );

  				}

  				return this.identity();

  			}

  			var detInv = 1 / det;

  			te[ 0 ] = t11 * detInv;
  			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  			te[ 4 ] = t12 * detInv;
  			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  			te[ 8 ] = t13 * detInv;
  			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  			te[ 12 ] = t14 * detInv;
  			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  			return this;

  		},

  		scale: function ( v ) {

  			var te = this.elements;
  			var x = v.x, y = v.y, z = v.z;

  			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  			return this;

  		},

  		getMaxScaleOnAxis: function () {

  			var te = this.elements;

  			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  		},

  		makeTranslation: function ( x, y, z ) {

  			this.set(

  				1, 0, 0, x,
  				0, 1, 0, y,
  				0, 0, 1, z,
  				0, 0, 0, 1

  			);

  			return this;

  		},

  		makeRotationX: function ( theta ) {

  			var c = Math.cos( theta ), s = Math.sin( theta );

  			this.set(

  				1, 0, 0, 0,
  				0, c, - s, 0,
  				0, s, c, 0,
  				0, 0, 0, 1

  			);

  			return this;

  		},

  		makeRotationY: function ( theta ) {

  			var c = Math.cos( theta ), s = Math.sin( theta );

  			this.set(

  				 c, 0, s, 0,
  				 0, 1, 0, 0,
  				- s, 0, c, 0,
  				 0, 0, 0, 1

  			);

  			return this;

  		},

  		makeRotationZ: function ( theta ) {

  			var c = Math.cos( theta ), s = Math.sin( theta );

  			this.set(

  				c, - s, 0, 0,
  				s, c, 0, 0,
  				0, 0, 1, 0,
  				0, 0, 0, 1

  			);

  			return this;

  		},

  		makeRotationAxis: function ( axis, angle ) {

  			// Based on http://www.gamedev.net/reference/articles/article1199.asp

  			var c = Math.cos( angle );
  			var s = Math.sin( angle );
  			var t = 1 - c;
  			var x = axis.x, y = axis.y, z = axis.z;
  			var tx = t * x, ty = t * y;

  			this.set(

  				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  				0, 0, 0, 1

  			);

  			 return this;

  		},

  		makeScale: function ( x, y, z ) {

  			this.set(

  				x, 0, 0, 0,
  				0, y, 0, 0,
  				0, 0, z, 0,
  				0, 0, 0, 1

  			);

  			return this;

  		},

  		makeShear: function ( x, y, z ) {

  			this.set(

  				1, y, z, 0,
  				x, 1, z, 0,
  				x, y, 1, 0,
  				0, 0, 0, 1

  			);

  			return this;

  		},

  		compose: function ( position, quaternion, scale ) {

  			var te = this.elements;

  			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
  			var x2 = x + x,	y2 = y + y, z2 = z + z;
  			var xx = x * x2, xy = x * y2, xz = x * z2;
  			var yy = y * y2, yz = y * z2, zz = z * z2;
  			var wx = w * x2, wy = w * y2, wz = w * z2;

  			var sx = scale.x, sy = scale.y, sz = scale.z;

  			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
  			te[ 1 ] = ( xy + wz ) * sx;
  			te[ 2 ] = ( xz - wy ) * sx;
  			te[ 3 ] = 0;

  			te[ 4 ] = ( xy - wz ) * sy;
  			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
  			te[ 6 ] = ( yz + wx ) * sy;
  			te[ 7 ] = 0;

  			te[ 8 ] = ( xz + wy ) * sz;
  			te[ 9 ] = ( yz - wx ) * sz;
  			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
  			te[ 11 ] = 0;

  			te[ 12 ] = position.x;
  			te[ 13 ] = position.y;
  			te[ 14 ] = position.z;
  			te[ 15 ] = 1;

  			return this;

  		},

  		decompose: function () {

  			var vector = new Vector3();
  			var matrix = new Matrix4();

  			return function decompose( position, quaternion, scale ) {

  				var te = this.elements;

  				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  				// if determine is negative, we need to invert one scale
  				var det = this.determinant();
  				if ( det < 0 ) sx = - sx;

  				position.x = te[ 12 ];
  				position.y = te[ 13 ];
  				position.z = te[ 14 ];

  				// scale the rotation part
  				matrix.copy( this );

  				var invSX = 1 / sx;
  				var invSY = 1 / sy;
  				var invSZ = 1 / sz;

  				matrix.elements[ 0 ] *= invSX;
  				matrix.elements[ 1 ] *= invSX;
  				matrix.elements[ 2 ] *= invSX;

  				matrix.elements[ 4 ] *= invSY;
  				matrix.elements[ 5 ] *= invSY;
  				matrix.elements[ 6 ] *= invSY;

  				matrix.elements[ 8 ] *= invSZ;
  				matrix.elements[ 9 ] *= invSZ;
  				matrix.elements[ 10 ] *= invSZ;

  				quaternion.setFromRotationMatrix( matrix );

  				scale.x = sx;
  				scale.y = sy;
  				scale.z = sz;

  				return this;

  			};

  		}(),

  		makePerspective: function ( left, right, top, bottom, near, far ) {

  			if ( far === undefined ) {

  				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

  			}

  			var te = this.elements;
  			var x = 2 * near / ( right - left );
  			var y = 2 * near / ( top - bottom );

  			var a = ( right + left ) / ( right - left );
  			var b = ( top + bottom ) / ( top - bottom );
  			var c = - ( far + near ) / ( far - near );
  			var d = - 2 * far * near / ( far - near );

  			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
  			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
  			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
  			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

  			return this;

  		},

  		makeOrthographic: function ( left, right, top, bottom, near, far ) {

  			var te = this.elements;
  			var w = 1.0 / ( right - left );
  			var h = 1.0 / ( top - bottom );
  			var p = 1.0 / ( far - near );

  			var x = ( right + left ) * w;
  			var y = ( top + bottom ) * h;
  			var z = ( far + near ) * p;

  			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
  			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
  			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
  			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

  			return this;

  		},

  		equals: function ( matrix ) {

  			var te = this.elements;
  			var me = matrix.elements;

  			for ( var i = 0; i < 16; i ++ ) {

  				if ( te[ i ] !== me[ i ] ) return false;

  			}

  			return true;

  		},

  		fromArray: function ( array, offset ) {

  			if ( offset === undefined ) offset = 0;

  			for ( var i = 0; i < 16; i ++ ) {

  				this.elements[ i ] = array[ i + offset ];

  			}

  			return this;

  		},

  		toArray: function ( array, offset ) {

  			if ( array === undefined ) array = [];
  			if ( offset === undefined ) offset = 0;

  			var te = this.elements;

  			array[ offset ] = te[ 0 ];
  			array[ offset + 1 ] = te[ 1 ];
  			array[ offset + 2 ] = te[ 2 ];
  			array[ offset + 3 ] = te[ 3 ];

  			array[ offset + 4 ] = te[ 4 ];
  			array[ offset + 5 ] = te[ 5 ];
  			array[ offset + 6 ] = te[ 6 ];
  			array[ offset + 7 ] = te[ 7 ];

  			array[ offset + 8 ] = te[ 8 ];
  			array[ offset + 9 ] = te[ 9 ];
  			array[ offset + 10 ] = te[ 10 ];
  			array[ offset + 11 ] = te[ 11 ];

  			array[ offset + 12 ] = te[ 12 ];
  			array[ offset + 13 ] = te[ 13 ];
  			array[ offset + 14 ] = te[ 14 ];
  			array[ offset + 15 ] = te[ 15 ];

  			return array;

  		}

  	} );

  	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

  	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

  	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

  	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

  	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

  	var begin_vertex = "vec3 transformed = vec3( position );";

  	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

  	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";

  	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

  	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

  	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

  	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";

  	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";

  	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

  	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

  	var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

  	var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

  	var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}";

  	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif";

  	var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

  	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

  	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";

  	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

  	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

  	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

  	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

  	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

  	var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

  	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

  	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

  	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";

  	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

  	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

  	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

  	var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif";

  	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";

  	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

  	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";

  	var lights_pars_begin = "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

  	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

  	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

  	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

  	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";

  	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

  	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif";

  	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif";

  	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";

  	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

  	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif";

  	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

  	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif";

  	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

  	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

  	var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif";

  	var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif";

  	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

  	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

  	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";

  	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

  	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

  	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif";

  	var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

  	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif";

  	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

  	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

  	var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";

  	var dithering_fragment = "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

  	var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

  	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

  	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

  	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

  	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif";

  	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";

  	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";

  	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

  	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

  	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

  	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

  	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

  	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

  	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

  	var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";

  	var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

  	var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif";

  	var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

  	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

  	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

  	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

  	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";

  	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

  	var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

  	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";

  	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";

  	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

  	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

  	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

  	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

  	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

  	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

  	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  	var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

  	var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

  	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

  	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

  	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}";

  	var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

  	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

  	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

  	var ShaderChunk = {
  		alphamap_fragment: alphamap_fragment,
  		alphamap_pars_fragment: alphamap_pars_fragment,
  		alphatest_fragment: alphatest_fragment,
  		aomap_fragment: aomap_fragment,
  		aomap_pars_fragment: aomap_pars_fragment,
  		begin_vertex: begin_vertex,
  		beginnormal_vertex: beginnormal_vertex,
  		bsdfs: bsdfs,
  		bumpmap_pars_fragment: bumpmap_pars_fragment,
  		clipping_planes_fragment: clipping_planes_fragment,
  		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  		clipping_planes_vertex: clipping_planes_vertex,
  		color_fragment: color_fragment,
  		color_pars_fragment: color_pars_fragment,
  		color_pars_vertex: color_pars_vertex,
  		color_vertex: color_vertex,
  		common: common,
  		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  		defaultnormal_vertex: defaultnormal_vertex,
  		displacementmap_pars_vertex: displacementmap_pars_vertex,
  		displacementmap_vertex: displacementmap_vertex,
  		emissivemap_fragment: emissivemap_fragment,
  		emissivemap_pars_fragment: emissivemap_pars_fragment,
  		encodings_fragment: encodings_fragment,
  		encodings_pars_fragment: encodings_pars_fragment,
  		envmap_fragment: envmap_fragment,
  		envmap_pars_fragment: envmap_pars_fragment,
  		envmap_pars_vertex: envmap_pars_vertex,
  		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  		envmap_vertex: envmap_vertex,
  		fog_vertex: fog_vertex,
  		fog_pars_vertex: fog_pars_vertex,
  		fog_fragment: fog_fragment,
  		fog_pars_fragment: fog_pars_fragment,
  		gradientmap_pars_fragment: gradientmap_pars_fragment,
  		lightmap_fragment: lightmap_fragment,
  		lightmap_pars_fragment: lightmap_pars_fragment,
  		lights_lambert_vertex: lights_lambert_vertex,
  		lights_pars_begin: lights_pars_begin,
  		lights_phong_fragment: lights_phong_fragment,
  		lights_phong_pars_fragment: lights_phong_pars_fragment,
  		lights_physical_fragment: lights_physical_fragment,
  		lights_physical_pars_fragment: lights_physical_pars_fragment,
  		lights_fragment_begin: lights_fragment_begin,
  		lights_fragment_maps: lights_fragment_maps,
  		lights_fragment_end: lights_fragment_end,
  		logdepthbuf_fragment: logdepthbuf_fragment,
  		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  		logdepthbuf_vertex: logdepthbuf_vertex,
  		map_fragment: map_fragment,
  		map_pars_fragment: map_pars_fragment,
  		map_particle_fragment: map_particle_fragment,
  		map_particle_pars_fragment: map_particle_pars_fragment,
  		metalnessmap_fragment: metalnessmap_fragment,
  		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  		morphnormal_vertex: morphnormal_vertex,
  		morphtarget_pars_vertex: morphtarget_pars_vertex,
  		morphtarget_vertex: morphtarget_vertex,
  		normal_fragment_begin: normal_fragment_begin,
  		normal_fragment_maps: normal_fragment_maps,
  		normalmap_pars_fragment: normalmap_pars_fragment,
  		packing: packing,
  		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  		project_vertex: project_vertex,
  		dithering_fragment: dithering_fragment,
  		dithering_pars_fragment: dithering_pars_fragment,
  		roughnessmap_fragment: roughnessmap_fragment,
  		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  		shadowmap_pars_fragment: shadowmap_pars_fragment,
  		shadowmap_pars_vertex: shadowmap_pars_vertex,
  		shadowmap_vertex: shadowmap_vertex,
  		shadowmask_pars_fragment: shadowmask_pars_fragment,
  		skinbase_vertex: skinbase_vertex,
  		skinning_pars_vertex: skinning_pars_vertex,
  		skinning_vertex: skinning_vertex,
  		skinnormal_vertex: skinnormal_vertex,
  		specularmap_fragment: specularmap_fragment,
  		specularmap_pars_fragment: specularmap_pars_fragment,
  		tonemapping_fragment: tonemapping_fragment,
  		tonemapping_pars_fragment: tonemapping_pars_fragment,
  		uv_pars_fragment: uv_pars_fragment,
  		uv_pars_vertex: uv_pars_vertex,
  		uv_vertex: uv_vertex,
  		uv2_pars_fragment: uv2_pars_fragment,
  		uv2_pars_vertex: uv2_pars_vertex,
  		uv2_vertex: uv2_vertex,
  		worldpos_vertex: worldpos_vertex,

  		background_frag: background_frag,
  		background_vert: background_vert,
  		cube_frag: cube_frag,
  		cube_vert: cube_vert,
  		depth_frag: depth_frag,
  		depth_vert: depth_vert,
  		distanceRGBA_frag: distanceRGBA_frag,
  		distanceRGBA_vert: distanceRGBA_vert,
  		equirect_frag: equirect_frag,
  		equirect_vert: equirect_vert,
  		linedashed_frag: linedashed_frag,
  		linedashed_vert: linedashed_vert,
  		meshbasic_frag: meshbasic_frag,
  		meshbasic_vert: meshbasic_vert,
  		meshlambert_frag: meshlambert_frag,
  		meshlambert_vert: meshlambert_vert,
  		meshmatcap_frag: meshmatcap_frag,
  		meshmatcap_vert: meshmatcap_vert,
  		meshphong_frag: meshphong_frag,
  		meshphong_vert: meshphong_vert,
  		meshphysical_frag: meshphysical_frag,
  		meshphysical_vert: meshphysical_vert,
  		normal_frag: normal_frag,
  		normal_vert: normal_vert,
  		points_frag: points_frag,
  		points_vert: points_vert,
  		shadow_frag: shadow_frag,
  		shadow_vert: shadow_vert,
  		sprite_frag: sprite_frag,
  		sprite_vert: sprite_vert
  	};

  	/**
  	 * Uniform Utilities
  	 */

  	function cloneUniforms( src ) {

  		var dst = {};

  		for ( var u in src ) {

  			dst[ u ] = {};

  			for ( var p in src[ u ] ) {

  				var property = src[ u ][ p ];

  				if ( property && ( property.isColor ||
  					property.isMatrix3 || property.isMatrix4 ||
  					property.isVector2 || property.isVector3 || property.isVector4 ||
  					property.isTexture ) ) {

  					dst[ u ][ p ] = property.clone();

  				} else if ( Array.isArray( property ) ) {

  					dst[ u ][ p ] = property.slice();

  				} else {

  					dst[ u ][ p ] = property;

  				}

  			}

  		}

  		return dst;

  	}

  	function mergeUniforms( uniforms ) {

  		var merged = {};

  		for ( var u = 0; u < uniforms.length; u ++ ) {

  			var tmp = cloneUniforms( uniforms[ u ] );

  			for ( var p in tmp ) {

  				merged[ p ] = tmp[ p ];

  			}

  		}

  		return merged;

  	}

  	// Legacy

  	var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  	function Color( r, g, b ) {

  		if ( g === undefined && b === undefined ) {

  			// r is THREE.Color, hex or string
  			return this.set( r );

  		}

  		return this.setRGB( r, g, b );

  	}

  	Object.assign( Color.prototype, {

  		isColor: true,

  		r: 1, g: 1, b: 1,

  		set: function ( value ) {

  			if ( value && value.isColor ) {

  				this.copy( value );

  			} else if ( typeof value === 'number' ) {

  				this.setHex( value );

  			} else if ( typeof value === 'string' ) {

  				this.setStyle( value );

  			}

  			return this;

  		},

  		setScalar: function ( scalar ) {

  			this.r = scalar;
  			this.g = scalar;
  			this.b = scalar;

  			return this;

  		},

  		setHex: function ( hex ) {

  			hex = Math.floor( hex );

  			this.r = ( hex >> 16 & 255 ) / 255;
  			this.g = ( hex >> 8 & 255 ) / 255;
  			this.b = ( hex & 255 ) / 255;

  			return this;

  		},

  		setRGB: function ( r, g, b ) {

  			this.r = r;
  			this.g = g;
  			this.b = b;

  			return this;

  		},

  		setHSL: function () {

  			function hue2rgb( p, q, t ) {

  				if ( t < 0 ) t += 1;
  				if ( t > 1 ) t -= 1;
  				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
  				if ( t < 1 / 2 ) return q;
  				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
  				return p;

  			}

  			return function setHSL( h, s, l ) {

  				// h,s,l ranges are in 0.0 - 1.0
  				h = _Math.euclideanModulo( h, 1 );
  				s = _Math.clamp( s, 0, 1 );
  				l = _Math.clamp( l, 0, 1 );

  				if ( s === 0 ) {

  					this.r = this.g = this.b = l;

  				} else {

  					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  					var q = ( 2 * l ) - p;

  					this.r = hue2rgb( q, p, h + 1 / 3 );
  					this.g = hue2rgb( q, p, h );
  					this.b = hue2rgb( q, p, h - 1 / 3 );

  				}

  				return this;

  			};

  		}(),

  		setStyle: function ( style ) {

  			function handleAlpha( string ) {

  				if ( string === undefined ) return;

  				if ( parseFloat( string ) < 1 ) {

  					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  				}

  			}


  			var m;

  			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

  				// rgb / hsl

  				var color;
  				var name = m[ 1 ];
  				var components = m[ 2 ];

  				switch ( name ) {

  					case 'rgb':
  					case 'rgba':

  						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  							// rgb(255,0,0) rgba(255,0,0,0.5)
  							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
  							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
  							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

  							handleAlpha( color[ 5 ] );

  							return this;

  						}

  						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
  							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
  							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

  							handleAlpha( color[ 5 ] );

  							return this;

  						}

  						break;

  					case 'hsl':
  					case 'hsla':

  						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  							var h = parseFloat( color[ 1 ] ) / 360;
  							var s = parseInt( color[ 2 ], 10 ) / 100;
  							var l = parseInt( color[ 3 ], 10 ) / 100;

  							handleAlpha( color[ 5 ] );

  							return this.setHSL( h, s, l );

  						}

  						break;

  				}

  			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

  				// hex color

  				var hex = m[ 1 ];
  				var size = hex.length;

  				if ( size === 3 ) {

  					// #ff0
  					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
  					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
  					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

  					return this;

  				} else if ( size === 6 ) {

  					// #ff0000
  					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
  					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
  					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

  					return this;

  				}

  			}

  			if ( style && style.length > 0 ) {

  				// color keywords
  				var hex = ColorKeywords[ style ];

  				if ( hex !== undefined ) {

  					// red
  					this.setHex( hex );

  				} else {

  					// unknown color
  					console.warn( 'THREE.Color: Unknown color ' + style );

  				}

  			}

  			return this;

  		},

  		clone: function () {

  			return new this.constructor( this.r, this.g, this.b );

  		},

  		copy: function ( color ) {

  			this.r = color.r;
  			this.g = color.g;
  			this.b = color.b;

  			return this;

  		},

  		copyGammaToLinear: function ( color, gammaFactor ) {

  			if ( gammaFactor === undefined ) gammaFactor = 2.0;

  			this.r = Math.pow( color.r, gammaFactor );
  			this.g = Math.pow( color.g, gammaFactor );
  			this.b = Math.pow( color.b, gammaFactor );

  			return this;

  		},

  		copyLinearToGamma: function ( color, gammaFactor ) {

  			if ( gammaFactor === undefined ) gammaFactor = 2.0;

  			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

  			this.r = Math.pow( color.r, safeInverse );
  			this.g = Math.pow( color.g, safeInverse );
  			this.b = Math.pow( color.b, safeInverse );

  			return this;

  		},

  		convertGammaToLinear: function ( gammaFactor ) {

  			this.copyGammaToLinear( this, gammaFactor );

  			return this;

  		},

  		convertLinearToGamma: function ( gammaFactor ) {

  			this.copyLinearToGamma( this, gammaFactor );

  			return this;

  		},

  		copySRGBToLinear: function () {

  			function SRGBToLinear( c ) {

  				return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

  			}

  			return function copySRGBToLinear( color ) {

  				this.r = SRGBToLinear( color.r );
  				this.g = SRGBToLinear( color.g );
  				this.b = SRGBToLinear( color.b );

  				return this;

  			};

  		}(),

  		copyLinearToSRGB: function () {

  			function LinearToSRGB( c ) {

  				return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

  			}

  			return function copyLinearToSRGB( color ) {

  				this.r = LinearToSRGB( color.r );
  				this.g = LinearToSRGB( color.g );
  				this.b = LinearToSRGB( color.b );

  				return this;

  			};

  		}(),

  		convertSRGBToLinear: function () {

  			this.copySRGBToLinear( this );

  			return this;

  		},

  		convertLinearToSRGB: function () {

  			this.copyLinearToSRGB( this );

  			return this;

  		},

  		getHex: function () {

  			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  		},

  		getHexString: function () {

  			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  		},

  		getHSL: function ( target ) {

  			// h,s,l ranges are in 0.0 - 1.0

  			if ( target === undefined ) {

  				console.warn( 'THREE.Color: .getHSL() target is now required' );
  				target = { h: 0, s: 0, l: 0 };

  			}

  			var r = this.r, g = this.g, b = this.b;

  			var max = Math.max( r, g, b );
  			var min = Math.min( r, g, b );

  			var hue, saturation;
  			var lightness = ( min + max ) / 2.0;

  			if ( min === max ) {

  				hue = 0;
  				saturation = 0;

  			} else {

  				var delta = max - min;

  				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  				switch ( max ) {

  					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  					case g: hue = ( b - r ) / delta + 2; break;
  					case b: hue = ( r - g ) / delta + 4; break;

  				}

  				hue /= 6;

  			}

  			target.h = hue;
  			target.s = saturation;
  			target.l = lightness;

  			return target;

  		},

  		getStyle: function () {

  			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  		},

  		offsetHSL: function () {

  			var hsl = {};

  			return function ( h, s, l ) {

  				this.getHSL( hsl );

  				hsl.h += h; hsl.s += s; hsl.l += l;

  				this.setHSL( hsl.h, hsl.s, hsl.l );

  				return this;

  			};

  		}(),

  		add: function ( color ) {

  			this.r += color.r;
  			this.g += color.g;
  			this.b += color.b;

  			return this;

  		},

  		addColors: function ( color1, color2 ) {

  			this.r = color1.r + color2.r;
  			this.g = color1.g + color2.g;
  			this.b = color1.b + color2.b;

  			return this;

  		},

  		addScalar: function ( s ) {

  			this.r += s;
  			this.g += s;
  			this.b += s;

  			return this;

  		},

  		sub: function ( color ) {

  			this.r = Math.max( 0, this.r - color.r );
  			this.g = Math.max( 0, this.g - color.g );
  			this.b = Math.max( 0, this.b - color.b );

  			return this;

  		},

  		multiply: function ( color ) {

  			this.r *= color.r;
  			this.g *= color.g;
  			this.b *= color.b;

  			return this;

  		},

  		multiplyScalar: function ( s ) {

  			this.r *= s;
  			this.g *= s;
  			this.b *= s;

  			return this;

  		},

  		lerp: function ( color, alpha ) {

  			this.r += ( color.r - this.r ) * alpha;
  			this.g += ( color.g - this.g ) * alpha;
  			this.b += ( color.b - this.b ) * alpha;

  			return this;

  		},

  		lerpHSL: function () {

  			var hslA = { h: 0, s: 0, l: 0 };
  			var hslB = { h: 0, s: 0, l: 0 };

  			return function lerpHSL( color, alpha ) {

  				this.getHSL( hslA );
  				color.getHSL( hslB );

  				var h = _Math.lerp( hslA.h, hslB.h, alpha );
  				var s = _Math.lerp( hslA.s, hslB.s, alpha );
  				var l = _Math.lerp( hslA.l, hslB.l, alpha );

  				this.setHSL( h, s, l );

  				return this;

  			};

  		}(),

  		equals: function ( c ) {

  			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  		},

  		fromArray: function ( array, offset ) {

  			if ( offset === undefined ) offset = 0;

  			this.r = array[ offset ];
  			this.g = array[ offset + 1 ];
  			this.b = array[ offset + 2 ];

  			return this;

  		},

  		toArray: function ( array, offset ) {

  			if ( array === undefined ) array = [];
  			if ( offset === undefined ) offset = 0;

  			array[ offset ] = this.r;
  			array[ offset + 1 ] = this.g;
  			array[ offset + 2 ] = this.b;

  			return array;

  		},

  		toJSON: function () {

  			return this.getHex();

  		}

  	} );

  	/**
  	 * Uniforms library for shared webgl shaders
  	 */

  	var UniformsLib = {

  		common: {

  			diffuse: { value: new Color( 0xeeeeee ) },
  			opacity: { value: 1.0 },

  			map: { value: null },
  			uvTransform: { value: new Matrix3() },

  			alphaMap: { value: null },

  		},

  		specularmap: {

  			specularMap: { value: null },

  		},

  		envmap: {

  			envMap: { value: null },
  			flipEnvMap: { value: - 1 },
  			reflectivity: { value: 1.0 },
  			refractionRatio: { value: 0.98 },
  			maxMipLevel: { value: 0 }

  		},

  		aomap: {

  			aoMap: { value: null },
  			aoMapIntensity: { value: 1 }

  		},

  		lightmap: {

  			lightMap: { value: null },
  			lightMapIntensity: { value: 1 }

  		},

  		emissivemap: {

  			emissiveMap: { value: null }

  		},

  		bumpmap: {

  			bumpMap: { value: null },
  			bumpScale: { value: 1 }

  		},

  		normalmap: {

  			normalMap: { value: null },
  			normalScale: { value: new Vector2( 1, 1 ) }

  		},

  		displacementmap: {

  			displacementMap: { value: null },
  			displacementScale: { value: 1 },
  			displacementBias: { value: 0 }

  		},

  		roughnessmap: {

  			roughnessMap: { value: null }

  		},

  		metalnessmap: {

  			metalnessMap: { value: null }

  		},

  		gradientmap: {

  			gradientMap: { value: null }

  		},

  		fog: {

  			fogDensity: { value: 0.00025 },
  			fogNear: { value: 1 },
  			fogFar: { value: 2000 },
  			fogColor: { value: new Color( 0xffffff ) }

  		},

  		lights: {

  			ambientLightColor: { value: [] },

  			lightProbe: { value: [] },

  			directionalLights: { value: [], properties: {
  				direction: {},
  				color: {},

  				shadow: {},
  				shadowBias: {},
  				shadowRadius: {},
  				shadowMapSize: {}
  			} },

  			directionalShadowMap: { value: [] },
  			directionalShadowMatrix: { value: [] },

  			spotLights: { value: [], properties: {
  				color: {},
  				position: {},
  				direction: {},
  				distance: {},
  				coneCos: {},
  				penumbraCos: {},
  				decay: {},

  				shadow: {},
  				shadowBias: {},
  				shadowRadius: {},
  				shadowMapSize: {}
  			} },

  			spotShadowMap: { value: [] },
  			spotShadowMatrix: { value: [] },

  			pointLights: { value: [], properties: {
  				color: {},
  				position: {},
  				decay: {},
  				distance: {},

  				shadow: {},
  				shadowBias: {},
  				shadowRadius: {},
  				shadowMapSize: {},
  				shadowCameraNear: {},
  				shadowCameraFar: {}
  			} },

  			pointShadowMap: { value: [] },
  			pointShadowMatrix: { value: [] },

  			hemisphereLights: { value: [], properties: {
  				direction: {},
  				skyColor: {},
  				groundColor: {}
  			} },

  			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  			rectAreaLights: { value: [], properties: {
  				color: {},
  				position: {},
  				width: {},
  				height: {}
  			} }

  		},

  		points: {

  			diffuse: { value: new Color( 0xeeeeee ) },
  			opacity: { value: 1.0 },
  			size: { value: 1.0 },
  			scale: { value: 1.0 },
  			map: { value: null },
  			uvTransform: { value: new Matrix3() }

  		},

  		sprite: {

  			diffuse: { value: new Color( 0xeeeeee ) },
  			opacity: { value: 1.0 },
  			center: { value: new Vector2( 0.5, 0.5 ) },
  			rotation: { value: 0.0 },
  			map: { value: null },
  			uvTransform: { value: new Matrix3() }

  		}

  	};

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author mikael emtinger / http://gomo.se/
  	 */

  	var ShaderLib = {

  		basic: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.specularmap,
  				UniformsLib.envmap,
  				UniformsLib.aomap,
  				UniformsLib.lightmap,
  				UniformsLib.fog
  			] ),

  			vertexShader: ShaderChunk.meshbasic_vert,
  			fragmentShader: ShaderChunk.meshbasic_frag

  		},

  		lambert: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.specularmap,
  				UniformsLib.envmap,
  				UniformsLib.aomap,
  				UniformsLib.lightmap,
  				UniformsLib.emissivemap,
  				UniformsLib.fog,
  				UniformsLib.lights,
  				{
  					emissive: { value: new Color( 0x000000 ) }
  				}
  			] ),

  			vertexShader: ShaderChunk.meshlambert_vert,
  			fragmentShader: ShaderChunk.meshlambert_frag

  		},

  		phong: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.specularmap,
  				UniformsLib.envmap,
  				UniformsLib.aomap,
  				UniformsLib.lightmap,
  				UniformsLib.emissivemap,
  				UniformsLib.bumpmap,
  				UniformsLib.normalmap,
  				UniformsLib.displacementmap,
  				UniformsLib.gradientmap,
  				UniformsLib.fog,
  				UniformsLib.lights,
  				{
  					emissive: { value: new Color( 0x000000 ) },
  					specular: { value: new Color( 0x111111 ) },
  					shininess: { value: 30 }
  				}
  			] ),

  			vertexShader: ShaderChunk.meshphong_vert,
  			fragmentShader: ShaderChunk.meshphong_frag

  		},

  		standard: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.envmap,
  				UniformsLib.aomap,
  				UniformsLib.lightmap,
  				UniformsLib.emissivemap,
  				UniformsLib.bumpmap,
  				UniformsLib.normalmap,
  				UniformsLib.displacementmap,
  				UniformsLib.roughnessmap,
  				UniformsLib.metalnessmap,
  				UniformsLib.fog,
  				UniformsLib.lights,
  				{
  					emissive: { value: new Color( 0x000000 ) },
  					roughness: { value: 0.5 },
  					metalness: { value: 0.5 },
  					envMapIntensity: { value: 1 } // temporary
  				}
  			] ),

  			vertexShader: ShaderChunk.meshphysical_vert,
  			fragmentShader: ShaderChunk.meshphysical_frag

  		},

  		matcap: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.bumpmap,
  				UniformsLib.normalmap,
  				UniformsLib.displacementmap,
  				UniformsLib.fog,
  				{
  					matcap: { value: null }
  				}
  			] ),

  			vertexShader: ShaderChunk.meshmatcap_vert,
  			fragmentShader: ShaderChunk.meshmatcap_frag

  		},

  		points: {

  			uniforms: mergeUniforms( [
  				UniformsLib.points,
  				UniformsLib.fog
  			] ),

  			vertexShader: ShaderChunk.points_vert,
  			fragmentShader: ShaderChunk.points_frag

  		},

  		dashed: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.fog,
  				{
  					scale: { value: 1 },
  					dashSize: { value: 1 },
  					totalSize: { value: 2 }
  				}
  			] ),

  			vertexShader: ShaderChunk.linedashed_vert,
  			fragmentShader: ShaderChunk.linedashed_frag

  		},

  		depth: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.displacementmap
  			] ),

  			vertexShader: ShaderChunk.depth_vert,
  			fragmentShader: ShaderChunk.depth_frag

  		},

  		normal: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.bumpmap,
  				UniformsLib.normalmap,
  				UniformsLib.displacementmap,
  				{
  					opacity: { value: 1.0 }
  				}
  			] ),

  			vertexShader: ShaderChunk.normal_vert,
  			fragmentShader: ShaderChunk.normal_frag

  		},

  		sprite: {

  			uniforms: mergeUniforms( [
  				UniformsLib.sprite,
  				UniformsLib.fog
  			] ),

  			vertexShader: ShaderChunk.sprite_vert,
  			fragmentShader: ShaderChunk.sprite_frag

  		},

  		background: {

  			uniforms: {
  				uvTransform: { value: new Matrix3() },
  				t2D: { value: null },
  			},

  			vertexShader: ShaderChunk.background_vert,
  			fragmentShader: ShaderChunk.background_frag

  		},
  		/* -------------------------------------------------------------------------
  		//	Cube map shader
  		 ------------------------------------------------------------------------- */

  		cube: {

  			uniforms: {
  				tCube: { value: null },
  				tFlip: { value: - 1 },
  				opacity: { value: 1.0 }
  			},

  			vertexShader: ShaderChunk.cube_vert,
  			fragmentShader: ShaderChunk.cube_frag

  		},

  		equirect: {

  			uniforms: {
  				tEquirect: { value: null },
  			},

  			vertexShader: ShaderChunk.equirect_vert,
  			fragmentShader: ShaderChunk.equirect_frag

  		},

  		distanceRGBA: {

  			uniforms: mergeUniforms( [
  				UniformsLib.common,
  				UniformsLib.displacementmap,
  				{
  					referencePosition: { value: new Vector3() },
  					nearDistance: { value: 1 },
  					farDistance: { value: 1000 }
  				}
  			] ),

  			vertexShader: ShaderChunk.distanceRGBA_vert,
  			fragmentShader: ShaderChunk.distanceRGBA_frag

  		},

  		shadow: {

  			uniforms: mergeUniforms( [
  				UniformsLib.lights,
  				UniformsLib.fog,
  				{
  					color: { value: new Color( 0x00000 ) },
  					opacity: { value: 1.0 }
  				},
  			] ),

  			vertexShader: ShaderChunk.shadow_vert,
  			fragmentShader: ShaderChunk.shadow_frag

  		}

  	};

  	ShaderLib.physical = {

  		uniforms: mergeUniforms( [
  			ShaderLib.standard.uniforms,
  			{
  				clearCoat: { value: 0 },
  				clearCoatRoughness: { value: 0 }
  			}
  		] ),

  		vertexShader: ShaderChunk.meshphysical_vert,
  		fragmentShader: ShaderChunk.meshphysical_frag

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLAnimation() {

  		var context = null;
  		var isAnimating = false;
  		var animationLoop = null;

  		function onAnimationFrame( time, frame ) {

  			if ( isAnimating === false ) return;

  			animationLoop( time, frame );

  			context.requestAnimationFrame( onAnimationFrame );

  		}

  		return {

  			start: function () {

  				if ( isAnimating === true ) return;
  				if ( animationLoop === null ) return;

  				context.requestAnimationFrame( onAnimationFrame );

  				isAnimating = true;

  			},

  			stop: function () {

  				isAnimating = false;

  			},

  			setAnimationLoop: function ( callback ) {

  				animationLoop = callback;

  			},

  			setContext: function ( value ) {

  				context = value;

  			}

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLAttributes( gl ) {

  		var buffers = new WeakMap();

  		function createBuffer( attribute, bufferType ) {

  			var array = attribute.array;
  			var usage = attribute.dynamic ? 35048 : 35044;

  			var buffer = gl.createBuffer();

  			gl.bindBuffer( bufferType, buffer );
  			gl.bufferData( bufferType, array, usage );

  			attribute.onUploadCallback();

  			var type = 5126;

  			if ( array instanceof Float32Array ) {

  				type = 5126;

  			} else if ( array instanceof Float64Array ) {

  				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

  			} else if ( array instanceof Uint16Array ) {

  				type = 5123;

  			} else if ( array instanceof Int16Array ) {

  				type = 5122;

  			} else if ( array instanceof Uint32Array ) {

  				type = 5125;

  			} else if ( array instanceof Int32Array ) {

  				type = 5124;

  			} else if ( array instanceof Int8Array ) {

  				type = 5120;

  			} else if ( array instanceof Uint8Array ) {

  				type = 5121;

  			}

  			return {
  				buffer: buffer,
  				type: type,
  				bytesPerElement: array.BYTES_PER_ELEMENT,
  				version: attribute.version
  			};

  		}

  		function updateBuffer( buffer, attribute, bufferType ) {

  			var array = attribute.array;
  			var updateRange = attribute.updateRange;

  			gl.bindBuffer( bufferType, buffer );

  			if ( attribute.dynamic === false ) {

  				gl.bufferData( bufferType, array, 35044 );

  			} else if ( updateRange.count === - 1 ) {

  				// Not using update ranges

  				gl.bufferSubData( bufferType, 0, array );

  			} else if ( updateRange.count === 0 ) {

  				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

  			} else {

  				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
  					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

  				updateRange.count = - 1; // reset range

  			}

  		}

  		//

  		function get( attribute ) {

  			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  			return buffers.get( attribute );

  		}

  		function remove( attribute ) {

  			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  			var data = buffers.get( attribute );

  			if ( data ) {

  				gl.deleteBuffer( data.buffer );

  				buffers.delete( attribute );

  			}

  		}

  		function update( attribute, bufferType ) {

  			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  			var data = buffers.get( attribute );

  			if ( data === undefined ) {

  				buffers.set( attribute, createBuffer( attribute, bufferType ) );

  			} else if ( data.version < attribute.version ) {

  				updateBuffer( data.buffer, attribute, bufferType );

  				data.version = attribute.version;

  			}

  		}

  		return {

  			get: get,
  			remove: remove,
  			update: update

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function Face3( a, b, c, normal, color, materialIndex ) {

  		this.a = a;
  		this.b = b;
  		this.c = c;

  		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
  		this.vertexNormals = Array.isArray( normal ) ? normal : [];

  		this.color = ( color && color.isColor ) ? color : new Color();
  		this.vertexColors = Array.isArray( color ) ? color : [];

  		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

  	}

  	Object.assign( Face3.prototype, {

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( source ) {

  			this.a = source.a;
  			this.b = source.b;
  			this.c = source.c;

  			this.normal.copy( source.normal );
  			this.color.copy( source.color );

  			this.materialIndex = source.materialIndex;

  			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

  				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

  			}

  			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

  				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

  			}

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 * @author bhouston / http://clara.io
  	 */

  	function Euler( x, y, z, order ) {

  		this._x = x || 0;
  		this._y = y || 0;
  		this._z = z || 0;
  		this._order = order || Euler.DefaultOrder;

  	}

  	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

  	Euler.DefaultOrder = 'XYZ';

  	Object.defineProperties( Euler.prototype, {

  		x: {

  			get: function () {

  				return this._x;

  			},

  			set: function ( value ) {

  				this._x = value;
  				this.onChangeCallback();

  			}

  		},

  		y: {

  			get: function () {

  				return this._y;

  			},

  			set: function ( value ) {

  				this._y = value;
  				this.onChangeCallback();

  			}

  		},

  		z: {

  			get: function () {

  				return this._z;

  			},

  			set: function ( value ) {

  				this._z = value;
  				this.onChangeCallback();

  			}

  		},

  		order: {

  			get: function () {

  				return this._order;

  			},

  			set: function ( value ) {

  				this._order = value;
  				this.onChangeCallback();

  			}

  		}

  	} );

  	Object.assign( Euler.prototype, {

  		isEuler: true,

  		set: function ( x, y, z, order ) {

  			this._x = x;
  			this._y = y;
  			this._z = z;
  			this._order = order || this._order;

  			this.onChangeCallback();

  			return this;

  		},

  		clone: function () {

  			return new this.constructor( this._x, this._y, this._z, this._order );

  		},

  		copy: function ( euler ) {

  			this._x = euler._x;
  			this._y = euler._y;
  			this._z = euler._z;
  			this._order = euler._order;

  			this.onChangeCallback();

  			return this;

  		},

  		setFromRotationMatrix: function ( m, order, update ) {

  			var clamp = _Math.clamp;

  			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  			var te = m.elements;
  			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  			order = order || this._order;

  			if ( order === 'XYZ' ) {

  				this._y = Math.asin( clamp( m13, - 1, 1 ) );

  				if ( Math.abs( m13 ) < 0.99999 ) {

  					this._x = Math.atan2( - m23, m33 );
  					this._z = Math.atan2( - m12, m11 );

  				} else {

  					this._x = Math.atan2( m32, m22 );
  					this._z = 0;

  				}

  			} else if ( order === 'YXZ' ) {

  				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

  				if ( Math.abs( m23 ) < 0.99999 ) {

  					this._y = Math.atan2( m13, m33 );
  					this._z = Math.atan2( m21, m22 );

  				} else {

  					this._y = Math.atan2( - m31, m11 );
  					this._z = 0;

  				}

  			} else if ( order === 'ZXY' ) {

  				this._x = Math.asin( clamp( m32, - 1, 1 ) );

  				if ( Math.abs( m32 ) < 0.99999 ) {

  					this._y = Math.atan2( - m31, m33 );
  					this._z = Math.atan2( - m12, m22 );

  				} else {

  					this._y = 0;
  					this._z = Math.atan2( m21, m11 );

  				}

  			} else if ( order === 'ZYX' ) {

  				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

  				if ( Math.abs( m31 ) < 0.99999 ) {

  					this._x = Math.atan2( m32, m33 );
  					this._z = Math.atan2( m21, m11 );

  				} else {

  					this._x = 0;
  					this._z = Math.atan2( - m12, m22 );

  				}

  			} else if ( order === 'YZX' ) {

  				this._z = Math.asin( clamp( m21, - 1, 1 ) );

  				if ( Math.abs( m21 ) < 0.99999 ) {

  					this._x = Math.atan2( - m23, m22 );
  					this._y = Math.atan2( - m31, m11 );

  				} else {

  					this._x = 0;
  					this._y = Math.atan2( m13, m33 );

  				}

  			} else if ( order === 'XZY' ) {

  				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

  				if ( Math.abs( m12 ) < 0.99999 ) {

  					this._x = Math.atan2( m32, m22 );
  					this._y = Math.atan2( m13, m11 );

  				} else {

  					this._x = Math.atan2( - m23, m33 );
  					this._y = 0;

  				}

  			} else {

  				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

  			}

  			this._order = order;

  			if ( update !== false ) this.onChangeCallback();

  			return this;

  		},

  		setFromQuaternion: function () {

  			var matrix = new Matrix4();

  			return function setFromQuaternion( q, order, update ) {

  				matrix.makeRotationFromQuaternion( q );

  				return this.setFromRotationMatrix( matrix, order, update );

  			};

  		}(),

  		setFromVector3: function ( v, order ) {

  			return this.set( v.x, v.y, v.z, order || this._order );

  		},

  		reorder: function () {

  			// WARNING: this discards revolution information -bhouston

  			var q = new Quaternion();

  			return function reorder( newOrder ) {

  				q.setFromEuler( this );

  				return this.setFromQuaternion( q, newOrder );

  			};

  		}(),

  		equals: function ( euler ) {

  			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  		},

  		fromArray: function ( array ) {

  			this._x = array[ 0 ];
  			this._y = array[ 1 ];
  			this._z = array[ 2 ];
  			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

  			this.onChangeCallback();

  			return this;

  		},

  		toArray: function ( array, offset ) {

  			if ( array === undefined ) array = [];
  			if ( offset === undefined ) offset = 0;

  			array[ offset ] = this._x;
  			array[ offset + 1 ] = this._y;
  			array[ offset + 2 ] = this._z;
  			array[ offset + 3 ] = this._order;

  			return array;

  		},

  		toVector3: function ( optionalResult ) {

  			if ( optionalResult ) {

  				return optionalResult.set( this._x, this._y, this._z );

  			} else {

  				return new Vector3( this._x, this._y, this._z );

  			}

  		},

  		onChange: function ( callback ) {

  			this.onChangeCallback = callback;

  			return this;

  		},

  		onChangeCallback: function () {}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function Layers() {

  		this.mask = 1 | 0;

  	}

  	Object.assign( Layers.prototype, {

  		set: function ( channel ) {

  			this.mask = 1 << channel | 0;

  		},

  		enable: function ( channel ) {

  			this.mask |= 1 << channel | 0;

  		},

  		toggle: function ( channel ) {

  			this.mask ^= 1 << channel | 0;

  		},

  		disable: function ( channel ) {

  			this.mask &= ~ ( 1 << channel | 0 );

  		},

  		test: function ( layers ) {

  			return ( this.mask & layers.mask ) !== 0;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 * @author elephantatwork / www.elephantatwork.ch
  	 */

  	var object3DId = 0;

  	function Object3D() {

  		Object.defineProperty( this, 'id', { value: object3DId ++ } );

  		this.uuid = _Math.generateUUID();

  		this.name = '';
  		this.type = 'Object3D';

  		this.parent = null;
  		this.children = [];

  		this.up = Object3D.DefaultUp.clone();

  		var position = new Vector3();
  		var rotation = new Euler();
  		var quaternion = new Quaternion();
  		var scale = new Vector3( 1, 1, 1 );

  		function onRotationChange() {

  			quaternion.setFromEuler( rotation, false );

  		}

  		function onQuaternionChange() {

  			rotation.setFromQuaternion( quaternion, undefined, false );

  		}

  		rotation.onChange( onRotationChange );
  		quaternion.onChange( onQuaternionChange );

  		Object.defineProperties( this, {
  			position: {
  				configurable: true,
  				enumerable: true,
  				value: position
  			},
  			rotation: {
  				configurable: true,
  				enumerable: true,
  				value: rotation
  			},
  			quaternion: {
  				configurable: true,
  				enumerable: true,
  				value: quaternion
  			},
  			scale: {
  				configurable: true,
  				enumerable: true,
  				value: scale
  			},
  			modelViewMatrix: {
  				value: new Matrix4()
  			},
  			normalMatrix: {
  				value: new Matrix3()
  			}
  		} );

  		this.matrix = new Matrix4();
  		this.matrixWorld = new Matrix4();

  		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  		this.matrixWorldNeedsUpdate = false;

  		this.layers = new Layers();
  		this.visible = true;

  		this.castShadow = false;
  		this.receiveShadow = false;

  		this.frustumCulled = true;
  		this.renderOrder = 0;

  		this.userData = {};

  	}

  	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
  	Object3D.DefaultMatrixAutoUpdate = true;

  	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  		constructor: Object3D,

  		isObject3D: true,

  		onBeforeRender: function () {},
  		onAfterRender: function () {},

  		applyMatrix: function ( matrix ) {

  			if ( this.matrixAutoUpdate ) this.updateMatrix();

  			this.matrix.premultiply( matrix );

  			this.matrix.decompose( this.position, this.quaternion, this.scale );

  		},

  		applyQuaternion: function ( q ) {

  			this.quaternion.premultiply( q );

  			return this;

  		},

  		setRotationFromAxisAngle: function ( axis, angle ) {

  			// assumes axis is normalized

  			this.quaternion.setFromAxisAngle( axis, angle );

  		},

  		setRotationFromEuler: function ( euler ) {

  			this.quaternion.setFromEuler( euler, true );

  		},

  		setRotationFromMatrix: function ( m ) {

  			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  			this.quaternion.setFromRotationMatrix( m );

  		},

  		setRotationFromQuaternion: function ( q ) {

  			// assumes q is normalized

  			this.quaternion.copy( q );

  		},

  		rotateOnAxis: function () {

  			// rotate object on axis in object space
  			// axis is assumed to be normalized

  			var q1 = new Quaternion();

  			return function rotateOnAxis( axis, angle ) {

  				q1.setFromAxisAngle( axis, angle );

  				this.quaternion.multiply( q1 );

  				return this;

  			};

  		}(),

  		rotateOnWorldAxis: function () {

  			// rotate object on axis in world space
  			// axis is assumed to be normalized
  			// method assumes no rotated parent

  			var q1 = new Quaternion();

  			return function rotateOnWorldAxis( axis, angle ) {

  				q1.setFromAxisAngle( axis, angle );

  				this.quaternion.premultiply( q1 );

  				return this;

  			};

  		}(),

  		rotateX: function () {

  			var v1 = new Vector3( 1, 0, 0 );

  			return function rotateX( angle ) {

  				return this.rotateOnAxis( v1, angle );

  			};

  		}(),

  		rotateY: function () {

  			var v1 = new Vector3( 0, 1, 0 );

  			return function rotateY( angle ) {

  				return this.rotateOnAxis( v1, angle );

  			};

  		}(),

  		rotateZ: function () {

  			var v1 = new Vector3( 0, 0, 1 );

  			return function rotateZ( angle ) {

  				return this.rotateOnAxis( v1, angle );

  			};

  		}(),

  		translateOnAxis: function () {

  			// translate object by distance along axis in object space
  			// axis is assumed to be normalized

  			var v1 = new Vector3();

  			return function translateOnAxis( axis, distance ) {

  				v1.copy( axis ).applyQuaternion( this.quaternion );

  				this.position.add( v1.multiplyScalar( distance ) );

  				return this;

  			};

  		}(),

  		translateX: function () {

  			var v1 = new Vector3( 1, 0, 0 );

  			return function translateX( distance ) {

  				return this.translateOnAxis( v1, distance );

  			};

  		}(),

  		translateY: function () {

  			var v1 = new Vector3( 0, 1, 0 );

  			return function translateY( distance ) {

  				return this.translateOnAxis( v1, distance );

  			};

  		}(),

  		translateZ: function () {

  			var v1 = new Vector3( 0, 0, 1 );

  			return function translateZ( distance ) {

  				return this.translateOnAxis( v1, distance );

  			};

  		}(),

  		localToWorld: function ( vector ) {

  			return vector.applyMatrix4( this.matrixWorld );

  		},

  		worldToLocal: function () {

  			var m1 = new Matrix4();

  			return function worldToLocal( vector ) {

  				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

  			};

  		}(),

  		lookAt: function () {

  			// This method does not support objects having non-uniformly-scaled parent(s)

  			var q1 = new Quaternion();
  			var m1 = new Matrix4();
  			var target = new Vector3();
  			var position = new Vector3();

  			return function lookAt( x, y, z ) {

  				if ( x.isVector3 ) {

  					target.copy( x );

  				} else {

  					target.set( x, y, z );

  				}

  				var parent = this.parent;

  				this.updateWorldMatrix( true, false );

  				position.setFromMatrixPosition( this.matrixWorld );

  				if ( this.isCamera || this.isLight ) {

  					m1.lookAt( position, target, this.up );

  				} else {

  					m1.lookAt( target, position, this.up );

  				}

  				this.quaternion.setFromRotationMatrix( m1 );

  				if ( parent ) {

  					m1.extractRotation( parent.matrixWorld );
  					q1.setFromRotationMatrix( m1 );
  					this.quaternion.premultiply( q1.inverse() );

  				}

  			};

  		}(),

  		add: function ( object ) {

  			if ( arguments.length > 1 ) {

  				for ( var i = 0; i < arguments.length; i ++ ) {

  					this.add( arguments[ i ] );

  				}

  				return this;

  			}

  			if ( object === this ) {

  				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
  				return this;

  			}

  			if ( ( object && object.isObject3D ) ) {

  				if ( object.parent !== null ) {

  					object.parent.remove( object );

  				}

  				object.parent = this;
  				object.dispatchEvent( { type: 'added' } );

  				this.children.push( object );

  			} else {

  				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

  			}

  			return this;

  		},

  		remove: function ( object ) {

  			if ( arguments.length > 1 ) {

  				for ( var i = 0; i < arguments.length; i ++ ) {

  					this.remove( arguments[ i ] );

  				}

  				return this;

  			}

  			var index = this.children.indexOf( object );

  			if ( index !== - 1 ) {

  				object.parent = null;

  				object.dispatchEvent( { type: 'removed' } );

  				this.children.splice( index, 1 );

  			}

  			return this;

  		},

  		getObjectById: function ( id ) {

  			return this.getObjectByProperty( 'id', id );

  		},

  		getObjectByName: function ( name ) {

  			return this.getObjectByProperty( 'name', name );

  		},

  		getObjectByProperty: function ( name, value ) {

  			if ( this[ name ] === value ) return this;

  			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

  				var child = this.children[ i ];
  				var object = child.getObjectByProperty( name, value );

  				if ( object !== undefined ) {

  					return object;

  				}

  			}

  			return undefined;

  		},

  		getWorldPosition: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
  				target = new Vector3();

  			}

  			this.updateMatrixWorld( true );

  			return target.setFromMatrixPosition( this.matrixWorld );

  		},

  		getWorldQuaternion: function () {

  			var position = new Vector3();
  			var scale = new Vector3();

  			return function getWorldQuaternion( target ) {

  				if ( target === undefined ) {

  					console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
  					target = new Quaternion();

  				}

  				this.updateMatrixWorld( true );

  				this.matrixWorld.decompose( position, target, scale );

  				return target;

  			};

  		}(),

  		getWorldScale: function () {

  			var position = new Vector3();
  			var quaternion = new Quaternion();

  			return function getWorldScale( target ) {

  				if ( target === undefined ) {

  					console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
  					target = new Vector3();

  				}

  				this.updateMatrixWorld( true );

  				this.matrixWorld.decompose( position, quaternion, target );

  				return target;

  			};

  		}(),

  		getWorldDirection: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
  				target = new Vector3();

  			}

  			this.updateMatrixWorld( true );

  			var e = this.matrixWorld.elements;

  			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

  		},

  		raycast: function () {},

  		traverse: function ( callback ) {

  			callback( this );

  			var children = this.children;

  			for ( var i = 0, l = children.length; i < l; i ++ ) {

  				children[ i ].traverse( callback );

  			}

  		},

  		traverseVisible: function ( callback ) {

  			if ( this.visible === false ) return;

  			callback( this );

  			var children = this.children;

  			for ( var i = 0, l = children.length; i < l; i ++ ) {

  				children[ i ].traverseVisible( callback );

  			}

  		},

  		traverseAncestors: function ( callback ) {

  			var parent = this.parent;

  			if ( parent !== null ) {

  				callback( parent );

  				parent.traverseAncestors( callback );

  			}

  		},

  		updateMatrix: function () {

  			this.matrix.compose( this.position, this.quaternion, this.scale );

  			this.matrixWorldNeedsUpdate = true;

  		},

  		updateMatrixWorld: function ( force ) {

  			if ( this.matrixAutoUpdate ) this.updateMatrix();

  			if ( this.matrixWorldNeedsUpdate || force ) {

  				if ( this.parent === null ) {

  					this.matrixWorld.copy( this.matrix );

  				} else {

  					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  				}

  				this.matrixWorldNeedsUpdate = false;

  				force = true;

  			}

  			// update children

  			var children = this.children;

  			for ( var i = 0, l = children.length; i < l; i ++ ) {

  				children[ i ].updateMatrixWorld( force );

  			}

  		},

  		updateWorldMatrix: function ( updateParents, updateChildren ) {

  			var parent = this.parent;

  			if ( updateParents === true && parent !== null ) {

  				parent.updateWorldMatrix( true, false );

  			}

  			if ( this.matrixAutoUpdate ) this.updateMatrix();

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  			// update children

  			if ( updateChildren === true ) {

  				var children = this.children;

  				for ( var i = 0, l = children.length; i < l; i ++ ) {

  					children[ i ].updateWorldMatrix( false, true );

  				}

  			}

  		},

  		toJSON: function ( meta ) {

  			// meta is a string when called from JSON.stringify
  			var isRootObject = ( meta === undefined || typeof meta === 'string' );

  			var output = {};

  			// meta is a hash used to collect geometries, materials.
  			// not providing it implies that this is the root object
  			// being serialized.
  			if ( isRootObject ) {

  				// initialize meta obj
  				meta = {
  					geometries: {},
  					materials: {},
  					textures: {},
  					images: {},
  					shapes: {}
  				};

  				output.metadata = {
  					version: 4.5,
  					type: 'Object',
  					generator: 'Object3D.toJSON'
  				};

  			}

  			// standard Object3D serialization

  			var object = {};

  			object.uuid = this.uuid;
  			object.type = this.type;

  			if ( this.name !== '' ) object.name = this.name;
  			if ( this.castShadow === true ) object.castShadow = true;
  			if ( this.receiveShadow === true ) object.receiveShadow = true;
  			if ( this.visible === false ) object.visible = false;
  			if ( this.frustumCulled === false ) object.frustumCulled = false;
  			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
  			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

  			object.layers = this.layers.mask;
  			object.matrix = this.matrix.toArray();

  			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

  			// object specific properties

  			if ( this.isMesh && this.drawMode !== TrianglesDrawMode ) object.drawMode = this.drawMode;

  			//

  			function serialize( library, element ) {

  				if ( library[ element.uuid ] === undefined ) {

  					library[ element.uuid ] = element.toJSON( meta );

  				}

  				return element.uuid;

  			}

  			if ( this.isMesh || this.isLine || this.isPoints ) {

  				object.geometry = serialize( meta.geometries, this.geometry );

  				var parameters = this.geometry.parameters;

  				if ( parameters !== undefined && parameters.shapes !== undefined ) {

  					var shapes = parameters.shapes;

  					if ( Array.isArray( shapes ) ) {

  						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

  							var shape = shapes[ i ];

  							serialize( meta.shapes, shape );

  						}

  					} else {

  						serialize( meta.shapes, shapes );

  					}

  				}

  			}

  			if ( this.material !== undefined ) {

  				if ( Array.isArray( this.material ) ) {

  					var uuids = [];

  					for ( var i = 0, l = this.material.length; i < l; i ++ ) {

  						uuids.push( serialize( meta.materials, this.material[ i ] ) );

  					}

  					object.material = uuids;

  				} else {

  					object.material = serialize( meta.materials, this.material );

  				}

  			}

  			//

  			if ( this.children.length > 0 ) {

  				object.children = [];

  				for ( var i = 0; i < this.children.length; i ++ ) {

  					object.children.push( this.children[ i ].toJSON( meta ).object );

  				}

  			}

  			if ( isRootObject ) {

  				var geometries = extractFromCache( meta.geometries );
  				var materials = extractFromCache( meta.materials );
  				var textures = extractFromCache( meta.textures );
  				var images = extractFromCache( meta.images );
  				var shapes = extractFromCache( meta.shapes );

  				if ( geometries.length > 0 ) output.geometries = geometries;
  				if ( materials.length > 0 ) output.materials = materials;
  				if ( textures.length > 0 ) output.textures = textures;
  				if ( images.length > 0 ) output.images = images;
  				if ( shapes.length > 0 ) output.shapes = shapes;

  			}

  			output.object = object;

  			return output;

  			// extract data from the cache hash
  			// remove metadata on each item
  			// and return as array
  			function extractFromCache( cache ) {

  				var values = [];
  				for ( var key in cache ) {

  					var data = cache[ key ];
  					delete data.metadata;
  					values.push( data );

  				}
  				return values;

  			}

  		},

  		clone: function ( recursive ) {

  			return new this.constructor().copy( this, recursive );

  		},

  		copy: function ( source, recursive ) {

  			if ( recursive === undefined ) recursive = true;

  			this.name = source.name;

  			this.up.copy( source.up );

  			this.position.copy( source.position );
  			this.quaternion.copy( source.quaternion );
  			this.scale.copy( source.scale );

  			this.matrix.copy( source.matrix );
  			this.matrixWorld.copy( source.matrixWorld );

  			this.matrixAutoUpdate = source.matrixAutoUpdate;
  			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  			this.layers.mask = source.layers.mask;
  			this.visible = source.visible;

  			this.castShadow = source.castShadow;
  			this.receiveShadow = source.receiveShadow;

  			this.frustumCulled = source.frustumCulled;
  			this.renderOrder = source.renderOrder;

  			this.userData = JSON.parse( JSON.stringify( source.userData ) );

  			if ( recursive === true ) {

  				for ( var i = 0; i < source.children.length; i ++ ) {

  					var child = source.children[ i ];
  					this.add( child.clone() );

  				}

  			}

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author kile / http://kile.stravaganza.org/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 * @author bhouston / http://clara.io
  	 */

  	var geometryId = 0; // Geometry uses even numbers as Id

  	function Geometry() {

  		Object.defineProperty( this, 'id', { value: geometryId += 2 } );

  		this.uuid = _Math.generateUUID();

  		this.name = '';
  		this.type = 'Geometry';

  		this.vertices = [];
  		this.colors = [];
  		this.faces = [];
  		this.faceVertexUvs = [[]];

  		this.morphTargets = [];
  		this.morphNormals = [];

  		this.skinWeights = [];
  		this.skinIndices = [];

  		this.lineDistances = [];

  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// update flags

  		this.elementsNeedUpdate = false;
  		this.verticesNeedUpdate = false;
  		this.uvsNeedUpdate = false;
  		this.normalsNeedUpdate = false;
  		this.colorsNeedUpdate = false;
  		this.lineDistancesNeedUpdate = false;
  		this.groupsNeedUpdate = false;

  	}

  	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  		constructor: Geometry,

  		isGeometry: true,

  		applyMatrix: function ( matrix ) {

  			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

  				var vertex = this.vertices[ i ];
  				vertex.applyMatrix4( matrix );

  			}

  			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

  				var face = this.faces[ i ];
  				face.normal.applyMatrix3( normalMatrix ).normalize();

  				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

  				}

  			}

  			if ( this.boundingBox !== null ) {

  				this.computeBoundingBox();

  			}

  			if ( this.boundingSphere !== null ) {

  				this.computeBoundingSphere();

  			}

  			this.verticesNeedUpdate = true;
  			this.normalsNeedUpdate = true;

  			return this;

  		},

  		rotateX: function () {

  			// rotate geometry around world x-axis

  			var m1 = new Matrix4();

  			return function rotateX( angle ) {

  				m1.makeRotationX( angle );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		rotateY: function () {

  			// rotate geometry around world y-axis

  			var m1 = new Matrix4();

  			return function rotateY( angle ) {

  				m1.makeRotationY( angle );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		rotateZ: function () {

  			// rotate geometry around world z-axis

  			var m1 = new Matrix4();

  			return function rotateZ( angle ) {

  				m1.makeRotationZ( angle );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		translate: function () {

  			// translate geometry

  			var m1 = new Matrix4();

  			return function translate( x, y, z ) {

  				m1.makeTranslation( x, y, z );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		scale: function () {

  			// scale geometry

  			var m1 = new Matrix4();

  			return function scale( x, y, z ) {

  				m1.makeScale( x, y, z );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		lookAt: function () {

  			var obj = new Object3D();

  			return function lookAt( vector ) {

  				obj.lookAt( vector );

  				obj.updateMatrix();

  				this.applyMatrix( obj.matrix );

  			};

  		}(),

  		fromBufferGeometry: function ( geometry ) {

  			var scope = this;

  			var indices = geometry.index !== null ? geometry.index.array : undefined;
  			var attributes = geometry.attributes;

  			var positions = attributes.position.array;
  			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
  			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
  			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
  			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

  			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

  			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

  				scope.vertices.push( new Vector3().fromArray( positions, i ) );

  				if ( colors !== undefined ) {

  					scope.colors.push( new Color().fromArray( colors, i ) );

  				}

  			}

  			function addFace( a, b, c, materialIndex ) {

  				var vertexColors = ( colors === undefined ) ? [] : [
  					scope.colors[ a ].clone(),
  					scope.colors[ b ].clone(),
  					scope.colors[ c ].clone() ];

  				var vertexNormals = ( normals === undefined ) ? [] : [
  					new Vector3().fromArray( normals, a * 3 ),
  					new Vector3().fromArray( normals, b * 3 ),
  					new Vector3().fromArray( normals, c * 3 )
  				];

  				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

  				scope.faces.push( face );

  				if ( uvs !== undefined ) {

  					scope.faceVertexUvs[ 0 ].push( [
  						new Vector2().fromArray( uvs, a * 2 ),
  						new Vector2().fromArray( uvs, b * 2 ),
  						new Vector2().fromArray( uvs, c * 2 )
  					] );

  				}

  				if ( uvs2 !== undefined ) {

  					scope.faceVertexUvs[ 1 ].push( [
  						new Vector2().fromArray( uvs2, a * 2 ),
  						new Vector2().fromArray( uvs2, b * 2 ),
  						new Vector2().fromArray( uvs2, c * 2 )
  					] );

  				}

  			}

  			var groups = geometry.groups;

  			if ( groups.length > 0 ) {

  				for ( var i = 0; i < groups.length; i ++ ) {

  					var group = groups[ i ];

  					var start = group.start;
  					var count = group.count;

  					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

  						if ( indices !== undefined ) {

  							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

  						} else {

  							addFace( j, j + 1, j + 2, group.materialIndex );

  						}

  					}

  				}

  			} else {

  				if ( indices !== undefined ) {

  					for ( var i = 0; i < indices.length; i += 3 ) {

  						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

  					}

  				} else {

  					for ( var i = 0; i < positions.length / 3; i += 3 ) {

  						addFace( i, i + 1, i + 2 );

  					}

  				}

  			}

  			this.computeFaceNormals();

  			if ( geometry.boundingBox !== null ) {

  				this.boundingBox = geometry.boundingBox.clone();

  			}

  			if ( geometry.boundingSphere !== null ) {

  				this.boundingSphere = geometry.boundingSphere.clone();

  			}

  			return this;

  		},

  		center: function () {

  			var offset = new Vector3();

  			return function center() {

  				this.computeBoundingBox();

  				this.boundingBox.getCenter( offset ).negate();

  				this.translate( offset.x, offset.y, offset.z );

  				return this;

  			};

  		}(),

  		normalize: function () {

  			this.computeBoundingSphere();

  			var center = this.boundingSphere.center;
  			var radius = this.boundingSphere.radius;

  			var s = radius === 0 ? 1 : 1.0 / radius;

  			var matrix = new Matrix4();
  			matrix.set(
  				s, 0, 0, - s * center.x,
  				0, s, 0, - s * center.y,
  				0, 0, s, - s * center.z,
  				0, 0, 0, 1
  			);

  			this.applyMatrix( matrix );

  			return this;

  		},

  		computeFaceNormals: function () {

  			var cb = new Vector3(), ab = new Vector3();

  			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				var face = this.faces[ f ];

  				var vA = this.vertices[ face.a ];
  				var vB = this.vertices[ face.b ];
  				var vC = this.vertices[ face.c ];

  				cb.subVectors( vC, vB );
  				ab.subVectors( vA, vB );
  				cb.cross( ab );

  				cb.normalize();

  				face.normal.copy( cb );

  			}

  		},

  		computeVertexNormals: function ( areaWeighted ) {

  			if ( areaWeighted === undefined ) areaWeighted = true;

  			var v, vl, f, fl, face, vertices;

  			vertices = new Array( this.vertices.length );

  			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  				vertices[ v ] = new Vector3();

  			}

  			if ( areaWeighted ) {

  				// vertex normals weighted by triangle areas
  				// http://www.iquilezles.org/www/articles/normals/normals.htm

  				var vA, vB, vC;
  				var cb = new Vector3(), ab = new Vector3();

  				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  					face = this.faces[ f ];

  					vA = this.vertices[ face.a ];
  					vB = this.vertices[ face.b ];
  					vC = this.vertices[ face.c ];

  					cb.subVectors( vC, vB );
  					ab.subVectors( vA, vB );
  					cb.cross( ab );

  					vertices[ face.a ].add( cb );
  					vertices[ face.b ].add( cb );
  					vertices[ face.c ].add( cb );

  				}

  			} else {

  				this.computeFaceNormals();

  				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  					face = this.faces[ f ];

  					vertices[ face.a ].add( face.normal );
  					vertices[ face.b ].add( face.normal );
  					vertices[ face.c ].add( face.normal );

  				}

  			}

  			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  				vertices[ v ].normalize();

  			}

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this.faces[ f ];

  				var vertexNormals = face.vertexNormals;

  				if ( vertexNormals.length === 3 ) {

  					vertexNormals[ 0 ].copy( vertices[ face.a ] );
  					vertexNormals[ 1 ].copy( vertices[ face.b ] );
  					vertexNormals[ 2 ].copy( vertices[ face.c ] );

  				} else {

  					vertexNormals[ 0 ] = vertices[ face.a ].clone();
  					vertexNormals[ 1 ] = vertices[ face.b ].clone();
  					vertexNormals[ 2 ] = vertices[ face.c ].clone();

  				}

  			}

  			if ( this.faces.length > 0 ) {

  				this.normalsNeedUpdate = true;

  			}

  		},

  		computeFlatVertexNormals: function () {

  			var f, fl, face;

  			this.computeFaceNormals();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this.faces[ f ];

  				var vertexNormals = face.vertexNormals;

  				if ( vertexNormals.length === 3 ) {

  					vertexNormals[ 0 ].copy( face.normal );
  					vertexNormals[ 1 ].copy( face.normal );
  					vertexNormals[ 2 ].copy( face.normal );

  				} else {

  					vertexNormals[ 0 ] = face.normal.clone();
  					vertexNormals[ 1 ] = face.normal.clone();
  					vertexNormals[ 2 ] = face.normal.clone();

  				}

  			}

  			if ( this.faces.length > 0 ) {

  				this.normalsNeedUpdate = true;

  			}

  		},

  		computeMorphNormals: function () {

  			var i, il, f, fl, face;

  			// save original normals
  			// - create temp variables on first access
  			//   otherwise just copy (for faster repeated calls)

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this.faces[ f ];

  				if ( ! face.__originalFaceNormal ) {

  					face.__originalFaceNormal = face.normal.clone();

  				} else {

  					face.__originalFaceNormal.copy( face.normal );

  				}

  				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

  				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

  					if ( ! face.__originalVertexNormals[ i ] ) {

  						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

  					} else {

  						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

  					}

  				}

  			}

  			// use temp geometry to compute face and vertex normals for each morph

  			var tmpGeo = new Geometry();
  			tmpGeo.faces = this.faces;

  			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

  				// create on first access

  				if ( ! this.morphNormals[ i ] ) {

  					this.morphNormals[ i ] = {};
  					this.morphNormals[ i ].faceNormals = [];
  					this.morphNormals[ i ].vertexNormals = [];

  					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
  					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

  					var faceNormal, vertexNormals;

  					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  						faceNormal = new Vector3();
  						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

  						dstNormalsFace.push( faceNormal );
  						dstNormalsVertex.push( vertexNormals );

  					}

  				}

  				var morphNormals = this.morphNormals[ i ];

  				// set vertices to morph target

  				tmpGeo.vertices = this.morphTargets[ i ].vertices;

  				// compute morph normals

  				tmpGeo.computeFaceNormals();
  				tmpGeo.computeVertexNormals();

  				// store morph normals

  				var faceNormal, vertexNormals;

  				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  					face = this.faces[ f ];

  					faceNormal = morphNormals.faceNormals[ f ];
  					vertexNormals = morphNormals.vertexNormals[ f ];

  					faceNormal.copy( face.normal );

  					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
  					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
  					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

  				}

  			}

  			// restore original normals

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this.faces[ f ];

  				face.normal = face.__originalFaceNormal;
  				face.vertexNormals = face.__originalVertexNormals;

  			}

  		},

  		computeBoundingBox: function () {

  			if ( this.boundingBox === null ) {

  				this.boundingBox = new Box3();

  			}

  			this.boundingBox.setFromPoints( this.vertices );

  		},

  		computeBoundingSphere: function () {

  			if ( this.boundingSphere === null ) {

  				this.boundingSphere = new Sphere();

  			}

  			this.boundingSphere.setFromPoints( this.vertices );

  		},

  		merge: function ( geometry, matrix, materialIndexOffset ) {

  			if ( ! ( geometry && geometry.isGeometry ) ) {

  				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
  				return;

  			}

  			var normalMatrix,
  				vertexOffset = this.vertices.length,
  				vertices1 = this.vertices,
  				vertices2 = geometry.vertices,
  				faces1 = this.faces,
  				faces2 = geometry.faces,
  				uvs1 = this.faceVertexUvs[ 0 ],
  				uvs2 = geometry.faceVertexUvs[ 0 ],
  				colors1 = this.colors,
  				colors2 = geometry.colors;

  			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

  			if ( matrix !== undefined ) {

  				normalMatrix = new Matrix3().getNormalMatrix( matrix );

  			}

  			// vertices

  			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

  				var vertex = vertices2[ i ];

  				var vertexCopy = vertex.clone();

  				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

  				vertices1.push( vertexCopy );

  			}

  			// colors

  			for ( var i = 0, il = colors2.length; i < il; i ++ ) {

  				colors1.push( colors2[ i ].clone() );

  			}

  			// faces

  			for ( i = 0, il = faces2.length; i < il; i ++ ) {

  				var face = faces2[ i ], faceCopy, normal, color,
  					faceVertexNormals = face.vertexNormals,
  					faceVertexColors = face.vertexColors;

  				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
  				faceCopy.normal.copy( face.normal );

  				if ( normalMatrix !== undefined ) {

  					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

  				}

  				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

  					normal = faceVertexNormals[ j ].clone();

  					if ( normalMatrix !== undefined ) {

  						normal.applyMatrix3( normalMatrix ).normalize();

  					}

  					faceCopy.vertexNormals.push( normal );

  				}

  				faceCopy.color.copy( face.color );

  				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

  					color = faceVertexColors[ j ];
  					faceCopy.vertexColors.push( color.clone() );

  				}

  				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

  				faces1.push( faceCopy );

  			}

  			// uvs

  			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

  				var uv = uvs2[ i ], uvCopy = [];

  				if ( uv === undefined ) {

  					continue;

  				}

  				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

  					uvCopy.push( uv[ j ].clone() );

  				}

  				uvs1.push( uvCopy );

  			}

  		},

  		mergeMesh: function ( mesh ) {

  			if ( ! ( mesh && mesh.isMesh ) ) {

  				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
  				return;

  			}

  			if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

  			this.merge( mesh.geometry, mesh.matrix );

  		},

  		/*
  		 * Checks for duplicate vertices with hashmap.
  		 * Duplicated vertices are removed
  		 * and faces' vertices are updated.
  		 */

  		mergeVertices: function () {

  			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
  			var unique = [], changes = [];

  			var v, key;
  			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
  			var precision = Math.pow( 10, precisionPoints );
  			var i, il, face;
  			var indices, j, jl;

  			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

  				v = this.vertices[ i ];
  				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

  				if ( verticesMap[ key ] === undefined ) {

  					verticesMap[ key ] = i;
  					unique.push( this.vertices[ i ] );
  					changes[ i ] = unique.length - 1;

  				} else {

  					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
  					changes[ i ] = changes[ verticesMap[ key ] ];

  				}

  			}


  			// if faces are completely degenerate after merging vertices, we
  			// have to remove them from the geometry.
  			var faceIndicesToRemove = [];

  			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

  				face = this.faces[ i ];

  				face.a = changes[ face.a ];
  				face.b = changes[ face.b ];
  				face.c = changes[ face.c ];

  				indices = [ face.a, face.b, face.c ];

  				// if any duplicate vertices are found in a Face3
  				// we have to remove the face as nothing can be saved
  				for ( var n = 0; n < 3; n ++ ) {

  					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

  						faceIndicesToRemove.push( i );
  						break;

  					}

  				}

  			}

  			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

  				var idx = faceIndicesToRemove[ i ];

  				this.faces.splice( idx, 1 );

  				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

  					this.faceVertexUvs[ j ].splice( idx, 1 );

  				}

  			}

  			// Use unique set of vertices

  			var diff = this.vertices.length - unique.length;
  			this.vertices = unique;
  			return diff;

  		},

  		setFromPoints: function ( points ) {

  			this.vertices = [];

  			for ( var i = 0, l = points.length; i < l; i ++ ) {

  				var point = points[ i ];
  				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

  			}

  			return this;

  		},

  		sortFacesByMaterialIndex: function () {

  			var faces = this.faces;
  			var length = faces.length;

  			// tag faces

  			for ( var i = 0; i < length; i ++ ) {

  				faces[ i ]._id = i;

  			}

  			// sort faces

  			function materialIndexSort( a, b ) {

  				return a.materialIndex - b.materialIndex;

  			}

  			faces.sort( materialIndexSort );

  			// sort uvs

  			var uvs1 = this.faceVertexUvs[ 0 ];
  			var uvs2 = this.faceVertexUvs[ 1 ];

  			var newUvs1, newUvs2;

  			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
  			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

  			for ( var i = 0; i < length; i ++ ) {

  				var id = faces[ i ]._id;

  				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
  				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

  			}

  			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
  			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

  		},

  		toJSON: function () {

  			var data = {
  				metadata: {
  					version: 4.5,
  					type: 'Geometry',
  					generator: 'Geometry.toJSON'
  				}
  			};

  			// standard Geometry serialization

  			data.uuid = this.uuid;
  			data.type = this.type;
  			if ( this.name !== '' ) data.name = this.name;

  			if ( this.parameters !== undefined ) {

  				var parameters = this.parameters;

  				for ( var key in parameters ) {

  					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  				}

  				return data;

  			}

  			var vertices = [];

  			for ( var i = 0; i < this.vertices.length; i ++ ) {

  				var vertex = this.vertices[ i ];
  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  			var faces = [];
  			var normals = [];
  			var normalsHash = {};
  			var colors = [];
  			var colorsHash = {};
  			var uvs = [];
  			var uvsHash = {};

  			for ( var i = 0; i < this.faces.length; i ++ ) {

  				var face = this.faces[ i ];

  				var hasMaterial = true;
  				var hasFaceUv = false; // deprecated
  				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
  				var hasFaceNormal = face.normal.length() > 0;
  				var hasFaceVertexNormal = face.vertexNormals.length > 0;
  				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
  				var hasFaceVertexColor = face.vertexColors.length > 0;

  				var faceType = 0;

  				faceType = setBit( faceType, 0, 0 ); // isQuad
  				faceType = setBit( faceType, 1, hasMaterial );
  				faceType = setBit( faceType, 2, hasFaceUv );
  				faceType = setBit( faceType, 3, hasFaceVertexUv );
  				faceType = setBit( faceType, 4, hasFaceNormal );
  				faceType = setBit( faceType, 5, hasFaceVertexNormal );
  				faceType = setBit( faceType, 6, hasFaceColor );
  				faceType = setBit( faceType, 7, hasFaceVertexColor );

  				faces.push( faceType );
  				faces.push( face.a, face.b, face.c );
  				faces.push( face.materialIndex );

  				if ( hasFaceVertexUv ) {

  					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

  					faces.push(
  						getUvIndex( faceVertexUvs[ 0 ] ),
  						getUvIndex( faceVertexUvs[ 1 ] ),
  						getUvIndex( faceVertexUvs[ 2 ] )
  					);

  				}

  				if ( hasFaceNormal ) {

  					faces.push( getNormalIndex( face.normal ) );

  				}

  				if ( hasFaceVertexNormal ) {

  					var vertexNormals = face.vertexNormals;

  					faces.push(
  						getNormalIndex( vertexNormals[ 0 ] ),
  						getNormalIndex( vertexNormals[ 1 ] ),
  						getNormalIndex( vertexNormals[ 2 ] )
  					);

  				}

  				if ( hasFaceColor ) {

  					faces.push( getColorIndex( face.color ) );

  				}

  				if ( hasFaceVertexColor ) {

  					var vertexColors = face.vertexColors;

  					faces.push(
  						getColorIndex( vertexColors[ 0 ] ),
  						getColorIndex( vertexColors[ 1 ] ),
  						getColorIndex( vertexColors[ 2 ] )
  					);

  				}

  			}

  			function setBit( value, position, enabled ) {

  				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

  			}

  			function getNormalIndex( normal ) {

  				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

  				if ( normalsHash[ hash ] !== undefined ) {

  					return normalsHash[ hash ];

  				}

  				normalsHash[ hash ] = normals.length / 3;
  				normals.push( normal.x, normal.y, normal.z );

  				return normalsHash[ hash ];

  			}

  			function getColorIndex( color ) {

  				var hash = color.r.toString() + color.g.toString() + color.b.toString();

  				if ( colorsHash[ hash ] !== undefined ) {

  					return colorsHash[ hash ];

  				}

  				colorsHash[ hash ] = colors.length;
  				colors.push( color.getHex() );

  				return colorsHash[ hash ];

  			}

  			function getUvIndex( uv ) {

  				var hash = uv.x.toString() + uv.y.toString();

  				if ( uvsHash[ hash ] !== undefined ) {

  					return uvsHash[ hash ];

  				}

  				uvsHash[ hash ] = uvs.length / 2;
  				uvs.push( uv.x, uv.y );

  				return uvsHash[ hash ];

  			}

  			data.data = {};

  			data.data.vertices = vertices;
  			data.data.normals = normals;
  			if ( colors.length > 0 ) data.data.colors = colors;
  			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
  			data.data.faces = faces;

  			return data;

  		},

  		clone: function () {

  			/*
  			 // Handle primitives

  			 var parameters = this.parameters;

  			 if ( parameters !== undefined ) {

  			 var values = [];

  			 for ( var key in parameters ) {

  			 values.push( parameters[ key ] );

  			 }

  			 var geometry = Object.create( this.constructor.prototype );
  			 this.constructor.apply( geometry, values );
  			 return geometry;

  			 }

  			 return new this.constructor().copy( this );
  			 */

  			return new Geometry().copy( this );

  		},

  		copy: function ( source ) {

  			var i, il, j, jl, k, kl;

  			// reset

  			this.vertices = [];
  			this.colors = [];
  			this.faces = [];
  			this.faceVertexUvs = [[]];
  			this.morphTargets = [];
  			this.morphNormals = [];
  			this.skinWeights = [];
  			this.skinIndices = [];
  			this.lineDistances = [];
  			this.boundingBox = null;
  			this.boundingSphere = null;

  			// name

  			this.name = source.name;

  			// vertices

  			var vertices = source.vertices;

  			for ( i = 0, il = vertices.length; i < il; i ++ ) {

  				this.vertices.push( vertices[ i ].clone() );

  			}

  			// colors

  			var colors = source.colors;

  			for ( i = 0, il = colors.length; i < il; i ++ ) {

  				this.colors.push( colors[ i ].clone() );

  			}

  			// faces

  			var faces = source.faces;

  			for ( i = 0, il = faces.length; i < il; i ++ ) {

  				this.faces.push( faces[ i ].clone() );

  			}

  			// face vertex uvs

  			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

  				var faceVertexUvs = source.faceVertexUvs[ i ];

  				if ( this.faceVertexUvs[ i ] === undefined ) {

  					this.faceVertexUvs[ i ] = [];

  				}

  				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

  					var uvs = faceVertexUvs[ j ], uvsCopy = [];

  					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

  						var uv = uvs[ k ];

  						uvsCopy.push( uv.clone() );

  					}

  					this.faceVertexUvs[ i ].push( uvsCopy );

  				}

  			}

  			// morph targets

  			var morphTargets = source.morphTargets;

  			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

  				var morphTarget = {};
  				morphTarget.name = morphTargets[ i ].name;

  				// vertices

  				if ( morphTargets[ i ].vertices !== undefined ) {

  					morphTarget.vertices = [];

  					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

  						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

  					}

  				}

  				// normals

  				if ( morphTargets[ i ].normals !== undefined ) {

  					morphTarget.normals = [];

  					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

  						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

  					}

  				}

  				this.morphTargets.push( morphTarget );

  			}

  			// morph normals

  			var morphNormals = source.morphNormals;

  			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

  				var morphNormal = {};

  				// vertex normals

  				if ( morphNormals[ i ].vertexNormals !== undefined ) {

  					morphNormal.vertexNormals = [];

  					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

  						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
  						var destVertexNormal = {};

  						destVertexNormal.a = srcVertexNormal.a.clone();
  						destVertexNormal.b = srcVertexNormal.b.clone();
  						destVertexNormal.c = srcVertexNormal.c.clone();

  						morphNormal.vertexNormals.push( destVertexNormal );

  					}

  				}

  				// face normals

  				if ( morphNormals[ i ].faceNormals !== undefined ) {

  					morphNormal.faceNormals = [];

  					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

  						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

  					}

  				}

  				this.morphNormals.push( morphNormal );

  			}

  			// skin weights

  			var skinWeights = source.skinWeights;

  			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

  				this.skinWeights.push( skinWeights[ i ].clone() );

  			}

  			// skin indices

  			var skinIndices = source.skinIndices;

  			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

  				this.skinIndices.push( skinIndices[ i ].clone() );

  			}

  			// line distances

  			var lineDistances = source.lineDistances;

  			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

  				this.lineDistances.push( lineDistances[ i ] );

  			}

  			// bounding box

  			var boundingBox = source.boundingBox;

  			if ( boundingBox !== null ) {

  				this.boundingBox = boundingBox.clone();

  			}

  			// bounding sphere

  			var boundingSphere = source.boundingSphere;

  			if ( boundingSphere !== null ) {

  				this.boundingSphere = boundingSphere.clone();

  			}

  			// update flags

  			this.elementsNeedUpdate = source.elementsNeedUpdate;
  			this.verticesNeedUpdate = source.verticesNeedUpdate;
  			this.uvsNeedUpdate = source.uvsNeedUpdate;
  			this.normalsNeedUpdate = source.normalsNeedUpdate;
  			this.colorsNeedUpdate = source.colorsNeedUpdate;
  			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
  			this.groupsNeedUpdate = source.groupsNeedUpdate;

  			return this;

  		},

  		dispose: function () {

  			this.dispatchEvent( { type: 'dispose' } );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function BufferAttribute( array, itemSize, normalized ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.name = '';

  		this.array = array;
  		this.itemSize = itemSize;
  		this.count = array !== undefined ? array.length / itemSize : 0;
  		this.normalized = normalized === true;

  		this.dynamic = false;
  		this.updateRange = { offset: 0, count: - 1 };

  		this.version = 0;

  	}

  	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

  		set: function ( value ) {

  			if ( value === true ) this.version ++;

  		}

  	} );

  	Object.assign( BufferAttribute.prototype, {

  		isBufferAttribute: true,

  		onUploadCallback: function () {},

  		setArray: function ( array ) {

  			if ( Array.isArray( array ) ) {

  				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  			}

  			this.count = array !== undefined ? array.length / this.itemSize : 0;
  			this.array = array;

  			return this;

  		},

  		setDynamic: function ( value ) {

  			this.dynamic = value;

  			return this;

  		},

  		copy: function ( source ) {

  			this.name = source.name;
  			this.array = new source.array.constructor( source.array );
  			this.itemSize = source.itemSize;
  			this.count = source.count;
  			this.normalized = source.normalized;

  			this.dynamic = source.dynamic;

  			return this;

  		},

  		copyAt: function ( index1, attribute, index2 ) {

  			index1 *= this.itemSize;
  			index2 *= attribute.itemSize;

  			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

  				this.array[ index1 + i ] = attribute.array[ index2 + i ];

  			}

  			return this;

  		},

  		copyArray: function ( array ) {

  			this.array.set( array );

  			return this;

  		},

  		copyColorsArray: function ( colors ) {

  			var array = this.array, offset = 0;

  			for ( var i = 0, l = colors.length; i < l; i ++ ) {

  				var color = colors[ i ];

  				if ( color === undefined ) {

  					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
  					color = new Color();

  				}

  				array[ offset ++ ] = color.r;
  				array[ offset ++ ] = color.g;
  				array[ offset ++ ] = color.b;

  			}

  			return this;

  		},

  		copyVector2sArray: function ( vectors ) {

  			var array = this.array, offset = 0;

  			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  				var vector = vectors[ i ];

  				if ( vector === undefined ) {

  					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
  					vector = new Vector2();

  				}

  				array[ offset ++ ] = vector.x;
  				array[ offset ++ ] = vector.y;

  			}

  			return this;

  		},

  		copyVector3sArray: function ( vectors ) {

  			var array = this.array, offset = 0;

  			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  				var vector = vectors[ i ];

  				if ( vector === undefined ) {

  					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
  					vector = new Vector3();

  				}

  				array[ offset ++ ] = vector.x;
  				array[ offset ++ ] = vector.y;
  				array[ offset ++ ] = vector.z;

  			}

  			return this;

  		},

  		copyVector4sArray: function ( vectors ) {

  			var array = this.array, offset = 0;

  			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  				var vector = vectors[ i ];

  				if ( vector === undefined ) {

  					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
  					vector = new Vector4();

  				}

  				array[ offset ++ ] = vector.x;
  				array[ offset ++ ] = vector.y;
  				array[ offset ++ ] = vector.z;
  				array[ offset ++ ] = vector.w;

  			}

  			return this;

  		},

  		set: function ( value, offset ) {

  			if ( offset === undefined ) offset = 0;

  			this.array.set( value, offset );

  			return this;

  		},

  		getX: function ( index ) {

  			return this.array[ index * this.itemSize ];

  		},

  		setX: function ( index, x ) {

  			this.array[ index * this.itemSize ] = x;

  			return this;

  		},

  		getY: function ( index ) {

  			return this.array[ index * this.itemSize + 1 ];

  		},

  		setY: function ( index, y ) {

  			this.array[ index * this.itemSize + 1 ] = y;

  			return this;

  		},

  		getZ: function ( index ) {

  			return this.array[ index * this.itemSize + 2 ];

  		},

  		setZ: function ( index, z ) {

  			this.array[ index * this.itemSize + 2 ] = z;

  			return this;

  		},

  		getW: function ( index ) {

  			return this.array[ index * this.itemSize + 3 ];

  		},

  		setW: function ( index, w ) {

  			this.array[ index * this.itemSize + 3 ] = w;

  			return this;

  		},

  		setXY: function ( index, x, y ) {

  			index *= this.itemSize;

  			this.array[ index + 0 ] = x;
  			this.array[ index + 1 ] = y;

  			return this;

  		},

  		setXYZ: function ( index, x, y, z ) {

  			index *= this.itemSize;

  			this.array[ index + 0 ] = x;
  			this.array[ index + 1 ] = y;
  			this.array[ index + 2 ] = z;

  			return this;

  		},

  		setXYZW: function ( index, x, y, z, w ) {

  			index *= this.itemSize;

  			this.array[ index + 0 ] = x;
  			this.array[ index + 1 ] = y;
  			this.array[ index + 2 ] = z;
  			this.array[ index + 3 ] = w;

  			return this;

  		},

  		onUpload: function ( callback ) {

  			this.onUploadCallback = callback;

  			return this;

  		},

  		clone: function () {

  			return new this.constructor( this.array, this.itemSize ).copy( this );

  		}

  	} );

  	//

  	function Int8BufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

  	}

  	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


  	function Uint8BufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

  	}

  	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


  	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

  	}

  	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


  	function Int16BufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

  	}

  	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


  	function Uint16BufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

  	}

  	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


  	function Int32BufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

  	}

  	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


  	function Uint32BufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

  	}

  	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


  	function Float32BufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

  	}

  	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


  	function Float64BufferAttribute( array, itemSize, normalized ) {

  		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

  	}

  	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
  	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function DirectGeometry() {

  		this.vertices = [];
  		this.normals = [];
  		this.colors = [];
  		this.uvs = [];
  		this.uvs2 = [];

  		this.groups = [];

  		this.morphTargets = {};

  		this.skinWeights = [];
  		this.skinIndices = [];

  		// this.lineDistances = [];

  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// update flags

  		this.verticesNeedUpdate = false;
  		this.normalsNeedUpdate = false;
  		this.colorsNeedUpdate = false;
  		this.uvsNeedUpdate = false;
  		this.groupsNeedUpdate = false;

  	}

  	Object.assign( DirectGeometry.prototype, {

  		computeGroups: function ( geometry ) {

  			var group;
  			var groups = [];
  			var materialIndex = undefined;

  			var faces = geometry.faces;

  			for ( var i = 0; i < faces.length; i ++ ) {

  				var face = faces[ i ];

  				// materials

  				if ( face.materialIndex !== materialIndex ) {

  					materialIndex = face.materialIndex;

  					if ( group !== undefined ) {

  						group.count = ( i * 3 ) - group.start;
  						groups.push( group );

  					}

  					group = {
  						start: i * 3,
  						materialIndex: materialIndex
  					};

  				}

  			}

  			if ( group !== undefined ) {

  				group.count = ( i * 3 ) - group.start;
  				groups.push( group );

  			}

  			this.groups = groups;

  		},

  		fromGeometry: function ( geometry ) {

  			var faces = geometry.faces;
  			var vertices = geometry.vertices;
  			var faceVertexUvs = geometry.faceVertexUvs;

  			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
  			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

  			// morphs

  			var morphTargets = geometry.morphTargets;
  			var morphTargetsLength = morphTargets.length;

  			var morphTargetsPosition;

  			if ( morphTargetsLength > 0 ) {

  				morphTargetsPosition = [];

  				for ( var i = 0; i < morphTargetsLength; i ++ ) {

  					morphTargetsPosition[ i ] = {
  						name: morphTargets[ i ].name,
  					 	data: []
  					};

  				}

  				this.morphTargets.position = morphTargetsPosition;

  			}

  			var morphNormals = geometry.morphNormals;
  			var morphNormalsLength = morphNormals.length;

  			var morphTargetsNormal;

  			if ( morphNormalsLength > 0 ) {

  				morphTargetsNormal = [];

  				for ( var i = 0; i < morphNormalsLength; i ++ ) {

  					morphTargetsNormal[ i ] = {
  						name: morphNormals[ i ].name,
  					 	data: []
  					};

  				}

  				this.morphTargets.normal = morphTargetsNormal;

  			}

  			// skins

  			var skinIndices = geometry.skinIndices;
  			var skinWeights = geometry.skinWeights;

  			var hasSkinIndices = skinIndices.length === vertices.length;
  			var hasSkinWeights = skinWeights.length === vertices.length;

  			//

  			if ( vertices.length > 0 && faces.length === 0 ) {

  				console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

  			}

  			for ( var i = 0; i < faces.length; i ++ ) {

  				var face = faces[ i ];

  				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

  				var vertexNormals = face.vertexNormals;

  				if ( vertexNormals.length === 3 ) {

  					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

  				} else {

  					var normal = face.normal;

  					this.normals.push( normal, normal, normal );

  				}

  				var vertexColors = face.vertexColors;

  				if ( vertexColors.length === 3 ) {

  					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

  				} else {

  					var color = face.color;

  					this.colors.push( color, color, color );

  				}

  				if ( hasFaceVertexUv === true ) {

  					var vertexUvs = faceVertexUvs[ 0 ][ i ];

  					if ( vertexUvs !== undefined ) {

  						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  					} else {

  						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

  						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

  					}

  				}

  				if ( hasFaceVertexUv2 === true ) {

  					var vertexUvs = faceVertexUvs[ 1 ][ i ];

  					if ( vertexUvs !== undefined ) {

  						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  					} else {

  						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

  						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

  					}

  				}

  				// morphs

  				for ( var j = 0; j < morphTargetsLength; j ++ ) {

  					var morphTarget = morphTargets[ j ].vertices;

  					morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

  				}

  				for ( var j = 0; j < morphNormalsLength; j ++ ) {

  					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

  					morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );

  				}

  				// skins

  				if ( hasSkinIndices ) {

  					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

  				}

  				if ( hasSkinWeights ) {

  					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

  				}

  			}

  			this.computeGroups( geometry );

  			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
  			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
  			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
  			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
  			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function arrayMax( array ) {

  		if ( array.length === 0 ) return - Infinity;

  		var max = array[ 0 ];

  		for ( var i = 1, l = array.length; i < l; ++ i ) {

  			if ( array[ i ] > max ) max = array[ i ];

  		}

  		return max;

  	}

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

  	function BufferGeometry() {

  		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

  		this.uuid = _Math.generateUUID();

  		this.name = '';
  		this.type = 'BufferGeometry';

  		this.index = null;
  		this.attributes = {};

  		this.morphAttributes = {};

  		this.groups = [];

  		this.boundingBox = null;
  		this.boundingSphere = null;

  		this.drawRange = { start: 0, count: Infinity };

  		this.userData = {};

  	}

  	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  		constructor: BufferGeometry,

  		isBufferGeometry: true,

  		getIndex: function () {

  			return this.index;

  		},

  		setIndex: function ( index ) {

  			if ( Array.isArray( index ) ) {

  				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

  			} else {

  				this.index = index;

  			}

  		},

  		addAttribute: function ( name, attribute ) {

  			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

  				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

  				return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

  			}

  			if ( name === 'index' ) {

  				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
  				this.setIndex( attribute );

  				return this;

  			}

  			this.attributes[ name ] = attribute;

  			return this;

  		},

  		getAttribute: function ( name ) {

  			return this.attributes[ name ];

  		},

  		removeAttribute: function ( name ) {

  			delete this.attributes[ name ];

  			return this;

  		},

  		addGroup: function ( start, count, materialIndex ) {

  			this.groups.push( {

  				start: start,
  				count: count,
  				materialIndex: materialIndex !== undefined ? materialIndex : 0

  			} );

  		},

  		clearGroups: function () {

  			this.groups = [];

  		},

  		setDrawRange: function ( start, count ) {

  			this.drawRange.start = start;
  			this.drawRange.count = count;

  		},

  		applyMatrix: function ( matrix ) {

  			var position = this.attributes.position;

  			if ( position !== undefined ) {

  				matrix.applyToBufferAttribute( position );
  				position.needsUpdate = true;

  			}

  			var normal = this.attributes.normal;

  			if ( normal !== undefined ) {

  				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

  				normalMatrix.applyToBufferAttribute( normal );
  				normal.needsUpdate = true;

  			}

  			var tangent = this.attributes.tangent;

  			if ( tangent !== undefined ) {

  				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

  				// Tangent is vec4, but the '.w' component is a sign value (+1/-1).
  				normalMatrix.applyToBufferAttribute( tangent );
  				tangent.needsUpdate = true;

  			}

  			if ( this.boundingBox !== null ) {

  				this.computeBoundingBox();

  			}

  			if ( this.boundingSphere !== null ) {

  				this.computeBoundingSphere();

  			}

  			return this;

  		},

  		rotateX: function () {

  			// rotate geometry around world x-axis

  			var m1 = new Matrix4();

  			return function rotateX( angle ) {

  				m1.makeRotationX( angle );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		rotateY: function () {

  			// rotate geometry around world y-axis

  			var m1 = new Matrix4();

  			return function rotateY( angle ) {

  				m1.makeRotationY( angle );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		rotateZ: function () {

  			// rotate geometry around world z-axis

  			var m1 = new Matrix4();

  			return function rotateZ( angle ) {

  				m1.makeRotationZ( angle );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		translate: function () {

  			// translate geometry

  			var m1 = new Matrix4();

  			return function translate( x, y, z ) {

  				m1.makeTranslation( x, y, z );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		scale: function () {

  			// scale geometry

  			var m1 = new Matrix4();

  			return function scale( x, y, z ) {

  				m1.makeScale( x, y, z );

  				this.applyMatrix( m1 );

  				return this;

  			};

  		}(),

  		lookAt: function () {

  			var obj = new Object3D();

  			return function lookAt( vector ) {

  				obj.lookAt( vector );

  				obj.updateMatrix();

  				this.applyMatrix( obj.matrix );

  			};

  		}(),

  		center: function () {

  			var offset = new Vector3();

  			return function center() {

  				this.computeBoundingBox();

  				this.boundingBox.getCenter( offset ).negate();

  				this.translate( offset.x, offset.y, offset.z );

  				return this;

  			};

  		}(),

  		setFromObject: function ( object ) {

  			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

  			var geometry = object.geometry;

  			if ( object.isPoints || object.isLine ) {

  				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
  				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

  				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
  				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

  				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

  					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

  					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

  				}

  				if ( geometry.boundingSphere !== null ) {

  					this.boundingSphere = geometry.boundingSphere.clone();

  				}

  				if ( geometry.boundingBox !== null ) {

  					this.boundingBox = geometry.boundingBox.clone();

  				}

  			} else if ( object.isMesh ) {

  				if ( geometry && geometry.isGeometry ) {

  					this.fromGeometry( geometry );

  				}

  			}

  			return this;

  		},

  		setFromPoints: function ( points ) {

  			var position = [];

  			for ( var i = 0, l = points.length; i < l; i ++ ) {

  				var point = points[ i ];
  				position.push( point.x, point.y, point.z || 0 );

  			}

  			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

  			return this;

  		},

  		updateFromObject: function ( object ) {

  			var geometry = object.geometry;

  			if ( object.isMesh ) {

  				var direct = geometry.__directGeometry;

  				if ( geometry.elementsNeedUpdate === true ) {

  					direct = undefined;
  					geometry.elementsNeedUpdate = false;

  				}

  				if ( direct === undefined ) {

  					return this.fromGeometry( geometry );

  				}

  				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
  				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
  				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
  				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
  				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

  				geometry.verticesNeedUpdate = false;
  				geometry.normalsNeedUpdate = false;
  				geometry.colorsNeedUpdate = false;
  				geometry.uvsNeedUpdate = false;
  				geometry.groupsNeedUpdate = false;

  				geometry = direct;

  			}

  			var attribute;

  			if ( geometry.verticesNeedUpdate === true ) {

  				attribute = this.attributes.position;

  				if ( attribute !== undefined ) {

  					attribute.copyVector3sArray( geometry.vertices );
  					attribute.needsUpdate = true;

  				}

  				geometry.verticesNeedUpdate = false;

  			}

  			if ( geometry.normalsNeedUpdate === true ) {

  				attribute = this.attributes.normal;

  				if ( attribute !== undefined ) {

  					attribute.copyVector3sArray( geometry.normals );
  					attribute.needsUpdate = true;

  				}

  				geometry.normalsNeedUpdate = false;

  			}

  			if ( geometry.colorsNeedUpdate === true ) {

  				attribute = this.attributes.color;

  				if ( attribute !== undefined ) {

  					attribute.copyColorsArray( geometry.colors );
  					attribute.needsUpdate = true;

  				}

  				geometry.colorsNeedUpdate = false;

  			}

  			if ( geometry.uvsNeedUpdate ) {

  				attribute = this.attributes.uv;

  				if ( attribute !== undefined ) {

  					attribute.copyVector2sArray( geometry.uvs );
  					attribute.needsUpdate = true;

  				}

  				geometry.uvsNeedUpdate = false;

  			}

  			if ( geometry.lineDistancesNeedUpdate ) {

  				attribute = this.attributes.lineDistance;

  				if ( attribute !== undefined ) {

  					attribute.copyArray( geometry.lineDistances );
  					attribute.needsUpdate = true;

  				}

  				geometry.lineDistancesNeedUpdate = false;

  			}

  			if ( geometry.groupsNeedUpdate ) {

  				geometry.computeGroups( object.geometry );
  				this.groups = geometry.groups;

  				geometry.groupsNeedUpdate = false;

  			}

  			return this;

  		},

  		fromGeometry: function ( geometry ) {

  			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

  			return this.fromDirectGeometry( geometry.__directGeometry );

  		},

  		fromDirectGeometry: function ( geometry ) {

  			var positions = new Float32Array( geometry.vertices.length * 3 );
  			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

  			if ( geometry.normals.length > 0 ) {

  				var normals = new Float32Array( geometry.normals.length * 3 );
  				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

  			}

  			if ( geometry.colors.length > 0 ) {

  				var colors = new Float32Array( geometry.colors.length * 3 );
  				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

  			}

  			if ( geometry.uvs.length > 0 ) {

  				var uvs = new Float32Array( geometry.uvs.length * 2 );
  				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

  			}

  			if ( geometry.uvs2.length > 0 ) {

  				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
  				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

  			}

  			// groups

  			this.groups = geometry.groups;

  			// morphs

  			for ( var name in geometry.morphTargets ) {

  				var array = [];
  				var morphTargets = geometry.morphTargets[ name ];

  				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

  					var morphTarget = morphTargets[ i ];

  					var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
  					attribute.name = morphTarget.name;

  					array.push( attribute.copyVector3sArray( morphTarget.data ) );

  				}

  				this.morphAttributes[ name ] = array;

  			}

  			// skinning

  			if ( geometry.skinIndices.length > 0 ) {

  				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
  				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

  			}

  			if ( geometry.skinWeights.length > 0 ) {

  				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
  				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

  			}

  			//

  			if ( geometry.boundingSphere !== null ) {

  				this.boundingSphere = geometry.boundingSphere.clone();

  			}

  			if ( geometry.boundingBox !== null ) {

  				this.boundingBox = geometry.boundingBox.clone();

  			}

  			return this;

  		},

  		computeBoundingBox: function () {

  			var box = new Box3();

  			return function computeBoundingBox() {

  				if ( this.boundingBox === null ) {

  					this.boundingBox = new Box3();

  				}

  				var position = this.attributes.position;
  				var morphAttributesPosition = this.morphAttributes.position;

  				if ( position !== undefined ) {

  					this.boundingBox.setFromBufferAttribute( position );

  					// process morph attributes if present

  					if ( morphAttributesPosition ) {

  						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  							var morphAttribute = morphAttributesPosition[ i ];
  							box.setFromBufferAttribute( morphAttribute );

  							this.boundingBox.expandByPoint( box.min );
  							this.boundingBox.expandByPoint( box.max );

  						}

  					}

  				} else {

  					this.boundingBox.makeEmpty();

  				}

  				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  				}

  			};

  		}(),

  		computeBoundingSphere: function () {

  			var box = new Box3();
  			var boxMorphTargets = new Box3();
  			var vector = new Vector3();

  			return function computeBoundingSphere() {

  				if ( this.boundingSphere === null ) {

  					this.boundingSphere = new Sphere();

  				}

  				var position = this.attributes.position;
  				var morphAttributesPosition = this.morphAttributes.position;

  				if ( position ) {

  					// first, find the center of the bounding sphere

  					var center = this.boundingSphere.center;

  					box.setFromBufferAttribute( position );

  					// process morph attributes if present

  					if ( morphAttributesPosition ) {

  						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  							var morphAttribute = morphAttributesPosition[ i ];
  							boxMorphTargets.setFromBufferAttribute( morphAttribute );

  							box.expandByPoint( boxMorphTargets.min );
  							box.expandByPoint( boxMorphTargets.max );

  						}

  					}

  					box.getCenter( center );

  					// second, try to find a boundingSphere with a radius smaller than the
  					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  					var maxRadiusSq = 0;

  					for ( var i = 0, il = position.count; i < il; i ++ ) {

  						vector.fromBufferAttribute( position, i );

  						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

  					}

  					// process morph attributes if present

  					if ( morphAttributesPosition ) {

  						for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

  							var morphAttribute = morphAttributesPosition[ i ];

  							for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

  								vector.fromBufferAttribute( morphAttribute, j );

  								maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

  							}

  						}

  					}

  					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  					if ( isNaN( this.boundingSphere.radius ) ) {

  						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  					}

  				}

  			};

  		}(),

  		computeFaceNormals: function () {

  			// backwards compatibility

  		},

  		computeVertexNormals: function () {

  			var index = this.index;
  			var attributes = this.attributes;

  			if ( attributes.position ) {

  				var positions = attributes.position.array;

  				if ( attributes.normal === undefined ) {

  					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

  				} else {

  					// reset existing normals to zero

  					var array = attributes.normal.array;

  					for ( var i = 0, il = array.length; i < il; i ++ ) {

  						array[ i ] = 0;

  					}

  				}

  				var normals = attributes.normal.array;

  				var vA, vB, vC;
  				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
  				var cb = new Vector3(), ab = new Vector3();

  				// indexed elements

  				if ( index ) {

  					var indices = index.array;

  					for ( var i = 0, il = index.count; i < il; i += 3 ) {

  						vA = indices[ i + 0 ] * 3;
  						vB = indices[ i + 1 ] * 3;
  						vC = indices[ i + 2 ] * 3;

  						pA.fromArray( positions, vA );
  						pB.fromArray( positions, vB );
  						pC.fromArray( positions, vC );

  						cb.subVectors( pC, pB );
  						ab.subVectors( pA, pB );
  						cb.cross( ab );

  						normals[ vA ] += cb.x;
  						normals[ vA + 1 ] += cb.y;
  						normals[ vA + 2 ] += cb.z;

  						normals[ vB ] += cb.x;
  						normals[ vB + 1 ] += cb.y;
  						normals[ vB + 2 ] += cb.z;

  						normals[ vC ] += cb.x;
  						normals[ vC + 1 ] += cb.y;
  						normals[ vC + 2 ] += cb.z;

  					}

  				} else {

  					// non-indexed elements (unconnected triangle soup)

  					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

  						pA.fromArray( positions, i );
  						pB.fromArray( positions, i + 3 );
  						pC.fromArray( positions, i + 6 );

  						cb.subVectors( pC, pB );
  						ab.subVectors( pA, pB );
  						cb.cross( ab );

  						normals[ i ] = cb.x;
  						normals[ i + 1 ] = cb.y;
  						normals[ i + 2 ] = cb.z;

  						normals[ i + 3 ] = cb.x;
  						normals[ i + 4 ] = cb.y;
  						normals[ i + 5 ] = cb.z;

  						normals[ i + 6 ] = cb.x;
  						normals[ i + 7 ] = cb.y;
  						normals[ i + 8 ] = cb.z;

  					}

  				}

  				this.normalizeNormals();

  				attributes.normal.needsUpdate = true;

  			}

  		},

  		merge: function ( geometry, offset ) {

  			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

  				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
  				return;

  			}

  			if ( offset === undefined ) {

  				offset = 0;

  				console.warn(
  					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
  					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
  				);

  			}

  			var attributes = this.attributes;

  			for ( var key in attributes ) {

  				if ( geometry.attributes[ key ] === undefined ) continue;

  				var attribute1 = attributes[ key ];
  				var attributeArray1 = attribute1.array;

  				var attribute2 = geometry.attributes[ key ];
  				var attributeArray2 = attribute2.array;

  				var attributeOffset = attribute2.itemSize * offset;
  				var length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

  				for ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

  					attributeArray1[ j ] = attributeArray2[ i ];

  				}

  			}

  			return this;

  		},

  		normalizeNormals: function () {

  			var vector = new Vector3();

  			return function normalizeNormals() {

  				var normals = this.attributes.normal;

  				for ( var i = 0, il = normals.count; i < il; i ++ ) {

  					vector.x = normals.getX( i );
  					vector.y = normals.getY( i );
  					vector.z = normals.getZ( i );

  					vector.normalize();

  					normals.setXYZ( i, vector.x, vector.y, vector.z );

  				}

  			};

  		}(),

  		toNonIndexed: function () {

  			function convertBufferAttribute( attribute, indices ) {

  				var array = attribute.array;
  				var itemSize = attribute.itemSize;

  				var array2 = new array.constructor( indices.length * itemSize );

  				var index = 0, index2 = 0;

  				for ( var i = 0, l = indices.length; i < l; i ++ ) {

  					index = indices[ i ] * itemSize;

  					for ( var j = 0; j < itemSize; j ++ ) {

  						array2[ index2 ++ ] = array[ index ++ ];

  					}

  				}

  				return new BufferAttribute( array2, itemSize );

  			}

  			//

  			if ( this.index === null ) {

  				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
  				return this;

  			}

  			var geometry2 = new BufferGeometry();

  			var indices = this.index.array;
  			var attributes = this.attributes;

  			// attributes

  			for ( var name in attributes ) {

  				var attribute = attributes[ name ];

  				var newAttribute = convertBufferAttribute( attribute, indices );

  				geometry2.addAttribute( name, newAttribute );

  			}

  			// morph attributes

  			var morphAttributes = this.morphAttributes;

  			for ( name in morphAttributes ) {

  				var morphArray = [];
  				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  				for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

  					var attribute = morphAttribute[ i ];

  					var newAttribute = convertBufferAttribute( attribute, indices );

  					morphArray.push( newAttribute );

  				}

  				geometry2.morphAttributes[ name ] = morphArray;

  			}

  			// groups

  			var groups = this.groups;

  			for ( var i = 0, l = groups.length; i < l; i ++ ) {

  				var group = groups[ i ];
  				geometry2.addGroup( group.start, group.count, group.materialIndex );

  			}

  			return geometry2;

  		},

  		toJSON: function () {

  			var data = {
  				metadata: {
  					version: 4.5,
  					type: 'BufferGeometry',
  					generator: 'BufferGeometry.toJSON'
  				}
  			};

  			// standard BufferGeometry serialization

  			data.uuid = this.uuid;
  			data.type = this.type;
  			if ( this.name !== '' ) data.name = this.name;
  			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

  			if ( this.parameters !== undefined ) {

  				var parameters = this.parameters;

  				for ( var key in parameters ) {

  					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  				}

  				return data;

  			}

  			data.data = { attributes: {} };

  			var index = this.index;

  			if ( index !== null ) {

  				data.data.index = {
  					type: index.array.constructor.name,
  					array: Array.prototype.slice.call( index.array )
  				};

  			}

  			var attributes = this.attributes;

  			for ( var key in attributes ) {

  				var attribute = attributes[ key ];

  				var attributeData = {
  					itemSize: attribute.itemSize,
  					type: attribute.array.constructor.name,
  					array: Array.prototype.slice.call( attribute.array ),
  					normalized: attribute.normalized
  				};

  				if ( attribute.name !== '' ) attributeData.name = attribute.name;

  				data.data.attributes[ key ] = attributeData;

  			}

  			var morphAttributes = {};
  			var hasMorphAttributes = false;

  			for ( var key in this.morphAttributes ) {

  				var attributeArray = this.morphAttributes[ key ];

  				var array = [];

  				for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

  					var attribute = attributeArray[ i ];

  					var attributeData = {
  						itemSize: attribute.itemSize,
  						type: attribute.array.constructor.name,
  						array: Array.prototype.slice.call( attribute.array ),
  						normalized: attribute.normalized
  					};

  					if ( attribute.name !== '' ) attributeData.name = attribute.name;

  					array.push( attributeData );

  				}

  				if ( array.length > 0 ) {

  					morphAttributes[ key ] = array;

  					hasMorphAttributes = true;

  				}

  			}

  			if ( hasMorphAttributes ) data.data.morphAttributes = morphAttributes;

  			var groups = this.groups;

  			if ( groups.length > 0 ) {

  				data.data.groups = JSON.parse( JSON.stringify( groups ) );

  			}

  			var boundingSphere = this.boundingSphere;

  			if ( boundingSphere !== null ) {

  				data.data.boundingSphere = {
  					center: boundingSphere.center.toArray(),
  					radius: boundingSphere.radius
  				};

  			}

  			return data;

  		},

  		clone: function () {

  			/*
  			 // Handle primitives

  			 var parameters = this.parameters;

  			 if ( parameters !== undefined ) {

  			 var values = [];

  			 for ( var key in parameters ) {

  			 values.push( parameters[ key ] );

  			 }

  			 var geometry = Object.create( this.constructor.prototype );
  			 this.constructor.apply( geometry, values );
  			 return geometry;

  			 }

  			 return new this.constructor().copy( this );
  			 */

  			return new BufferGeometry().copy( this );

  		},

  		copy: function ( source ) {

  			var name, i, l;

  			// reset

  			this.index = null;
  			this.attributes = {};
  			this.morphAttributes = {};
  			this.groups = [];
  			this.boundingBox = null;
  			this.boundingSphere = null;

  			// name

  			this.name = source.name;

  			// index

  			var index = source.index;

  			if ( index !== null ) {

  				this.setIndex( index.clone() );

  			}

  			// attributes

  			var attributes = source.attributes;

  			for ( name in attributes ) {

  				var attribute = attributes[ name ];
  				this.addAttribute( name, attribute.clone() );

  			}

  			// morph attributes

  			var morphAttributes = source.morphAttributes;

  			for ( name in morphAttributes ) {

  				var array = [];
  				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

  					array.push( morphAttribute[ i ].clone() );

  				}

  				this.morphAttributes[ name ] = array;

  			}

  			// groups

  			var groups = source.groups;

  			for ( i = 0, l = groups.length; i < l; i ++ ) {

  				var group = groups[ i ];
  				this.addGroup( group.start, group.count, group.materialIndex );

  			}

  			// bounding box

  			var boundingBox = source.boundingBox;

  			if ( boundingBox !== null ) {

  				this.boundingBox = boundingBox.clone();

  			}

  			// bounding sphere

  			var boundingSphere = source.boundingSphere;

  			if ( boundingSphere !== null ) {

  				this.boundingSphere = boundingSphere.clone();

  			}

  			// draw range

  			this.drawRange.start = source.drawRange.start;
  			this.drawRange.count = source.drawRange.count;

  			// user data

  			this.userData = source.userData;

  			return this;

  		},

  		dispose: function () {

  			this.dispatchEvent( { type: 'dispose' } );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// BoxGeometry

  	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  		Geometry.call( this );

  		this.type = 'BoxGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			depth: depth,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			depthSegments: depthSegments
  		};

  		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
  		this.mergeVertices();

  	}

  	BoxGeometry.prototype = Object.create( Geometry.prototype );
  	BoxGeometry.prototype.constructor = BoxGeometry;

  	// BoxBufferGeometry

  	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  		BufferGeometry.call( this );

  		this.type = 'BoxBufferGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			depth: depth,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			depthSegments: depthSegments
  		};

  		var scope = this;

  		width = width || 1;
  		height = height || 1;
  		depth = depth || 1;

  		// segments

  		widthSegments = Math.floor( widthSegments ) || 1;
  		heightSegments = Math.floor( heightSegments ) || 1;
  		depthSegments = Math.floor( depthSegments ) || 1;

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// helper variables

  		var numberOfVertices = 0;
  		var groupStart = 0;

  		// build each side of the box geometry

  		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
  		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
  		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
  		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
  		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
  		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  			var segmentWidth = width / gridX;
  			var segmentHeight = height / gridY;

  			var widthHalf = width / 2;
  			var heightHalf = height / 2;
  			var depthHalf = depth / 2;

  			var gridX1 = gridX + 1;
  			var gridY1 = gridY + 1;

  			var vertexCounter = 0;
  			var groupCount = 0;

  			var ix, iy;

  			var vector = new Vector3();

  			// generate vertices, normals and uvs

  			for ( iy = 0; iy < gridY1; iy ++ ) {

  				var y = iy * segmentHeight - heightHalf;

  				for ( ix = 0; ix < gridX1; ix ++ ) {

  					var x = ix * segmentWidth - widthHalf;

  					// set values to correct vector component

  					vector[ u ] = x * udir;
  					vector[ v ] = y * vdir;
  					vector[ w ] = depthHalf;

  					// now apply vector to vertex buffer

  					vertices.push( vector.x, vector.y, vector.z );

  					// set values to correct vector component

  					vector[ u ] = 0;
  					vector[ v ] = 0;
  					vector[ w ] = depth > 0 ? 1 : - 1;

  					// now apply vector to normal buffer

  					normals.push( vector.x, vector.y, vector.z );

  					// uvs

  					uvs.push( ix / gridX );
  					uvs.push( 1 - ( iy / gridY ) );

  					// counters

  					vertexCounter += 1;

  				}

  			}

  			// indices

  			// 1. you need three indices to draw a single face
  			// 2. a single segment consists of two faces
  			// 3. so we need to generate six (2*3) indices per segment

  			for ( iy = 0; iy < gridY; iy ++ ) {

  				for ( ix = 0; ix < gridX; ix ++ ) {

  					var a = numberOfVertices + ix + gridX1 * iy;
  					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  					// increase counter

  					groupCount += 6;

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, materialIndex );

  			// calculate new start value for groups

  			groupStart += groupCount;

  			// update total number of vertices

  			numberOfVertices += vertexCounter;

  		}

  	}

  	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// PlaneGeometry

  	function PlaneGeometry( width, height, widthSegments, heightSegments ) {

  		Geometry.call( this );

  		this.type = 'PlaneGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments
  		};

  		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
  		this.mergeVertices();

  	}

  	PlaneGeometry.prototype = Object.create( Geometry.prototype );
  	PlaneGeometry.prototype.constructor = PlaneGeometry;

  	// PlaneBufferGeometry

  	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

  		BufferGeometry.call( this );

  		this.type = 'PlaneBufferGeometry';

  		this.parameters = {
  			width: width,
  			height: height,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments
  		};

  		width = width || 1;
  		height = height || 1;

  		var width_half = width / 2;
  		var height_half = height / 2;

  		var gridX = Math.floor( widthSegments ) || 1;
  		var gridY = Math.floor( heightSegments ) || 1;

  		var gridX1 = gridX + 1;
  		var gridY1 = gridY + 1;

  		var segment_width = width / gridX;
  		var segment_height = height / gridY;

  		var ix, iy;

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// generate vertices, normals and uvs

  		for ( iy = 0; iy < gridY1; iy ++ ) {

  			var y = iy * segment_height - height_half;

  			for ( ix = 0; ix < gridX1; ix ++ ) {

  				var x = ix * segment_width - width_half;

  				vertices.push( x, - y, 0 );

  				normals.push( 0, 0, 1 );

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  			}

  		}

  		// indices

  		for ( iy = 0; iy < gridY; iy ++ ) {

  			for ( ix = 0; ix < gridX; ix ++ ) {

  				var a = ix + gridX1 * iy;
  				var b = ix + gridX1 * ( iy + 1 );
  				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  				var d = ( ix + 1 ) + gridX1 * iy;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	var materialId = 0;

  	function Material() {

  		Object.defineProperty( this, 'id', { value: materialId ++ } );

  		this.uuid = _Math.generateUUID();

  		this.name = '';
  		this.type = 'Material';

  		this.fog = true;
  		this.lights = true;

  		this.blending = NormalBlending;
  		this.side = FrontSide;
  		this.flatShading = false;
  		this.vertexTangents = false;
  		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

  		this.opacity = 1;
  		this.transparent = false;

  		this.blendSrc = SrcAlphaFactor;
  		this.blendDst = OneMinusSrcAlphaFactor;
  		this.blendEquation = AddEquation;
  		this.blendSrcAlpha = null;
  		this.blendDstAlpha = null;
  		this.blendEquationAlpha = null;

  		this.depthFunc = LessEqualDepth;
  		this.depthTest = true;
  		this.depthWrite = true;

  		this.clippingPlanes = null;
  		this.clipIntersection = false;
  		this.clipShadows = false;

  		this.shadowSide = null;

  		this.colorWrite = true;

  		this.precision = null; // override the renderer's default precision for this material

  		this.polygonOffset = false;
  		this.polygonOffsetFactor = 0;
  		this.polygonOffsetUnits = 0;

  		this.dithering = false;

  		this.alphaTest = 0;
  		this.premultipliedAlpha = false;

  		this.visible = true;

  		this.userData = {};

  		this.needsUpdate = true;

  	}

  	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  		constructor: Material,

  		isMaterial: true,

  		onBeforeCompile: function () {},

  		setValues: function ( values ) {

  			if ( values === undefined ) return;

  			for ( var key in values ) {

  				var newValue = values[ key ];

  				if ( newValue === undefined ) {

  					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
  					continue;

  				}

  				// for backward compatability if shading is set in the constructor
  				if ( key === 'shading' ) {

  					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
  					this.flatShading = ( newValue === FlatShading ) ? true : false;
  					continue;

  				}

  				var currentValue = this[ key ];

  				if ( currentValue === undefined ) {

  					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
  					continue;

  				}

  				if ( currentValue && currentValue.isColor ) {

  					currentValue.set( newValue );

  				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  					currentValue.copy( newValue );

  				} else {

  					this[ key ] = newValue;

  				}

  			}

  		},

  		toJSON: function ( meta ) {

  			var isRoot = ( meta === undefined || typeof meta === 'string' );

  			if ( isRoot ) {

  				meta = {
  					textures: {},
  					images: {}
  				};

  			}

  			var data = {
  				metadata: {
  					version: 4.5,
  					type: 'Material',
  					generator: 'Material.toJSON'
  				}
  			};

  			// standard Material serialization
  			data.uuid = this.uuid;
  			data.type = this.type;

  			if ( this.name !== '' ) data.name = this.name;

  			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

  			if ( this.roughness !== undefined ) data.roughness = this.roughness;
  			if ( this.metalness !== undefined ) data.metalness = this.metalness;

  			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
  			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

  			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
  			if ( this.shininess !== undefined ) data.shininess = this.shininess;
  			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
  			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

  			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
  			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
  			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
  			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

  			if ( this.aoMap && this.aoMap.isTexture ) {

  				data.aoMap = this.aoMap.toJSON( meta ).uuid;
  				data.aoMapIntensity = this.aoMapIntensity;

  			}

  			if ( this.bumpMap && this.bumpMap.isTexture ) {

  				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  				data.bumpScale = this.bumpScale;

  			}

  			if ( this.normalMap && this.normalMap.isTexture ) {

  				data.normalMap = this.normalMap.toJSON( meta ).uuid;
  				data.normalMapType = this.normalMapType;
  				data.normalScale = this.normalScale.toArray();

  			}

  			if ( this.displacementMap && this.displacementMap.isTexture ) {

  				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  				data.displacementScale = this.displacementScale;
  				data.displacementBias = this.displacementBias;

  			}

  			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
  			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

  			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
  			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

  			if ( this.envMap && this.envMap.isTexture ) {

  				data.envMap = this.envMap.toJSON( meta ).uuid;
  				data.reflectivity = this.reflectivity; // Scale behind envMap

  				if ( this.combine !== undefined ) data.combine = this.combine;
  				if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

  			}

  			if ( this.gradientMap && this.gradientMap.isTexture ) {

  				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  			}

  			if ( this.size !== undefined ) data.size = this.size;
  			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

  			if ( this.blending !== NormalBlending ) data.blending = this.blending;
  			if ( this.flatShading === true ) data.flatShading = this.flatShading;
  			if ( this.side !== FrontSide ) data.side = this.side;
  			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

  			if ( this.opacity < 1 ) data.opacity = this.opacity;
  			if ( this.transparent === true ) data.transparent = this.transparent;

  			data.depthFunc = this.depthFunc;
  			data.depthTest = this.depthTest;
  			data.depthWrite = this.depthWrite;

  			// rotation (SpriteMaterial)
  			if ( this.rotation !== 0 ) data.rotation = this.rotation;

  			if ( this.polygonOffset === true ) data.polygonOffset = true;
  			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
  			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

  			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
  			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
  			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
  			if ( this.scale !== undefined ) data.scale = this.scale;

  			if ( this.dithering === true ) data.dithering = true;

  			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
  			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

  			if ( this.wireframe === true ) data.wireframe = this.wireframe;
  			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
  			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
  			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

  			if ( this.morphTargets === true ) data.morphTargets = true;
  			if ( this.skinning === true ) data.skinning = true;

  			if ( this.visible === false ) data.visible = false;
  			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

  			// TODO: Copied from Object3D.toJSON

  			function extractFromCache( cache ) {

  				var values = [];

  				for ( var key in cache ) {

  					var data = cache[ key ];
  					delete data.metadata;
  					values.push( data );

  				}

  				return values;

  			}

  			if ( isRoot ) {

  				var textures = extractFromCache( meta.textures );
  				var images = extractFromCache( meta.images );

  				if ( textures.length > 0 ) data.textures = textures;
  				if ( images.length > 0 ) data.images = images;

  			}

  			return data;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( source ) {

  			this.name = source.name;

  			this.fog = source.fog;
  			this.lights = source.lights;

  			this.blending = source.blending;
  			this.side = source.side;
  			this.flatShading = source.flatShading;
  			this.vertexColors = source.vertexColors;

  			this.opacity = source.opacity;
  			this.transparent = source.transparent;

  			this.blendSrc = source.blendSrc;
  			this.blendDst = source.blendDst;
  			this.blendEquation = source.blendEquation;
  			this.blendSrcAlpha = source.blendSrcAlpha;
  			this.blendDstAlpha = source.blendDstAlpha;
  			this.blendEquationAlpha = source.blendEquationAlpha;

  			this.depthFunc = source.depthFunc;
  			this.depthTest = source.depthTest;
  			this.depthWrite = source.depthWrite;

  			this.colorWrite = source.colorWrite;

  			this.precision = source.precision;

  			this.polygonOffset = source.polygonOffset;
  			this.polygonOffsetFactor = source.polygonOffsetFactor;
  			this.polygonOffsetUnits = source.polygonOffsetUnits;

  			this.dithering = source.dithering;

  			this.alphaTest = source.alphaTest;
  			this.premultipliedAlpha = source.premultipliedAlpha;

  			this.visible = source.visible;
  			this.userData = JSON.parse( JSON.stringify( source.userData ) );

  			this.clipShadows = source.clipShadows;
  			this.clipIntersection = source.clipIntersection;

  			var srcPlanes = source.clippingPlanes,
  				dstPlanes = null;

  			if ( srcPlanes !== null ) {

  				var n = srcPlanes.length;
  				dstPlanes = new Array( n );

  				for ( var i = 0; i !== n; ++ i )
  					dstPlanes[ i ] = srcPlanes[ i ].clone();

  			}

  			this.clippingPlanes = dstPlanes;

  			this.shadowSide = source.shadowSide;

  			return this;

  		},

  		dispose: function () {

  			this.dispatchEvent( { type: 'dispose' } );

  		}

  	} );

  	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

  	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * parameters = {
  	 *  defines: { "label" : "value" },
  	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
  	 *
  	 *  fragmentShader: <string>,
  	 *  vertexShader: <string>,
  	 *
  	 *  wireframe: <boolean>,
  	 *  wireframeLinewidth: <float>,
  	 *
  	 *  lights: <bool>,
  	 *
  	 *  skinning: <bool>,
  	 *  morphTargets: <bool>,
  	 *  morphNormals: <bool>
  	 * }
  	 */

  	function ShaderMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'ShaderMaterial';

  		this.defines = {};
  		this.uniforms = {};

  		this.vertexShader = default_vertex;
  		this.fragmentShader = default_fragment;

  		this.linewidth = 1;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.fog = false; // set to use scene fog
  		this.lights = false; // set to use scene lights
  		this.clipping = false; // set to use user-defined clipping planes

  		this.skinning = false; // set to use skinning attribute streams
  		this.morphTargets = false; // set to use morph targets
  		this.morphNormals = false; // set to use morph normals

  		this.extensions = {
  			derivatives: false, // set to use derivatives
  			fragDepth: false, // set to use fragment depth values
  			drawBuffers: false, // set to use draw buffers
  			shaderTextureLOD: false // set to use shader texture LOD
  		};

  		// When rendered geometry doesn't include these attributes but the material does,
  		// use these default values in WebGL. This avoids errors when buffer data is missing.
  		this.defaultAttributeValues = {
  			'color': [ 1, 1, 1 ],
  			'uv': [ 0, 0 ],
  			'uv2': [ 0, 0 ]
  		};

  		this.index0AttributeName = undefined;
  		this.uniformsNeedUpdate = false;

  		if ( parameters !== undefined ) {

  			if ( parameters.attributes !== undefined ) {

  				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

  			}

  			this.setValues( parameters );

  		}

  	}

  	ShaderMaterial.prototype = Object.create( Material.prototype );
  	ShaderMaterial.prototype.constructor = ShaderMaterial;

  	ShaderMaterial.prototype.isShaderMaterial = true;

  	ShaderMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.fragmentShader = source.fragmentShader;
  		this.vertexShader = source.vertexShader;

  		this.uniforms = cloneUniforms( source.uniforms );

  		this.defines = Object.assign( {}, source.defines );

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.lights = source.lights;
  		this.clipping = source.clipping;

  		this.skinning = source.skinning;

  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		this.extensions = source.extensions;

  		return this;

  	};

  	ShaderMaterial.prototype.toJSON = function ( meta ) {

  		var data = Material.prototype.toJSON.call( this, meta );

  		data.uniforms = {};

  		for ( var name in this.uniforms ) {

  			var uniform = this.uniforms[ name ];
  			var value = uniform.value;

  			if ( value && value.isTexture ) {

  				data.uniforms[ name ] = {
  					type: 't',
  					value: value.toJSON( meta ).uuid
  				};

  			} else if ( value && value.isColor ) {

  				data.uniforms[ name ] = {
  					type: 'c',
  					value: value.getHex()
  				};

  			} else if ( value && value.isVector2 ) {

  				data.uniforms[ name ] = {
  					type: 'v2',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector3 ) {

  				data.uniforms[ name ] = {
  					type: 'v3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isVector4 ) {

  				data.uniforms[ name ] = {
  					type: 'v4',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix3 ) {

  				data.uniforms[ name ] = {
  					type: 'm3',
  					value: value.toArray()
  				};

  			} else if ( value && value.isMatrix4 ) {

  				data.uniforms[ name ] = {
  					type: 'm4',
  					value: value.toArray()
  				};

  			} else {

  				data.uniforms[ name ] = {
  					value: value
  				};

  				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

  			}

  		}

  		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

  		data.vertexShader = this.vertexShader;
  		data.fragmentShader = this.fragmentShader;

  		var extensions = {};

  		for ( var key in this.extensions ) {

  			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

  		}

  		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

  		return data;

  	};

  	/**
  	 * @author bhouston / http://clara.io
  	 */

  	function Ray( origin, direction ) {

  		this.origin = ( origin !== undefined ) ? origin : new Vector3();
  		this.direction = ( direction !== undefined ) ? direction : new Vector3();

  	}

  	Object.assign( Ray.prototype, {

  		set: function ( origin, direction ) {

  			this.origin.copy( origin );
  			this.direction.copy( direction );

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( ray ) {

  			this.origin.copy( ray.origin );
  			this.direction.copy( ray.direction );

  			return this;

  		},

  		at: function ( t, target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Ray: .at() target is now required' );
  				target = new Vector3();

  			}

  			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  		},

  		lookAt: function ( v ) {

  			this.direction.copy( v ).sub( this.origin ).normalize();

  			return this;

  		},

  		recast: function () {

  			var v1 = new Vector3();

  			return function recast( t ) {

  				this.origin.copy( this.at( t, v1 ) );

  				return this;

  			};

  		}(),

  		closestPointToPoint: function ( point, target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
  				target = new Vector3();

  			}

  			target.subVectors( point, this.origin );

  			var directionDistance = target.dot( this.direction );

  			if ( directionDistance < 0 ) {

  				return target.copy( this.origin );

  			}

  			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  		},

  		distanceToPoint: function ( point ) {

  			return Math.sqrt( this.distanceSqToPoint( point ) );

  		},

  		distanceSqToPoint: function () {

  			var v1 = new Vector3();

  			return function distanceSqToPoint( point ) {

  				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

  				// point behind the ray

  				if ( directionDistance < 0 ) {

  					return this.origin.distanceToSquared( point );

  				}

  				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  				return v1.distanceToSquared( point );

  			};

  		}(),

  		distanceSqToSegment: function () {

  			var segCenter = new Vector3();
  			var segDir = new Vector3();
  			var diff = new Vector3();

  			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  				// It returns the min distance between the ray and the segment
  				// defined by v0 and v1
  				// It can also set two optional targets :
  				// - The closest point on the ray
  				// - The closest point on the segment

  				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  				segDir.copy( v1 ).sub( v0 ).normalize();
  				diff.copy( this.origin ).sub( segCenter );

  				var segExtent = v0.distanceTo( v1 ) * 0.5;
  				var a01 = - this.direction.dot( segDir );
  				var b0 = diff.dot( this.direction );
  				var b1 = - diff.dot( segDir );
  				var c = diff.lengthSq();
  				var det = Math.abs( 1 - a01 * a01 );
  				var s0, s1, sqrDist, extDet;

  				if ( det > 0 ) {

  					// The ray and segment are not parallel.

  					s0 = a01 * b1 - b0;
  					s1 = a01 * b0 - b1;
  					extDet = segExtent * det;

  					if ( s0 >= 0 ) {

  						if ( s1 >= - extDet ) {

  							if ( s1 <= extDet ) {

  								// region 0
  								// Minimum at interior points of ray and segment.

  								var invDet = 1 / det;
  								s0 *= invDet;
  								s1 *= invDet;
  								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  							} else {

  								// region 1

  								s1 = segExtent;
  								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  							}

  						} else {

  							// region 5

  							s1 = - segExtent;
  							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  						}

  					} else {

  						if ( s1 <= - extDet ) {

  							// region 4

  							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  						} else if ( s1 <= extDet ) {

  							// region 3

  							s0 = 0;
  							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  						} else {

  							// region 2

  							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  						}

  					}

  				} else {

  					// Ray and segment are parallel.

  					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  				}

  				if ( optionalPointOnRay ) {

  					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

  				}

  				if ( optionalPointOnSegment ) {

  					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

  				}

  				return sqrDist;

  			};

  		}(),

  		intersectSphere: function () {

  			var v1 = new Vector3();

  			return function intersectSphere( sphere, target ) {

  				v1.subVectors( sphere.center, this.origin );
  				var tca = v1.dot( this.direction );
  				var d2 = v1.dot( v1 ) - tca * tca;
  				var radius2 = sphere.radius * sphere.radius;

  				if ( d2 > radius2 ) return null;

  				var thc = Math.sqrt( radius2 - d2 );

  				// t0 = first intersect point - entrance on front of sphere
  				var t0 = tca - thc;

  				// t1 = second intersect point - exit point on back of sphere
  				var t1 = tca + thc;

  				// test to see if both t0 and t1 are behind the ray - if so, return null
  				if ( t0 < 0 && t1 < 0 ) return null;

  				// test to see if t0 is behind the ray:
  				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  				// in order to always return an intersect point that is in front of the ray.
  				if ( t0 < 0 ) return this.at( t1, target );

  				// else t0 is in front of the ray, so return the first collision point scaled by t0
  				return this.at( t0, target );

  			};

  		}(),

  		intersectsSphere: function ( sphere ) {

  			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

  		},

  		distanceToPlane: function ( plane ) {

  			var denominator = plane.normal.dot( this.direction );

  			if ( denominator === 0 ) {

  				// line is coplanar, return origin
  				if ( plane.distanceToPoint( this.origin ) === 0 ) {

  					return 0;

  				}

  				// Null is preferable to undefined since undefined means.... it is undefined

  				return null;

  			}

  			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  			// Return if the ray never intersects the plane

  			return t >= 0 ? t : null;

  		},

  		intersectPlane: function ( plane, target ) {

  			var t = this.distanceToPlane( plane );

  			if ( t === null ) {

  				return null;

  			}

  			return this.at( t, target );

  		},

  		intersectsPlane: function ( plane ) {

  			// check if the ray lies on the plane first

  			var distToPoint = plane.distanceToPoint( this.origin );

  			if ( distToPoint === 0 ) {

  				return true;

  			}

  			var denominator = plane.normal.dot( this.direction );

  			if ( denominator * distToPoint < 0 ) {

  				return true;

  			}

  			// ray origin is behind the plane (and is pointing behind it)

  			return false;

  		},

  		intersectBox: function ( box, target ) {

  			var tmin, tmax, tymin, tymax, tzmin, tzmax;

  			var invdirx = 1 / this.direction.x,
  				invdiry = 1 / this.direction.y,
  				invdirz = 1 / this.direction.z;

  			var origin = this.origin;

  			if ( invdirx >= 0 ) {

  				tmin = ( box.min.x - origin.x ) * invdirx;
  				tmax = ( box.max.x - origin.x ) * invdirx;

  			} else {

  				tmin = ( box.max.x - origin.x ) * invdirx;
  				tmax = ( box.min.x - origin.x ) * invdirx;

  			}

  			if ( invdiry >= 0 ) {

  				tymin = ( box.min.y - origin.y ) * invdiry;
  				tymax = ( box.max.y - origin.y ) * invdiry;

  			} else {

  				tymin = ( box.max.y - origin.y ) * invdiry;
  				tymax = ( box.min.y - origin.y ) * invdiry;

  			}

  			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

  			// These lines also handle the case where tmin or tmax is NaN
  			// (result of 0 * Infinity). x !== x returns true if x is NaN

  			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

  			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

  			if ( invdirz >= 0 ) {

  				tzmin = ( box.min.z - origin.z ) * invdirz;
  				tzmax = ( box.max.z - origin.z ) * invdirz;

  			} else {

  				tzmin = ( box.max.z - origin.z ) * invdirz;
  				tzmax = ( box.min.z - origin.z ) * invdirz;

  			}

  			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

  			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

  			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

  			//return point closest to the ray (positive side)

  			if ( tmax < 0 ) return null;

  			return this.at( tmin >= 0 ? tmin : tmax, target );

  		},

  		intersectsBox: ( function () {

  			var v = new Vector3();

  			return function intersectsBox( box ) {

  				return this.intersectBox( box, v ) !== null;

  			};

  		} )(),

  		intersectTriangle: function () {

  			// Compute the offset origin, edges, and normal.
  			var diff = new Vector3();
  			var edge1 = new Vector3();
  			var edge2 = new Vector3();
  			var normal = new Vector3();

  			return function intersectTriangle( a, b, c, backfaceCulling, target ) {

  				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  				edge1.subVectors( b, a );
  				edge2.subVectors( c, a );
  				normal.crossVectors( edge1, edge2 );

  				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  				var DdN = this.direction.dot( normal );
  				var sign;

  				if ( DdN > 0 ) {

  					if ( backfaceCulling ) return null;
  					sign = 1;

  				} else if ( DdN < 0 ) {

  					sign = - 1;
  					DdN = - DdN;

  				} else {

  					return null;

  				}

  				diff.subVectors( this.origin, a );
  				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

  				// b1 < 0, no intersection
  				if ( DdQxE2 < 0 ) {

  					return null;

  				}

  				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

  				// b2 < 0, no intersection
  				if ( DdE1xQ < 0 ) {

  					return null;

  				}

  				// b1+b2 > 1, no intersection
  				if ( DdQxE2 + DdE1xQ > DdN ) {

  					return null;

  				}

  				// Line intersects triangle, check if ray does.
  				var QdN = - sign * diff.dot( normal );

  				// t < 0, no intersection
  				if ( QdN < 0 ) {

  					return null;

  				}

  				// Ray intersects triangle.
  				return this.at( QdN / DdN, target );

  			};

  		}(),

  		applyMatrix4: function ( matrix4 ) {

  			this.origin.applyMatrix4( matrix4 );
  			this.direction.transformDirection( matrix4 );

  			return this;

  		},

  		equals: function ( ray ) {

  			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  		}

  	} );

  	/**
  	 * @author bhouston / http://clara.io
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function Triangle( a, b, c ) {

  		this.a = ( a !== undefined ) ? a : new Vector3();
  		this.b = ( b !== undefined ) ? b : new Vector3();
  		this.c = ( c !== undefined ) ? c : new Vector3();

  	}

  	Object.assign( Triangle, {

  		getNormal: function () {

  			var v0 = new Vector3();

  			return function getNormal( a, b, c, target ) {

  				if ( target === undefined ) {

  					console.warn( 'THREE.Triangle: .getNormal() target is now required' );
  					target = new Vector3();

  				}

  				target.subVectors( c, b );
  				v0.subVectors( a, b );
  				target.cross( v0 );

  				var targetLengthSq = target.lengthSq();
  				if ( targetLengthSq > 0 ) {

  					return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

  				}

  				return target.set( 0, 0, 0 );

  			};

  		}(),

  		// static/instance method to calculate barycentric coordinates
  		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  		getBarycoord: function () {

  			var v0 = new Vector3();
  			var v1 = new Vector3();
  			var v2 = new Vector3();

  			return function getBarycoord( point, a, b, c, target ) {

  				v0.subVectors( c, a );
  				v1.subVectors( b, a );
  				v2.subVectors( point, a );

  				var dot00 = v0.dot( v0 );
  				var dot01 = v0.dot( v1 );
  				var dot02 = v0.dot( v2 );
  				var dot11 = v1.dot( v1 );
  				var dot12 = v1.dot( v2 );

  				var denom = ( dot00 * dot11 - dot01 * dot01 );

  				if ( target === undefined ) {

  					console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
  					target = new Vector3();

  				}

  				// collinear or singular triangle
  				if ( denom === 0 ) {

  					// arbitrary location outside of triangle?
  					// not sure if this is the best idea, maybe should be returning undefined
  					return target.set( - 2, - 1, - 1 );

  				}

  				var invDenom = 1 / denom;
  				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  				// barycentric coordinates must always sum to 1
  				return target.set( 1 - u - v, v, u );

  			};

  		}(),

  		containsPoint: function () {

  			var v1 = new Vector3();

  			return function containsPoint( point, a, b, c ) {

  				Triangle.getBarycoord( point, a, b, c, v1 );

  				return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );

  			};

  		}(),

  		getUV: function () {

  			var barycoord = new Vector3();

  			return function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

  				this.getBarycoord( point, p1, p2, p3, barycoord );

  				target.set( 0, 0 );
  				target.addScaledVector( uv1, barycoord.x );
  				target.addScaledVector( uv2, barycoord.y );
  				target.addScaledVector( uv3, barycoord.z );

  				return target;

  			};

  		}()

  	} );

  	Object.assign( Triangle.prototype, {

  		set: function ( a, b, c ) {

  			this.a.copy( a );
  			this.b.copy( b );
  			this.c.copy( c );

  			return this;

  		},

  		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

  			this.a.copy( points[ i0 ] );
  			this.b.copy( points[ i1 ] );
  			this.c.copy( points[ i2 ] );

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( triangle ) {

  			this.a.copy( triangle.a );
  			this.b.copy( triangle.b );
  			this.c.copy( triangle.c );

  			return this;

  		},

  		getArea: function () {

  			var v0 = new Vector3();
  			var v1 = new Vector3();

  			return function getArea() {

  				v0.subVectors( this.c, this.b );
  				v1.subVectors( this.a, this.b );

  				return v0.cross( v1 ).length() * 0.5;

  			};

  		}(),

  		getMidpoint: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
  				target = new Vector3();

  			}

  			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  		},

  		getNormal: function ( target ) {

  			return Triangle.getNormal( this.a, this.b, this.c, target );

  		},

  		getPlane: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
  				target = new Vector3();

  			}

  			return target.setFromCoplanarPoints( this.a, this.b, this.c );

  		},

  		getBarycoord: function ( point, target ) {

  			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

  		},

  		containsPoint: function ( point ) {

  			return Triangle.containsPoint( point, this.a, this.b, this.c );

  		},

  		getUV: function ( point, uv1, uv2, uv3, result ) {

  			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );

  		},

  		intersectsBox: function ( box ) {

  			return box.intersectsTriangle( this );

  		},

  		closestPointToPoint: function () {

  			var vab = new Vector3();
  			var vac = new Vector3();
  			var vbc = new Vector3();
  			var vap = new Vector3();
  			var vbp = new Vector3();
  			var vcp = new Vector3();

  			return function closestPointToPoint( p, target ) {

  				if ( target === undefined ) {

  					console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
  					target = new Vector3();

  				}

  				var a = this.a, b = this.b, c = this.c;
  				var v, w;

  				// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
  				// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
  				// under the accompanying license; see chapter 5.1.5 for detailed explanation.
  				// basically, we're distinguishing which of the voronoi regions of the triangle
  				// the point lies in with the minimum amount of redundant computation.

  				vab.subVectors( b, a );
  				vac.subVectors( c, a );
  				vap.subVectors( p, a );
  				var d1 = vab.dot( vap );
  				var d2 = vac.dot( vap );
  				if ( d1 <= 0 && d2 <= 0 ) {

  					// vertex region of A; barycentric coords (1, 0, 0)
  					return target.copy( a );

  				}

  				vbp.subVectors( p, b );
  				var d3 = vab.dot( vbp );
  				var d4 = vac.dot( vbp );
  				if ( d3 >= 0 && d4 <= d3 ) {

  					// vertex region of B; barycentric coords (0, 1, 0)
  					return target.copy( b );

  				}

  				var vc = d1 * d4 - d3 * d2;
  				if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

  					v = d1 / ( d1 - d3 );
  					// edge region of AB; barycentric coords (1-v, v, 0)
  					return target.copy( a ).addScaledVector( vab, v );

  				}

  				vcp.subVectors( p, c );
  				var d5 = vab.dot( vcp );
  				var d6 = vac.dot( vcp );
  				if ( d6 >= 0 && d5 <= d6 ) {

  					// vertex region of C; barycentric coords (0, 0, 1)
  					return target.copy( c );

  				}

  				var vb = d5 * d2 - d1 * d6;
  				if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

  					w = d2 / ( d2 - d6 );
  					// edge region of AC; barycentric coords (1-w, 0, w)
  					return target.copy( a ).addScaledVector( vac, w );

  				}

  				var va = d3 * d6 - d5 * d4;
  				if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

  					vbc.subVectors( c, b );
  					w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
  					// edge region of BC; barycentric coords (0, 1-w, w)
  					return target.copy( b ).addScaledVector( vbc, w ); // edge region of BC

  				}

  				// face region
  				var denom = 1 / ( va + vb + vc );
  				// u = va * denom
  				v = vb * denom;
  				w = vc * denom;
  				return target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );

  			};

  		}(),

  		equals: function ( triangle ) {

  			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  opacity: <float>,
  	 *  map: new THREE.Texture( <Image> ),
  	 *
  	 *  lightMap: new THREE.Texture( <Image> ),
  	 *  lightMapIntensity: <float>
  	 *
  	 *  aoMap: new THREE.Texture( <Image> ),
  	 *  aoMapIntensity: <float>
  	 *
  	 *  specularMap: new THREE.Texture( <Image> ),
  	 *
  	 *  alphaMap: new THREE.Texture( <Image> ),
  	 *
  	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
  	 *  combine: THREE.Multiply,
  	 *  reflectivity: <float>,
  	 *  refractionRatio: <float>,
  	 *
  	 *  depthTest: <bool>,
  	 *  depthWrite: <bool>,
  	 *
  	 *  wireframe: <boolean>,
  	 *  wireframeLinewidth: <float>,
  	 *
  	 *  skinning: <bool>,
  	 *  morphTargets: <bool>
  	 * }
  	 */

  	function MeshBasicMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'MeshBasicMaterial';

  		this.color = new Color( 0xffffff ); // emissive

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.skinning = false;
  		this.morphTargets = false;

  		this.lights = false;

  		this.setValues( parameters );

  	}

  	MeshBasicMaterial.prototype = Object.create( Material.prototype );
  	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

  	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

  	MeshBasicMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.skinning = source.skinning;
  		this.morphTargets = source.morphTargets;

  		return this;

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author jonobr1 / http://jonobr1.com/
  	 */

  	function Mesh( geometry, material ) {

  		Object3D.call( this );

  		this.type = 'Mesh';

  		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

  		this.drawMode = TrianglesDrawMode;

  		this.updateMorphTargets();

  	}

  	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Mesh,

  		isMesh: true,

  		setDrawMode: function ( value ) {

  			this.drawMode = value;

  		},

  		copy: function ( source ) {

  			Object3D.prototype.copy.call( this, source );

  			this.drawMode = source.drawMode;

  			if ( source.morphTargetInfluences !== undefined ) {

  				this.morphTargetInfluences = source.morphTargetInfluences.slice();

  			}

  			if ( source.morphTargetDictionary !== undefined ) {

  				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

  			}

  			return this;

  		},

  		updateMorphTargets: function () {

  			var geometry = this.geometry;
  			var m, ml, name;

  			if ( geometry.isBufferGeometry ) {

  				var morphAttributes = geometry.morphAttributes;
  				var keys = Object.keys( morphAttributes );

  				if ( keys.length > 0 ) {

  					var morphAttribute = morphAttributes[ keys[ 0 ] ];

  					if ( morphAttribute !== undefined ) {

  						this.morphTargetInfluences = [];
  						this.morphTargetDictionary = {};

  						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

  							name = morphAttribute[ m ].name || String( m );

  							this.morphTargetInfluences.push( 0 );
  							this.morphTargetDictionary[ name ] = m;

  						}

  					}

  				}

  			} else {

  				var morphTargets = geometry.morphTargets;

  				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

  					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

  				}

  			}

  		},

  		raycast: ( function () {

  			var inverseMatrix = new Matrix4();
  			var ray = new Ray();
  			var sphere = new Sphere();

  			var vA = new Vector3();
  			var vB = new Vector3();
  			var vC = new Vector3();

  			var tempA = new Vector3();
  			var tempB = new Vector3();
  			var tempC = new Vector3();

  			var morphA = new Vector3();
  			var morphB = new Vector3();
  			var morphC = new Vector3();

  			var uvA = new Vector2();
  			var uvB = new Vector2();
  			var uvC = new Vector2();

  			var intersectionPoint = new Vector3();
  			var intersectionPointWorld = new Vector3();

  			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

  				var intersect;

  				if ( material.side === BackSide ) {

  					intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  				} else {

  					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

  				}

  				if ( intersect === null ) return null;

  				intersectionPointWorld.copy( point );
  				intersectionPointWorld.applyMatrix4( object.matrixWorld );

  				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

  				if ( distance < raycaster.near || distance > raycaster.far ) return null;

  				return {
  					distance: distance,
  					point: intersectionPointWorld.clone(),
  					object: object
  				};

  			}

  			function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, uv, a, b, c ) {

  				vA.fromBufferAttribute( position, a );
  				vB.fromBufferAttribute( position, b );
  				vC.fromBufferAttribute( position, c );

  				var morphInfluences = object.morphTargetInfluences;

  				if ( material.morphTargets && morphPosition && morphInfluences ) {

  					morphA.set( 0, 0, 0 );
  					morphB.set( 0, 0, 0 );
  					morphC.set( 0, 0, 0 );

  					for ( var i = 0, il = morphPosition.length; i < il; i ++ ) {

  						var influence = morphInfluences[ i ];
  						var morphAttribute = morphPosition[ i ];

  						if ( influence === 0 ) continue;

  						tempA.fromBufferAttribute( morphAttribute, a );
  						tempB.fromBufferAttribute( morphAttribute, b );
  						tempC.fromBufferAttribute( morphAttribute, c );

  						morphA.addScaledVector( tempA.sub( vA ), influence );
  						morphB.addScaledVector( tempB.sub( vB ), influence );
  						morphC.addScaledVector( tempC.sub( vC ), influence );

  					}

  					vA.add( morphA );
  					vB.add( morphB );
  					vC.add( morphC );

  				}

  				var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );

  				if ( intersection ) {

  					if ( uv ) {

  						uvA.fromBufferAttribute( uv, a );
  						uvB.fromBufferAttribute( uv, b );
  						uvC.fromBufferAttribute( uv, c );

  						intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );

  					}

  					var face = new Face3( a, b, c );
  					Triangle.getNormal( vA, vB, vC, face.normal );

  					intersection.face = face;

  				}

  				return intersection;

  			}

  			return function raycast( raycaster, intersects ) {

  				var geometry = this.geometry;
  				var material = this.material;
  				var matrixWorld = this.matrixWorld;

  				if ( material === undefined ) return;

  				// Checking boundingSphere distance to ray

  				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  				sphere.copy( geometry.boundingSphere );
  				sphere.applyMatrix4( matrixWorld );

  				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

  				//

  				inverseMatrix.getInverse( matrixWorld );
  				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  				// Check boundingBox before continuing

  				if ( geometry.boundingBox !== null ) {

  					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

  				}

  				var intersection;

  				if ( geometry.isBufferGeometry ) {

  					var a, b, c;
  					var index = geometry.index;
  					var position = geometry.attributes.position;
  					var morphPosition = geometry.morphAttributes.position;
  					var uv = geometry.attributes.uv;
  					var groups = geometry.groups;
  					var drawRange = geometry.drawRange;
  					var i, j, il, jl;
  					var group, groupMaterial;
  					var start, end;

  					if ( index !== null ) {

  						// indexed buffer geometry

  						if ( Array.isArray( material ) ) {

  							for ( i = 0, il = groups.length; i < il; i ++ ) {

  								group = groups[ i ];
  								groupMaterial = material[ group.materialIndex ];

  								start = Math.max( group.start, drawRange.start );
  								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

  								for ( j = start, jl = end; j < jl; j += 3 ) {

  									a = index.getX( j );
  									b = index.getX( j + 1 );
  									c = index.getX( j + 2 );

  									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c );

  									if ( intersection ) {

  										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
  										intersection.face.materialIndex = group.materialIndex;
  										intersects.push( intersection );

  									}

  								}

  							}

  						} else {

  							start = Math.max( 0, drawRange.start );
  							end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

  							for ( i = start, il = end; i < il; i += 3 ) {

  								a = index.getX( i );
  								b = index.getX( i + 1 );
  								c = index.getX( i + 2 );

  								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, morphPosition, uv, a, b, c );

  								if ( intersection ) {

  									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
  									intersects.push( intersection );

  								}

  							}

  						}

  					} else if ( position !== undefined ) {

  						// non-indexed buffer geometry

  						if ( Array.isArray( material ) ) {

  							for ( i = 0, il = groups.length; i < il; i ++ ) {

  								group = groups[ i ];
  								groupMaterial = material[ group.materialIndex ];

  								start = Math.max( group.start, drawRange.start );
  								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

  								for ( j = start, jl = end; j < jl; j += 3 ) {

  									a = j;
  									b = j + 1;
  									c = j + 2;

  									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c );

  									if ( intersection ) {

  										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
  										intersection.face.materialIndex = group.materialIndex;
  										intersects.push( intersection );

  									}

  								}

  							}

  						} else {

  							start = Math.max( 0, drawRange.start );
  							end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

  							for ( i = start, il = end; i < il; i += 3 ) {

  								a = i;
  								b = i + 1;
  								c = i + 2;

  								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, morphPosition, uv, a, b, c );

  								if ( intersection ) {

  									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
  									intersects.push( intersection );

  								}

  							}

  						}

  					}

  				} else if ( geometry.isGeometry ) {

  					var fvA, fvB, fvC;
  					var isMultiMaterial = Array.isArray( material );

  					var vertices = geometry.vertices;
  					var faces = geometry.faces;
  					var uvs;

  					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
  					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

  					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

  						var face = faces[ f ];
  						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

  						if ( faceMaterial === undefined ) continue;

  						fvA = vertices[ face.a ];
  						fvB = vertices[ face.b ];
  						fvC = vertices[ face.c ];

  						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

  						if ( intersection ) {

  							if ( uvs && uvs[ f ] ) {

  								var uvs_f = uvs[ f ];
  								uvA.copy( uvs_f[ 0 ] );
  								uvB.copy( uvs_f[ 1 ] );
  								uvC.copy( uvs_f[ 2 ] );

  								intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );

  							}

  							intersection.face = face;
  							intersection.faceIndex = f;
  							intersects.push( intersection );

  						}

  					}

  				}

  			};

  		}() ),

  		clone: function () {

  			return new this.constructor( this.geometry, this.material ).copy( this );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

  		var clearColor = new Color( 0x000000 );
  		var clearAlpha = 0;

  		var planeMesh;
  		var boxMesh;
  		// Store the current background texture and its `version`
  		// so we can recompile the material accordingly.
  		var currentBackground = null;
  		var currentBackgroundVersion = 0;

  		function render( renderList, scene, camera, forceClear ) {

  			var background = scene.background;

  			// Ignore background in AR
  			// TODO: Reconsider this.

  			var vr = renderer.vr;
  			var session = vr.getSession && vr.getSession();

  			if ( session && session.environmentBlendMode === 'additive' ) {

  				background = null;

  			}

  			if ( background === null ) {

  				setClear( clearColor, clearAlpha );
  				currentBackground = null;
  				currentBackgroundVersion = 0;

  			} else if ( background && background.isColor ) {

  				setClear( background, 1 );
  				forceClear = true;
  				currentBackground = null;
  				currentBackgroundVersion = 0;

  			}

  			if ( renderer.autoClear || forceClear ) {

  				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

  			}

  			if ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {

  				if ( boxMesh === undefined ) {

  					boxMesh = new Mesh(
  						new BoxBufferGeometry( 1, 1, 1 ),
  						new ShaderMaterial( {
  							type: 'BackgroundCubeMaterial',
  							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
  							vertexShader: ShaderLib.cube.vertexShader,
  							fragmentShader: ShaderLib.cube.fragmentShader,
  							side: BackSide,
  							depthTest: false,
  							depthWrite: false,
  							fog: false
  						} )
  					);

  					boxMesh.geometry.removeAttribute( 'normal' );
  					boxMesh.geometry.removeAttribute( 'uv' );

  					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

  						this.matrixWorld.copyPosition( camera.matrixWorld );

  					};

  					// enable code injection for non-built-in material
  					Object.defineProperty( boxMesh.material, 'map', {

  						get: function () {

  							return this.uniforms.tCube.value;

  						}

  					} );

  					objects.update( boxMesh );

  				}

  				var texture = background.isWebGLRenderTargetCube ? background.texture : background;
  				boxMesh.material.uniforms.tCube.value = texture;
  				boxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;

  				if ( currentBackground !== background ||
  				     currentBackgroundVersion !== texture.version ) {

  					boxMesh.material.needsUpdate = true;

  					currentBackground = background;
  					currentBackgroundVersion = texture.version;

  				}

  				// push to the pre-sorted opaque render list
  				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

  			} else if ( background && background.isTexture ) {

  				if ( planeMesh === undefined ) {

  					planeMesh = new Mesh(
  						new PlaneBufferGeometry( 2, 2 ),
  						new ShaderMaterial( {
  							type: 'BackgroundMaterial',
  							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
  							vertexShader: ShaderLib.background.vertexShader,
  							fragmentShader: ShaderLib.background.fragmentShader,
  							side: FrontSide,
  							depthTest: false,
  							depthWrite: false,
  							fog: false
  						} )
  					);

  					planeMesh.geometry.removeAttribute( 'normal' );

  					// enable code injection for non-built-in material
  					Object.defineProperty( planeMesh.material, 'map', {

  						get: function () {

  							return this.uniforms.t2D.value;

  						}

  					} );

  					objects.update( planeMesh );

  				}

  				planeMesh.material.uniforms.t2D.value = background;

  				if ( background.matrixAutoUpdate === true ) {

  					background.updateMatrix();

  				}

  				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

  				if ( currentBackground !== background ||
  					   currentBackgroundVersion !== background.version ) {

  					planeMesh.material.needsUpdate = true;

  					currentBackground = background;
  					currentBackgroundVersion = background.version;

  				}


  				// push to the pre-sorted opaque render list
  				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

  			}

  		}

  		function setClear( color, alpha ) {

  			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

  		}

  		return {

  			getClearColor: function () {

  				return clearColor;

  			},
  			setClearColor: function ( color, alpha ) {

  				clearColor.set( color );
  				clearAlpha = alpha !== undefined ? alpha : 1;
  				setClear( clearColor, clearAlpha );

  			},
  			getClearAlpha: function () {

  				return clearAlpha;

  			},
  			setClearAlpha: function ( alpha ) {

  				clearAlpha = alpha;
  				setClear( clearColor, clearAlpha );

  			},
  			render: render

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

  		var mode;

  		function setMode( value ) {

  			mode = value;

  		}

  		function render( start, count ) {

  			gl.drawArrays( mode, start, count );

  			info.update( count, mode );

  		}

  		function renderInstances( geometry, start, count ) {

  			var extension;

  			if ( capabilities.isWebGL2 ) {

  				extension = gl;

  			} else {

  				extension = extensions.get( 'ANGLE_instanced_arrays' );

  				if ( extension === null ) {

  					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  					return;

  				}

  			}

  			extension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );

  			info.update( count, mode, geometry.maxInstancedCount );

  		}

  		//

  		this.setMode = setMode;
  		this.render = render;
  		this.renderInstances = renderInstances;

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLCapabilities( gl, extensions, parameters ) {

  		var maxAnisotropy;

  		function getMaxAnisotropy() {

  			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

  			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  			if ( extension !== null ) {

  				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  			} else {

  				maxAnisotropy = 0;

  			}

  			return maxAnisotropy;

  		}

  		function getMaxPrecision( precision ) {

  			if ( precision === 'highp' ) {

  				if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
  				     gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

  					return 'highp';

  				}

  				precision = 'mediump';

  			}

  			if ( precision === 'mediump' ) {

  				if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
  				     gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

  					return 'mediump';

  				}

  			}

  			return 'lowp';

  		}

  		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

  		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  		var maxPrecision = getMaxPrecision( precision );

  		if ( maxPrecision !== precision ) {

  			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
  			precision = maxPrecision;

  		}

  		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

  		var maxTextures = gl.getParameter( 34930 );
  		var maxVertexTextures = gl.getParameter( 35660 );
  		var maxTextureSize = gl.getParameter( 3379 );
  		var maxCubemapSize = gl.getParameter( 34076 );

  		var maxAttributes = gl.getParameter( 34921 );
  		var maxVertexUniforms = gl.getParameter( 36347 );
  		var maxVaryings = gl.getParameter( 36348 );
  		var maxFragmentUniforms = gl.getParameter( 36349 );

  		var vertexTextures = maxVertexTextures > 0;
  		var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
  		var floatVertexTextures = vertexTextures && floatFragmentTextures;

  		var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

  		return {

  			isWebGL2: isWebGL2,

  			getMaxAnisotropy: getMaxAnisotropy,
  			getMaxPrecision: getMaxPrecision,

  			precision: precision,
  			logarithmicDepthBuffer: logarithmicDepthBuffer,

  			maxTextures: maxTextures,
  			maxVertexTextures: maxVertexTextures,
  			maxTextureSize: maxTextureSize,
  			maxCubemapSize: maxCubemapSize,

  			maxAttributes: maxAttributes,
  			maxVertexUniforms: maxVertexUniforms,
  			maxVaryings: maxVaryings,
  			maxFragmentUniforms: maxFragmentUniforms,

  			vertexTextures: vertexTextures,
  			floatFragmentTextures: floatFragmentTextures,
  			floatVertexTextures: floatVertexTextures,

  			maxSamples: maxSamples

  		};

  	}

  	/**
  	 * @author tschw
  	 */

  	function WebGLClipping() {

  		var scope = this,

  			globalState = null,
  			numGlobalPlanes = 0,
  			localClippingEnabled = false,
  			renderingShadows = false,

  			plane = new Plane(),
  			viewNormalMatrix = new Matrix3(),

  			uniform = { value: null, needsUpdate: false };

  		this.uniform = uniform;
  		this.numPlanes = 0;
  		this.numIntersection = 0;

  		this.init = function ( planes, enableLocalClipping, camera ) {

  			var enabled =
  				planes.length !== 0 ||
  				enableLocalClipping ||
  				// enable state of previous frame - the clipping code has to
  				// run another frame in order to reset the state:
  				numGlobalPlanes !== 0 ||
  				localClippingEnabled;

  			localClippingEnabled = enableLocalClipping;

  			globalState = projectPlanes( planes, camera, 0 );
  			numGlobalPlanes = planes.length;

  			return enabled;

  		};

  		this.beginShadows = function () {

  			renderingShadows = true;
  			projectPlanes( null );

  		};

  		this.endShadows = function () {

  			renderingShadows = false;
  			resetGlobalState();

  		};

  		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

  			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

  				// there's no local clipping

  				if ( renderingShadows ) {

  					// there's no global clipping

  					projectPlanes( null );

  				} else {

  					resetGlobalState();

  				}

  			} else {

  				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
  					lGlobal = nGlobal * 4,

  					dstArray = cache.clippingState || null;

  				uniform.value = dstArray; // ensure unique state

  				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

  				for ( var i = 0; i !== lGlobal; ++ i ) {

  					dstArray[ i ] = globalState[ i ];

  				}

  				cache.clippingState = dstArray;
  				this.numIntersection = clipIntersection ? this.numPlanes : 0;
  				this.numPlanes += nGlobal;

  			}


  		};

  		function resetGlobalState() {

  			if ( uniform.value !== globalState ) {

  				uniform.value = globalState;
  				uniform.needsUpdate = numGlobalPlanes > 0;

  			}

  			scope.numPlanes = numGlobalPlanes;
  			scope.numIntersection = 0;

  		}

  		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

  			var nPlanes = planes !== null ? planes.length : 0,
  				dstArray = null;

  			if ( nPlanes !== 0 ) {

  				dstArray = uniform.value;

  				if ( skipTransform !== true || dstArray === null ) {

  					var flatSize = dstOffset + nPlanes * 4,
  						viewMatrix = camera.matrixWorldInverse;

  					viewNormalMatrix.getNormalMatrix( viewMatrix );

  					if ( dstArray === null || dstArray.length < flatSize ) {

  						dstArray = new Float32Array( flatSize );

  					}

  					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

  						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

  						plane.normal.toArray( dstArray, i4 );
  						dstArray[ i4 + 3 ] = plane.constant;

  					}

  				}

  				uniform.value = dstArray;
  				uniform.needsUpdate = true;

  			}

  			scope.numPlanes = nPlanes;

  			return dstArray;

  		}

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLExtensions( gl ) {

  		var extensions = {};

  		return {

  			get: function ( name ) {

  				if ( extensions[ name ] !== undefined ) {

  					return extensions[ name ];

  				}

  				var extension;

  				switch ( name ) {

  					case 'WEBGL_depth_texture':
  						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
  						break;

  					case 'EXT_texture_filter_anisotropic':
  						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
  						break;

  					case 'WEBGL_compressed_texture_s3tc':
  						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
  						break;

  					case 'WEBGL_compressed_texture_pvrtc':
  						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
  						break;

  					default:
  						extension = gl.getExtension( name );

  				}

  				if ( extension === null ) {

  					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

  				}

  				extensions[ name ] = extension;

  				return extension;

  			}

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLGeometries( gl, attributes, info ) {

  		var geometries = {};
  		var wireframeAttributes = {};

  		function onGeometryDispose( event ) {

  			var geometry = event.target;
  			var buffergeometry = geometries[ geometry.id ];

  			if ( buffergeometry.index !== null ) {

  				attributes.remove( buffergeometry.index );

  			}

  			for ( var name in buffergeometry.attributes ) {

  				attributes.remove( buffergeometry.attributes[ name ] );

  			}

  			geometry.removeEventListener( 'dispose', onGeometryDispose );

  			delete geometries[ geometry.id ];

  			var attribute = wireframeAttributes[ buffergeometry.id ];

  			if ( attribute ) {

  				attributes.remove( attribute );
  				delete wireframeAttributes[ buffergeometry.id ];

  			}

  			//

  			info.memory.geometries --;

  		}

  		function get( object, geometry ) {

  			var buffergeometry = geometries[ geometry.id ];

  			if ( buffergeometry ) return buffergeometry;

  			geometry.addEventListener( 'dispose', onGeometryDispose );

  			if ( geometry.isBufferGeometry ) {

  				buffergeometry = geometry;

  			} else if ( geometry.isGeometry ) {

  				if ( geometry._bufferGeometry === undefined ) {

  					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

  				}

  				buffergeometry = geometry._bufferGeometry;

  			}

  			geometries[ geometry.id ] = buffergeometry;

  			info.memory.geometries ++;

  			return buffergeometry;

  		}

  		function update( geometry ) {

  			var index = geometry.index;
  			var geometryAttributes = geometry.attributes;

  			if ( index !== null ) {

  				attributes.update( index, 34963 );

  			}

  			for ( var name in geometryAttributes ) {

  				attributes.update( geometryAttributes[ name ], 34962 );

  			}

  			// morph targets

  			var morphAttributes = geometry.morphAttributes;

  			for ( var name in morphAttributes ) {

  				var array = morphAttributes[ name ];

  				for ( var i = 0, l = array.length; i < l; i ++ ) {

  					attributes.update( array[ i ], 34962 );

  				}

  			}

  		}

  		function getWireframeAttribute( geometry ) {

  			var attribute = wireframeAttributes[ geometry.id ];

  			if ( attribute ) return attribute;

  			var indices = [];

  			var geometryIndex = geometry.index;
  			var geometryAttributes = geometry.attributes;

  			// console.time( 'wireframe' );

  			if ( geometryIndex !== null ) {

  				var array = geometryIndex.array;

  				for ( var i = 0, l = array.length; i < l; i += 3 ) {

  					var a = array[ i + 0 ];
  					var b = array[ i + 1 ];
  					var c = array[ i + 2 ];

  					indices.push( a, b, b, c, c, a );

  				}

  			} else {

  				var array = geometryAttributes.position.array;

  				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  					var a = i + 0;
  					var b = i + 1;
  					var c = i + 2;

  					indices.push( a, b, b, c, c, a );

  				}

  			}

  			// console.timeEnd( 'wireframe' );

  			attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

  			attributes.update( attribute, 34963 );

  			wireframeAttributes[ geometry.id ] = attribute;

  			return attribute;

  		}

  		return {

  			get: get,
  			update: update,

  			getWireframeAttribute: getWireframeAttribute

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

  		var mode;

  		function setMode( value ) {

  			mode = value;

  		}

  		var type, bytesPerElement;

  		function setIndex( value ) {

  			type = value.type;
  			bytesPerElement = value.bytesPerElement;

  		}

  		function render( start, count ) {

  			gl.drawElements( mode, count, type, start * bytesPerElement );

  			info.update( count, mode );

  		}

  		function renderInstances( geometry, start, count ) {

  			var extension;

  			if ( capabilities.isWebGL2 ) {

  				extension = gl;

  			} else {

  				var extension = extensions.get( 'ANGLE_instanced_arrays' );

  				if ( extension === null ) {

  					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  					return;

  				}

  			}

  			extension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

  			info.update( count, mode, geometry.maxInstancedCount );

  		}

  		//

  		this.setMode = setMode;
  		this.setIndex = setIndex;
  		this.render = render;
  		this.renderInstances = renderInstances;

  	}

  	/**
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	function WebGLInfo( gl ) {

  		var memory = {
  			geometries: 0,
  			textures: 0
  		};

  		var render = {
  			frame: 0,
  			calls: 0,
  			triangles: 0,
  			points: 0,
  			lines: 0
  		};

  		function update( count, mode, instanceCount ) {

  			instanceCount = instanceCount || 1;

  			render.calls ++;

  			switch ( mode ) {

  				case 4:
  					render.triangles += instanceCount * ( count / 3 );
  					break;

  				case 5:
  				case 6:
  					render.triangles += instanceCount * ( count - 2 );
  					break;

  				case 1:
  					render.lines += instanceCount * ( count / 2 );
  					break;

  				case 3:
  					render.lines += instanceCount * ( count - 1 );
  					break;

  				case 2:
  					render.lines += instanceCount * count;
  					break;

  				case 0:
  					render.points += instanceCount * count;
  					break;

  				default:
  					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
  					break;

  			}

  		}

  		function reset() {

  			render.frame ++;
  			render.calls = 0;
  			render.triangles = 0;
  			render.points = 0;
  			render.lines = 0;

  		}

  		return {
  			memory: memory,
  			render: render,
  			programs: null,
  			autoReset: true,
  			reset: reset,
  			update: update
  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function absNumericalSort( a, b ) {

  		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

  	}

  	function WebGLMorphtargets( gl ) {

  		var influencesList = {};
  		var morphInfluences = new Float32Array( 8 );

  		function update( object, geometry, material, program ) {

  			var objectInfluences = object.morphTargetInfluences;

  			var length = objectInfluences.length;

  			var influences = influencesList[ geometry.id ];

  			if ( influences === undefined ) {

  				// initialise list

  				influences = [];

  				for ( var i = 0; i < length; i ++ ) {

  					influences[ i ] = [ i, 0 ];

  				}

  				influencesList[ geometry.id ] = influences;

  			}

  			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
  			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

  			// Remove current morphAttributes

  			for ( var i = 0; i < length; i ++ ) {

  				var influence = influences[ i ];

  				if ( influence[ 1 ] !== 0 ) {

  					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
  					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );

  				}

  			}

  			// Collect influences

  			for ( var i = 0; i < length; i ++ ) {

  				var influence = influences[ i ];

  				influence[ 0 ] = i;
  				influence[ 1 ] = objectInfluences[ i ];

  			}

  			influences.sort( absNumericalSort );

  			// Add morphAttributes

  			for ( var i = 0; i < 8; i ++ ) {

  				var influence = influences[ i ];

  				if ( influence ) {

  					var index = influence[ 0 ];
  					var value = influence[ 1 ];

  					if ( value ) {

  						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
  						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );

  						morphInfluences[ i ] = value;
  						continue;

  					}

  				}

  				morphInfluences[ i ] = 0;

  			}

  			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

  		}

  		return {

  			update: update

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLObjects( geometries, info ) {

  		var updateList = {};

  		function update( object ) {

  			var frame = info.render.frame;

  			var geometry = object.geometry;
  			var buffergeometry = geometries.get( object, geometry );

  			// Update once per frame

  			if ( updateList[ buffergeometry.id ] !== frame ) {

  				if ( geometry.isGeometry ) {

  					buffergeometry.updateFromObject( object );

  				}

  				geometries.update( buffergeometry );

  				updateList[ buffergeometry.id ] = frame;

  			}

  			return buffergeometry;

  		}

  		function dispose() {

  			updateList = {};

  		}

  		return {

  			update: update,
  			dispose: dispose

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  		images = images !== undefined ? images : [];
  		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
  		format = format !== undefined ? format : RGBFormat;

  		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  		this.flipY = false;

  	}

  	CubeTexture.prototype = Object.create( Texture.prototype );
  	CubeTexture.prototype.constructor = CubeTexture;

  	CubeTexture.prototype.isCubeTexture = true;

  	Object.defineProperty( CubeTexture.prototype, 'images', {

  		get: function () {

  			return this.image;

  		},

  		set: function ( value ) {

  			this.image = value;

  		}

  	} );

  	/**
  	 * @author Takahiro https://github.com/takahirox
  	 */

  	function DataTexture2DArray( data, width, height, depth ) {

  		Texture.call( this, null );

  		this.image = { data: data, width: width, height: height, depth: depth };

  		this.magFilter = NearestFilter;
  		this.minFilter = NearestFilter;

  		this.wrapR = ClampToEdgeWrapping;

  		this.generateMipmaps = false;
  		this.flipY = false;

  	}

  	DataTexture2DArray.prototype = Object.create( Texture.prototype );
  	DataTexture2DArray.prototype.constructor = DataTexture2DArray;
  	DataTexture2DArray.prototype.isDataTexture2DArray = true;

  	/**
  	 * @author Artur Trzesiok
  	 */

  	function DataTexture3D( data, width, height, depth ) {

  		// We're going to add .setXXX() methods for setting properties later.
  		// Users can still set in DataTexture3D directly.
  		//
  		//	var texture = new THREE.DataTexture3D( data, width, height, depth );
  		// 	texture.anisotropy = 16;
  		//
  		// See #14839

  		Texture.call( this, null );

  		this.image = { data: data, width: width, height: height, depth: depth };

  		this.magFilter = NearestFilter;
  		this.minFilter = NearestFilter;

  		this.wrapR = ClampToEdgeWrapping;

  		this.generateMipmaps = false;
  		this.flipY = false;

  	}

  	DataTexture3D.prototype = Object.create( Texture.prototype );
  	DataTexture3D.prototype.constructor = DataTexture3D;
  	DataTexture3D.prototype.isDataTexture3D = true;

  	/**
  	 * @author tschw
  	 * @author Mugen87 / https://github.com/Mugen87
  	 * @author mrdoob / http://mrdoob.com/
  	 *
  	 * Uniforms of a program.
  	 * Those form a tree structure with a special top-level container for the root,
  	 * which you get by calling 'new WebGLUniforms( gl, program )'.
  	 *
  	 *
  	 * Properties of inner nodes including the top-level container:
  	 *
  	 * .seq - array of nested uniforms
  	 * .map - nested uniforms by name
  	 *
  	 *
  	 * Methods of all nodes except the top-level container:
  	 *
  	 * .setValue( gl, value, [textures] )
  	 *
  	 * 		uploads a uniform value(s)
  	 *  	the 'textures' parameter is needed for sampler uniforms
  	 *
  	 *
  	 * Static methods of the top-level container (textures factorizations):
  	 *
  	 * .upload( gl, seq, values, textures )
  	 *
  	 * 		sets uniforms in 'seq' to 'values[id].value'
  	 *
  	 * .seqWithValue( seq, values ) : filteredSeq
  	 *
  	 * 		filters 'seq' entries with corresponding entry in values
  	 *
  	 *
  	 * Methods of the top-level container (textures factorizations):
  	 *
  	 * .setValue( gl, name, value, textures )
  	 *
  	 * 		sets uniform with  name 'name' to 'value'
  	 *
  	 * .setOptional( gl, obj, prop )
  	 *
  	 * 		like .set for an optional property of the object
  	 *
  	 */

  	var emptyTexture = new Texture();
  	var emptyTexture2dArray = new DataTexture2DArray();
  	var emptyTexture3d = new DataTexture3D();
  	var emptyCubeTexture = new CubeTexture();

  	// --- Utilities ---

  	// Array Caches (provide typed arrays for temporary by size)

  	var arrayCacheF32 = [];
  	var arrayCacheI32 = [];

  	// Float32Array caches used for uploading Matrix uniforms

  	var mat4array = new Float32Array( 16 );
  	var mat3array = new Float32Array( 9 );
  	var mat2array = new Float32Array( 4 );

  	// Flattening for arrays of vectors and matrices

  	function flatten( array, nBlocks, blockSize ) {

  		var firstElem = array[ 0 ];

  		if ( firstElem <= 0 || firstElem > 0 ) return array;
  		// unoptimized: ! isNaN( firstElem )
  		// see http://jacksondunstan.com/articles/983

  		var n = nBlocks * blockSize,
  			r = arrayCacheF32[ n ];

  		if ( r === undefined ) {

  			r = new Float32Array( n );
  			arrayCacheF32[ n ] = r;

  		}

  		if ( nBlocks !== 0 ) {

  			firstElem.toArray( r, 0 );

  			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

  				offset += blockSize;
  				array[ i ].toArray( r, offset );

  			}

  		}

  		return r;

  	}

  	function arraysEqual( a, b ) {

  		if ( a.length !== b.length ) return false;

  		for ( var i = 0, l = a.length; i < l; i ++ ) {

  			if ( a[ i ] !== b[ i ] ) return false;

  		}

  		return true;

  	}

  	function copyArray( a, b ) {

  		for ( var i = 0, l = b.length; i < l; i ++ ) {

  			a[ i ] = b[ i ];

  		}

  	}

  	// Texture unit allocation

  	function allocTexUnits( textures, n ) {

  		var r = arrayCacheI32[ n ];

  		if ( r === undefined ) {

  			r = new Int32Array( n );
  			arrayCacheI32[ n ] = r;

  		}

  		for ( var i = 0; i !== n; ++ i )
  			r[ i ] = textures.allocateTextureUnit();

  		return r;

  	}

  	// --- Setters ---

  	// Note: Defining these methods externally, because they come in a bunch
  	// and this way their names minify.

  	// Single scalar

  	function setValue1f( gl, v ) {

  		var cache = this.cache;

  		if ( cache[ 0 ] === v ) return;

  		gl.uniform1f( this.addr, v );

  		cache[ 0 ] = v;

  	}

  	function setValue1i( gl, v ) {

  		var cache = this.cache;

  		if ( cache[ 0 ] === v ) return;

  		gl.uniform1i( this.addr, v );

  		cache[ 0 ] = v;

  	}

  	// Single float vector (from flat array or THREE.VectorN)

  	function setValue2fv( gl, v ) {

  		var cache = this.cache;

  		if ( v.x !== undefined ) {

  			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

  				gl.uniform2f( this.addr, v.x, v.y );

  				cache[ 0 ] = v.x;
  				cache[ 1 ] = v.y;

  			}

  		} else {

  			if ( arraysEqual( cache, v ) ) return;

  			gl.uniform2fv( this.addr, v );

  			copyArray( cache, v );

  		}

  	}

  	function setValue3fv( gl, v ) {

  		var cache = this.cache;

  		if ( v.x !== undefined ) {

  			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

  				gl.uniform3f( this.addr, v.x, v.y, v.z );

  				cache[ 0 ] = v.x;
  				cache[ 1 ] = v.y;
  				cache[ 2 ] = v.z;

  			}

  		} else if ( v.r !== undefined ) {

  			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

  				gl.uniform3f( this.addr, v.r, v.g, v.b );

  				cache[ 0 ] = v.r;
  				cache[ 1 ] = v.g;
  				cache[ 2 ] = v.b;

  			}

  		} else {

  			if ( arraysEqual( cache, v ) ) return;

  			gl.uniform3fv( this.addr, v );

  			copyArray( cache, v );

  		}

  	}

  	function setValue4fv( gl, v ) {

  		var cache = this.cache;

  		if ( v.x !== undefined ) {

  			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

  				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

  				cache[ 0 ] = v.x;
  				cache[ 1 ] = v.y;
  				cache[ 2 ] = v.z;
  				cache[ 3 ] = v.w;

  			}

  		} else {

  			if ( arraysEqual( cache, v ) ) return;

  			gl.uniform4fv( this.addr, v );

  			copyArray( cache, v );

  		}

  	}

  	// Single matrix (from flat array or MatrixN)

  	function setValue2fm( gl, v ) {

  		var cache = this.cache;
  		var elements = v.elements;

  		if ( elements === undefined ) {

  			if ( arraysEqual( cache, v ) ) return;

  			gl.uniformMatrix2fv( this.addr, false, v );

  			copyArray( cache, v );

  		} else {

  			if ( arraysEqual( cache, elements ) ) return;

  			mat2array.set( elements );

  			gl.uniformMatrix2fv( this.addr, false, mat2array );

  			copyArray( cache, elements );

  		}

  	}

  	function setValue3fm( gl, v ) {

  		var cache = this.cache;
  		var elements = v.elements;

  		if ( elements === undefined ) {

  			if ( arraysEqual( cache, v ) ) return;

  			gl.uniformMatrix3fv( this.addr, false, v );

  			copyArray( cache, v );

  		} else {

  			if ( arraysEqual( cache, elements ) ) return;

  			mat3array.set( elements );

  			gl.uniformMatrix3fv( this.addr, false, mat3array );

  			copyArray( cache, elements );

  		}

  	}

  	function setValue4fm( gl, v ) {

  		var cache = this.cache;
  		var elements = v.elements;

  		if ( elements === undefined ) {

  			if ( arraysEqual( cache, v ) ) return;

  			gl.uniformMatrix4fv( this.addr, false, v );

  			copyArray( cache, v );

  		} else {

  			if ( arraysEqual( cache, elements ) ) return;

  			mat4array.set( elements );

  			gl.uniformMatrix4fv( this.addr, false, mat4array );

  			copyArray( cache, elements );

  		}

  	}

  	// Single texture (2D / Cube)

  	function setValueT1( gl, v, textures ) {

  		var cache = this.cache;
  		var unit = textures.allocateTextureUnit();

  		if ( cache[ 0 ] !== unit ) {

  			gl.uniform1i( this.addr, unit );
  			cache[ 0 ] = unit;

  		}

  		textures.safeSetTexture2D( v || emptyTexture, unit );

  	}

  	function setValueT2DArray1( gl, v, textures ) {

  		var cache = this.cache;
  		var unit = textures.allocateTextureUnit();

  		if ( cache[ 0 ] !== unit ) {

  			gl.uniform1i( this.addr, unit );
  			cache[ 0 ] = unit;

  		}

  		textures.setTexture2DArray( v || emptyTexture2dArray, unit );

  	}

  	function setValueT3D1( gl, v, textures ) {

  		var cache = this.cache;
  		var unit = textures.allocateTextureUnit();

  		if ( cache[ 0 ] !== unit ) {

  			gl.uniform1i( this.addr, unit );
  			cache[ 0 ] = unit;

  		}

  		textures.setTexture3D( v || emptyTexture3d, unit );

  	}

  	function setValueT6( gl, v, textures ) {

  		var cache = this.cache;
  		var unit = textures.allocateTextureUnit();

  		if ( cache[ 0 ] !== unit ) {

  			gl.uniform1i( this.addr, unit );
  			cache[ 0 ] = unit;

  		}

  		textures.safeSetTextureCube( v || emptyCubeTexture, unit );

  	}

  	// Integer / Boolean vectors or arrays thereof (always flat arrays)

  	function setValue2iv( gl, v ) {

  		var cache = this.cache;

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform2iv( this.addr, v );

  		copyArray( cache, v );

  	}

  	function setValue3iv( gl, v ) {

  		var cache = this.cache;

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform3iv( this.addr, v );

  		copyArray( cache, v );

  	}

  	function setValue4iv( gl, v ) {

  		var cache = this.cache;

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform4iv( this.addr, v );

  		copyArray( cache, v );

  	}

  	// Helper to pick the right setter for the singular case

  	function getSingularSetter( type ) {

  		switch ( type ) {

  			case 0x1406: return setValue1f; // FLOAT
  			case 0x8b50: return setValue2fv; // _VEC2
  			case 0x8b51: return setValue3fv; // _VEC3
  			case 0x8b52: return setValue4fv; // _VEC4

  			case 0x8b5a: return setValue2fm; // _MAT2
  			case 0x8b5b: return setValue3fm; // _MAT3
  			case 0x8b5c: return setValue4fm; // _MAT4

  			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
  			case 0x8b5f: return setValueT3D1; // SAMPLER_3D
  			case 0x8b60: return setValueT6; // SAMPLER_CUBE
  			case 0x8DC1: return setValueT2DArray1; // SAMPLER_2D_ARRAY

  			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
  			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
  			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
  			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

  		}

  	}

  	// Array of scalars

  	function setValue1fv( gl, v ) {

  		var cache = this.cache;

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform1fv( this.addr, v );

  		copyArray( cache, v );

  	}
  	function setValue1iv( gl, v ) {

  		var cache = this.cache;

  		if ( arraysEqual( cache, v ) ) return;

  		gl.uniform1iv( this.addr, v );

  		copyArray( cache, v );

  	}

  	// Array of vectors (flat or from THREE classes)

  	function setValueV2a( gl, v ) {

  		var cache = this.cache;
  		var data = flatten( v, this.size, 2 );

  		if ( arraysEqual( cache, data ) ) return;

  		gl.uniform2fv( this.addr, data );

  		this.updateCache( data );

  	}

  	function setValueV3a( gl, v ) {

  		var cache = this.cache;
  		var data = flatten( v, this.size, 3 );

  		if ( arraysEqual( cache, data ) ) return;

  		gl.uniform3fv( this.addr, data );

  		this.updateCache( data );

  	}

  	function setValueV4a( gl, v ) {

  		var cache = this.cache;
  		var data = flatten( v, this.size, 4 );

  		if ( arraysEqual( cache, data ) ) return;

  		gl.uniform4fv( this.addr, data );

  		this.updateCache( data );

  	}

  	// Array of matrices (flat or from THREE clases)

  	function setValueM2a( gl, v ) {

  		var cache = this.cache;
  		var data = flatten( v, this.size, 4 );

  		if ( arraysEqual( cache, data ) ) return;

  		gl.uniformMatrix2fv( this.addr, false, data );

  		this.updateCache( data );

  	}

  	function setValueM3a( gl, v ) {

  		var cache = this.cache;
  		var data = flatten( v, this.size, 9 );

  		if ( arraysEqual( cache, data ) ) return;

  		gl.uniformMatrix3fv( this.addr, false, data );

  		this.updateCache( data );

  	}

  	function setValueM4a( gl, v ) {

  		var cache = this.cache;
  		var data = flatten( v, this.size, 16 );

  		if ( arraysEqual( cache, data ) ) return;

  		gl.uniformMatrix4fv( this.addr, false, data );

  		this.updateCache( data );

  	}

  	// Array of textures (2D / Cube)

  	function setValueT1a( gl, v, textures ) {

  		var cache = this.cache;
  		var n = v.length;

  		var units = allocTexUnits( textures, n );

  		if ( arraysEqual( cache, units ) === false ) {

  			gl.uniform1iv( this.addr, units );
  			copyArray( cache, units );

  		}

  		for ( var i = 0; i !== n; ++ i ) {

  			textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

  		}

  	}

  	function setValueT6a( gl, v, textures ) {

  		var cache = this.cache;
  		var n = v.length;

  		var units = allocTexUnits( textures, n );

  		if ( arraysEqual( cache, units ) === false ) {

  			gl.uniform1iv( this.addr, units );
  			copyArray( cache, units );

  		}

  		for ( var i = 0; i !== n; ++ i ) {

  			textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

  		}

  	}

  	// Helper to pick the right setter for a pure (bottom-level) array

  	function getPureArraySetter( type ) {

  		switch ( type ) {

  			case 0x1406: return setValue1fv; // FLOAT
  			case 0x8b50: return setValueV2a; // _VEC2
  			case 0x8b51: return setValueV3a; // _VEC3
  			case 0x8b52: return setValueV4a; // _VEC4

  			case 0x8b5a: return setValueM2a; // _MAT2
  			case 0x8b5b: return setValueM3a; // _MAT3
  			case 0x8b5c: return setValueM4a; // _MAT4

  			case 0x8b5e: return setValueT1a; // SAMPLER_2D
  			case 0x8b60: return setValueT6a; // SAMPLER_CUBE

  			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
  			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
  			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
  			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

  		}

  	}

  	// --- Uniform Classes ---

  	function SingleUniform( id, activeInfo, addr ) {

  		this.id = id;
  		this.addr = addr;
  		this.cache = [];
  		this.setValue = getSingularSetter( activeInfo.type );

  		// this.path = activeInfo.name; // DEBUG

  	}

  	function PureArrayUniform( id, activeInfo, addr ) {

  		this.id = id;
  		this.addr = addr;
  		this.cache = [];
  		this.size = activeInfo.size;
  		this.setValue = getPureArraySetter( activeInfo.type );

  		// this.path = activeInfo.name; // DEBUG

  	}

  	PureArrayUniform.prototype.updateCache = function ( data ) {

  		var cache = this.cache;

  		if ( data instanceof Float32Array && cache.length !== data.length ) {

  			this.cache = new Float32Array( data.length );

  		}

  		copyArray( cache, data );

  	};

  	function StructuredUniform( id ) {

  		this.id = id;

  		this.seq = [];
  		this.map = {};

  	}

  	StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

  		var seq = this.seq;

  		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  			var u = seq[ i ];
  			u.setValue( gl, value[ u.id ], textures );

  		}

  	};

  	// --- Top-level ---

  	// Parser - builds up the property tree from the path strings

  	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

  	// extracts
  	// 	- the identifier (member name or array index)
  	//  - followed by an optional right bracket (found when array index)
  	//  - followed by an optional left bracket or dot (type of subscript)
  	//
  	// Note: These portions can be read in a non-overlapping fashion and
  	// allow straightforward parsing of the hierarchy that WebGL encodes
  	// in the uniform names.

  	function addUniform( container, uniformObject ) {

  		container.seq.push( uniformObject );
  		container.map[ uniformObject.id ] = uniformObject;

  	}

  	function parseUniform( activeInfo, addr, container ) {

  		var path = activeInfo.name,
  			pathLength = path.length;

  		// reset RegExp object, because of the early exit of a previous run
  		RePathPart.lastIndex = 0;

  		while ( true ) {

  			var match = RePathPart.exec( path ),
  				matchEnd = RePathPart.lastIndex,

  				id = match[ 1 ],
  				idIsIndex = match[ 2 ] === ']',
  				subscript = match[ 3 ];

  			if ( idIsIndex ) id = id | 0; // convert to integer

  			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

  				// bare name or "pure" bottom-level array "[0]" suffix

  				addUniform( container, subscript === undefined ?
  					new SingleUniform( id, activeInfo, addr ) :
  					new PureArrayUniform( id, activeInfo, addr ) );

  				break;

  			} else {

  				// step into inner node / create it in case it doesn't exist

  				var map = container.map, next = map[ id ];

  				if ( next === undefined ) {

  					next = new StructuredUniform( id );
  					addUniform( container, next );

  				}

  				container = next;

  			}

  		}

  	}

  	// Root Container

  	function WebGLUniforms( gl, program ) {

  		this.seq = [];
  		this.map = {};

  		var n = gl.getProgramParameter( program, 35718 );

  		for ( var i = 0; i < n; ++ i ) {

  			var info = gl.getActiveUniform( program, i ),
  				addr = gl.getUniformLocation( program, info.name );

  			parseUniform( info, addr, this );

  		}

  	}

  	WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

  		var u = this.map[ name ];

  		if ( u !== undefined ) u.setValue( gl, value, textures );

  	};

  	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

  		var v = object[ name ];

  		if ( v !== undefined ) this.setValue( gl, name, v );

  	};


  	// Static interface

  	WebGLUniforms.upload = function ( gl, seq, values, textures ) {

  		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  			var u = seq[ i ],
  				v = values[ u.id ];

  			if ( v.needsUpdate !== false ) {

  				// note: always updating when .needsUpdate is undefined
  				u.setValue( gl, v.value, textures );

  			}

  		}

  	};

  	WebGLUniforms.seqWithValue = function ( seq, values ) {

  		var r = [];

  		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  			var u = seq[ i ];
  			if ( u.id in values ) r.push( u );

  		}

  		return r;

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function addLineNumbers( string ) {

  		var lines = string.split( '\n' );

  		for ( var i = 0; i < lines.length; i ++ ) {

  			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

  		}

  		return lines.join( '\n' );

  	}

  	function WebGLShader( gl, type, string, debug ) {

  		var shader = gl.createShader( type );

  		gl.shaderSource( shader, string );
  		gl.compileShader( shader );

  		if ( debug === true ) {

  			if ( gl.getShaderParameter( shader, 35713 ) === false ) {

  				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

  			}

  			if ( gl.getShaderInfoLog( shader ) !== '' ) {

  				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === 35633 ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

  			}

  		}

  		// --enable-privileged-webgl-extension
  		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  		return shader;

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	var programIdCount = 0;

  	function getEncodingComponents( encoding ) {

  		switch ( encoding ) {

  			case LinearEncoding:
  				return [ 'Linear', '( value )' ];
  			case sRGBEncoding:
  				return [ 'sRGB', '( value )' ];
  			case RGBEEncoding:
  				return [ 'RGBE', '( value )' ];
  			case RGBM7Encoding:
  				return [ 'RGBM', '( value, 7.0 )' ];
  			case RGBM16Encoding:
  				return [ 'RGBM', '( value, 16.0 )' ];
  			case RGBDEncoding:
  				return [ 'RGBD', '( value, 256.0 )' ];
  			case GammaEncoding:
  				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
  			default:
  				throw new Error( 'unsupported encoding: ' + encoding );

  		}

  	}

  	function getTexelDecodingFunction( functionName, encoding ) {

  		var components = getEncodingComponents( encoding );
  		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

  	}

  	function getTexelEncodingFunction( functionName, encoding ) {

  		var components = getEncodingComponents( encoding );
  		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

  	}

  	function getToneMappingFunction( functionName, toneMapping ) {

  		var toneMappingName;

  		switch ( toneMapping ) {

  			case LinearToneMapping:
  				toneMappingName = 'Linear';
  				break;

  			case ReinhardToneMapping:
  				toneMappingName = 'Reinhard';
  				break;

  			case Uncharted2ToneMapping:
  				toneMappingName = 'Uncharted2';
  				break;

  			case CineonToneMapping:
  				toneMappingName = 'OptimizedCineon';
  				break;

  			case ACESFilmicToneMapping:
  				toneMappingName = 'ACESFilmic';
  				break;

  			default:
  				throw new Error( 'unsupported toneMapping: ' + toneMapping );

  		}

  		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

  	}

  	function generateExtensions( extensions, parameters, rendererExtensions ) {

  		extensions = extensions || {};

  		var chunks = [
  			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
  			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
  			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
  			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
  		];

  		return chunks.filter( filterEmptyLine ).join( '\n' );

  	}

  	function generateDefines( defines ) {

  		var chunks = [];

  		for ( var name in defines ) {

  			var value = defines[ name ];

  			if ( value === false ) continue;

  			chunks.push( '#define ' + name + ' ' + value );

  		}

  		return chunks.join( '\n' );

  	}

  	function fetchAttributeLocations( gl, program ) {

  		var attributes = {};

  		var n = gl.getProgramParameter( program, 35721 );

  		for ( var i = 0; i < n; i ++ ) {

  			var info = gl.getActiveAttrib( program, i );
  			var name = info.name;

  			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

  			attributes[ name ] = gl.getAttribLocation( program, name );

  		}

  		return attributes;

  	}

  	function filterEmptyLine( string ) {

  		return string !== '';

  	}

  	function replaceLightNums( string, parameters ) {

  		return string
  			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
  			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
  			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
  			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
  			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

  	}

  	function replaceClippingPlaneNums( string, parameters ) {

  		return string
  			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
  			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

  	}

  	function parseIncludes( string ) {

  		var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

  		function replace( match, include ) {

  			var replace = ShaderChunk[ include ];

  			if ( replace === undefined ) {

  				throw new Error( 'Can not resolve #include <' + include + '>' );

  			}

  			return parseIncludes( replace );

  		}

  		return string.replace( pattern, replace );

  	}

  	function unrollLoops( string ) {

  		var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

  		function replace( match, start, end, snippet ) {

  			var unroll = '';

  			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

  				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

  			}

  			return unroll;

  		}

  		return string.replace( pattern, replace );

  	}

  	function WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities, textures ) {

  		var gl = renderer.context;

  		var defines = material.defines;

  		var vertexShader = shader.vertexShader;
  		var fragmentShader = shader.fragmentShader;

  		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  		if ( parameters.shadowMapType === PCFShadowMap ) {

  			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

  		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

  			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

  		}

  		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

  		if ( parameters.envMap ) {

  			switch ( material.envMap.mapping ) {

  				case CubeReflectionMapping:
  				case CubeRefractionMapping:
  					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  					break;

  				case CubeUVReflectionMapping:
  				case CubeUVRefractionMapping:
  					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
  					break;

  				case EquirectangularReflectionMapping:
  				case EquirectangularRefractionMapping:
  					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
  					break;

  				case SphericalReflectionMapping:
  					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
  					break;

  			}

  			switch ( material.envMap.mapping ) {

  				case CubeRefractionMapping:
  				case EquirectangularRefractionMapping:
  					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
  					break;

  			}

  			switch ( material.combine ) {

  				case MultiplyOperation:
  					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
  					break;

  				case MixOperation:
  					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
  					break;

  				case AddOperation:
  					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
  					break;

  			}

  		}

  		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

  		// console.log( 'building new program ' );

  		//

  		var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );

  		var customDefines = generateDefines( defines );

  		//

  		var program = gl.createProgram();

  		var prefixVertex, prefixFragment;

  		if ( material.isRawShaderMaterial ) {

  			prefixVertex = [

  				customDefines

  			].filter( filterEmptyLine ).join( '\n' );

  			if ( prefixVertex.length > 0 ) {

  				prefixVertex += '\n';

  			}

  			prefixFragment = [

  				customExtensions,
  				customDefines

  			].filter( filterEmptyLine ).join( '\n' );

  			if ( prefixFragment.length > 0 ) {

  				prefixFragment += '\n';

  			}

  		} else {

  			prefixVertex = [

  				'precision ' + parameters.precision + ' float;',
  				'precision ' + parameters.precision + ' int;',

  				'#define SHADER_NAME ' + shader.name,

  				customDefines,

  				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

  				'#define GAMMA_FACTOR ' + gammaFactorDefine,

  				'#define MAX_BONES ' + parameters.maxBones,
  				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

  				parameters.map ? '#define USE_MAP' : '',
  				parameters.envMap ? '#define USE_ENVMAP' : '',
  				parameters.envMap ? '#define ' + envMapModeDefine : '',
  				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  				parameters.aoMap ? '#define USE_AOMAP' : '',
  				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  				parameters.normalMap ? '#define USE_NORMALMAP' : '',
  				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
  				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
  				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

  				parameters.vertexTangents ? '#define USE_TANGENT' : '',
  				parameters.vertexColors ? '#define USE_COLOR' : '',

  				parameters.flatShading ? '#define FLAT_SHADED' : '',

  				parameters.skinning ? '#define USE_SKINNING' : '',
  				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

  				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
  				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
  				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  				parameters.flipSided ? '#define FLIP_SIDED' : '',

  				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

  				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  				'uniform mat4 modelMatrix;',
  				'uniform mat4 modelViewMatrix;',
  				'uniform mat4 projectionMatrix;',
  				'uniform mat4 viewMatrix;',
  				'uniform mat3 normalMatrix;',
  				'uniform vec3 cameraPosition;',

  				'attribute vec3 position;',
  				'attribute vec3 normal;',
  				'attribute vec2 uv;',

  				'#ifdef USE_TANGENT',

  				'	attribute vec4 tangent;',

  				'#endif',

  				'#ifdef USE_COLOR',

  				'	attribute vec3 color;',

  				'#endif',

  				'#ifdef USE_MORPHTARGETS',

  				'	attribute vec3 morphTarget0;',
  				'	attribute vec3 morphTarget1;',
  				'	attribute vec3 morphTarget2;',
  				'	attribute vec3 morphTarget3;',

  				'	#ifdef USE_MORPHNORMALS',

  				'		attribute vec3 morphNormal0;',
  				'		attribute vec3 morphNormal1;',
  				'		attribute vec3 morphNormal2;',
  				'		attribute vec3 morphNormal3;',

  				'	#else',

  				'		attribute vec3 morphTarget4;',
  				'		attribute vec3 morphTarget5;',
  				'		attribute vec3 morphTarget6;',
  				'		attribute vec3 morphTarget7;',

  				'	#endif',

  				'#endif',

  				'#ifdef USE_SKINNING',

  				'	attribute vec4 skinIndex;',
  				'	attribute vec4 skinWeight;',

  				'#endif',

  				'\n'

  			].filter( filterEmptyLine ).join( '\n' );

  			prefixFragment = [

  				customExtensions,

  				'precision ' + parameters.precision + ' float;',
  				'precision ' + parameters.precision + ' int;',

  				'#define SHADER_NAME ' + shader.name,

  				customDefines,

  				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

  				'#define GAMMA_FACTOR ' + gammaFactorDefine,

  				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

  				parameters.map ? '#define USE_MAP' : '',
  				parameters.matcap ? '#define USE_MATCAP' : '',
  				parameters.envMap ? '#define USE_ENVMAP' : '',
  				parameters.envMap ? '#define ' + envMapTypeDefine : '',
  				parameters.envMap ? '#define ' + envMapModeDefine : '',
  				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
  				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  				parameters.aoMap ? '#define USE_AOMAP' : '',
  				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  				parameters.normalMap ? '#define USE_NORMALMAP' : '',
  				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
  				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

  				parameters.vertexTangents ? '#define USE_TANGENT' : '',
  				parameters.vertexColors ? '#define USE_COLOR' : '',

  				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

  				parameters.flatShading ? '#define FLAT_SHADED' : '',

  				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  				parameters.flipSided ? '#define FLIP_SIDED' : '',

  				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

  				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

  				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  				parameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',

  				'uniform mat4 viewMatrix;',
  				'uniform vec3 cameraPosition;',

  				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
  				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
  				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

  				parameters.dithering ? '#define DITHERING' : '',

  				( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?
  					ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
  				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
  				parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
  				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
  				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
  				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

  				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

  				'\n'

  			].filter( filterEmptyLine ).join( '\n' );

  		}

  		vertexShader = parseIncludes( vertexShader );
  		vertexShader = replaceLightNums( vertexShader, parameters );
  		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

  		fragmentShader = parseIncludes( fragmentShader );
  		fragmentShader = replaceLightNums( fragmentShader, parameters );
  		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

  		vertexShader = unrollLoops( vertexShader );
  		fragmentShader = unrollLoops( fragmentShader );

  		if ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {

  			var isGLSL3ShaderMaterial = false;

  			var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

  			if ( material.isShaderMaterial &&
  				vertexShader.match( versionRegex ) !== null &&
  				fragmentShader.match( versionRegex ) !== null ) {

  				isGLSL3ShaderMaterial = true;

  				vertexShader = vertexShader.replace( versionRegex, '' );
  				fragmentShader = fragmentShader.replace( versionRegex, '' );

  			}

  			// GLSL 3.0 conversion
  			prefixVertex = [
  				'#version 300 es\n',
  				'#define attribute in',
  				'#define varying out',
  				'#define texture2D texture'
  			].join( '\n' ) + '\n' + prefixVertex;

  			prefixFragment = [
  				'#version 300 es\n',
  				'#define varying in',
  				isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
  				isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
  				'#define gl_FragDepthEXT gl_FragDepth',
  				'#define texture2D texture',
  				'#define textureCube texture',
  				'#define texture2DProj textureProj',
  				'#define texture2DLodEXT textureLod',
  				'#define texture2DProjLodEXT textureProjLod',
  				'#define textureCubeLodEXT textureLod',
  				'#define texture2DGradEXT textureGrad',
  				'#define texture2DProjGradEXT textureProjGrad',
  				'#define textureCubeGradEXT textureGrad'
  			].join( '\n' ) + '\n' + prefixFragment;

  		}

  		var vertexGlsl = prefixVertex + vertexShader;
  		var fragmentGlsl = prefixFragment + fragmentShader;

  		// console.log( '*VERTEX*', vertexGlsl );
  		// console.log( '*FRAGMENT*', fragmentGlsl );

  		var glVertexShader = WebGLShader( gl, 35633, vertexGlsl, renderer.debug.checkShaderErrors );
  		var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl, renderer.debug.checkShaderErrors );

  		gl.attachShader( program, glVertexShader );
  		gl.attachShader( program, glFragmentShader );

  		// Force a particular attribute to index 0.

  		if ( material.index0AttributeName !== undefined ) {

  			gl.bindAttribLocation( program, 0, material.index0AttributeName );

  		} else if ( parameters.morphTargets === true ) {

  			// programs with morphTargets displace position out of attribute 0
  			gl.bindAttribLocation( program, 0, 'position' );

  		}

  		gl.linkProgram( program );

  		// check for link errors
  		if ( renderer.debug.checkShaderErrors ) {

  			var programLog = gl.getProgramInfoLog( program ).trim();
  			var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
  			var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

  			var runnable = true;
  			var haveDiagnostics = true;

  			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
  			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

  			if ( gl.getProgramParameter( program, 35714 ) === false ) {

  				runnable = false;

  				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

  			} else if ( programLog !== '' ) {

  				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

  			} else if ( vertexLog === '' || fragmentLog === '' ) {

  				haveDiagnostics = false;

  			}

  			if ( haveDiagnostics ) {

  				this.diagnostics = {

  					runnable: runnable,
  					material: material,

  					programLog: programLog,

  					vertexShader: {

  						log: vertexLog,
  						prefix: prefixVertex

  					},

  					fragmentShader: {

  						log: fragmentLog,
  						prefix: prefixFragment

  					}

  				};

  			}

  		}

  		// clean up

  		gl.deleteShader( glVertexShader );
  		gl.deleteShader( glFragmentShader );

  		// set up caching for uniform locations

  		var cachedUniforms;

  		this.getUniforms = function () {

  			if ( cachedUniforms === undefined ) {

  				cachedUniforms = new WebGLUniforms( gl, program, textures );

  			}

  			return cachedUniforms;

  		};

  		// set up caching for attribute locations

  		var cachedAttributes;

  		this.getAttributes = function () {

  			if ( cachedAttributes === undefined ) {

  				cachedAttributes = fetchAttributeLocations( gl, program );

  			}

  			return cachedAttributes;

  		};

  		// free resource

  		this.destroy = function () {

  			gl.deleteProgram( program );
  			this.program = undefined;

  		};

  		// DEPRECATED

  		Object.defineProperties( this, {

  			uniforms: {
  				get: function () {

  					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
  					return this.getUniforms();

  				}
  			},

  			attributes: {
  				get: function () {

  					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
  					return this.getAttributes();

  				}
  			}

  		} );


  		//

  		this.name = shader.name;
  		this.id = programIdCount ++;
  		this.code = code;
  		this.usedTimes = 1;
  		this.program = program;
  		this.vertexShader = glVertexShader;
  		this.fragmentShader = glFragmentShader;

  		return this;

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLPrograms( renderer, extensions, capabilities, textures ) {

  		var programs = [];

  		var shaderIDs = {
  			MeshDepthMaterial: 'depth',
  			MeshDistanceMaterial: 'distanceRGBA',
  			MeshNormalMaterial: 'normal',
  			MeshBasicMaterial: 'basic',
  			MeshLambertMaterial: 'lambert',
  			MeshPhongMaterial: 'phong',
  			MeshToonMaterial: 'phong',
  			MeshStandardMaterial: 'physical',
  			MeshPhysicalMaterial: 'physical',
  			MeshMatcapMaterial: 'matcap',
  			LineBasicMaterial: 'basic',
  			LineDashedMaterial: 'dashed',
  			PointsMaterial: 'points',
  			ShadowMaterial: 'shadow',
  			SpriteMaterial: 'sprite'
  		};

  		var parameterNames = [
  			"precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding",
  			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap",
  			"roughnessMap", "metalnessMap", "gradientMap",
  			"alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp",
  			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
  			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
  			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
  			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
  			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
  			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
  		];


  		function allocateBones( object ) {

  			var skeleton = object.skeleton;
  			var bones = skeleton.bones;

  			if ( capabilities.floatVertexTextures ) {

  				return 1024;

  			} else {

  				// default for when object is not specified
  				// ( for example when prebuilding shader to be used with multiple objects )
  				//
  				//  - leave some extra space for other uniforms
  				//  - limit here is ANGLE's 254 max uniform vectors
  				//    (up to 54 should be safe)

  				var nVertexUniforms = capabilities.maxVertexUniforms;
  				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

  				var maxBones = Math.min( nVertexMatrices, bones.length );

  				if ( maxBones < bones.length ) {

  					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
  					return 0;

  				}

  				return maxBones;

  			}

  		}

  		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

  			var encoding;

  			if ( ! map ) {

  				encoding = LinearEncoding;

  			} else if ( map.isTexture ) {

  				encoding = map.encoding;

  			} else if ( map.isWebGLRenderTarget ) {

  				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
  				encoding = map.texture.encoding;

  			}

  			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
  			if ( encoding === LinearEncoding && gammaOverrideLinear ) {

  				encoding = GammaEncoding;

  			}

  			return encoding;

  		}

  		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

  			var shaderID = shaderIDs[ material.type ];

  			// heuristics to create shader parameters according to lights in the scene
  			// (not to blow over maxLights budget)

  			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
  			var precision = capabilities.precision;

  			if ( material.precision !== null ) {

  				precision = capabilities.getMaxPrecision( material.precision );

  				if ( precision !== material.precision ) {

  					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

  				}

  			}

  			var currentRenderTarget = renderer.getRenderTarget();

  			var parameters = {

  				shaderID: shaderID,

  				precision: precision,
  				supportsVertexTextures: capabilities.vertexTextures,
  				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
  				map: !! material.map,
  				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
  				matcap: !! material.matcap,
  				matcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),
  				envMap: !! material.envMap,
  				envMapMode: material.envMap && material.envMap.mapping,
  				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
  				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
  				lightMap: !! material.lightMap,
  				aoMap: !! material.aoMap,
  				emissiveMap: !! material.emissiveMap,
  				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
  				bumpMap: !! material.bumpMap,
  				normalMap: !! material.normalMap,
  				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
  				displacementMap: !! material.displacementMap,
  				roughnessMap: !! material.roughnessMap,
  				metalnessMap: !! material.metalnessMap,
  				specularMap: !! material.specularMap,
  				alphaMap: !! material.alphaMap,

  				gradientMap: !! material.gradientMap,

  				combine: material.combine,

  				vertexTangents: ( material.normalMap && material.vertexTangents ),
  				vertexColors: material.vertexColors,

  				fog: !! fog,
  				useFog: material.fog,
  				fogExp: ( fog && fog.isFogExp2 ),

  				flatShading: material.flatShading,

  				sizeAttenuation: material.sizeAttenuation,
  				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

  				skinning: material.skinning && maxBones > 0,
  				maxBones: maxBones,
  				useVertexTexture: capabilities.floatVertexTextures,

  				morphTargets: material.morphTargets,
  				morphNormals: material.morphNormals,
  				maxMorphTargets: renderer.maxMorphTargets,
  				maxMorphNormals: renderer.maxMorphNormals,

  				numDirLights: lights.directional.length,
  				numPointLights: lights.point.length,
  				numSpotLights: lights.spot.length,
  				numRectAreaLights: lights.rectArea.length,
  				numHemiLights: lights.hemi.length,

  				numClippingPlanes: nClipPlanes,
  				numClipIntersection: nClipIntersection,

  				dithering: material.dithering,

  				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
  				shadowMapType: renderer.shadowMap.type,

  				toneMapping: renderer.toneMapping,
  				physicallyCorrectLights: renderer.physicallyCorrectLights,

  				premultipliedAlpha: material.premultipliedAlpha,

  				alphaTest: material.alphaTest,
  				doubleSided: material.side === DoubleSide,
  				flipSided: material.side === BackSide,

  				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

  			};

  			return parameters;

  		};

  		this.getProgramCode = function ( material, parameters ) {

  			var array = [];

  			if ( parameters.shaderID ) {

  				array.push( parameters.shaderID );

  			} else {

  				array.push( material.fragmentShader );
  				array.push( material.vertexShader );

  			}

  			if ( material.defines !== undefined ) {

  				for ( var name in material.defines ) {

  					array.push( name );
  					array.push( material.defines[ name ] );

  				}

  			}

  			for ( var i = 0; i < parameterNames.length; i ++ ) {

  				array.push( parameters[ parameterNames[ i ] ] );

  			}

  			array.push( material.onBeforeCompile.toString() );

  			array.push( renderer.gammaOutput );

  			array.push( renderer.gammaFactor );

  			return array.join();

  		};

  		this.acquireProgram = function ( material, shader, parameters, code ) {

  			var program;

  			// Check if code has been already compiled
  			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

  				var programInfo = programs[ p ];

  				if ( programInfo.code === code ) {

  					program = programInfo;
  					++ program.usedTimes;

  					break;

  				}

  			}

  			if ( program === undefined ) {

  				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities, textures );
  				programs.push( program );

  			}

  			return program;

  		};

  		this.releaseProgram = function ( program ) {

  			if ( -- program.usedTimes === 0 ) {

  				// Remove from unordered set
  				var i = programs.indexOf( program );
  				programs[ i ] = programs[ programs.length - 1 ];
  				programs.pop();

  				// Free WebGL resources
  				program.destroy();

  			}

  		};

  		// Exposed for resource monitoring & error feedback via renderer.info:
  		this.programs = programs;

  	}

  	/**
  	 * @author fordacious / fordacious.github.io
  	 */

  	function WebGLProperties() {

  		var properties = new WeakMap();

  		function get( object ) {

  			var map = properties.get( object );

  			if ( map === undefined ) {

  				map = {};
  				properties.set( object, map );

  			}

  			return map;

  		}

  		function remove( object ) {

  			properties.delete( object );

  		}

  		function update( object, key, value ) {

  			properties.get( object )[ key ] = value;

  		}

  		function dispose() {

  			properties = new WeakMap();

  		}

  		return {
  			get: get,
  			remove: remove,
  			update: update,
  			dispose: dispose
  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function painterSortStable( a, b ) {

  		if ( a.groupOrder !== b.groupOrder ) {

  			return a.groupOrder - b.groupOrder;

  		} else if ( a.renderOrder !== b.renderOrder ) {

  			return a.renderOrder - b.renderOrder;

  		} else if ( a.program !== b.program ) {

  			return a.program.id - b.program.id;

  		} else if ( a.material.id !== b.material.id ) {

  			return a.material.id - b.material.id;

  		} else if ( a.z !== b.z ) {

  			return a.z - b.z;

  		} else {

  			return a.id - b.id;

  		}

  	}

  	function reversePainterSortStable( a, b ) {

  		if ( a.groupOrder !== b.groupOrder ) {

  			return a.groupOrder - b.groupOrder;

  		} else if ( a.renderOrder !== b.renderOrder ) {

  			return a.renderOrder - b.renderOrder;

  		} else if ( a.z !== b.z ) {

  			return b.z - a.z;

  		} else {

  			return a.id - b.id;

  		}

  	}


  	function WebGLRenderList() {

  		var renderItems = [];
  		var renderItemsIndex = 0;

  		var opaque = [];
  		var transparent = [];

  		var defaultProgram = { id: - 1 };

  		function init() {

  			renderItemsIndex = 0;

  			opaque.length = 0;
  			transparent.length = 0;

  		}

  		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

  			var renderItem = renderItems[ renderItemsIndex ];

  			if ( renderItem === undefined ) {

  				renderItem = {
  					id: object.id,
  					object: object,
  					geometry: geometry,
  					material: material,
  					program: material.program || defaultProgram,
  					groupOrder: groupOrder,
  					renderOrder: object.renderOrder,
  					z: z,
  					group: group
  				};

  				renderItems[ renderItemsIndex ] = renderItem;

  			} else {

  				renderItem.id = object.id;
  				renderItem.object = object;
  				renderItem.geometry = geometry;
  				renderItem.material = material;
  				renderItem.program = material.program || defaultProgram;
  				renderItem.groupOrder = groupOrder;
  				renderItem.renderOrder = object.renderOrder;
  				renderItem.z = z;
  				renderItem.group = group;

  			}

  			renderItemsIndex ++;

  			return renderItem;

  		}

  		function push( object, geometry, material, groupOrder, z, group ) {

  			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  			( material.transparent === true ? transparent : opaque ).push( renderItem );

  		}

  		function unshift( object, geometry, material, groupOrder, z, group ) {

  			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

  			( material.transparent === true ? transparent : opaque ).unshift( renderItem );

  		}

  		function sort() {

  			if ( opaque.length > 1 ) opaque.sort( painterSortStable );
  			if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );

  		}

  		return {
  			opaque: opaque,
  			transparent: transparent,

  			init: init,
  			push: push,
  			unshift: unshift,

  			sort: sort
  		};

  	}

  	function WebGLRenderLists() {

  		var lists = {};

  		function onSceneDispose( event ) {

  			var scene = event.target;

  			scene.removeEventListener( 'dispose', onSceneDispose );

  			delete lists[ scene.id ];

  		}

  		function get( scene, camera ) {

  			var cameras = lists[ scene.id ];
  			var list;
  			if ( cameras === undefined ) {

  				list = new WebGLRenderList();
  				lists[ scene.id ] = {};
  				lists[ scene.id ][ camera.id ] = list;

  				scene.addEventListener( 'dispose', onSceneDispose );

  			} else {

  				list = cameras[ camera.id ];
  				if ( list === undefined ) {

  					list = new WebGLRenderList();
  					cameras[ camera.id ] = list;

  				}

  			}

  			return list;

  		}

  		function dispose() {

  			lists = {};

  		}

  		return {
  			get: get,
  			dispose: dispose
  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function UniformsCache() {

  		var lights = {};

  		return {

  			get: function ( light ) {

  				if ( lights[ light.id ] !== undefined ) {

  					return lights[ light.id ];

  				}

  				var uniforms;

  				switch ( light.type ) {

  					case 'DirectionalLight':
  						uniforms = {
  							direction: new Vector3(),
  							color: new Color(),

  							shadow: false,
  							shadowBias: 0,
  							shadowRadius: 1,
  							shadowMapSize: new Vector2()
  						};
  						break;

  					case 'SpotLight':
  						uniforms = {
  							position: new Vector3(),
  							direction: new Vector3(),
  							color: new Color(),
  							distance: 0,
  							coneCos: 0,
  							penumbraCos: 0,
  							decay: 0,

  							shadow: false,
  							shadowBias: 0,
  							shadowRadius: 1,
  							shadowMapSize: new Vector2()
  						};
  						break;

  					case 'PointLight':
  						uniforms = {
  							position: new Vector3(),
  							color: new Color(),
  							distance: 0,
  							decay: 0,

  							shadow: false,
  							shadowBias: 0,
  							shadowRadius: 1,
  							shadowMapSize: new Vector2(),
  							shadowCameraNear: 1,
  							shadowCameraFar: 1000
  						};
  						break;

  					case 'HemisphereLight':
  						uniforms = {
  							direction: new Vector3(),
  							skyColor: new Color(),
  							groundColor: new Color()
  						};
  						break;

  					case 'RectAreaLight':
  						uniforms = {
  							color: new Color(),
  							position: new Vector3(),
  							halfWidth: new Vector3(),
  							halfHeight: new Vector3()
  							// TODO (abelnation): set RectAreaLight shadow uniforms
  						};
  						break;

  				}

  				lights[ light.id ] = uniforms;

  				return uniforms;

  			}

  		};

  	}

  	var count = 0;

  	function WebGLLights() {

  		var cache = new UniformsCache();

  		var state = {

  			id: count ++,

  			hash: {
  				stateID: - 1,
  				directionalLength: - 1,
  				pointLength: - 1,
  				spotLength: - 1,
  				rectAreaLength: - 1,
  				hemiLength: - 1,
  				shadowsLength: - 1
  			},

  			ambient: [ 0, 0, 0 ],
  			probe: [],
  			directional: [],
  			directionalShadowMap: [],
  			directionalShadowMatrix: [],
  			spot: [],
  			spotShadowMap: [],
  			spotShadowMatrix: [],
  			rectArea: [],
  			point: [],
  			pointShadowMap: [],
  			pointShadowMatrix: [],
  			hemi: []

  		};

  		for ( var i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

  		var vector3 = new Vector3();
  		var matrix4 = new Matrix4();
  		var matrix42 = new Matrix4();

  		function setup( lights, shadows, camera ) {

  			var r = 0, g = 0, b = 0;

  			for ( var i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

  			var directionalLength = 0;
  			var pointLength = 0;
  			var spotLength = 0;
  			var rectAreaLength = 0;
  			var hemiLength = 0;

  			var viewMatrix = camera.matrixWorldInverse;

  			for ( var i = 0, l = lights.length; i < l; i ++ ) {

  				var light = lights[ i ];

  				var color = light.color;
  				var intensity = light.intensity;
  				var distance = light.distance;

  				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

  				if ( light.isAmbientLight ) {

  					r += color.r * intensity;
  					g += color.g * intensity;
  					b += color.b * intensity;

  				} else if ( light.isLightProbe ) {

  					for ( var j = 0; j < 9; j ++ ) {

  						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

  					}

  				} else if ( light.isDirectionalLight ) {

  					var uniforms = cache.get( light );

  					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  					vector3.setFromMatrixPosition( light.target.matrixWorld );
  					uniforms.direction.sub( vector3 );
  					uniforms.direction.transformDirection( viewMatrix );

  					uniforms.shadow = light.castShadow;

  					if ( light.castShadow ) {

  						var shadow = light.shadow;

  						uniforms.shadowBias = shadow.bias;
  						uniforms.shadowRadius = shadow.radius;
  						uniforms.shadowMapSize = shadow.mapSize;

  					}

  					state.directionalShadowMap[ directionalLength ] = shadowMap;
  					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
  					state.directional[ directionalLength ] = uniforms;

  					directionalLength ++;

  				} else if ( light.isSpotLight ) {

  					var uniforms = cache.get( light );

  					uniforms.position.setFromMatrixPosition( light.matrixWorld );
  					uniforms.position.applyMatrix4( viewMatrix );

  					uniforms.color.copy( color ).multiplyScalar( intensity );
  					uniforms.distance = distance;

  					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  					vector3.setFromMatrixPosition( light.target.matrixWorld );
  					uniforms.direction.sub( vector3 );
  					uniforms.direction.transformDirection( viewMatrix );

  					uniforms.coneCos = Math.cos( light.angle );
  					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
  					uniforms.decay = light.decay;

  					uniforms.shadow = light.castShadow;

  					if ( light.castShadow ) {

  						var shadow = light.shadow;

  						uniforms.shadowBias = shadow.bias;
  						uniforms.shadowRadius = shadow.radius;
  						uniforms.shadowMapSize = shadow.mapSize;

  					}

  					state.spotShadowMap[ spotLength ] = shadowMap;
  					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
  					state.spot[ spotLength ] = uniforms;

  					spotLength ++;

  				} else if ( light.isRectAreaLight ) {

  					var uniforms = cache.get( light );

  					// (a) intensity is the total visible light emitted
  					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

  					// (b) intensity is the brightness of the light
  					uniforms.color.copy( color ).multiplyScalar( intensity );

  					uniforms.position.setFromMatrixPosition( light.matrixWorld );
  					uniforms.position.applyMatrix4( viewMatrix );

  					// extract local rotation of light to derive width/height half vectors
  					matrix42.identity();
  					matrix4.copy( light.matrixWorld );
  					matrix4.premultiply( viewMatrix );
  					matrix42.extractRotation( matrix4 );

  					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
  					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

  					uniforms.halfWidth.applyMatrix4( matrix42 );
  					uniforms.halfHeight.applyMatrix4( matrix42 );

  					// TODO (abelnation): RectAreaLight distance?
  					// uniforms.distance = distance;

  					state.rectArea[ rectAreaLength ] = uniforms;

  					rectAreaLength ++;

  				} else if ( light.isPointLight ) {

  					var uniforms = cache.get( light );

  					uniforms.position.setFromMatrixPosition( light.matrixWorld );
  					uniforms.position.applyMatrix4( viewMatrix );

  					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  					uniforms.distance = light.distance;
  					uniforms.decay = light.decay;

  					uniforms.shadow = light.castShadow;

  					if ( light.castShadow ) {

  						var shadow = light.shadow;

  						uniforms.shadowBias = shadow.bias;
  						uniforms.shadowRadius = shadow.radius;
  						uniforms.shadowMapSize = shadow.mapSize;
  						uniforms.shadowCameraNear = shadow.camera.near;
  						uniforms.shadowCameraFar = shadow.camera.far;

  					}

  					state.pointShadowMap[ pointLength ] = shadowMap;
  					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
  					state.point[ pointLength ] = uniforms;

  					pointLength ++;

  				} else if ( light.isHemisphereLight ) {

  					var uniforms = cache.get( light );

  					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  					uniforms.direction.transformDirection( viewMatrix );
  					uniforms.direction.normalize();

  					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
  					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

  					state.hemi[ hemiLength ] = uniforms;

  					hemiLength ++;

  				}

  			}

  			state.ambient[ 0 ] = r;
  			state.ambient[ 1 ] = g;
  			state.ambient[ 2 ] = b;

  			state.directional.length = directionalLength;
  			state.spot.length = spotLength;
  			state.rectArea.length = rectAreaLength;
  			state.point.length = pointLength;
  			state.hemi.length = hemiLength;

  			state.hash.stateID = state.id;
  			state.hash.directionalLength = directionalLength;
  			state.hash.pointLength = pointLength;
  			state.hash.spotLength = spotLength;
  			state.hash.rectAreaLength = rectAreaLength;
  			state.hash.hemiLength = hemiLength;
  			state.hash.shadowsLength = shadows.length;

  		}

  		return {
  			setup: setup,
  			state: state
  		};

  	}

  	/**
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	function WebGLRenderState() {

  		var lights = new WebGLLights();

  		var lightsArray = [];
  		var shadowsArray = [];

  		function init() {

  			lightsArray.length = 0;
  			shadowsArray.length = 0;

  		}

  		function pushLight( light ) {

  			lightsArray.push( light );

  		}

  		function pushShadow( shadowLight ) {

  			shadowsArray.push( shadowLight );

  		}

  		function setupLights( camera ) {

  			lights.setup( lightsArray, shadowsArray, camera );

  		}

  		var state = {
  			lightsArray: lightsArray,
  			shadowsArray: shadowsArray,

  			lights: lights
  		};

  		return {
  			init: init,
  			state: state,
  			setupLights: setupLights,

  			pushLight: pushLight,
  			pushShadow: pushShadow
  		};

  	}

  	function WebGLRenderStates() {

  		var renderStates = {};

  		function onSceneDispose( event ) {

  			var scene = event.target;

  			scene.removeEventListener( 'dispose', onSceneDispose );

  			delete renderStates[ scene.id ];

  		}

  		function get( scene, camera ) {

  			var renderState;

  			if ( renderStates[ scene.id ] === undefined ) {

  				renderState = new WebGLRenderState();
  				renderStates[ scene.id ] = {};
  				renderStates[ scene.id ][ camera.id ] = renderState;

  				scene.addEventListener( 'dispose', onSceneDispose );

  			} else {

  				if ( renderStates[ scene.id ][ camera.id ] === undefined ) {

  					renderState = new WebGLRenderState();
  					renderStates[ scene.id ][ camera.id ] = renderState;

  				} else {

  					renderState = renderStates[ scene.id ][ camera.id ];

  				}

  			}

  			return renderState;

  		}

  		function dispose() {

  			renderStates = {};

  		}

  		return {
  			get: get,
  			dispose: dispose
  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author bhouston / https://clara.io
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * parameters = {
  	 *
  	 *  opacity: <float>,
  	 *
  	 *  map: new THREE.Texture( <Image> ),
  	 *
  	 *  alphaMap: new THREE.Texture( <Image> ),
  	 *
  	 *  displacementMap: new THREE.Texture( <Image> ),
  	 *  displacementScale: <float>,
  	 *  displacementBias: <float>,
  	 *
  	 *  wireframe: <boolean>,
  	 *  wireframeLinewidth: <float>
  	 * }
  	 */

  	function MeshDepthMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'MeshDepthMaterial';

  		this.depthPacking = BasicDepthPacking;

  		this.skinning = false;
  		this.morphTargets = false;

  		this.map = null;

  		this.alphaMap = null;

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.fog = false;
  		this.lights = false;

  		this.setValues( parameters );

  	}

  	MeshDepthMaterial.prototype = Object.create( Material.prototype );
  	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

  	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

  	MeshDepthMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.depthPacking = source.depthPacking;

  		this.skinning = source.skinning;
  		this.morphTargets = source.morphTargets;

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		return this;

  	};

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * parameters = {
  	 *
  	 *  referencePosition: <float>,
  	 *  nearDistance: <float>,
  	 *  farDistance: <float>,
  	 *
  	 *  skinning: <bool>,
  	 *  morphTargets: <bool>,
  	 *
  	 *  map: new THREE.Texture( <Image> ),
  	 *
  	 *  alphaMap: new THREE.Texture( <Image> ),
  	 *
  	 *  displacementMap: new THREE.Texture( <Image> ),
  	 *  displacementScale: <float>,
  	 *  displacementBias: <float>
  	 *
  	 * }
  	 */

  	function MeshDistanceMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'MeshDistanceMaterial';

  		this.referencePosition = new Vector3();
  		this.nearDistance = 1;
  		this.farDistance = 1000;

  		this.skinning = false;
  		this.morphTargets = false;

  		this.map = null;

  		this.alphaMap = null;

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.fog = false;
  		this.lights = false;

  		this.setValues( parameters );

  	}

  	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
  	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

  	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

  	MeshDistanceMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.referencePosition.copy( source.referencePosition );
  		this.nearDistance = source.nearDistance;
  		this.farDistance = source.farDistance;

  		this.skinning = source.skinning;
  		this.morphTargets = source.morphTargets;

  		this.map = source.map;

  		this.alphaMap = source.alphaMap;

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		return this;

  	};

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

  		var _frustum = new Frustum(),
  			_projScreenMatrix = new Matrix4(),

  			_shadowMapSize = new Vector2(),
  			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

  			_lookTarget = new Vector3(),
  			_lightPositionWorld = new Vector3(),

  			_MorphingFlag = 1,
  			_SkinningFlag = 2,

  			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

  			_depthMaterials = new Array( _NumberOfMaterialVariants ),
  			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

  			_materialCache = {};

  		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

  		var cubeDirections = [
  			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
  			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
  		];

  		var cubeUps = [
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
  			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
  		];

  		var cube2DViewPorts = [
  			new Vector4(), new Vector4(), new Vector4(),
  			new Vector4(), new Vector4(), new Vector4()
  		];

  		// init

  		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

  			var useMorphing = ( i & _MorphingFlag ) !== 0;
  			var useSkinning = ( i & _SkinningFlag ) !== 0;

  			var depthMaterial = new MeshDepthMaterial( {

  				depthPacking: RGBADepthPacking,

  				morphTargets: useMorphing,
  				skinning: useSkinning

  			} );

  			_depthMaterials[ i ] = depthMaterial;

  			//

  			var distanceMaterial = new MeshDistanceMaterial( {

  				morphTargets: useMorphing,
  				skinning: useSkinning

  			} );

  			_distanceMaterials[ i ] = distanceMaterial;

  		}

  		//

  		var scope = this;

  		this.enabled = false;

  		this.autoUpdate = true;
  		this.needsUpdate = false;

  		this.type = PCFShadowMap;

  		this.render = function ( lights, scene, camera ) {

  			if ( scope.enabled === false ) return;
  			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

  			if ( lights.length === 0 ) return;

  			var currentRenderTarget = _renderer.getRenderTarget();

  			var _state = _renderer.state;

  			// Set GL state for depth map.
  			_state.setBlending( NoBlending );
  			_state.buffers.color.setClear( 1, 1, 1, 1 );
  			_state.buffers.depth.setTest( true );
  			_state.setScissorTest( false );

  			// render depth map

  			var faceCount;

  			for ( var i = 0, il = lights.length; i < il; i ++ ) {

  				var light = lights[ i ];
  				var shadow = light.shadow;
  				var isPointLight = light && light.isPointLight;

  				if ( shadow === undefined ) {

  					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
  					continue;

  				}

  				var shadowCamera = shadow.camera;

  				_shadowMapSize.copy( shadow.mapSize );
  				_shadowMapSize.min( _maxShadowMapSize );

  				if ( isPointLight ) {

  					var vpWidth = _shadowMapSize.x;
  					var vpHeight = _shadowMapSize.y;

  					// These viewports map a cube-map onto a 2D texture with the
  					// following orientation:
  					//
  					//  xzXZ
  					//   y Y
  					//
  					// X - Positive x direction
  					// x - Negative x direction
  					// Y - Positive y direction
  					// y - Negative y direction
  					// Z - Positive z direction
  					// z - Negative z direction

  					// positive X
  					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
  					// negative X
  					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
  					// positive Z
  					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
  					// negative Z
  					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
  					// positive Y
  					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
  					// negative Y
  					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

  					_shadowMapSize.x *= 4.0;
  					_shadowMapSize.y *= 2.0;

  				}

  				if ( shadow.map === null ) {

  					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

  					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
  					shadow.map.texture.name = light.name + ".shadowMap";

  					shadowCamera.updateProjectionMatrix();

  				}

  				if ( shadow.isSpotLightShadow ) {

  					shadow.update( light );

  				}

  				var shadowMap = shadow.map;
  				var shadowMatrix = shadow.matrix;

  				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  				shadowCamera.position.copy( _lightPositionWorld );

  				if ( isPointLight ) {

  					faceCount = 6;

  					// for point lights we set the shadow matrix to be a translation-only matrix
  					// equal to inverse of the light's position

  					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  				} else {

  					faceCount = 1;

  					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
  					shadowCamera.lookAt( _lookTarget );
  					shadowCamera.updateMatrixWorld();

  					// compute shadow matrix

  					shadowMatrix.set(
  						0.5, 0.0, 0.0, 0.5,
  						0.0, 0.5, 0.0, 0.5,
  						0.0, 0.0, 0.5, 0.5,
  						0.0, 0.0, 0.0, 1.0
  					);

  					shadowMatrix.multiply( shadowCamera.projectionMatrix );
  					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

  				}

  				_renderer.setRenderTarget( shadowMap );
  				_renderer.clear();

  				// render shadow map for each cube face (if omni-directional) or
  				// run a single pass if not

  				for ( var face = 0; face < faceCount; face ++ ) {

  					if ( isPointLight ) {

  						_lookTarget.copy( shadowCamera.position );
  						_lookTarget.add( cubeDirections[ face ] );
  						shadowCamera.up.copy( cubeUps[ face ] );
  						shadowCamera.lookAt( _lookTarget );
  						shadowCamera.updateMatrixWorld();

  						var vpDimensions = cube2DViewPorts[ face ];
  						_state.viewport( vpDimensions );

  					}

  					// update camera matrices and frustum

  					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  					_frustum.setFromMatrix( _projScreenMatrix );

  					// set object matrices & frustum culling

  					renderObject( scene, camera, shadowCamera, isPointLight );

  				}

  			}

  			scope.needsUpdate = false;

  			_renderer.setRenderTarget( currentRenderTarget );

  		};

  		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

  			var geometry = object.geometry;

  			var result = null;

  			var materialVariants = _depthMaterials;
  			var customMaterial = object.customDepthMaterial;

  			if ( isPointLight ) {

  				materialVariants = _distanceMaterials;
  				customMaterial = object.customDistanceMaterial;

  			}

  			if ( ! customMaterial ) {

  				var useMorphing = false;

  				if ( material.morphTargets ) {

  					if ( geometry && geometry.isBufferGeometry ) {

  						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

  					} else if ( geometry && geometry.isGeometry ) {

  						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

  					}

  				}

  				if ( object.isSkinnedMesh && material.skinning === false ) {

  					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

  				}

  				var useSkinning = object.isSkinnedMesh && material.skinning;

  				var variantIndex = 0;

  				if ( useMorphing ) variantIndex |= _MorphingFlag;
  				if ( useSkinning ) variantIndex |= _SkinningFlag;

  				result = materialVariants[ variantIndex ];

  			} else {

  				result = customMaterial;

  			}

  			if ( _renderer.localClippingEnabled &&
  					material.clipShadows === true &&
  					material.clippingPlanes.length !== 0 ) {

  				// in this case we need a unique material instance reflecting the
  				// appropriate state

  				var keyA = result.uuid, keyB = material.uuid;

  				var materialsForVariant = _materialCache[ keyA ];

  				if ( materialsForVariant === undefined ) {

  					materialsForVariant = {};
  					_materialCache[ keyA ] = materialsForVariant;

  				}

  				var cachedMaterial = materialsForVariant[ keyB ];

  				if ( cachedMaterial === undefined ) {

  					cachedMaterial = result.clone();
  					materialsForVariant[ keyB ] = cachedMaterial;

  				}

  				result = cachedMaterial;

  			}

  			result.visible = material.visible;
  			result.wireframe = material.wireframe;

  			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];

  			result.clipShadows = material.clipShadows;
  			result.clippingPlanes = material.clippingPlanes;
  			result.clipIntersection = material.clipIntersection;

  			result.wireframeLinewidth = material.wireframeLinewidth;
  			result.linewidth = material.linewidth;

  			if ( isPointLight && result.isMeshDistanceMaterial ) {

  				result.referencePosition.copy( lightPositionWorld );
  				result.nearDistance = shadowCameraNear;
  				result.farDistance = shadowCameraFar;

  			}

  			return result;

  		}

  		function renderObject( object, camera, shadowCamera, isPointLight ) {

  			if ( object.visible === false ) return;

  			var visible = object.layers.test( camera.layers );

  			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

  				if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

  					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

  					var geometry = _objects.update( object );
  					var material = object.material;

  					if ( Array.isArray( material ) ) {

  						var groups = geometry.groups;

  						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

  							var group = groups[ k ];
  							var groupMaterial = material[ group.materialIndex ];

  							if ( groupMaterial && groupMaterial.visible ) {

  								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
  								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

  							}

  						}

  					} else if ( material.visible ) {

  						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
  						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

  					}

  				}

  			}

  			var children = object.children;

  			for ( var i = 0, l = children.length; i < l; i ++ ) {

  				renderObject( children[ i ], camera, shadowCamera, isPointLight );

  			}

  		}

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLState( gl, extensions, utils, capabilities ) {

  		function ColorBuffer() {

  			var locked = false;

  			var color = new Vector4();
  			var currentColorMask = null;
  			var currentColorClear = new Vector4( 0, 0, 0, 0 );

  			return {

  				setMask: function ( colorMask ) {

  					if ( currentColorMask !== colorMask && ! locked ) {

  						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  						currentColorMask = colorMask;

  					}

  				},

  				setLocked: function ( lock ) {

  					locked = lock;

  				},

  				setClear: function ( r, g, b, a, premultipliedAlpha ) {

  					if ( premultipliedAlpha === true ) {

  						r *= a; g *= a; b *= a;

  					}

  					color.set( r, g, b, a );

  					if ( currentColorClear.equals( color ) === false ) {

  						gl.clearColor( r, g, b, a );
  						currentColorClear.copy( color );

  					}

  				},

  				reset: function () {

  					locked = false;

  					currentColorMask = null;
  					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

  				}

  			};

  		}

  		function DepthBuffer() {

  			var locked = false;

  			var currentDepthMask = null;
  			var currentDepthFunc = null;
  			var currentDepthClear = null;

  			return {

  				setTest: function ( depthTest ) {

  					if ( depthTest ) {

  						enable( 2929 );

  					} else {

  						disable( 2929 );

  					}

  				},

  				setMask: function ( depthMask ) {

  					if ( currentDepthMask !== depthMask && ! locked ) {

  						gl.depthMask( depthMask );
  						currentDepthMask = depthMask;

  					}

  				},

  				setFunc: function ( depthFunc ) {

  					if ( currentDepthFunc !== depthFunc ) {

  						if ( depthFunc ) {

  							switch ( depthFunc ) {

  								case NeverDepth:

  									gl.depthFunc( 512 );
  									break;

  								case AlwaysDepth:

  									gl.depthFunc( 519 );
  									break;

  								case LessDepth:

  									gl.depthFunc( 513 );
  									break;

  								case LessEqualDepth:

  									gl.depthFunc( 515 );
  									break;

  								case EqualDepth:

  									gl.depthFunc( 514 );
  									break;

  								case GreaterEqualDepth:

  									gl.depthFunc( 518 );
  									break;

  								case GreaterDepth:

  									gl.depthFunc( 516 );
  									break;

  								case NotEqualDepth:

  									gl.depthFunc( 517 );
  									break;

  								default:

  									gl.depthFunc( 515 );

  							}

  						} else {

  							gl.depthFunc( 515 );

  						}

  						currentDepthFunc = depthFunc;

  					}

  				},

  				setLocked: function ( lock ) {

  					locked = lock;

  				},

  				setClear: function ( depth ) {

  					if ( currentDepthClear !== depth ) {

  						gl.clearDepth( depth );
  						currentDepthClear = depth;

  					}

  				},

  				reset: function () {

  					locked = false;

  					currentDepthMask = null;
  					currentDepthFunc = null;
  					currentDepthClear = null;

  				}

  			};

  		}

  		function StencilBuffer() {

  			var locked = false;

  			var currentStencilMask = null;
  			var currentStencilFunc = null;
  			var currentStencilRef = null;
  			var currentStencilFuncMask = null;
  			var currentStencilFail = null;
  			var currentStencilZFail = null;
  			var currentStencilZPass = null;
  			var currentStencilClear = null;

  			return {

  				setTest: function ( stencilTest ) {

  					if ( stencilTest ) {

  						enable( 2960 );

  					} else {

  						disable( 2960 );

  					}

  				},

  				setMask: function ( stencilMask ) {

  					if ( currentStencilMask !== stencilMask && ! locked ) {

  						gl.stencilMask( stencilMask );
  						currentStencilMask = stencilMask;

  					}

  				},

  				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

  					if ( currentStencilFunc !== stencilFunc ||
  					     currentStencilRef 	!== stencilRef 	||
  					     currentStencilFuncMask !== stencilMask ) {

  						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  						currentStencilFunc = stencilFunc;
  						currentStencilRef = stencilRef;
  						currentStencilFuncMask = stencilMask;

  					}

  				},

  				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

  					if ( currentStencilFail	 !== stencilFail 	||
  					     currentStencilZFail !== stencilZFail ||
  					     currentStencilZPass !== stencilZPass ) {

  						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  						currentStencilFail = stencilFail;
  						currentStencilZFail = stencilZFail;
  						currentStencilZPass = stencilZPass;

  					}

  				},

  				setLocked: function ( lock ) {

  					locked = lock;

  				},

  				setClear: function ( stencil ) {

  					if ( currentStencilClear !== stencil ) {

  						gl.clearStencil( stencil );
  						currentStencilClear = stencil;

  					}

  				},

  				reset: function () {

  					locked = false;

  					currentStencilMask = null;
  					currentStencilFunc = null;
  					currentStencilRef = null;
  					currentStencilFuncMask = null;
  					currentStencilFail = null;
  					currentStencilZFail = null;
  					currentStencilZPass = null;
  					currentStencilClear = null;

  				}

  			};

  		}

  		//

  		var colorBuffer = new ColorBuffer();
  		var depthBuffer = new DepthBuffer();
  		var stencilBuffer = new StencilBuffer();

  		var maxVertexAttributes = gl.getParameter( 34921 );
  		var newAttributes = new Uint8Array( maxVertexAttributes );
  		var enabledAttributes = new Uint8Array( maxVertexAttributes );
  		var attributeDivisors = new Uint8Array( maxVertexAttributes );

  		var enabledCapabilities = {};

  		var compressedTextureFormats = null;

  		var currentProgram = null;

  		var currentBlendingEnabled = null;
  		var currentBlending = null;
  		var currentBlendEquation = null;
  		var currentBlendSrc = null;
  		var currentBlendDst = null;
  		var currentBlendEquationAlpha = null;
  		var currentBlendSrcAlpha = null;
  		var currentBlendDstAlpha = null;
  		var currentPremultipledAlpha = false;

  		var currentFlipSided = null;
  		var currentCullFace = null;

  		var currentLineWidth = null;

  		var currentPolygonOffsetFactor = null;
  		var currentPolygonOffsetUnits = null;

  		var maxTextures = gl.getParameter( 35661 );

  		var lineWidthAvailable = false;
  		var version = 0;
  		var glVersion = gl.getParameter( 7938 );

  		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

  			version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
  			lineWidthAvailable = ( version >= 1.0 );

  		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

  			version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
  			lineWidthAvailable = ( version >= 2.0 );

  		}

  		var currentTextureSlot = null;
  		var currentBoundTextures = {};

  		var currentScissor = new Vector4();
  		var currentViewport = new Vector4();

  		function createTexture( type, target, count ) {

  			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
  			var texture = gl.createTexture();

  			gl.bindTexture( type, texture );
  			gl.texParameteri( type, 10241, 9728 );
  			gl.texParameteri( type, 10240, 9728 );

  			for ( var i = 0; i < count; i ++ ) {

  				gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

  			}

  			return texture;

  		}

  		var emptyTextures = {};
  		emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
  		emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

  		// init

  		colorBuffer.setClear( 0, 0, 0, 1 );
  		depthBuffer.setClear( 1 );
  		stencilBuffer.setClear( 0 );

  		enable( 2929 );
  		depthBuffer.setFunc( LessEqualDepth );

  		setFlipSided( false );
  		setCullFace( CullFaceBack );
  		enable( 2884 );

  		setBlending( NoBlending );

  		//

  		function initAttributes() {

  			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

  				newAttributes[ i ] = 0;

  			}

  		}

  		function enableAttribute( attribute ) {

  			enableAttributeAndDivisor( attribute, 0 );

  		}

  		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

  			newAttributes[ attribute ] = 1;

  			if ( enabledAttributes[ attribute ] === 0 ) {

  				gl.enableVertexAttribArray( attribute );
  				enabledAttributes[ attribute ] = 1;

  			}

  			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

  				var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

  				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
  				attributeDivisors[ attribute ] = meshPerAttribute;

  			}

  		}

  		function disableUnusedAttributes() {

  			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

  				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

  					gl.disableVertexAttribArray( i );
  					enabledAttributes[ i ] = 0;

  				}

  			}

  		}

  		function enable( id ) {

  			if ( enabledCapabilities[ id ] !== true ) {

  				gl.enable( id );
  				enabledCapabilities[ id ] = true;

  			}

  		}

  		function disable( id ) {

  			if ( enabledCapabilities[ id ] !== false ) {

  				gl.disable( id );
  				enabledCapabilities[ id ] = false;

  			}

  		}

  		function getCompressedTextureFormats() {

  			if ( compressedTextureFormats === null ) {

  				compressedTextureFormats = [];

  				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
  				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
  				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
  				     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {

  					var formats = gl.getParameter( 34467 );

  					for ( var i = 0; i < formats.length; i ++ ) {

  						compressedTextureFormats.push( formats[ i ] );

  					}

  				}

  			}

  			return compressedTextureFormats;

  		}

  		function useProgram( program ) {

  			if ( currentProgram !== program ) {

  				gl.useProgram( program );

  				currentProgram = program;

  				return true;

  			}

  			return false;

  		}

  		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

  			if ( blending === NoBlending ) {

  				if ( currentBlendingEnabled ) {

  					disable( 3042 );
  					currentBlendingEnabled = false;

  				}

  				return;

  			}

  			if ( ! currentBlendingEnabled ) {

  				enable( 3042 );
  				currentBlendingEnabled = true;

  			}

  			if ( blending !== CustomBlending ) {

  				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

  					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

  						gl.blendEquation( 32774 );

  						currentBlendEquation = AddEquation;
  						currentBlendEquationAlpha = AddEquation;

  					}

  					if ( premultipliedAlpha ) {

  						switch ( blending ) {

  							case NormalBlending:
  								gl.blendFuncSeparate( 1, 771, 1, 771 );
  								break;

  							case AdditiveBlending:
  								gl.blendFunc( 1, 1 );
  								break;

  							case SubtractiveBlending:
  								gl.blendFuncSeparate( 0, 0, 769, 771 );
  								break;

  							case MultiplyBlending:
  								gl.blendFuncSeparate( 0, 768, 0, 770 );
  								break;

  							default:
  								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  								break;

  						}

  					} else {

  						switch ( blending ) {

  							case NormalBlending:
  								gl.blendFuncSeparate( 770, 771, 1, 771 );
  								break;

  							case AdditiveBlending:
  								gl.blendFunc( 770, 1 );
  								break;

  							case SubtractiveBlending:
  								gl.blendFunc( 0, 769 );
  								break;

  							case MultiplyBlending:
  								gl.blendFunc( 0, 768 );
  								break;

  							default:
  								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
  								break;

  						}

  					}

  					currentBlendSrc = null;
  					currentBlendDst = null;
  					currentBlendSrcAlpha = null;
  					currentBlendDstAlpha = null;

  					currentBlending = blending;
  					currentPremultipledAlpha = premultipliedAlpha;

  				}

  				return;

  			}

  			// custom blending

  			blendEquationAlpha = blendEquationAlpha || blendEquation;
  			blendSrcAlpha = blendSrcAlpha || blendSrc;
  			blendDstAlpha = blendDstAlpha || blendDst;

  			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

  				gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

  				currentBlendEquation = blendEquation;
  				currentBlendEquationAlpha = blendEquationAlpha;

  			}

  			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

  				gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

  				currentBlendSrc = blendSrc;
  				currentBlendDst = blendDst;
  				currentBlendSrcAlpha = blendSrcAlpha;
  				currentBlendDstAlpha = blendDstAlpha;

  			}

  			currentBlending = blending;
  			currentPremultipledAlpha = null;

  		}

  		function setMaterial( material, frontFaceCW ) {

  			material.side === DoubleSide
  				? disable( 2884 )
  				: enable( 2884 );

  			var flipSided = ( material.side === BackSide );
  			if ( frontFaceCW ) flipSided = ! flipSided;

  			setFlipSided( flipSided );

  			( material.blending === NormalBlending && material.transparent === false )
  				? setBlending( NoBlending )
  				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

  			depthBuffer.setFunc( material.depthFunc );
  			depthBuffer.setTest( material.depthTest );
  			depthBuffer.setMask( material.depthWrite );
  			colorBuffer.setMask( material.colorWrite );

  			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  		}

  		//

  		function setFlipSided( flipSided ) {

  			if ( currentFlipSided !== flipSided ) {

  				if ( flipSided ) {

  					gl.frontFace( 2304 );

  				} else {

  					gl.frontFace( 2305 );

  				}

  				currentFlipSided = flipSided;

  			}

  		}

  		function setCullFace( cullFace ) {

  			if ( cullFace !== CullFaceNone ) {

  				enable( 2884 );

  				if ( cullFace !== currentCullFace ) {

  					if ( cullFace === CullFaceBack ) {

  						gl.cullFace( 1029 );

  					} else if ( cullFace === CullFaceFront ) {

  						gl.cullFace( 1028 );

  					} else {

  						gl.cullFace( 1032 );

  					}

  				}

  			} else {

  				disable( 2884 );

  			}

  			currentCullFace = cullFace;

  		}

  		function setLineWidth( width ) {

  			if ( width !== currentLineWidth ) {

  				if ( lineWidthAvailable ) gl.lineWidth( width );

  				currentLineWidth = width;

  			}

  		}

  		function setPolygonOffset( polygonOffset, factor, units ) {

  			if ( polygonOffset ) {

  				enable( 32823 );

  				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

  					gl.polygonOffset( factor, units );

  					currentPolygonOffsetFactor = factor;
  					currentPolygonOffsetUnits = units;

  				}

  			} else {

  				disable( 32823 );

  			}

  		}

  		function setScissorTest( scissorTest ) {

  			if ( scissorTest ) {

  				enable( 3089 );

  			} else {

  				disable( 3089 );

  			}

  		}

  		// texture

  		function activeTexture( webglSlot ) {

  			if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

  			if ( currentTextureSlot !== webglSlot ) {

  				gl.activeTexture( webglSlot );
  				currentTextureSlot = webglSlot;

  			}

  		}

  		function bindTexture( webglType, webglTexture ) {

  			if ( currentTextureSlot === null ) {

  				activeTexture();

  			}

  			var boundTexture = currentBoundTextures[ currentTextureSlot ];

  			if ( boundTexture === undefined ) {

  				boundTexture = { type: undefined, texture: undefined };
  				currentBoundTextures[ currentTextureSlot ] = boundTexture;

  			}

  			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

  				boundTexture.type = webglType;
  				boundTexture.texture = webglTexture;

  			}

  		}

  		function compressedTexImage2D() {

  			try {

  				gl.compressedTexImage2D.apply( gl, arguments );

  			} catch ( error ) {

  				console.error( 'THREE.WebGLState:', error );

  			}

  		}

  		function texImage2D() {

  			try {

  				gl.texImage2D.apply( gl, arguments );

  			} catch ( error ) {

  				console.error( 'THREE.WebGLState:', error );

  			}

  		}

  		function texImage3D() {

  			try {

  				gl.texImage3D.apply( gl, arguments );

  			} catch ( error ) {

  				console.error( 'THREE.WebGLState:', error );

  			}

  		}

  		//

  		function scissor( scissor ) {

  			if ( currentScissor.equals( scissor ) === false ) {

  				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
  				currentScissor.copy( scissor );

  			}

  		}

  		function viewport( viewport ) {

  			if ( currentViewport.equals( viewport ) === false ) {

  				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
  				currentViewport.copy( viewport );

  			}

  		}

  		//

  		function reset() {

  			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

  				if ( enabledAttributes[ i ] === 1 ) {

  					gl.disableVertexAttribArray( i );
  					enabledAttributes[ i ] = 0;

  				}

  			}

  			enabledCapabilities = {};

  			compressedTextureFormats = null;

  			currentTextureSlot = null;
  			currentBoundTextures = {};

  			currentProgram = null;

  			currentBlending = null;

  			currentFlipSided = null;
  			currentCullFace = null;

  			colorBuffer.reset();
  			depthBuffer.reset();
  			stencilBuffer.reset();

  		}

  		return {

  			buffers: {
  				color: colorBuffer,
  				depth: depthBuffer,
  				stencil: stencilBuffer
  			},

  			initAttributes: initAttributes,
  			enableAttribute: enableAttribute,
  			enableAttributeAndDivisor: enableAttributeAndDivisor,
  			disableUnusedAttributes: disableUnusedAttributes,
  			enable: enable,
  			disable: disable,
  			getCompressedTextureFormats: getCompressedTextureFormats,

  			useProgram: useProgram,

  			setBlending: setBlending,
  			setMaterial: setMaterial,

  			setFlipSided: setFlipSided,
  			setCullFace: setCullFace,

  			setLineWidth: setLineWidth,
  			setPolygonOffset: setPolygonOffset,

  			setScissorTest: setScissorTest,

  			activeTexture: activeTexture,
  			bindTexture: bindTexture,
  			compressedTexImage2D: compressedTexImage2D,
  			texImage2D: texImage2D,
  			texImage3D: texImage3D,

  			scissor: scissor,
  			viewport: viewport,

  			reset: reset

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

  		var _videoTextures = {};
  		var _canvas;

  		//

  		var useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined';

  		function createCanvas( width, height ) {

  			// Use OffscreenCanvas when available. Specially needed in web workers

  			return useOffscreenCanvas ?
  				new OffscreenCanvas( width, height ) :
  				document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

  		}

  		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

  			var scale = 1;

  			// handle case if texture exceeds max size

  			if ( image.width > maxSize || image.height > maxSize ) {

  				scale = maxSize / Math.max( image.width, image.height );

  			}

  			// only perform resize if necessary

  			if ( scale < 1 || needsPowerOfTwo === true ) {

  				// only perform resize for certain image types

  				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
  					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
  					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

  					var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;

  					var width = floor( scale * image.width );
  					var height = floor( scale * image.height );

  					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

  					// cube textures can't reuse the same canvas

  					var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

  					canvas.width = width;
  					canvas.height = height;

  					var context = canvas.getContext( '2d' );
  					context.drawImage( image, 0, 0, width, height );

  					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

  					return canvas;

  				} else {

  					if ( 'data' in image ) {

  						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

  					}

  					return image;

  				}

  			}

  			return image;

  		}

  		function isPowerOfTwo( image ) {

  			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

  		}

  		function textureNeedsPowerOfTwo( texture ) {

  			if ( capabilities.isWebGL2 ) return false;

  			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
  				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

  		}

  		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

  			return texture.generateMipmaps && supportsMips &&
  				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

  		}

  		function generateMipmap( target, texture, width, height ) {

  			_gl.generateMipmap( target );

  			var textureProperties = properties.get( texture );

  			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
  			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

  		}

  		function getInternalFormat( glFormat, glType ) {

  			if ( ! capabilities.isWebGL2 ) return glFormat;

  			var internalFormat = glFormat;

  			if ( glFormat === 6403 ) {

  				if ( glType === 5126 ) internalFormat = 33326;
  				if ( glType === 5131 ) internalFormat = 33325;
  				if ( glType === 5121 ) internalFormat = 33321;

  			}

  			if ( glFormat === 6407 ) {

  				if ( glType === 5126 ) internalFormat = 34837;
  				if ( glType === 5131 ) internalFormat = 34843;
  				if ( glType === 5121 ) internalFormat = 32849;

  			}

  			if ( glFormat === 6408 ) {

  				if ( glType === 5126 ) internalFormat = 34836;
  				if ( glType === 5131 ) internalFormat = 34842;
  				if ( glType === 5121 ) internalFormat = 32856;

  			}

  			if ( internalFormat === 33325 || internalFormat === 33326 ||
  				internalFormat === 34842 || internalFormat === 34836 ) {

  				extensions.get( 'EXT_color_buffer_float' );

  			} else if ( internalFormat === 34843 || internalFormat === 34837 ) {

  				console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );

  			}

  			return internalFormat;

  		}

  		// Fallback filters for non-power-of-2 textures

  		function filterFallback( f ) {

  			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

  				return 9728;

  			}

  			return 9729;

  		}

  		//

  		function onTextureDispose( event ) {

  			var texture = event.target;

  			texture.removeEventListener( 'dispose', onTextureDispose );

  			deallocateTexture( texture );

  			if ( texture.isVideoTexture ) {

  				delete _videoTextures[ texture.id ];

  			}

  			info.memory.textures --;

  		}

  		function onRenderTargetDispose( event ) {

  			var renderTarget = event.target;

  			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

  			deallocateRenderTarget( renderTarget );

  			info.memory.textures --;

  		}

  		//

  		function deallocateTexture( texture ) {

  			var textureProperties = properties.get( texture );

  			if ( textureProperties.__webglInit === undefined ) return;

  			_gl.deleteTexture( textureProperties.__webglTexture );

  			properties.remove( texture );

  		}

  		function deallocateRenderTarget( renderTarget ) {

  			var renderTargetProperties = properties.get( renderTarget );
  			var textureProperties = properties.get( renderTarget.texture );

  			if ( ! renderTarget ) return;

  			if ( textureProperties.__webglTexture !== undefined ) {

  				_gl.deleteTexture( textureProperties.__webglTexture );

  			}

  			if ( renderTarget.depthTexture ) {

  				renderTarget.depthTexture.dispose();

  			}

  			if ( renderTarget.isWebGLRenderTargetCube ) {

  				for ( var i = 0; i < 6; i ++ ) {

  					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
  					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

  				}

  			} else {

  				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
  				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

  			}

  			properties.remove( renderTarget.texture );
  			properties.remove( renderTarget );

  		}

  		//

  		var textureUnits = 0;

  		function resetTextureUnits() {

  			textureUnits = 0;

  		}

  		function allocateTextureUnit() {

  			var textureUnit = textureUnits;

  			if ( textureUnit >= capabilities.maxTextures ) {

  				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

  			}

  			textureUnits += 1;

  			return textureUnit;

  		}

  		//

  		function setTexture2D( texture, slot ) {

  			var textureProperties = properties.get( texture );

  			if ( texture.isVideoTexture ) updateVideoTexture( texture );

  			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  				var image = texture.image;

  				if ( image === undefined ) {

  					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

  				} else if ( image.complete === false ) {

  					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

  				} else {

  					uploadTexture( textureProperties, texture, slot );
  					return;

  				}

  			}

  			state.activeTexture( 33984 + slot );
  			state.bindTexture( 3553, textureProperties.__webglTexture );

  		}

  		function setTexture2DArray( texture, slot ) {

  			var textureProperties = properties.get( texture );

  			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  				uploadTexture( textureProperties, texture, slot );
  				return;

  			}

  			state.activeTexture( 33984 + slot );
  			state.bindTexture( 35866, textureProperties.__webglTexture );

  		}

  		function setTexture3D( texture, slot ) {

  			var textureProperties = properties.get( texture );

  			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  				uploadTexture( textureProperties, texture, slot );
  				return;

  			}

  			state.activeTexture( 33984 + slot );
  			state.bindTexture( 32879, textureProperties.__webglTexture );

  		}

  		function setTextureCube( texture, slot ) {

  			var textureProperties = properties.get( texture );

  			if ( texture.image.length === 6 ) {

  				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  					initTexture( textureProperties, texture );

  					state.activeTexture( 33984 + slot );
  					state.bindTexture( 34067, textureProperties.__webglTexture );

  					_gl.pixelStorei( 37440, texture.flipY );

  					var isCompressed = ( texture && texture.isCompressedTexture );
  					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

  					var cubeImage = [];

  					for ( var i = 0; i < 6; i ++ ) {

  						if ( ! isCompressed && ! isDataTexture ) {

  							cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );

  						} else {

  							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

  						}

  					}

  					var image = cubeImage[ 0 ],
  						supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
  						glFormat = utils.convert( texture.format ),
  						glType = utils.convert( texture.type ),
  						glInternalFormat = getInternalFormat( glFormat, glType );

  					setTextureParameters( 34067, texture, supportsMips );

  					for ( var i = 0; i < 6; i ++ ) {

  						if ( ! isCompressed ) {

  							if ( isDataTexture ) {

  								state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

  							} else {

  								state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

  							}

  						} else {

  							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

  							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

  								mipmap = mipmaps[ j ];

  								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

  									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

  										state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  									} else {

  										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

  									}

  								} else {

  									state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  								}

  							}

  						}

  					}

  					if ( ! isCompressed ) {

  						textureProperties.__maxMipLevel = 0;

  					} else {

  						textureProperties.__maxMipLevel = mipmaps.length - 1;

  					}

  					if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  						// We assume images for cube map have the same size.
  						generateMipmap( 34067, texture, image.width, image.height );

  					}

  					textureProperties.__version = texture.version;

  					if ( texture.onUpdate ) texture.onUpdate( texture );

  				} else {

  					state.activeTexture( 33984 + slot );
  					state.bindTexture( 34067, textureProperties.__webglTexture );

  				}

  			}

  		}

  		function setTextureCubeDynamic( texture, slot ) {

  			state.activeTexture( 33984 + slot );
  			state.bindTexture( 34067, properties.get( texture ).__webglTexture );

  		}

  		function setTextureParameters( textureType, texture, supportsMips ) {

  			var extension;

  			if ( supportsMips ) {

  				_gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) );
  				_gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) );

  				if ( textureType === 32879 || textureType === 35866 ) {

  					_gl.texParameteri( textureType, 32882, utils.convert( texture.wrapR ) );

  				}

  				_gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) );
  				_gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) );

  			} else {

  				_gl.texParameteri( textureType, 10242, 33071 );
  				_gl.texParameteri( textureType, 10243, 33071 );

  				if ( textureType === 32879 || textureType === 35866 ) {

  					_gl.texParameteri( textureType, 32882, 33071 );

  				}

  				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

  					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

  				}

  				_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
  				_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

  				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

  					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

  				}

  			}

  			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  			if ( extension ) {

  				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
  				if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

  				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

  					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
  					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

  				}

  			}

  		}

  		function initTexture( textureProperties, texture ) {

  			if ( textureProperties.__webglInit === undefined ) {

  				textureProperties.__webglInit = true;

  				texture.addEventListener( 'dispose', onTextureDispose );

  				textureProperties.__webglTexture = _gl.createTexture();

  				info.memory.textures ++;

  			}

  		}

  		function uploadTexture( textureProperties, texture, slot ) {

  			var textureType = 3553;

  			if ( texture.isDataTexture2DArray ) textureType = 35866;
  			if ( texture.isDataTexture3D ) textureType = 32879;

  			initTexture( textureProperties, texture );

  			state.activeTexture( 33984 + slot );
  			state.bindTexture( textureType, textureProperties.__webglTexture );

  			_gl.pixelStorei( 37440, texture.flipY );
  			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
  			_gl.pixelStorei( 3317, texture.unpackAlignment );

  			var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
  			var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );

  			var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
  				glFormat = utils.convert( texture.format ),
  				glType = utils.convert( texture.type ),
  				glInternalFormat = getInternalFormat( glFormat, glType );

  			setTextureParameters( textureType, texture, supportsMips );

  			var mipmap, mipmaps = texture.mipmaps;

  			if ( texture.isDepthTexture ) {

  				// populate depth texture with dummy data

  				glInternalFormat = 6402;

  				if ( texture.type === FloatType ) {

  					if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
  					glInternalFormat = 36012;

  				} else if ( capabilities.isWebGL2 ) {

  					// WebGL 2.0 requires signed internalformat for glTexImage2D
  					glInternalFormat = 33189;

  				}

  				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

  					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

  						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

  						texture.type = UnsignedShortType;
  						glType = utils.convert( texture.type );

  					}

  				}

  				// Depth stencil textures need the DEPTH_STENCIL internal format
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.format === DepthStencilFormat ) {

  					glInternalFormat = 34041;

  					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  					if ( texture.type !== UnsignedInt248Type ) {

  						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

  						texture.type = UnsignedInt248Type;
  						glType = utils.convert( texture.type );

  					}

  				}

  				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

  			} else if ( texture.isDataTexture ) {

  				// use manually created mipmaps if available
  				// if there are no manual mipmaps
  				// set 0 level mipmap and then use GL to generate other mipmap levels

  				if ( mipmaps.length > 0 && supportsMips ) {

  					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];
  						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  					}

  					texture.generateMipmaps = false;
  					textureProperties.__maxMipLevel = mipmaps.length - 1;

  				} else {

  					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
  					textureProperties.__maxMipLevel = 0;

  				}

  			} else if ( texture.isCompressedTexture ) {

  				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];

  					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

  						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

  							state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  						} else {

  							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

  						}

  					} else {

  						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  					}

  				}

  				textureProperties.__maxMipLevel = mipmaps.length - 1;

  			} else if ( texture.isDataTexture2DArray ) {

  				state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
  				textureProperties.__maxMipLevel = 0;

  			} else if ( texture.isDataTexture3D ) {

  				state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
  				textureProperties.__maxMipLevel = 0;

  			} else {

  				// regular Texture (image, video, canvas)

  				// use manually created mipmaps if available
  				// if there are no manual mipmaps
  				// set 0 level mipmap and then use GL to generate other mipmap levels

  				if ( mipmaps.length > 0 && supportsMips ) {

  					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  						mipmap = mipmaps[ i ];
  						state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

  					}

  					texture.generateMipmaps = false;
  					textureProperties.__maxMipLevel = mipmaps.length - 1;

  				} else {

  					state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
  					textureProperties.__maxMipLevel = 0;

  				}

  			}

  			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  				generateMipmap( 3553, texture, image.width, image.height );

  			}

  			textureProperties.__version = texture.version;

  			if ( texture.onUpdate ) texture.onUpdate( texture );

  		}

  		// Render targets

  		// Setup storage for target texture and bind it to correct framebuffer
  		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

  			var glFormat = utils.convert( renderTarget.texture.format );
  			var glType = utils.convert( renderTarget.texture.type );
  			var glInternalFormat = getInternalFormat( glFormat, glType );
  			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
  			_gl.bindFramebuffer( 36160, framebuffer );
  			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
  			_gl.bindFramebuffer( 36160, null );

  		}

  		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

  			_gl.bindRenderbuffer( 36161, renderbuffer );

  			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

  				if ( isMultisample ) {

  					var samples = getRenderTargetSamples( renderTarget );

  					_gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );

  				} else {

  					_gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );

  				}

  				_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

  			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

  				if ( isMultisample ) {

  					var samples = getRenderTargetSamples( renderTarget );

  					_gl.renderbufferStorageMultisample( 36161, samples, 34041, renderTarget.width, renderTarget.height );

  				} else {

  					_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

  				}


  				_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

  			} else {

  				var glFormat = utils.convert( renderTarget.texture.format );
  				var glType = utils.convert( renderTarget.texture.type );
  				var glInternalFormat = getInternalFormat( glFormat, glType );

  				if ( isMultisample ) {

  					var samples = getRenderTargetSamples( renderTarget );

  					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  				} else {

  					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

  				}

  			}

  			_gl.bindRenderbuffer( 36161, null );

  		}

  		// Setup resources for a Depth Texture for a FBO (needs an extension)
  		function setupDepthTexture( framebuffer, renderTarget ) {

  			var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
  			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

  			_gl.bindFramebuffer( 36160, framebuffer );

  			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

  				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

  			}

  			// upload an empty depth texture with framebuffer size
  			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
  					renderTarget.depthTexture.image.width !== renderTarget.width ||
  					renderTarget.depthTexture.image.height !== renderTarget.height ) {

  				renderTarget.depthTexture.image.width = renderTarget.width;
  				renderTarget.depthTexture.image.height = renderTarget.height;
  				renderTarget.depthTexture.needsUpdate = true;

  			}

  			setTexture2D( renderTarget.depthTexture, 0 );

  			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

  			if ( renderTarget.depthTexture.format === DepthFormat ) {

  				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

  			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

  				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

  			} else {

  				throw new Error( 'Unknown depthTexture format' );

  			}

  		}

  		// Setup GL resources for a non-texture depth buffer
  		function setupDepthRenderbuffer( renderTarget ) {

  			var renderTargetProperties = properties.get( renderTarget );

  			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

  			if ( renderTarget.depthTexture ) {

  				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

  				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

  			} else {

  				if ( isCube ) {

  					renderTargetProperties.__webglDepthbuffer = [];

  					for ( var i = 0; i < 6; i ++ ) {

  						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
  						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
  						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

  					}

  				} else {

  					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
  					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

  				}

  			}

  			_gl.bindFramebuffer( 36160, null );

  		}

  		// Set up GL resources for the render target
  		function setupRenderTarget( renderTarget ) {

  			var renderTargetProperties = properties.get( renderTarget );
  			var textureProperties = properties.get( renderTarget.texture );

  			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

  			textureProperties.__webglTexture = _gl.createTexture();

  			info.memory.textures ++;

  			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
  			var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
  			var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

  			// Setup framebuffer

  			if ( isCube ) {

  				renderTargetProperties.__webglFramebuffer = [];

  				for ( var i = 0; i < 6; i ++ ) {

  					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

  				}

  			} else {

  				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

  				if ( isMultisample ) {

  					if ( capabilities.isWebGL2 ) {

  						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
  						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

  						_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );
  						var glFormat = utils.convert( renderTarget.texture.format );
  						var glType = utils.convert( renderTarget.texture.type );
  						var glInternalFormat = getInternalFormat( glFormat, glType );
  						var samples = getRenderTargetSamples( renderTarget );
  						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

  						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
  						_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
  						_gl.bindRenderbuffer( 36161, null );

  						if ( renderTarget.depthBuffer ) {

  							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
  							setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

  						}

  						_gl.bindFramebuffer( 36160, null );


  					} else {

  						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

  					}

  				}

  			}

  			// Setup color buffer

  			if ( isCube ) {

  				state.bindTexture( 34067, textureProperties.__webglTexture );
  				setTextureParameters( 34067, renderTarget.texture, supportsMips );

  				for ( var i = 0; i < 6; i ++ ) {

  					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

  				}

  				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

  					generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );

  				}

  				state.bindTexture( 34067, null );

  			} else {

  				state.bindTexture( 3553, textureProperties.__webglTexture );
  				setTextureParameters( 3553, renderTarget.texture, supportsMips );
  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );

  				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

  					generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );

  				}

  				state.bindTexture( 3553, null );

  			}

  			// Setup depth and stencil buffers

  			if ( renderTarget.depthBuffer ) {

  				setupDepthRenderbuffer( renderTarget );

  			}

  		}

  		function updateRenderTargetMipmap( renderTarget ) {

  			var texture = renderTarget.texture;
  			var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;

  			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

  				var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
  				var webglTexture = properties.get( texture ).__webglTexture;

  				state.bindTexture( target, webglTexture );
  				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
  				state.bindTexture( target, null );

  			}

  		}

  		function updateMultisampleRenderTarget( renderTarget ) {

  			if ( renderTarget.isWebGLMultisampleRenderTarget ) {

  				if ( capabilities.isWebGL2 ) {

  					var renderTargetProperties = properties.get( renderTarget );

  					_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
  					_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

  					var width = renderTarget.width;
  					var height = renderTarget.height;
  					var mask = 16384;

  					if ( renderTarget.depthBuffer ) mask |= 256;
  					if ( renderTarget.stencilBuffer ) mask |= 1024;

  					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

  				} else {

  					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

  				}

  			}

  		}

  		function getRenderTargetSamples( renderTarget ) {

  			return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
  				Math.min( capabilities.maxSamples, renderTarget.samples ) : 0;

  		}

  		function updateVideoTexture( texture ) {

  			var id = texture.id;
  			var frame = info.render.frame;

  			// Check the last frame we updated the VideoTexture

  			if ( _videoTextures[ id ] !== frame ) {

  				_videoTextures[ id ] = frame;
  				texture.update();

  			}

  		}

  		// backwards compatibility

  		var warnedTexture2D = false;
  		var warnedTextureCube = false;

  		function safeSetTexture2D( texture, slot ) {

  			if ( texture && texture.isWebGLRenderTarget ) {

  				if ( warnedTexture2D === false ) {

  					console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
  					warnedTexture2D = true;

  				}

  				texture = texture.texture;

  			}

  			setTexture2D( texture, slot );

  		}

  		function safeSetTextureCube( texture, slot ) {

  			if ( texture && texture.isWebGLRenderTargetCube ) {

  				if ( warnedTextureCube === false ) {

  					console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
  					warnedTextureCube = true;

  				}

  				texture = texture.texture;

  			}

  			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
  			// TODO: unify these code paths
  			if ( ( texture && texture.isCubeTexture ) ||
  				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

  				// CompressedTexture can have Array in image :/

  				// this function alone should take care of cube textures
  				setTextureCube( texture, slot );

  			} else {

  				// assumed: texture property of THREE.WebGLRenderTargetCube
  				setTextureCubeDynamic( texture, slot );

  			}

  		}

  		//

  		this.allocateTextureUnit = allocateTextureUnit;
  		this.resetTextureUnits = resetTextureUnits;

  		this.setTexture2D = setTexture2D;
  		this.setTexture2DArray = setTexture2DArray;
  		this.setTexture3D = setTexture3D;
  		this.setTextureCube = setTextureCube;
  		this.setTextureCubeDynamic = setTextureCubeDynamic;
  		this.setupRenderTarget = setupRenderTarget;
  		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

  		this.safeSetTexture2D = safeSetTexture2D;
  		this.safeSetTextureCube = safeSetTextureCube;

  	}

  	/**
  	 * @author thespite / http://www.twitter.com/thespite
  	 */

  	function WebGLUtils( gl, extensions, capabilities ) {

  		function convert( p ) {

  			var extension;

  			if ( p === RepeatWrapping ) return 10497;
  			if ( p === ClampToEdgeWrapping ) return 33071;
  			if ( p === MirroredRepeatWrapping ) return 33648;

  			if ( p === NearestFilter ) return 9728;
  			if ( p === NearestMipMapNearestFilter ) return 9984;
  			if ( p === NearestMipMapLinearFilter ) return 9986;

  			if ( p === LinearFilter ) return 9729;
  			if ( p === LinearMipMapNearestFilter ) return 9985;
  			if ( p === LinearMipMapLinearFilter ) return 9987;

  			if ( p === UnsignedByteType ) return 5121;
  			if ( p === UnsignedShort4444Type ) return 32819;
  			if ( p === UnsignedShort5551Type ) return 32820;
  			if ( p === UnsignedShort565Type ) return 33635;

  			if ( p === ByteType ) return 5120;
  			if ( p === ShortType ) return 5122;
  			if ( p === UnsignedShortType ) return 5123;
  			if ( p === IntType ) return 5124;
  			if ( p === UnsignedIntType ) return 5125;
  			if ( p === FloatType ) return 5126;

  			if ( p === HalfFloatType ) {

  				if ( capabilities.isWebGL2 ) return 5131;

  				extension = extensions.get( 'OES_texture_half_float' );

  				if ( extension !== null ) return extension.HALF_FLOAT_OES;

  			}

  			if ( p === AlphaFormat ) return 6406;
  			if ( p === RGBFormat ) return 6407;
  			if ( p === RGBAFormat ) return 6408;
  			if ( p === LuminanceFormat ) return 6409;
  			if ( p === LuminanceAlphaFormat ) return 6410;
  			if ( p === DepthFormat ) return 6402;
  			if ( p === DepthStencilFormat ) return 34041;
  			if ( p === RedFormat ) return 6403;

  			if ( p === AddEquation ) return 32774;
  			if ( p === SubtractEquation ) return 32778;
  			if ( p === ReverseSubtractEquation ) return 32779;

  			if ( p === ZeroFactor ) return 0;
  			if ( p === OneFactor ) return 1;
  			if ( p === SrcColorFactor ) return 768;
  			if ( p === OneMinusSrcColorFactor ) return 769;
  			if ( p === SrcAlphaFactor ) return 770;
  			if ( p === OneMinusSrcAlphaFactor ) return 771;
  			if ( p === DstAlphaFactor ) return 772;
  			if ( p === OneMinusDstAlphaFactor ) return 773;

  			if ( p === DstColorFactor ) return 774;
  			if ( p === OneMinusDstColorFactor ) return 775;
  			if ( p === SrcAlphaSaturateFactor ) return 776;

  			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
  				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

  				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  				if ( extension !== null ) {

  					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
  					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
  					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

  				}

  			}

  			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
  				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

  				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  				if ( extension !== null ) {

  					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
  					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
  					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
  					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

  				}

  			}

  			if ( p === RGB_ETC1_Format ) {

  				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

  				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

  			}

  			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
  				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
  				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
  				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
  				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

  				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

  				if ( extension !== null ) {

  					return p;

  				}

  			}

  			if ( p === MinEquation || p === MaxEquation ) {

  				if ( capabilities.isWebGL2 ) {

  					if ( p === MinEquation ) return 32775;
  					if ( p === MaxEquation ) return 32776;

  				}

  				extension = extensions.get( 'EXT_blend_minmax' );

  				if ( extension !== null ) {

  					if ( p === MinEquation ) return extension.MIN_EXT;
  					if ( p === MaxEquation ) return extension.MAX_EXT;

  				}

  			}

  			if ( p === UnsignedInt248Type ) {

  				if ( capabilities.isWebGL2 ) return 34042;

  				extension = extensions.get( 'WEBGL_depth_texture' );

  				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

  			}

  			return 0;

  		}

  		return { convert: convert };

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function Group() {

  		Object3D.call( this );

  		this.type = 'Group';

  	}

  	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Group,

  		isGroup: true

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author WestLangley / http://github.com/WestLangley
  	*/

  	function Camera() {

  		Object3D.call( this );

  		this.type = 'Camera';

  		this.matrixWorldInverse = new Matrix4();

  		this.projectionMatrix = new Matrix4();
  		this.projectionMatrixInverse = new Matrix4();

  	}

  	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Camera,

  		isCamera: true,

  		copy: function ( source, recursive ) {

  			Object3D.prototype.copy.call( this, source, recursive );

  			this.matrixWorldInverse.copy( source.matrixWorldInverse );

  			this.projectionMatrix.copy( source.projectionMatrix );
  			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

  			return this;

  		},

  		getWorldDirection: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
  				target = new Vector3();

  			}

  			this.updateMatrixWorld( true );

  			var e = this.matrixWorld.elements;

  			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

  		},

  		updateMatrixWorld: function ( force ) {

  			Object3D.prototype.updateMatrixWorld.call( this, force );

  			this.matrixWorldInverse.getInverse( this.matrixWorld );

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author greggman / http://games.greggman.com/
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 * @author tschw
  	 */

  	function PerspectiveCamera( fov, aspect, near, far ) {

  		Camera.call( this );

  		this.type = 'PerspectiveCamera';

  		this.fov = fov !== undefined ? fov : 50;
  		this.zoom = 1;

  		this.near = near !== undefined ? near : 0.1;
  		this.far = far !== undefined ? far : 2000;
  		this.focus = 10;

  		this.aspect = aspect !== undefined ? aspect : 1;
  		this.view = null;

  		this.filmGauge = 35;	// width of the film (default in millimeters)
  		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

  		this.updateProjectionMatrix();

  	}

  	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

  		constructor: PerspectiveCamera,

  		isPerspectiveCamera: true,

  		copy: function ( source, recursive ) {

  			Camera.prototype.copy.call( this, source, recursive );

  			this.fov = source.fov;
  			this.zoom = source.zoom;

  			this.near = source.near;
  			this.far = source.far;
  			this.focus = source.focus;

  			this.aspect = source.aspect;
  			this.view = source.view === null ? null : Object.assign( {}, source.view );

  			this.filmGauge = source.filmGauge;
  			this.filmOffset = source.filmOffset;

  			return this;

  		},

  		/**
  		 * Sets the FOV by focal length in respect to the current .filmGauge.
  		 *
  		 * The default film gauge is 35, so that the focal length can be specified for
  		 * a 35mm (full frame) camera.
  		 *
  		 * Values for focal length and film gauge must have the same unit.
  		 */
  		setFocalLength: function ( focalLength ) {

  			// see http://www.bobatkins.com/photography/technical/field_of_view.html
  			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
  			this.updateProjectionMatrix();

  		},

  		/**
  		 * Calculates the focal length from the current .fov and .filmGauge.
  		 */
  		getFocalLength: function () {

  			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

  			return 0.5 * this.getFilmHeight() / vExtentSlope;

  		},

  		getEffectiveFOV: function () {

  			return _Math.RAD2DEG * 2 * Math.atan(
  				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

  		},

  		getFilmWidth: function () {

  			// film not completely covered in portrait format (aspect < 1)
  			return this.filmGauge * Math.min( this.aspect, 1 );

  		},

  		getFilmHeight: function () {

  			// film not completely covered in landscape format (aspect > 1)
  			return this.filmGauge / Math.max( this.aspect, 1 );

  		},

  		/**
  		 * Sets an offset in a larger frustum. This is useful for multi-window or
  		 * multi-monitor/multi-machine setups.
  		 *
  		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  		 * the monitors are in grid like this
  		 *
  		 *   +---+---+---+
  		 *   | A | B | C |
  		 *   +---+---+---+
  		 *   | D | E | F |
  		 *   +---+---+---+
  		 *
  		 * then for each monitor you would call it like this
  		 *
  		 *   var w = 1920;
  		 *   var h = 1080;
  		 *   var fullWidth = w * 3;
  		 *   var fullHeight = h * 2;
  		 *
  		 *   --A--
  		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  		 *   --B--
  		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  		 *   --C--
  		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  		 *   --D--
  		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  		 *   --E--
  		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  		 *   --F--
  		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  		 *
  		 *   Note there is no reason monitors have to be the same size or in a grid.
  		 */
  		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  			this.aspect = fullWidth / fullHeight;

  			if ( this.view === null ) {

  				this.view = {
  					enabled: true,
  					fullWidth: 1,
  					fullHeight: 1,
  					offsetX: 0,
  					offsetY: 0,
  					width: 1,
  					height: 1
  				};

  			}

  			this.view.enabled = true;
  			this.view.fullWidth = fullWidth;
  			this.view.fullHeight = fullHeight;
  			this.view.offsetX = x;
  			this.view.offsetY = y;
  			this.view.width = width;
  			this.view.height = height;

  			this.updateProjectionMatrix();

  		},

  		clearViewOffset: function () {

  			if ( this.view !== null ) {

  				this.view.enabled = false;

  			}

  			this.updateProjectionMatrix();

  		},

  		updateProjectionMatrix: function () {

  			var near = this.near,
  				top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
  				height = 2 * top,
  				width = this.aspect * height,
  				left = - 0.5 * width,
  				view = this.view;

  			if ( this.view !== null && this.view.enabled ) {

  				var fullWidth = view.fullWidth,
  					fullHeight = view.fullHeight;

  				left += view.offsetX * width / fullWidth;
  				top -= view.offsetY * height / fullHeight;
  				width *= view.width / fullWidth;
  				height *= view.height / fullHeight;

  			}

  			var skew = this.filmOffset;
  			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

  			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

  			this.projectionMatrixInverse.getInverse( this.projectionMatrix );

  		},

  		toJSON: function ( meta ) {

  			var data = Object3D.prototype.toJSON.call( this, meta );

  			data.object.fov = this.fov;
  			data.object.zoom = this.zoom;

  			data.object.near = this.near;
  			data.object.far = this.far;
  			data.object.focus = this.focus;

  			data.object.aspect = this.aspect;

  			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  			data.object.filmGauge = this.filmGauge;
  			data.object.filmOffset = this.filmOffset;

  			return data;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function ArrayCamera( array ) {

  		PerspectiveCamera.call( this );

  		this.cameras = array || [];

  	}

  	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

  		constructor: ArrayCamera,

  		isArrayCamera: true

  	} );

  	/**
  	 * @author jsantell / https://www.jsantell.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	var cameraLPos = new Vector3();
  	var cameraRPos = new Vector3();

  	/**
  	 * Assumes 2 cameras that are parallel and share an X-axis, and that
  	 * the cameras' projection and world matrices have already been set.
  	 * And that near and far planes are identical for both cameras.
  	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
  	 */
  	function setProjectionFromUnion( camera, cameraL, cameraR ) {

  		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
  		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

  		var ipd = cameraLPos.distanceTo( cameraRPos );

  		var projL = cameraL.projectionMatrix.elements;
  		var projR = cameraR.projectionMatrix.elements;

  		// VR systems will have identical far and near planes, and
  		// most likely identical top and bottom frustum extents.
  		// Use the left camera for these values.
  		var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
  		var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
  		var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
  		var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

  		var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
  		var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
  		var left = near * leftFov;
  		var right = near * rightFov;

  		// Calculate the new camera's position offset from the
  		// left camera. xOffset should be roughly half `ipd`.
  		var zOffset = ipd / ( - leftFov + rightFov );
  		var xOffset = zOffset * - leftFov;

  		// TODO: Better way to apply this offset?
  		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
  		camera.translateX( xOffset );
  		camera.translateZ( zOffset );
  		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
  		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

  		// Find the union of the frustum values of the cameras and scale
  		// the values so that the near plane's position does not change in world space,
  		// although must now be relative to the new union camera.
  		var near2 = near + zOffset;
  		var far2 = far + zOffset;
  		var left2 = left - xOffset;
  		var right2 = right + ( ipd - xOffset );
  		var top2 = topFov * far / far2 * near2;
  		var bottom2 = bottomFov * far / far2 * near2;

  		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebVRManager( renderer ) {

  		var scope = this;

  		var device = null;
  		var frameData = null;

  		var poseTarget = null;

  		var controllers = [];
  		var standingMatrix = new Matrix4();
  		var standingMatrixInverse = new Matrix4();

  		var framebufferScaleFactor = 1.0;

  		var frameOfReferenceType = 'stage';

  		if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

  			frameData = new window.VRFrameData();
  			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

  		}

  		var matrixWorldInverse = new Matrix4();
  		var tempQuaternion = new Quaternion();
  		var tempPosition = new Vector3();

  		var cameraL = new PerspectiveCamera();
  		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
  		cameraL.layers.enable( 1 );

  		var cameraR = new PerspectiveCamera();
  		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
  		cameraR.layers.enable( 2 );

  		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
  		cameraVR.layers.enable( 1 );
  		cameraVR.layers.enable( 2 );

  		//

  		function isPresenting() {

  			return device !== null && device.isPresenting === true;

  		}

  		var currentSize = new Vector2(), currentPixelRatio;

  		function onVRDisplayPresentChange() {

  			if ( isPresenting() ) {

  				var eyeParameters = device.getEyeParameters( 'left' );
  				var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
  				var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;

  				currentPixelRatio = renderer.getPixelRatio();
  				renderer.getSize( currentSize );

  				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

  				animation.start();

  			} else {

  				if ( scope.enabled ) {

  					renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

  				}

  				animation.stop();

  			}

  		}

  		//

  		var triggers = [];

  		function findGamepad( id ) {

  			var gamepads = navigator.getGamepads && navigator.getGamepads();

  			for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {

  				var gamepad = gamepads[ i ];

  				if ( gamepad && ( gamepad.id === 'Daydream Controller' ||
  					gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
  					gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
  					gamepad.id.startsWith( 'Spatial Controller' ) ) ) {

  					if ( j === id ) return gamepad;

  					j ++;

  				}

  			}

  		}

  		function updateControllers() {

  			for ( var i = 0; i < controllers.length; i ++ ) {

  				var controller = controllers[ i ];

  				var gamepad = findGamepad( i );

  				if ( gamepad !== undefined && gamepad.pose !== undefined ) {

  					if ( gamepad.pose === null ) return;

  					// Pose

  					var pose = gamepad.pose;

  					if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );

  					if ( pose.position !== null ) controller.position.fromArray( pose.position );
  					if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );
  					controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
  					controller.matrix.premultiply( standingMatrix );
  					controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
  					controller.matrixWorldNeedsUpdate = true;
  					controller.visible = true;

  					// Trigger

  					var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

  					if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {

  						triggers[ i ] = gamepad.buttons[ buttonId ].pressed;

  						if ( triggers[ i ] === true ) {

  							controller.dispatchEvent( { type: 'selectstart' } );

  						} else {

  							controller.dispatchEvent( { type: 'selectend' } );
  							controller.dispatchEvent( { type: 'select' } );

  						}

  					}

  				} else {

  					controller.visible = false;

  				}

  			}

  		}

  		//

  		this.enabled = false;

  		this.getController = function ( id ) {

  			var controller = controllers[ id ];

  			if ( controller === undefined ) {

  				controller = new Group();
  				controller.matrixAutoUpdate = false;
  				controller.visible = false;

  				controllers[ id ] = controller;

  			}

  			return controller;

  		};

  		this.getDevice = function () {

  			return device;

  		};

  		this.setDevice = function ( value ) {

  			if ( value !== undefined ) device = value;

  			animation.setContext( value );

  		};

  		this.setFramebufferScaleFactor = function ( value ) {

  			framebufferScaleFactor = value;

  		};

  		this.setFrameOfReferenceType = function ( value ) {

  			frameOfReferenceType = value;

  		};

  		this.setPoseTarget = function ( object ) {

  			if ( object !== undefined ) poseTarget = object;

  		};

  		this.getCamera = function ( camera ) {

  			var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;

  			if ( isPresenting() === false ) {

  				camera.position.set( 0, userHeight, 0 );
  				camera.rotation.set( 0, 0, 0 );

  				return camera;

  			}

  			device.depthNear = camera.near;
  			device.depthFar = camera.far;

  			device.getFrameData( frameData );

  			//

  			if ( frameOfReferenceType === 'stage' ) {

  				var stageParameters = device.stageParameters;

  				if ( stageParameters ) {

  					standingMatrix.fromArray( stageParameters.sittingToStandingTransform );

  				} else {

  					standingMatrix.makeTranslation( 0, userHeight, 0 );

  				}

  			}


  			var pose = frameData.pose;
  			var poseObject = poseTarget !== null ? poseTarget : camera;

  			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
  			poseObject.matrix.copy( standingMatrix );
  			poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );

  			if ( pose.orientation !== null ) {

  				tempQuaternion.fromArray( pose.orientation );
  				poseObject.quaternion.multiply( tempQuaternion );

  			}

  			if ( pose.position !== null ) {

  				tempQuaternion.setFromRotationMatrix( standingMatrix );
  				tempPosition.fromArray( pose.position );
  				tempPosition.applyQuaternion( tempQuaternion );
  				poseObject.position.add( tempPosition );

  			}

  			poseObject.updateMatrixWorld();

  			//

  			cameraL.near = camera.near;
  			cameraR.near = camera.near;

  			cameraL.far = camera.far;
  			cameraR.far = camera.far;

  			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
  			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

  			// TODO (mrdoob) Double check this code

  			standingMatrixInverse.getInverse( standingMatrix );

  			if ( frameOfReferenceType === 'stage' ) {

  				cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
  				cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

  			}

  			var parent = poseObject.parent;

  			if ( parent !== null ) {

  				matrixWorldInverse.getInverse( parent.matrixWorld );

  				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
  				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

  			}

  			// envMap and Mirror needs camera.matrixWorld

  			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
  			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

  			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
  			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

  			setProjectionFromUnion( cameraVR, cameraL, cameraR );

  			//

  			var layers = device.getLayers();

  			if ( layers.length ) {

  				var layer = layers[ 0 ];

  				if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

  					cameraL.bounds.fromArray( layer.leftBounds );

  				}

  				if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

  					cameraR.bounds.fromArray( layer.rightBounds );

  				}

  			}

  			updateControllers();

  			return cameraVR;

  		};

  		this.getStandingMatrix = function () {

  			return standingMatrix;

  		};

  		this.isPresenting = isPresenting;

  		// Animation Loop

  		var animation = new WebGLAnimation();

  		this.setAnimationLoop = function ( callback ) {

  			animation.setAnimationLoop( callback );

  			if ( isPresenting() ) animation.start();

  		};

  		this.submitFrame = function () {

  			if ( isPresenting() ) device.submitFrame();

  		};

  		this.dispose = function () {

  			if ( typeof window !== 'undefined' ) {

  				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

  			}

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function WebXRManager( renderer ) {

  		var gl = renderer.context;

  		var device = null;
  		var session = null;

  		var framebufferScaleFactor = 1.0;

  		var frameOfReference = null;
  		var frameOfReferenceType = 'stage';

  		var pose = null;

  		var controllers = [];
  		var inputSources = [];

  		function isPresenting() {

  			return session !== null && frameOfReference !== null;

  		}

  		//

  		var cameraL = new PerspectiveCamera();
  		cameraL.layers.enable( 1 );
  		cameraL.viewport = new Vector4();

  		var cameraR = new PerspectiveCamera();
  		cameraR.layers.enable( 2 );
  		cameraR.viewport = new Vector4();

  		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
  		cameraVR.layers.enable( 1 );
  		cameraVR.layers.enable( 2 );

  		//

  		this.enabled = false;

  		this.getController = function ( id ) {

  			var controller = controllers[ id ];

  			if ( controller === undefined ) {

  				controller = new Group();
  				controller.matrixAutoUpdate = false;
  				controller.visible = false;

  				controllers[ id ] = controller;

  			}

  			return controller;

  		};

  		this.getDevice = function () {

  			return device;

  		};

  		this.setDevice = function ( value ) {

  			if ( value !== undefined ) device = value;
  			if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value );

  		};

  		//

  		function onSessionEvent( event ) {

  			var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
  			if ( controller ) controller.dispatchEvent( { type: event.type } );

  		}

  		function onSessionEnd() {

  			renderer.setFramebuffer( null );
  			renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
  			animation.stop();

  		}

  		this.setFramebufferScaleFactor = function ( value ) {

  			framebufferScaleFactor = value;

  		};

  		this.setFrameOfReferenceType = function ( value ) {

  			frameOfReferenceType = value;

  		};

  		this.setSession = function ( value ) {

  			session = value;

  			if ( session !== null ) {

  				session.addEventListener( 'select', onSessionEvent );
  				session.addEventListener( 'selectstart', onSessionEvent );
  				session.addEventListener( 'selectend', onSessionEvent );
  				session.addEventListener( 'end', onSessionEnd );

  				session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } );
  				session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {

  					frameOfReference = value;

  					renderer.setFramebuffer( session.baseLayer.framebuffer );

  					animation.setContext( session );
  					animation.start();

  				} );

  				//

  				inputSources = session.getInputSources();

  				session.addEventListener( 'inputsourceschange', function () {

  					inputSources = session.getInputSources();
  					console.log( inputSources );

  					for ( var i = 0; i < controllers.length; i ++ ) {

  						var controller = controllers[ i ];
  						controller.userData.inputSource = inputSources[ i ];

  					}

  				} );

  			}

  		};

  		function updateCamera( camera, parent ) {

  			if ( parent === null ) {

  				camera.matrixWorld.copy( camera.matrix );

  			} else {

  				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

  			}

  			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

  		}

  		this.getCamera = function ( camera ) {

  			if ( isPresenting() ) {

  				var parent = camera.parent;
  				var cameras = cameraVR.cameras;

  				updateCamera( cameraVR, parent );

  				for ( var i = 0; i < cameras.length; i ++ ) {

  					updateCamera( cameras[ i ], parent );

  				}

  				// update camera and its children

  				camera.matrixWorld.copy( cameraVR.matrixWorld );

  				var children = camera.children;

  				for ( var i = 0, l = children.length; i < l; i ++ ) {

  					children[ i ].updateMatrixWorld( true );

  				}

  				setProjectionFromUnion( cameraVR, cameraL, cameraR );

  				return cameraVR;

  			}

  			return camera;

  		};

  		this.isPresenting = isPresenting;

  		// Animation Loop

  		var onAnimationFrameCallback = null;

  		function onAnimationFrame( time, frame ) {

  			pose = frame.getDevicePose( frameOfReference );

  			if ( pose !== null ) {

  				var layer = session.baseLayer;
  				var views = frame.views;

  				for ( var i = 0; i < views.length; i ++ ) {

  					var view = views[ i ];
  					var viewport = layer.getViewport( view );
  					var viewMatrix = pose.getViewMatrix( view );

  					var camera = cameraVR.cameras[ i ];
  					camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
  					camera.projectionMatrix.fromArray( view.projectionMatrix );
  					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

  					if ( i === 0 ) {

  						cameraVR.matrix.copy( camera.matrix );

  					}

  				}

  			}

  			//

  			for ( var i = 0; i < controllers.length; i ++ ) {

  				var controller = controllers[ i ];

  				var inputSource = inputSources[ i ];

  				if ( inputSource ) {

  					var inputPose = frame.getInputPose( inputSource, frameOfReference );

  					if ( inputPose !== null ) {

  						if ( 'targetRay' in inputPose ) {

  							controller.matrix.elements = inputPose.targetRay.transformMatrix;

  						} else if ( 'pointerMatrix' in inputPose ) {

  							// DEPRECATED

  							controller.matrix.elements = inputPose.pointerMatrix;

  						}

  						controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
  						controller.visible = true;

  						continue;

  					}

  				}

  				controller.visible = false;

  			}

  			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

  		}

  		var animation = new WebGLAnimation();
  		animation.setAnimationLoop( onAnimationFrame );

  		this.setAnimationLoop = function ( callback ) {

  			onAnimationFrameCallback = callback;

  		};

  		this.dispose = function () {};

  		// DEPRECATED

  		this.getStandingMatrix = function () {

  			console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );
  			return new Matrix4();

  		};

  		this.submitFrame = function () {};

  	}

  	/**
  	 * @author supereggbert / http://www.paulbrunt.co.uk/
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author szimek / https://github.com/szimek/
  	 * @author tschw
  	 */

  	function WebGLRenderer( parameters ) {

  		console.log( 'THREE.WebGLRenderer', REVISION );

  		parameters = parameters || {};

  		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
  			_context = parameters.context !== undefined ? parameters.context : null,

  			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  			_depth = parameters.depth !== undefined ? parameters.depth : true,
  			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
  			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

  		var currentRenderList = null;
  		var currentRenderState = null;

  		// public properties

  		this.domElement = _canvas;
  		this.context = null;

  		// Debug configuration container
  		this.debug = {

  			/**
  			 * Enables error checking and reporting when shader programs are being compiled
  			 * @type {boolean}
  			 */
  			checkShaderErrors: false
  		};

  		// clearing

  		this.autoClear = true;
  		this.autoClearColor = true;
  		this.autoClearDepth = true;
  		this.autoClearStencil = true;

  		// scene graph

  		this.sortObjects = true;

  		// user-defined clipping

  		this.clippingPlanes = [];
  		this.localClippingEnabled = false;

  		// physically based shading

  		this.gammaFactor = 2.0;	// for backwards compatibility
  		this.gammaInput = false;
  		this.gammaOutput = false;

  		// physical lights

  		this.physicallyCorrectLights = false;

  		// tone mapping

  		this.toneMapping = LinearToneMapping;
  		this.toneMappingExposure = 1.0;
  		this.toneMappingWhitePoint = 1.0;

  		// morphs

  		this.maxMorphTargets = 8;
  		this.maxMorphNormals = 4;

  		// internal properties

  		var _this = this,

  			_isContextLost = false,

  			// internal state cache

  			_framebuffer = null,

  			_currentRenderTarget = null,
  			_currentFramebuffer = null,
  			_currentMaterialId = - 1,

  			// geometry and program caching

  			_currentGeometryProgram = {
  				geometry: null,
  				program: null,
  				wireframe: false
  			},

  			_currentCamera = null,
  			_currentArrayCamera = null,

  			_currentViewport = new Vector4(),
  			_currentScissor = new Vector4(),
  			_currentScissorTest = null,

  			//

  			_width = _canvas.width,
  			_height = _canvas.height,

  			_pixelRatio = 1,

  			_viewport = new Vector4( 0, 0, _width, _height ),
  			_scissor = new Vector4( 0, 0, _width, _height ),
  			_scissorTest = false,

  			// frustum

  			_frustum = new Frustum(),

  			// clipping

  			_clipping = new WebGLClipping(),
  			_clippingEnabled = false,
  			_localClippingEnabled = false,

  			// camera matrices cache

  			_projScreenMatrix = new Matrix4(),

  			_vector3 = new Vector3();

  		function getTargetPixelRatio() {

  			return _currentRenderTarget === null ? _pixelRatio : 1;

  		}

  		// initialize

  		var _gl;

  		try {

  			var contextAttributes = {
  				alpha: _alpha,
  				depth: _depth,
  				stencil: _stencil,
  				antialias: _antialias,
  				premultipliedAlpha: _premultipliedAlpha,
  				preserveDrawingBuffer: _preserveDrawingBuffer,
  				powerPreference: _powerPreference
  			};

  			// event listeners must be registered before WebGL context is created, see #12753

  			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
  			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

  			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

  			if ( _gl === null ) {

  				if ( _canvas.getContext( 'webgl' ) !== null ) {

  					throw new Error( 'Error creating WebGL context with your selected attributes.' );

  				} else {

  					throw new Error( 'Error creating WebGL context.' );

  				}

  			}

  			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

  			if ( _gl.getShaderPrecisionFormat === undefined ) {

  				_gl.getShaderPrecisionFormat = function () {

  					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

  				};

  			}

  		} catch ( error ) {

  			console.error( 'THREE.WebGLRenderer: ' + error.message );
  			throw error;

  		}

  		var extensions, capabilities, state, info;
  		var properties, textures, attributes, geometries, objects;
  		var programCache, renderLists, renderStates;

  		var background, morphtargets, bufferRenderer, indexedBufferRenderer;

  		var utils;

  		function initGLContext() {

  			extensions = new WebGLExtensions( _gl );

  			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

  			if ( ! capabilities.isWebGL2 ) {

  				extensions.get( 'WEBGL_depth_texture' );
  				extensions.get( 'OES_texture_float' );
  				extensions.get( 'OES_texture_half_float' );
  				extensions.get( 'OES_texture_half_float_linear' );
  				extensions.get( 'OES_standard_derivatives' );
  				extensions.get( 'OES_element_index_uint' );
  				extensions.get( 'ANGLE_instanced_arrays' );

  			}

  			extensions.get( 'OES_texture_float_linear' );

  			utils = new WebGLUtils( _gl, extensions, capabilities );

  			state = new WebGLState( _gl, extensions, utils, capabilities );
  			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
  			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

  			info = new WebGLInfo( _gl );
  			properties = new WebGLProperties();
  			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
  			attributes = new WebGLAttributes( _gl );
  			geometries = new WebGLGeometries( _gl, attributes, info );
  			objects = new WebGLObjects( geometries, info );
  			morphtargets = new WebGLMorphtargets( _gl );
  			programCache = new WebGLPrograms( _this, extensions, capabilities, textures );
  			renderLists = new WebGLRenderLists();
  			renderStates = new WebGLRenderStates();

  			background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

  			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
  			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

  			info.programs = programCache.programs;

  			_this.context = _gl;
  			_this.capabilities = capabilities;
  			_this.extensions = extensions;
  			_this.properties = properties;
  			_this.renderLists = renderLists;
  			_this.state = state;
  			_this.info = info;

  		}

  		initGLContext();

  		// vr

  		var vr = ( typeof navigator !== 'undefined' && 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );

  		this.vr = vr;

  		// shadow map

  		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

  		this.shadowMap = shadowMap;

  		// API

  		this.getContext = function () {

  			return _gl;

  		};

  		this.getContextAttributes = function () {

  			return _gl.getContextAttributes();

  		};

  		this.forceContextLoss = function () {

  			var extension = extensions.get( 'WEBGL_lose_context' );
  			if ( extension ) extension.loseContext();

  		};

  		this.forceContextRestore = function () {

  			var extension = extensions.get( 'WEBGL_lose_context' );
  			if ( extension ) extension.restoreContext();

  		};

  		this.getPixelRatio = function () {

  			return _pixelRatio;

  		};

  		this.setPixelRatio = function ( value ) {

  			if ( value === undefined ) return;

  			_pixelRatio = value;

  			this.setSize( _width, _height, false );

  		};

  		this.getSize = function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

  				target = new Vector2();

  			}

  			return target.set( _width, _height );

  		};

  		this.setSize = function ( width, height, updateStyle ) {

  			if ( vr.isPresenting() ) {

  				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
  				return;

  			}

  			_width = width;
  			_height = height;

  			_canvas.width = width * _pixelRatio;
  			_canvas.height = height * _pixelRatio;

  			if ( updateStyle !== false ) {

  				_canvas.style.width = width + 'px';
  				_canvas.style.height = height + 'px';

  			}

  			this.setViewport( 0, 0, width, height );

  		};

  		this.getDrawingBufferSize = function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

  				target = new Vector2();

  			}

  			return target.set( _width * _pixelRatio, _height * _pixelRatio );

  		};

  		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

  			_width = width;
  			_height = height;

  			_pixelRatio = pixelRatio;

  			_canvas.width = width * pixelRatio;
  			_canvas.height = height * pixelRatio;

  			this.setViewport( 0, 0, width, height );

  		};

  		this.getCurrentViewport = function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

  				target = new Vector4();

  			}

  			return target.copy( _currentViewport );

  		};

  		this.getViewport = function ( target ) {

  			return target.copy( _viewport );

  		};

  		this.setViewport = function ( x, y, width, height ) {

  			if ( x.isVector4 ) {

  				_viewport.set( x.x, x.y, x.z, x.w );

  			} else {

  				_viewport.set( x, y, width, height );

  			}

  			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

  		};

  		this.getScissor = function ( target ) {

  			return target.copy( _scissor );

  		};

  		this.setScissor = function ( x, y, width, height ) {

  			if ( x.isVector4 ) {

  				_scissor.set( x.x, x.y, x.z, x.w );

  			} else {

  				_scissor.set( x, y, width, height );

  			}

  			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

  		};

  		this.getScissorTest = function () {

  			return _scissorTest;

  		};

  		this.setScissorTest = function ( boolean ) {

  			state.setScissorTest( _scissorTest = boolean );

  		};

  		// Clearing

  		this.getClearColor = function () {

  			return background.getClearColor();

  		};

  		this.setClearColor = function () {

  			background.setClearColor.apply( background, arguments );

  		};

  		this.getClearAlpha = function () {

  			return background.getClearAlpha();

  		};

  		this.setClearAlpha = function () {

  			background.setClearAlpha.apply( background, arguments );

  		};

  		this.clear = function ( color, depth, stencil ) {

  			var bits = 0;

  			if ( color === undefined || color ) bits |= 16384;
  			if ( depth === undefined || depth ) bits |= 256;
  			if ( stencil === undefined || stencil ) bits |= 1024;

  			_gl.clear( bits );

  		};

  		this.clearColor = function () {

  			this.clear( true, false, false );

  		};

  		this.clearDepth = function () {

  			this.clear( false, true, false );

  		};

  		this.clearStencil = function () {

  			this.clear( false, false, true );

  		};

  		//

  		this.dispose = function () {

  			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
  			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

  			renderLists.dispose();
  			renderStates.dispose();
  			properties.dispose();
  			objects.dispose();

  			vr.dispose();

  			animation.stop();

  		};

  		// Events

  		function onContextLost( event ) {

  			event.preventDefault();

  			console.log( 'THREE.WebGLRenderer: Context Lost.' );

  			_isContextLost = true;

  		}

  		function onContextRestore( /* event */ ) {

  			console.log( 'THREE.WebGLRenderer: Context Restored.' );

  			_isContextLost = false;

  			initGLContext();

  		}

  		function onMaterialDispose( event ) {

  			var material = event.target;

  			material.removeEventListener( 'dispose', onMaterialDispose );

  			deallocateMaterial( material );

  		}

  		// Buffer deallocation

  		function deallocateMaterial( material ) {

  			releaseMaterialProgramReference( material );

  			properties.remove( material );

  		}


  		function releaseMaterialProgramReference( material ) {

  			var programInfo = properties.get( material ).program;

  			material.program = undefined;

  			if ( programInfo !== undefined ) {

  				programCache.releaseProgram( programInfo );

  			}

  		}

  		// Buffer rendering

  		function renderObjectImmediate( object, program ) {

  			object.render( function ( object ) {

  				_this.renderBufferImmediate( object, program );

  			} );

  		}

  		this.renderBufferImmediate = function ( object, program ) {

  			state.initAttributes();

  			var buffers = properties.get( object );

  			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
  			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
  			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
  			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

  			var programAttributes = program.getAttributes();

  			if ( object.hasPositions ) {

  				_gl.bindBuffer( 34962, buffers.position );
  				_gl.bufferData( 34962, object.positionArray, 35048 );

  				state.enableAttribute( programAttributes.position );
  				_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

  			}

  			if ( object.hasNormals ) {

  				_gl.bindBuffer( 34962, buffers.normal );
  				_gl.bufferData( 34962, object.normalArray, 35048 );

  				state.enableAttribute( programAttributes.normal );
  				_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

  			}

  			if ( object.hasUvs ) {

  				_gl.bindBuffer( 34962, buffers.uv );
  				_gl.bufferData( 34962, object.uvArray, 35048 );

  				state.enableAttribute( programAttributes.uv );
  				_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

  			}

  			if ( object.hasColors ) {

  				_gl.bindBuffer( 34962, buffers.color );
  				_gl.bufferData( 34962, object.colorArray, 35048 );

  				state.enableAttribute( programAttributes.color );
  				_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

  			}

  			state.disableUnusedAttributes();

  			_gl.drawArrays( 4, 0, object.count );

  			object.count = 0;

  		};

  		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

  			var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

  			state.setMaterial( material, frontFaceCW );

  			var program = setProgram( camera, fog, material, object );

  			var updateBuffers = false;

  			if ( _currentGeometryProgram.geometry !== geometry.id ||
  				_currentGeometryProgram.program !== program.id ||
  				_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

  				_currentGeometryProgram.geometry = geometry.id;
  				_currentGeometryProgram.program = program.id;
  				_currentGeometryProgram.wireframe = material.wireframe === true;
  				updateBuffers = true;

  			}

  			if ( object.morphTargetInfluences ) {

  				morphtargets.update( object, geometry, material, program );

  				updateBuffers = true;

  			}

  			//

  			var index = geometry.index;
  			var position = geometry.attributes.position;
  			var rangeFactor = 1;

  			if ( material.wireframe === true ) {

  				index = geometries.getWireframeAttribute( geometry );
  				rangeFactor = 2;

  			}

  			var attribute;
  			var renderer = bufferRenderer;

  			if ( index !== null ) {

  				attribute = attributes.get( index );

  				renderer = indexedBufferRenderer;
  				renderer.setIndex( attribute );

  			}

  			if ( updateBuffers ) {

  				setupVertexAttributes( material, program, geometry );

  				if ( index !== null ) {

  					_gl.bindBuffer( 34963, attribute.buffer );

  				}

  			}

  			//

  			var dataCount = Infinity;

  			if ( index !== null ) {

  				dataCount = index.count;

  			} else if ( position !== undefined ) {

  				dataCount = position.count;

  			}

  			var rangeStart = geometry.drawRange.start * rangeFactor;
  			var rangeCount = geometry.drawRange.count * rangeFactor;

  			var groupStart = group !== null ? group.start * rangeFactor : 0;
  			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

  			var drawStart = Math.max( rangeStart, groupStart );
  			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

  			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

  			if ( drawCount === 0 ) return;

  			//

  			if ( object.isMesh ) {

  				if ( material.wireframe === true ) {

  					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
  					renderer.setMode( 1 );

  				} else {

  					switch ( object.drawMode ) {

  						case TrianglesDrawMode:
  							renderer.setMode( 4 );
  							break;

  						case TriangleStripDrawMode:
  							renderer.setMode( 5 );
  							break;

  						case TriangleFanDrawMode:
  							renderer.setMode( 6 );
  							break;

  					}

  				}


  			} else if ( object.isLine ) {

  				var lineWidth = material.linewidth;

  				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

  				state.setLineWidth( lineWidth * getTargetPixelRatio() );

  				if ( object.isLineSegments ) {

  					renderer.setMode( 1 );

  				} else if ( object.isLineLoop ) {

  					renderer.setMode( 2 );

  				} else {

  					renderer.setMode( 3 );

  				}

  			} else if ( object.isPoints ) {

  				renderer.setMode( 0 );

  			} else if ( object.isSprite ) {

  				renderer.setMode( 4 );

  			}

  			if ( geometry && geometry.isInstancedBufferGeometry ) {

  				if ( geometry.maxInstancedCount > 0 ) {

  					renderer.renderInstances( geometry, drawStart, drawCount );

  				}

  			} else {

  				renderer.render( drawStart, drawCount );

  			}

  		};

  		function setupVertexAttributes( material, program, geometry ) {

  			if ( geometry && geometry.isInstancedBufferGeometry && ! capabilities.isWebGL2 ) {

  				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

  					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  					return;

  				}

  			}

  			state.initAttributes();

  			var geometryAttributes = geometry.attributes;

  			var programAttributes = program.getAttributes();

  			var materialDefaultAttributeValues = material.defaultAttributeValues;

  			for ( var name in programAttributes ) {

  				var programAttribute = programAttributes[ name ];

  				if ( programAttribute >= 0 ) {

  					var geometryAttribute = geometryAttributes[ name ];

  					if ( geometryAttribute !== undefined ) {

  						var normalized = geometryAttribute.normalized;
  						var size = geometryAttribute.itemSize;

  						var attribute = attributes.get( geometryAttribute );

  						// TODO Attribute may not be available on context restore

  						if ( attribute === undefined ) continue;

  						var buffer = attribute.buffer;
  						var type = attribute.type;
  						var bytesPerElement = attribute.bytesPerElement;

  						if ( geometryAttribute.isInterleavedBufferAttribute ) {

  							var data = geometryAttribute.data;
  							var stride = data.stride;
  							var offset = geometryAttribute.offset;

  							if ( data && data.isInstancedInterleavedBuffer ) {

  								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

  								if ( geometry.maxInstancedCount === undefined ) {

  									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

  								}

  							} else {

  								state.enableAttribute( programAttribute );

  							}

  							_gl.bindBuffer( 34962, buffer );
  							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

  						} else {

  							if ( geometryAttribute.isInstancedBufferAttribute ) {

  								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

  								if ( geometry.maxInstancedCount === undefined ) {

  									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

  								}

  							} else {

  								state.enableAttribute( programAttribute );

  							}

  							_gl.bindBuffer( 34962, buffer );
  							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

  						}

  					} else if ( materialDefaultAttributeValues !== undefined ) {

  						var value = materialDefaultAttributeValues[ name ];

  						if ( value !== undefined ) {

  							switch ( value.length ) {

  								case 2:
  									_gl.vertexAttrib2fv( programAttribute, value );
  									break;

  								case 3:
  									_gl.vertexAttrib3fv( programAttribute, value );
  									break;

  								case 4:
  									_gl.vertexAttrib4fv( programAttribute, value );
  									break;

  								default:
  									_gl.vertexAttrib1fv( programAttribute, value );

  							}

  						}

  					}

  				}

  			}

  			state.disableUnusedAttributes();

  		}

  		// Compile

  		this.compile = function ( scene, camera ) {

  			currentRenderState = renderStates.get( scene, camera );
  			currentRenderState.init();

  			scene.traverse( function ( object ) {

  				if ( object.isLight ) {

  					currentRenderState.pushLight( object );

  					if ( object.castShadow ) {

  						currentRenderState.pushShadow( object );

  					}

  				}

  			} );

  			currentRenderState.setupLights( camera );

  			scene.traverse( function ( object ) {

  				if ( object.material ) {

  					if ( Array.isArray( object.material ) ) {

  						for ( var i = 0; i < object.material.length; i ++ ) {

  							initMaterial( object.material[ i ], scene.fog, object );

  						}

  					} else {

  						initMaterial( object.material, scene.fog, object );

  					}

  				}

  			} );

  		};

  		// Animation Loop

  		var onAnimationFrameCallback = null;

  		function onAnimationFrame( time ) {

  			if ( vr.isPresenting() ) return;
  			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

  		}

  		var animation = new WebGLAnimation();
  		animation.setAnimationLoop( onAnimationFrame );

  		if ( typeof window !== 'undefined' ) animation.setContext( window );

  		this.setAnimationLoop = function ( callback ) {

  			onAnimationFrameCallback = callback;
  			vr.setAnimationLoop( callback );

  			animation.start();

  		};

  		// Rendering

  		this.render = function ( scene, camera ) {

  			var renderTarget, forceClear;

  			if ( arguments[ 2 ] !== undefined ) {

  				console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
  				renderTarget = arguments[ 2 ];

  			}

  			if ( arguments[ 3 ] !== undefined ) {

  				console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
  				forceClear = arguments[ 3 ];

  			}

  			if ( ! ( camera && camera.isCamera ) ) {

  				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
  				return;

  			}

  			if ( _isContextLost ) return;

  			// reset caching for this frame

  			_currentGeometryProgram.geometry = null;
  			_currentGeometryProgram.program = null;
  			_currentGeometryProgram.wireframe = false;
  			_currentMaterialId = - 1;
  			_currentCamera = null;

  			// update scene graph

  			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

  			// update camera matrices and frustum

  			if ( camera.parent === null ) camera.updateMatrixWorld();

  			if ( vr.enabled ) {

  				camera = vr.getCamera( camera );

  			}

  			//

  			currentRenderState = renderStates.get( scene, camera );
  			currentRenderState.init();

  			scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

  			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  			_frustum.setFromMatrix( _projScreenMatrix );

  			_localClippingEnabled = this.localClippingEnabled;
  			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

  			currentRenderList = renderLists.get( scene, camera );
  			currentRenderList.init();

  			projectObject( scene, camera, 0, _this.sortObjects );

  			if ( _this.sortObjects === true ) {

  				currentRenderList.sort();

  			}

  			//

  			if ( _clippingEnabled ) _clipping.beginShadows();

  			var shadowsArray = currentRenderState.state.shadowsArray;

  			shadowMap.render( shadowsArray, scene, camera );

  			currentRenderState.setupLights( camera );

  			if ( _clippingEnabled ) _clipping.endShadows();

  			//

  			if ( this.info.autoReset ) this.info.reset();

  			if ( renderTarget !== undefined ) {

  				this.setRenderTarget( renderTarget );

  			}

  			//

  			background.render( currentRenderList, scene, camera, forceClear );

  			// render scene

  			var opaqueObjects = currentRenderList.opaque;
  			var transparentObjects = currentRenderList.transparent;

  			if ( scene.overrideMaterial ) {

  				var overrideMaterial = scene.overrideMaterial;

  				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
  				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

  			} else {

  				// opaque pass (front-to-back order)

  				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

  				// transparent pass (back-to-front order)

  				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

  			}

  			//

  			scene.onAfterRender( _this, scene, camera );

  			//

  			if ( _currentRenderTarget !== null ) {

  				// Generate mipmap if we're using any kind of mipmap filtering

  				textures.updateRenderTargetMipmap( _currentRenderTarget );

  				// resolve multisample renderbuffers to a single-sample texture if necessary

  				textures.updateMultisampleRenderTarget( _currentRenderTarget );

  			}

  			// Ensure depth buffer writing is enabled so it can be cleared on next render

  			state.buffers.depth.setTest( true );
  			state.buffers.depth.setMask( true );
  			state.buffers.color.setMask( true );

  			state.setPolygonOffset( false );

  			if ( vr.enabled ) {

  				vr.submitFrame();

  			}

  			// _gl.finish();

  			currentRenderList = null;
  			currentRenderState = null;

  		};

  		function projectObject( object, camera, groupOrder, sortObjects ) {

  			if ( object.visible === false ) return;

  			var visible = object.layers.test( camera.layers );

  			if ( visible ) {

  				if ( object.isGroup ) {

  					groupOrder = object.renderOrder;

  				} else if ( object.isLight ) {

  					currentRenderState.pushLight( object );

  					if ( object.castShadow ) {

  						currentRenderState.pushShadow( object );

  					}

  				} else if ( object.isSprite ) {

  					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

  						if ( sortObjects ) {

  							_vector3.setFromMatrixPosition( object.matrixWorld )
  								.applyMatrix4( _projScreenMatrix );

  						}

  						var geometry = objects.update( object );
  						var material = object.material;

  						if ( material.visible ) {

  							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

  						}

  					}

  				} else if ( object.isImmediateRenderObject ) {

  					if ( sortObjects ) {

  						_vector3.setFromMatrixPosition( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

  				} else if ( object.isMesh || object.isLine || object.isPoints ) {

  					if ( object.isSkinnedMesh ) {

  						object.skeleton.update();

  					}

  					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

  						if ( sortObjects ) {

  							_vector3.setFromMatrixPosition( object.matrixWorld )
  								.applyMatrix4( _projScreenMatrix );

  						}

  						var geometry = objects.update( object );
  						var material = object.material;

  						if ( Array.isArray( material ) ) {

  							var groups = geometry.groups;

  							for ( var i = 0, l = groups.length; i < l; i ++ ) {

  								var group = groups[ i ];
  								var groupMaterial = material[ group.materialIndex ];

  								if ( groupMaterial && groupMaterial.visible ) {

  									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

  								}

  							}

  						} else if ( material.visible ) {

  							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

  						}

  					}

  				}

  			}

  			var children = object.children;

  			for ( var i = 0, l = children.length; i < l; i ++ ) {

  				projectObject( children[ i ], camera, groupOrder, sortObjects );

  			}

  		}

  		function renderObjects( renderList, scene, camera, overrideMaterial ) {

  			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

  				var renderItem = renderList[ i ];

  				var object = renderItem.object;
  				var geometry = renderItem.geometry;
  				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
  				var group = renderItem.group;

  				if ( camera.isArrayCamera ) {

  					_currentArrayCamera = camera;

  					var cameras = camera.cameras;

  					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

  						var camera2 = cameras[ j ];

  						if ( object.layers.test( camera2.layers ) ) {

  							if ( 'viewport' in camera2 ) { // XR

  								state.viewport( _currentViewport.copy( camera2.viewport ) );

  							} else {

  								var bounds = camera2.bounds;

  								var x = bounds.x * _width;
  								var y = bounds.y * _height;
  								var width = bounds.z * _width;
  								var height = bounds.w * _height;

  								state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

  							}

  							currentRenderState.setupLights( camera2 );

  							renderObject( object, scene, camera2, geometry, material, group );

  						}

  					}

  				} else {

  					_currentArrayCamera = null;

  					renderObject( object, scene, camera, geometry, material, group );

  				}

  			}

  		}

  		function renderObject( object, scene, camera, geometry, material, group ) {

  			object.onBeforeRender( _this, scene, camera, geometry, material, group );
  			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

  			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
  			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

  			if ( object.isImmediateRenderObject ) {

  				state.setMaterial( material );

  				var program = setProgram( camera, scene.fog, material, object );

  				_currentGeometryProgram.geometry = null;
  				_currentGeometryProgram.program = null;
  				_currentGeometryProgram.wireframe = false;

  				renderObjectImmediate( object, program );

  			} else {

  				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

  			}

  			object.onAfterRender( _this, scene, camera, geometry, material, group );
  			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

  		}

  		function initMaterial( material, fog, object ) {

  			var materialProperties = properties.get( material );

  			var lights = currentRenderState.state.lights;
  			var shadowsArray = currentRenderState.state.shadowsArray;

  			var lightsHash = materialProperties.lightsHash;
  			var lightsStateHash = lights.state.hash;

  			var parameters = programCache.getParameters(
  				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

  			var code = programCache.getProgramCode( material, parameters );

  			var program = materialProperties.program;
  			var programChange = true;

  			if ( program === undefined ) {

  				// new material
  				material.addEventListener( 'dispose', onMaterialDispose );

  			} else if ( program.code !== code ) {

  				// changed glsl or parameters
  				releaseMaterialProgramReference( material );

  			} else if ( lightsHash.stateID !== lightsStateHash.stateID ||
  				lightsHash.directionalLength !== lightsStateHash.directionalLength ||
  				lightsHash.pointLength !== lightsStateHash.pointLength ||
  				lightsHash.spotLength !== lightsStateHash.spotLength ||
  				lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
  				lightsHash.hemiLength !== lightsStateHash.hemiLength ||
  				lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {

  				lightsHash.stateID = lightsStateHash.stateID;
  				lightsHash.directionalLength = lightsStateHash.directionalLength;
  				lightsHash.pointLength = lightsStateHash.pointLength;
  				lightsHash.spotLength = lightsStateHash.spotLength;
  				lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
  				lightsHash.hemiLength = lightsStateHash.hemiLength;
  				lightsHash.shadowsLength = lightsStateHash.shadowsLength;

  				programChange = false;

  			} else if ( parameters.shaderID !== undefined ) {

  				// same glsl and uniform list
  				return;

  			} else {

  				// only rebuild uniform list
  				programChange = false;

  			}

  			if ( programChange ) {

  				if ( parameters.shaderID ) {

  					var shader = ShaderLib[ parameters.shaderID ];

  					materialProperties.shader = {
  						name: material.type,
  						uniforms: cloneUniforms( shader.uniforms ),
  						vertexShader: shader.vertexShader,
  						fragmentShader: shader.fragmentShader
  					};

  				} else {

  					materialProperties.shader = {
  						name: material.type,
  						uniforms: material.uniforms,
  						vertexShader: material.vertexShader,
  						fragmentShader: material.fragmentShader
  					};

  				}

  				material.onBeforeCompile( materialProperties.shader, _this );

  				// Computing code again as onBeforeCompile may have changed the shaders
  				code = programCache.getProgramCode( material, parameters );

  				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

  				materialProperties.program = program;
  				material.program = program;

  			}

  			var programAttributes = program.getAttributes();

  			if ( material.morphTargets ) {

  				material.numSupportedMorphTargets = 0;

  				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

  					if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

  						material.numSupportedMorphTargets ++;

  					}

  				}

  			}

  			if ( material.morphNormals ) {

  				material.numSupportedMorphNormals = 0;

  				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

  					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

  						material.numSupportedMorphNormals ++;

  					}

  				}

  			}

  			var uniforms = materialProperties.shader.uniforms;

  			if ( ! material.isShaderMaterial &&
  				! material.isRawShaderMaterial ||
  				material.clipping === true ) {

  				materialProperties.numClippingPlanes = _clipping.numPlanes;
  				materialProperties.numIntersection = _clipping.numIntersection;
  				uniforms.clippingPlanes = _clipping.uniform;

  			}

  			materialProperties.fog = fog;

  			// store the light setup it was created for
  			if ( lightsHash === undefined ) {

  				materialProperties.lightsHash = lightsHash = {};

  			}

  			lightsHash.stateID = lightsStateHash.stateID;
  			lightsHash.directionalLength = lightsStateHash.directionalLength;
  			lightsHash.pointLength = lightsStateHash.pointLength;
  			lightsHash.spotLength = lightsStateHash.spotLength;
  			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
  			lightsHash.hemiLength = lightsStateHash.hemiLength;
  			lightsHash.shadowsLength = lightsStateHash.shadowsLength;

  			if ( material.lights ) {

  				// wire up the material to this renderer's lighting state

  				uniforms.ambientLightColor.value = lights.state.ambient;
  				uniforms.lightProbe.value = lights.state.probe;
  				uniforms.directionalLights.value = lights.state.directional;
  				uniforms.spotLights.value = lights.state.spot;
  				uniforms.rectAreaLights.value = lights.state.rectArea;
  				uniforms.pointLights.value = lights.state.point;
  				uniforms.hemisphereLights.value = lights.state.hemi;

  				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
  				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
  				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
  				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
  				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
  				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
  				// TODO (abelnation): add area lights shadow info to uniforms

  			}

  			var progUniforms = materialProperties.program.getUniforms(),
  				uniformsList =
  					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

  			materialProperties.uniformsList = uniformsList;

  		}

  		function setProgram( camera, fog, material, object ) {

  			textures.resetTextureUnits();

  			var materialProperties = properties.get( material );
  			var lights = currentRenderState.state.lights;

  			var lightsHash = materialProperties.lightsHash;
  			var lightsStateHash = lights.state.hash;

  			if ( _clippingEnabled ) {

  				if ( _localClippingEnabled || camera !== _currentCamera ) {

  					var useCache =
  						camera === _currentCamera &&
  						material.id === _currentMaterialId;

  					// we might want to call this function with some ClippingGroup
  					// object instead of the material, once it becomes feasible
  					// (#8465, #8379)
  					_clipping.setState(
  						material.clippingPlanes, material.clipIntersection, material.clipShadows,
  						camera, materialProperties, useCache );

  				}

  			}

  			if ( material.needsUpdate === false ) {

  				if ( materialProperties.program === undefined ) {

  					material.needsUpdate = true;

  				} else if ( material.fog && materialProperties.fog !== fog ) {

  					material.needsUpdate = true;

  				} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||
  					lightsHash.directionalLength !== lightsStateHash.directionalLength ||
  					lightsHash.pointLength !== lightsStateHash.pointLength ||
  					lightsHash.spotLength !== lightsStateHash.spotLength ||
  					lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
  					lightsHash.hemiLength !== lightsStateHash.hemiLength ||
  					lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {

  					material.needsUpdate = true;

  				} else if ( materialProperties.numClippingPlanes !== undefined &&
  					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
  					materialProperties.numIntersection !== _clipping.numIntersection ) ) {

  					material.needsUpdate = true;

  				}

  			}

  			if ( material.needsUpdate ) {

  				initMaterial( material, fog, object );
  				material.needsUpdate = false;

  			}

  			var refreshProgram = false;
  			var refreshMaterial = false;
  			var refreshLights = false;

  			var program = materialProperties.program,
  				p_uniforms = program.getUniforms(),
  				m_uniforms = materialProperties.shader.uniforms;

  			if ( state.useProgram( program.program ) ) {

  				refreshProgram = true;
  				refreshMaterial = true;
  				refreshLights = true;

  			}

  			if ( material.id !== _currentMaterialId ) {

  				_currentMaterialId = material.id;

  				refreshMaterial = true;

  			}

  			if ( refreshProgram || _currentCamera !== camera ) {

  				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

  				if ( capabilities.logarithmicDepthBuffer ) {

  					p_uniforms.setValue( _gl, 'logDepthBufFC',
  						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

  				}

  				if ( _currentCamera !== camera ) {

  					_currentCamera = camera;

  					// lighting uniforms depend on the camera so enforce an update
  					// now, in case this material supports lights - or later, when
  					// the next material that does gets activated:

  					refreshMaterial = true;		// set to true on material change
  					refreshLights = true;		// remains set until update done

  				}

  				// load material specific uniforms
  				// (shader material also gets them for the sake of genericity)

  				if ( material.isShaderMaterial ||
  					material.isMeshPhongMaterial ||
  					material.isMeshStandardMaterial ||
  					material.envMap ) {

  					var uCamPos = p_uniforms.map.cameraPosition;

  					if ( uCamPos !== undefined ) {

  						uCamPos.setValue( _gl,
  							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

  					}

  				}

  				if ( material.isMeshPhongMaterial ||
  					material.isMeshLambertMaterial ||
  					material.isMeshBasicMaterial ||
  					material.isMeshStandardMaterial ||
  					material.isShaderMaterial ||
  					material.skinning ) {

  					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

  				}

  			}

  			// skinning uniforms must be set even if material didn't change
  			// auto-setting of texture unit for bone texture must go before other textures
  			// not sure why, but otherwise weird things happen

  			if ( material.skinning ) {

  				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
  				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

  				var skeleton = object.skeleton;

  				if ( skeleton ) {

  					var bones = skeleton.bones;

  					if ( capabilities.floatVertexTextures ) {

  						if ( skeleton.boneTexture === undefined ) {

  							// layout (1 matrix = 4 pixels)
  							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


  							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
  							size = _Math.ceilPowerOfTwo( size );
  							size = Math.max( size, 4 );

  							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
  							boneMatrices.set( skeleton.boneMatrices ); // copy current values

  							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
  							boneTexture.needsUpdate = true;

  							skeleton.boneMatrices = boneMatrices;
  							skeleton.boneTexture = boneTexture;
  							skeleton.boneTextureSize = size;

  						}

  						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
  						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

  					} else {

  						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

  					}

  				}

  			}

  			if ( refreshMaterial ) {

  				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
  				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

  				if ( material.lights ) {

  					// the current material requires lighting info

  					// note: all lighting uniforms are always set correctly
  					// they simply reference the renderer's state for their
  					// values
  					//
  					// use the current material's .needsUpdate flags to set
  					// the GL state when required

  					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

  				}

  				// refresh uniforms common to several materials

  				if ( fog && material.fog ) {

  					refreshUniformsFog( m_uniforms, fog );

  				}

  				if ( material.isMeshBasicMaterial ) {

  					refreshUniformsCommon( m_uniforms, material );

  				} else if ( material.isMeshLambertMaterial ) {

  					refreshUniformsCommon( m_uniforms, material );
  					refreshUniformsLambert( m_uniforms, material );

  				} else if ( material.isMeshPhongMaterial ) {

  					refreshUniformsCommon( m_uniforms, material );

  					if ( material.isMeshToonMaterial ) {

  						refreshUniformsToon( m_uniforms, material );

  					} else {

  						refreshUniformsPhong( m_uniforms, material );

  					}

  				} else if ( material.isMeshStandardMaterial ) {

  					refreshUniformsCommon( m_uniforms, material );

  					if ( material.isMeshPhysicalMaterial ) {

  						refreshUniformsPhysical( m_uniforms, material );

  					} else {

  						refreshUniformsStandard( m_uniforms, material );

  					}

  				} else if ( material.isMeshMatcapMaterial ) {

  					refreshUniformsCommon( m_uniforms, material );

  					refreshUniformsMatcap( m_uniforms, material );

  				} else if ( material.isMeshDepthMaterial ) {

  					refreshUniformsCommon( m_uniforms, material );
  					refreshUniformsDepth( m_uniforms, material );

  				} else if ( material.isMeshDistanceMaterial ) {

  					refreshUniformsCommon( m_uniforms, material );
  					refreshUniformsDistance( m_uniforms, material );

  				} else if ( material.isMeshNormalMaterial ) {

  					refreshUniformsCommon( m_uniforms, material );
  					refreshUniformsNormal( m_uniforms, material );

  				} else if ( material.isLineBasicMaterial ) {

  					refreshUniformsLine( m_uniforms, material );

  					if ( material.isLineDashedMaterial ) {

  						refreshUniformsDash( m_uniforms, material );

  					}

  				} else if ( material.isPointsMaterial ) {

  					refreshUniformsPoints( m_uniforms, material );

  				} else if ( material.isSpriteMaterial ) {

  					refreshUniformsSprites( m_uniforms, material );

  				} else if ( material.isShadowMaterial ) {

  					m_uniforms.color.value.copy( material.color );
  					m_uniforms.opacity.value = material.opacity;

  				}

  				// RectAreaLight Texture
  				// TODO (mrdoob): Find a nicer implementation

  				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
  				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

  				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

  			}

  			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

  				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
  				material.uniformsNeedUpdate = false;

  			}

  			if ( material.isSpriteMaterial ) {

  				p_uniforms.setValue( _gl, 'center', object.center );

  			}

  			// common matrices

  			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
  			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
  			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

  			return program;

  		}

  		// Uniforms (refresh uniforms objects)

  		function refreshUniformsCommon( uniforms, material ) {

  			uniforms.opacity.value = material.opacity;

  			if ( material.color ) {

  				uniforms.diffuse.value.copy( material.color );

  			}

  			if ( material.emissive ) {

  				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

  			}

  			if ( material.map ) {

  				uniforms.map.value = material.map;

  			}

  			if ( material.alphaMap ) {

  				uniforms.alphaMap.value = material.alphaMap;

  			}

  			if ( material.specularMap ) {

  				uniforms.specularMap.value = material.specularMap;

  			}

  			if ( material.envMap ) {

  				uniforms.envMap.value = material.envMap;

  				// don't flip CubeTexture envMaps, flip everything else:
  				//  WebGLRenderTargetCube will be flipped for backwards compatibility
  				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
  				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
  				uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;

  				uniforms.reflectivity.value = material.reflectivity;
  				uniforms.refractionRatio.value = material.refractionRatio;

  				uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;

  			}

  			if ( material.lightMap ) {

  				uniforms.lightMap.value = material.lightMap;
  				uniforms.lightMapIntensity.value = material.lightMapIntensity;

  			}

  			if ( material.aoMap ) {

  				uniforms.aoMap.value = material.aoMap;
  				uniforms.aoMapIntensity.value = material.aoMapIntensity;

  			}

  			// uv repeat and offset setting priorities
  			// 1. color map
  			// 2. specular map
  			// 3. normal map
  			// 4. bump map
  			// 5. alpha map
  			// 6. emissive map

  			var uvScaleMap;

  			if ( material.map ) {

  				uvScaleMap = material.map;

  			} else if ( material.specularMap ) {

  				uvScaleMap = material.specularMap;

  			} else if ( material.displacementMap ) {

  				uvScaleMap = material.displacementMap;

  			} else if ( material.normalMap ) {

  				uvScaleMap = material.normalMap;

  			} else if ( material.bumpMap ) {

  				uvScaleMap = material.bumpMap;

  			} else if ( material.roughnessMap ) {

  				uvScaleMap = material.roughnessMap;

  			} else if ( material.metalnessMap ) {

  				uvScaleMap = material.metalnessMap;

  			} else if ( material.alphaMap ) {

  				uvScaleMap = material.alphaMap;

  			} else if ( material.emissiveMap ) {

  				uvScaleMap = material.emissiveMap;

  			}

  			if ( uvScaleMap !== undefined ) {

  				// backwards compatibility
  				if ( uvScaleMap.isWebGLRenderTarget ) {

  					uvScaleMap = uvScaleMap.texture;

  				}

  				if ( uvScaleMap.matrixAutoUpdate === true ) {

  					uvScaleMap.updateMatrix();

  				}

  				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

  			}

  		}

  		function refreshUniformsLine( uniforms, material ) {

  			uniforms.diffuse.value.copy( material.color );
  			uniforms.opacity.value = material.opacity;

  		}

  		function refreshUniformsDash( uniforms, material ) {

  			uniforms.dashSize.value = material.dashSize;
  			uniforms.totalSize.value = material.dashSize + material.gapSize;
  			uniforms.scale.value = material.scale;

  		}

  		function refreshUniformsPoints( uniforms, material ) {

  			uniforms.diffuse.value.copy( material.color );
  			uniforms.opacity.value = material.opacity;
  			uniforms.size.value = material.size * _pixelRatio;
  			uniforms.scale.value = _height * 0.5;

  			uniforms.map.value = material.map;

  			if ( material.map !== null ) {

  				if ( material.map.matrixAutoUpdate === true ) {

  					material.map.updateMatrix();

  				}

  				uniforms.uvTransform.value.copy( material.map.matrix );

  			}

  		}

  		function refreshUniformsSprites( uniforms, material ) {

  			uniforms.diffuse.value.copy( material.color );
  			uniforms.opacity.value = material.opacity;
  			uniforms.rotation.value = material.rotation;
  			uniforms.map.value = material.map;

  			if ( material.map !== null ) {

  				if ( material.map.matrixAutoUpdate === true ) {

  					material.map.updateMatrix();

  				}

  				uniforms.uvTransform.value.copy( material.map.matrix );

  			}

  		}

  		function refreshUniformsFog( uniforms, fog ) {

  			uniforms.fogColor.value.copy( fog.color );

  			if ( fog.isFog ) {

  				uniforms.fogNear.value = fog.near;
  				uniforms.fogFar.value = fog.far;

  			} else if ( fog.isFogExp2 ) {

  				uniforms.fogDensity.value = fog.density;

  			}

  		}

  		function refreshUniformsLambert( uniforms, material ) {

  			if ( material.emissiveMap ) {

  				uniforms.emissiveMap.value = material.emissiveMap;

  			}

  		}

  		function refreshUniformsPhong( uniforms, material ) {

  			uniforms.specular.value.copy( material.specular );
  			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

  			if ( material.emissiveMap ) {

  				uniforms.emissiveMap.value = material.emissiveMap;

  			}

  			if ( material.bumpMap ) {

  				uniforms.bumpMap.value = material.bumpMap;
  				uniforms.bumpScale.value = material.bumpScale;
  				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  			}

  			if ( material.normalMap ) {

  				uniforms.normalMap.value = material.normalMap;
  				uniforms.normalScale.value.copy( material.normalScale );
  				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  			}

  			if ( material.displacementMap ) {

  				uniforms.displacementMap.value = material.displacementMap;
  				uniforms.displacementScale.value = material.displacementScale;
  				uniforms.displacementBias.value = material.displacementBias;

  			}

  		}

  		function refreshUniformsToon( uniforms, material ) {

  			refreshUniformsPhong( uniforms, material );

  			if ( material.gradientMap ) {

  				uniforms.gradientMap.value = material.gradientMap;

  			}

  		}

  		function refreshUniformsStandard( uniforms, material ) {

  			uniforms.roughness.value = material.roughness;
  			uniforms.metalness.value = material.metalness;

  			if ( material.roughnessMap ) {

  				uniforms.roughnessMap.value = material.roughnessMap;

  			}

  			if ( material.metalnessMap ) {

  				uniforms.metalnessMap.value = material.metalnessMap;

  			}

  			if ( material.emissiveMap ) {

  				uniforms.emissiveMap.value = material.emissiveMap;

  			}

  			if ( material.bumpMap ) {

  				uniforms.bumpMap.value = material.bumpMap;
  				uniforms.bumpScale.value = material.bumpScale;
  				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  			}

  			if ( material.normalMap ) {

  				uniforms.normalMap.value = material.normalMap;
  				uniforms.normalScale.value.copy( material.normalScale );
  				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  			}

  			if ( material.displacementMap ) {

  				uniforms.displacementMap.value = material.displacementMap;
  				uniforms.displacementScale.value = material.displacementScale;
  				uniforms.displacementBias.value = material.displacementBias;

  			}

  			if ( material.envMap ) {

  				//uniforms.envMap.value = material.envMap; // part of uniforms common
  				uniforms.envMapIntensity.value = material.envMapIntensity;

  			}

  		}

  		function refreshUniformsPhysical( uniforms, material ) {

  			refreshUniformsStandard( uniforms, material );

  			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

  			uniforms.clearCoat.value = material.clearCoat;
  			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

  		}

  		function refreshUniformsMatcap( uniforms, material ) {

  			if ( material.matcap ) {

  				uniforms.matcap.value = material.matcap;

  			}

  			if ( material.bumpMap ) {

  				uniforms.bumpMap.value = material.bumpMap;
  				uniforms.bumpScale.value = material.bumpScale;
  				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  			}

  			if ( material.normalMap ) {

  				uniforms.normalMap.value = material.normalMap;
  				uniforms.normalScale.value.copy( material.normalScale );
  				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  			}

  			if ( material.displacementMap ) {

  				uniforms.displacementMap.value = material.displacementMap;
  				uniforms.displacementScale.value = material.displacementScale;
  				uniforms.displacementBias.value = material.displacementBias;

  			}

  		}

  		function refreshUniformsDepth( uniforms, material ) {

  			if ( material.displacementMap ) {

  				uniforms.displacementMap.value = material.displacementMap;
  				uniforms.displacementScale.value = material.displacementScale;
  				uniforms.displacementBias.value = material.displacementBias;

  			}

  		}

  		function refreshUniformsDistance( uniforms, material ) {

  			if ( material.displacementMap ) {

  				uniforms.displacementMap.value = material.displacementMap;
  				uniforms.displacementScale.value = material.displacementScale;
  				uniforms.displacementBias.value = material.displacementBias;

  			}

  			uniforms.referencePosition.value.copy( material.referencePosition );
  			uniforms.nearDistance.value = material.nearDistance;
  			uniforms.farDistance.value = material.farDistance;

  		}

  		function refreshUniformsNormal( uniforms, material ) {

  			if ( material.bumpMap ) {

  				uniforms.bumpMap.value = material.bumpMap;
  				uniforms.bumpScale.value = material.bumpScale;
  				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

  			}

  			if ( material.normalMap ) {

  				uniforms.normalMap.value = material.normalMap;
  				uniforms.normalScale.value.copy( material.normalScale );
  				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

  			}

  			if ( material.displacementMap ) {

  				uniforms.displacementMap.value = material.displacementMap;
  				uniforms.displacementScale.value = material.displacementScale;
  				uniforms.displacementBias.value = material.displacementBias;

  			}

  		}

  		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

  		function markUniformsLightsNeedsUpdate( uniforms, value ) {

  			uniforms.ambientLightColor.needsUpdate = value;
  			uniforms.lightProbe.needsUpdate = value;

  			uniforms.directionalLights.needsUpdate = value;
  			uniforms.pointLights.needsUpdate = value;
  			uniforms.spotLights.needsUpdate = value;
  			uniforms.rectAreaLights.needsUpdate = value;
  			uniforms.hemisphereLights.needsUpdate = value;

  		}

  		//

  		this.setFramebuffer = function ( value ) {

  			_framebuffer = value;

  		};

  		this.getRenderTarget = function () {

  			return _currentRenderTarget;

  		};

  		this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipMapLevel ) {

  			_currentRenderTarget = renderTarget;

  			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

  				textures.setupRenderTarget( renderTarget );

  			}

  			var framebuffer = _framebuffer;
  			var isCube = false;

  			if ( renderTarget ) {

  				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

  				if ( renderTarget.isWebGLRenderTargetCube ) {

  					framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];
  					isCube = true;

  				} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

  					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

  				} else {

  					framebuffer = __webglFramebuffer;

  				}

  				_currentViewport.copy( renderTarget.viewport );
  				_currentScissor.copy( renderTarget.scissor );
  				_currentScissorTest = renderTarget.scissorTest;

  			} else {

  				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
  				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
  				_currentScissorTest = _scissorTest;

  			}

  			if ( _currentFramebuffer !== framebuffer ) {

  				_gl.bindFramebuffer( 36160, framebuffer );
  				_currentFramebuffer = framebuffer;

  			}

  			state.viewport( _currentViewport );
  			state.scissor( _currentScissor );
  			state.setScissorTest( _currentScissorTest );

  			if ( isCube ) {

  				var textureProperties = properties.get( renderTarget.texture );
  				_gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipMapLevel || 0 );

  			}

  		};

  		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

  			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

  				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
  				return;

  			}

  			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

  			if ( framebuffer ) {

  				var restore = false;

  				if ( framebuffer !== _currentFramebuffer ) {

  					_gl.bindFramebuffer( 36160, framebuffer );

  					restore = true;

  				}

  				try {

  					var texture = renderTarget.texture;
  					var textureFormat = texture.format;
  					var textureType = texture.type;

  					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

  						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
  						return;

  					}

  					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
  						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
  						! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

  						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
  						return;

  					}

  					if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

  						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

  						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

  						}

  					} else {

  						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

  					}

  				} finally {

  					if ( restore ) {

  						_gl.bindFramebuffer( 36160, _currentFramebuffer );

  					}

  				}

  			}

  		};

  		this.copyFramebufferToTexture = function ( position, texture, level ) {

  			var width = texture.image.width;
  			var height = texture.image.height;
  			var glFormat = utils.convert( texture.format );

  			textures.setTexture2D( texture, 0 );

  			_gl.copyTexImage2D( 3553, level || 0, glFormat, position.x, position.y, width, height, 0 );

  		};

  		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

  			var width = srcTexture.image.width;
  			var height = srcTexture.image.height;
  			var glFormat = utils.convert( dstTexture.format );
  			var glType = utils.convert( dstTexture.type );

  			textures.setTexture2D( dstTexture, 0 );

  			if ( srcTexture.isDataTexture ) {

  				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

  			} else {

  				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

  			}

  		};

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function FogExp2( color, density ) {

  		this.name = '';

  		this.color = new Color( color );
  		this.density = ( density !== undefined ) ? density : 0.00025;

  	}

  	Object.assign( FogExp2.prototype, {

  		isFogExp2: true,

  		clone: function () {

  			return new FogExp2( this.color, this.density );

  		},

  		toJSON: function ( /* meta */ ) {

  			return {
  				type: 'FogExp2',
  				color: this.color.getHex(),
  				density: this.density
  			};

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function Fog( color, near, far ) {

  		this.name = '';

  		this.color = new Color( color );

  		this.near = ( near !== undefined ) ? near : 1;
  		this.far = ( far !== undefined ) ? far : 1000;

  	}

  	Object.assign( Fog.prototype, {

  		isFog: true,

  		clone: function () {

  			return new Fog( this.color, this.near, this.far );

  		},

  		toJSON: function ( /* meta */ ) {

  			return {
  				type: 'Fog',
  				color: this.color.getHex(),
  				near: this.near,
  				far: this.far
  			};

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function Scene() {

  		Object3D.call( this );

  		this.type = 'Scene';

  		this.background = null;
  		this.fog = null;
  		this.overrideMaterial = null;

  		this.autoUpdate = true; // checked by the renderer

  	}

  	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Scene,

  		isScene: true,

  		copy: function ( source, recursive ) {

  			Object3D.prototype.copy.call( this, source, recursive );

  			if ( source.background !== null ) this.background = source.background.clone();
  			if ( source.fog !== null ) this.fog = source.fog.clone();
  			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  			this.autoUpdate = source.autoUpdate;
  			this.matrixAutoUpdate = source.matrixAutoUpdate;

  			return this;

  		},

  		toJSON: function ( meta ) {

  			var data = Object3D.prototype.toJSON.call( this, meta );

  			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
  			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

  			return data;

  		},

  		dispose: function () {

  			this.dispatchEvent( { type: 'dispose' } );

  		}

  	} );

  	/**
  	 * @author benaadams / https://twitter.com/ben_a_adams
  	 */

  	function InterleavedBuffer( array, stride ) {

  		this.array = array;
  		this.stride = stride;
  		this.count = array !== undefined ? array.length / stride : 0;

  		this.dynamic = false;
  		this.updateRange = { offset: 0, count: - 1 };

  		this.version = 0;

  	}

  	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

  		set: function ( value ) {

  			if ( value === true ) this.version ++;

  		}

  	} );

  	Object.assign( InterleavedBuffer.prototype, {

  		isInterleavedBuffer: true,

  		onUploadCallback: function () {},

  		setArray: function ( array ) {

  			if ( Array.isArray( array ) ) {

  				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  			}

  			this.count = array !== undefined ? array.length / this.stride : 0;
  			this.array = array;

  			return this;

  		},

  		setDynamic: function ( value ) {

  			this.dynamic = value;

  			return this;

  		},

  		copy: function ( source ) {

  			this.array = new source.array.constructor( source.array );
  			this.count = source.count;
  			this.stride = source.stride;
  			this.dynamic = source.dynamic;

  			return this;

  		},

  		copyAt: function ( index1, attribute, index2 ) {

  			index1 *= this.stride;
  			index2 *= attribute.stride;

  			for ( var i = 0, l = this.stride; i < l; i ++ ) {

  				this.array[ index1 + i ] = attribute.array[ index2 + i ];

  			}

  			return this;

  		},

  		set: function ( value, offset ) {

  			if ( offset === undefined ) offset = 0;

  			this.array.set( value, offset );

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		onUpload: function ( callback ) {

  			this.onUploadCallback = callback;

  			return this;

  		}

  	} );

  	/**
  	 * @author benaadams / https://twitter.com/ben_a_adams
  	 */

  	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

  		this.data = interleavedBuffer;
  		this.itemSize = itemSize;
  		this.offset = offset;

  		this.normalized = normalized === true;

  	}

  	Object.defineProperties( InterleavedBufferAttribute.prototype, {

  		count: {

  			get: function () {

  				return this.data.count;

  			}

  		},

  		array: {

  			get: function () {

  				return this.data.array;

  			}

  		}

  	} );

  	Object.assign( InterleavedBufferAttribute.prototype, {

  		isInterleavedBufferAttribute: true,

  		setX: function ( index, x ) {

  			this.data.array[ index * this.data.stride + this.offset ] = x;

  			return this;

  		},

  		setY: function ( index, y ) {

  			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  			return this;

  		},

  		setZ: function ( index, z ) {

  			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  			return this;

  		},

  		setW: function ( index, w ) {

  			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  			return this;

  		},

  		getX: function ( index ) {

  			return this.data.array[ index * this.data.stride + this.offset ];

  		},

  		getY: function ( index ) {

  			return this.data.array[ index * this.data.stride + this.offset + 1 ];

  		},

  		getZ: function ( index ) {

  			return this.data.array[ index * this.data.stride + this.offset + 2 ];

  		},

  		getW: function ( index ) {

  			return this.data.array[ index * this.data.stride + this.offset + 3 ];

  		},

  		setXY: function ( index, x, y ) {

  			index = index * this.data.stride + this.offset;

  			this.data.array[ index + 0 ] = x;
  			this.data.array[ index + 1 ] = y;

  			return this;

  		},

  		setXYZ: function ( index, x, y, z ) {

  			index = index * this.data.stride + this.offset;

  			this.data.array[ index + 0 ] = x;
  			this.data.array[ index + 1 ] = y;
  			this.data.array[ index + 2 ] = z;

  			return this;

  		},

  		setXYZW: function ( index, x, y, z, w ) {

  			index = index * this.data.stride + this.offset;

  			this.data.array[ index + 0 ] = x;
  			this.data.array[ index + 1 ] = y;
  			this.data.array[ index + 2 ] = z;
  			this.data.array[ index + 3 ] = w;

  			return this;

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  map: new THREE.Texture( <Image> ),
  	 *  rotation: <float>,
  	 *  sizeAttenuation: <bool>
  	 * }
  	 */

  	function SpriteMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'SpriteMaterial';

  		this.color = new Color( 0xffffff );
  		this.map = null;

  		this.rotation = 0;

  		this.sizeAttenuation = true;

  		this.lights = false;
  		this.transparent = true;

  		this.setValues( parameters );

  	}

  	SpriteMaterial.prototype = Object.create( Material.prototype );
  	SpriteMaterial.prototype.constructor = SpriteMaterial;
  	SpriteMaterial.prototype.isSpriteMaterial = true;

  	SpriteMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.color.copy( source.color );
  		this.map = source.map;

  		this.rotation = source.rotation;

  		this.sizeAttenuation = source.sizeAttenuation;

  		return this;

  	};

  	/**
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	var geometry;

  	function Sprite( material ) {

  		Object3D.call( this );

  		this.type = 'Sprite';

  		if ( geometry === undefined ) {

  			geometry = new BufferGeometry();

  			var float32Array = new Float32Array( [
  				- 0.5, - 0.5, 0, 0, 0,
  				0.5, - 0.5, 0, 1, 0,
  				0.5, 0.5, 0, 1, 1,
  				- 0.5, 0.5, 0, 0, 1
  			] );

  			var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

  			geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
  			geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
  			geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

  		}

  		this.geometry = geometry;
  		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

  		this.center = new Vector2( 0.5, 0.5 );

  	}

  	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Sprite,

  		isSprite: true,

  		raycast: ( function () {

  			var intersectPoint = new Vector3();
  			var worldScale = new Vector3();
  			var mvPosition = new Vector3();

  			var alignedPosition = new Vector2();
  			var rotatedPosition = new Vector2();
  			var viewWorldMatrix = new Matrix4();

  			var vA = new Vector3();
  			var vB = new Vector3();
  			var vC = new Vector3();

  			var uvA = new Vector2();
  			var uvB = new Vector2();
  			var uvC = new Vector2();

  			function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

  				// compute position in camera space
  				alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

  				// to check if rotation is not zero
  				if ( sin !== undefined ) {

  					rotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );
  					rotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );

  				} else {

  					rotatedPosition.copy( alignedPosition );

  				}


  				vertexPosition.copy( mvPosition );
  				vertexPosition.x += rotatedPosition.x;
  				vertexPosition.y += rotatedPosition.y;

  				// transform to world space
  				vertexPosition.applyMatrix4( viewWorldMatrix );

  			}

  			return function raycast( raycaster, intersects ) {

  				worldScale.setFromMatrixScale( this.matrixWorld );
  				viewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );
  				mvPosition.setFromMatrixPosition( this.modelViewMatrix );

  				var rotation = this.material.rotation;
  				var sin, cos;
  				if ( rotation !== 0 ) {

  					cos = Math.cos( rotation );
  					sin = Math.sin( rotation );

  				}

  				var center = this.center;

  				transformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
  				transformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
  				transformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );

  				uvA.set( 0, 0 );
  				uvB.set( 1, 0 );
  				uvC.set( 1, 1 );

  				// check first triangle
  				var intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );

  				if ( intersect === null ) {

  					// check second triangle
  					transformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
  					uvB.set( 0, 1 );

  					intersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );
  					if ( intersect === null ) {

  						return;

  					}

  				}

  				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  				if ( distance < raycaster.near || distance > raycaster.far ) return;

  				intersects.push( {

  					distance: distance,
  					point: intersectPoint.clone(),
  					uv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),
  					face: null,
  					object: this

  				} );

  			};

  		}() ),

  		clone: function () {

  			return new this.constructor( this.material ).copy( this );

  		},

  		copy: function ( source ) {

  			Object3D.prototype.copy.call( this, source );

  			if ( source.center !== undefined ) this.center.copy( source.center );

  			return this;

  		}


  	} );

  	/**
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function LOD() {

  		Object3D.call( this );

  		this.type = 'LOD';

  		Object.defineProperties( this, {
  			levels: {
  				enumerable: true,
  				value: []
  			}
  		} );

  	}

  	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: LOD,

  		isLOD: true,

  		copy: function ( source ) {

  			Object3D.prototype.copy.call( this, source, false );

  			var levels = source.levels;

  			for ( var i = 0, l = levels.length; i < l; i ++ ) {

  				var level = levels[ i ];

  				this.addLevel( level.object.clone(), level.distance );

  			}

  			return this;

  		},

  		addLevel: function ( object, distance ) {

  			if ( distance === undefined ) distance = 0;

  			distance = Math.abs( distance );

  			var levels = this.levels;

  			for ( var l = 0; l < levels.length; l ++ ) {

  				if ( distance < levels[ l ].distance ) {

  					break;

  				}

  			}

  			levels.splice( l, 0, { distance: distance, object: object } );

  			this.add( object );

  			return this;

  		},

  		getObjectForDistance: function ( distance ) {

  			var levels = this.levels;

  			for ( var i = 1, l = levels.length; i < l; i ++ ) {

  				if ( distance < levels[ i ].distance ) {

  					break;

  				}

  			}

  			return levels[ i - 1 ].object;

  		},

  		raycast: ( function () {

  			var matrixPosition = new Vector3();

  			return function raycast( raycaster, intersects ) {

  				matrixPosition.setFromMatrixPosition( this.matrixWorld );

  				var distance = raycaster.ray.origin.distanceTo( matrixPosition );

  				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  			};

  		}() ),

  		update: function () {

  			var v1 = new Vector3();
  			var v2 = new Vector3();

  			return function update( camera ) {

  				var levels = this.levels;

  				if ( levels.length > 1 ) {

  					v1.setFromMatrixPosition( camera.matrixWorld );
  					v2.setFromMatrixPosition( this.matrixWorld );

  					var distance = v1.distanceTo( v2 );

  					levels[ 0 ].object.visible = true;

  					for ( var i = 1, l = levels.length; i < l; i ++ ) {

  						if ( distance >= levels[ i ].distance ) {

  							levels[ i - 1 ].object.visible = false;
  							levels[ i ].object.visible = true;

  						} else {

  							break;

  						}

  					}

  					for ( ; i < l; i ++ ) {

  						levels[ i ].object.visible = false;

  					}

  				}

  			};

  		}(),

  		toJSON: function ( meta ) {

  			var data = Object3D.prototype.toJSON.call( this, meta );

  			data.object.levels = [];

  			var levels = this.levels;

  			for ( var i = 0, l = levels.length; i < l; i ++ ) {

  				var level = levels[ i ];

  				data.object.levels.push( {
  					object: level.object.uuid,
  					distance: level.distance
  				} );

  			}

  			return data;

  		}

  	} );

  	/**
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author ikerr / http://verold.com
  	 */

  	function SkinnedMesh( geometry, material ) {

  		if ( geometry && geometry.isGeometry ) {

  			console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

  		}

  		Mesh.call( this, geometry, material );

  		this.type = 'SkinnedMesh';

  		this.bindMode = 'attached';
  		this.bindMatrix = new Matrix4();
  		this.bindMatrixInverse = new Matrix4();

  	}

  	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

  		constructor: SkinnedMesh,

  		isSkinnedMesh: true,

  		bind: function ( skeleton, bindMatrix ) {

  			this.skeleton = skeleton;

  			if ( bindMatrix === undefined ) {

  				this.updateMatrixWorld( true );

  				this.skeleton.calculateInverses();

  				bindMatrix = this.matrixWorld;

  			}

  			this.bindMatrix.copy( bindMatrix );
  			this.bindMatrixInverse.getInverse( bindMatrix );

  		},

  		pose: function () {

  			this.skeleton.pose();

  		},

  		normalizeSkinWeights: function () {

  			var vector = new Vector4();

  			var skinWeight = this.geometry.attributes.skinWeight;

  			for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {

  				vector.x = skinWeight.getX( i );
  				vector.y = skinWeight.getY( i );
  				vector.z = skinWeight.getZ( i );
  				vector.w = skinWeight.getW( i );

  				var scale = 1.0 / vector.manhattanLength();

  				if ( scale !== Infinity ) {

  					vector.multiplyScalar( scale );

  				} else {

  					vector.set( 1, 0, 0, 0 ); // do something reasonable

  				}

  				skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

  			}

  		},

  		updateMatrixWorld: function ( force ) {

  			Mesh.prototype.updateMatrixWorld.call( this, force );

  			if ( this.bindMode === 'attached' ) {

  				this.bindMatrixInverse.getInverse( this.matrixWorld );

  			} else if ( this.bindMode === 'detached' ) {

  				this.bindMatrixInverse.getInverse( this.bindMatrix );

  			} else {

  				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

  			}

  		},

  		clone: function () {

  			return new this.constructor( this.geometry, this.material ).copy( this );

  		}

  	} );

  	/**
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author michael guerrero / http://realitymeltdown.com
  	 * @author ikerr / http://verold.com
  	 */

  	function Skeleton( bones, boneInverses ) {

  		// copy the bone array

  		bones = bones || [];

  		this.bones = bones.slice( 0 );
  		this.boneMatrices = new Float32Array( this.bones.length * 16 );

  		// use the supplied bone inverses or calculate the inverses

  		if ( boneInverses === undefined ) {

  			this.calculateInverses();

  		} else {

  			if ( this.bones.length === boneInverses.length ) {

  				this.boneInverses = boneInverses.slice( 0 );

  			} else {

  				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

  				this.boneInverses = [];

  				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  					this.boneInverses.push( new Matrix4() );

  				}

  			}

  		}

  	}

  	Object.assign( Skeleton.prototype, {

  		calculateInverses: function () {

  			this.boneInverses = [];

  			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  				var inverse = new Matrix4();

  				if ( this.bones[ i ] ) {

  					inverse.getInverse( this.bones[ i ].matrixWorld );

  				}

  				this.boneInverses.push( inverse );

  			}

  		},

  		pose: function () {

  			var bone, i, il;

  			// recover the bind-time world matrices

  			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  				bone = this.bones[ i ];

  				if ( bone ) {

  					bone.matrixWorld.getInverse( this.boneInverses[ i ] );

  				}

  			}

  			// compute the local matrices, positions, rotations and scales

  			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  				bone = this.bones[ i ];

  				if ( bone ) {

  					if ( bone.parent && bone.parent.isBone ) {

  						bone.matrix.getInverse( bone.parent.matrixWorld );
  						bone.matrix.multiply( bone.matrixWorld );

  					} else {

  						bone.matrix.copy( bone.matrixWorld );

  					}

  					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  				}

  			}

  		},

  		update: ( function () {

  			var offsetMatrix = new Matrix4();
  			var identityMatrix = new Matrix4();

  			return function update() {

  				var bones = this.bones;
  				var boneInverses = this.boneInverses;
  				var boneMatrices = this.boneMatrices;
  				var boneTexture = this.boneTexture;

  				// flatten bone matrices to array

  				for ( var i = 0, il = bones.length; i < il; i ++ ) {

  					// compute the offset between the current and the original transform

  					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

  					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
  					offsetMatrix.toArray( boneMatrices, i * 16 );

  				}

  				if ( boneTexture !== undefined ) {

  					boneTexture.needsUpdate = true;

  				}

  			};

  		} )(),

  		clone: function () {

  			return new Skeleton( this.bones, this.boneInverses );

  		},

  		getBoneByName: function ( name ) {

  			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  				var bone = this.bones[ i ];

  				if ( bone.name === name ) {

  					return bone;

  				}

  			}

  			return undefined;

  		}

  	} );

  	/**
  	 * @author mikael emtinger / http://gomo.se/
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author ikerr / http://verold.com
  	 */

  	function Bone() {

  		Object3D.call( this );

  		this.type = 'Bone';

  	}

  	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Bone,

  		isBone: true

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  opacity: <float>,
  	 *
  	 *  linewidth: <float>,
  	 *  linecap: "round",
  	 *  linejoin: "round"
  	 * }
  	 */

  	function LineBasicMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'LineBasicMaterial';

  		this.color = new Color( 0xffffff );

  		this.linewidth = 1;
  		this.linecap = 'round';
  		this.linejoin = 'round';

  		this.lights = false;

  		this.setValues( parameters );

  	}

  	LineBasicMaterial.prototype = Object.create( Material.prototype );
  	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

  	LineBasicMaterial.prototype.isLineBasicMaterial = true;

  	LineBasicMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.color.copy( source.color );

  		this.linewidth = source.linewidth;
  		this.linecap = source.linecap;
  		this.linejoin = source.linejoin;

  		return this;

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function Line( geometry, material, mode ) {

  		if ( mode === 1 ) {

  			console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );

  		}

  		Object3D.call( this );

  		this.type = 'Line';

  		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

  	}

  	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Line,

  		isLine: true,

  		computeLineDistances: ( function () {

  			var start = new Vector3();
  			var end = new Vector3();

  			return function computeLineDistances() {

  				var geometry = this.geometry;

  				if ( geometry.isBufferGeometry ) {

  					// we assume non-indexed geometry

  					if ( geometry.index === null ) {

  						var positionAttribute = geometry.attributes.position;
  						var lineDistances = [ 0 ];

  						for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

  							start.fromBufferAttribute( positionAttribute, i - 1 );
  							end.fromBufferAttribute( positionAttribute, i );

  							lineDistances[ i ] = lineDistances[ i - 1 ];
  							lineDistances[ i ] += start.distanceTo( end );

  						}

  						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  					} else {

  						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  					}

  				} else if ( geometry.isGeometry ) {

  					var vertices = geometry.vertices;
  					var lineDistances = geometry.lineDistances;

  					lineDistances[ 0 ] = 0;

  					for ( var i = 1, l = vertices.length; i < l; i ++ ) {

  						lineDistances[ i ] = lineDistances[ i - 1 ];
  						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

  					}

  				}

  				return this;

  			};

  		}() ),

  		raycast: ( function () {

  			var inverseMatrix = new Matrix4();
  			var ray = new Ray();
  			var sphere = new Sphere();

  			return function raycast( raycaster, intersects ) {

  				var precision = raycaster.linePrecision;

  				var geometry = this.geometry;
  				var matrixWorld = this.matrixWorld;

  				// Checking boundingSphere distance to ray

  				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  				sphere.copy( geometry.boundingSphere );
  				sphere.applyMatrix4( matrixWorld );
  				sphere.radius += precision;

  				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

  				//

  				inverseMatrix.getInverse( matrixWorld );
  				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  				var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  				var localPrecisionSq = localPrecision * localPrecision;

  				var vStart = new Vector3();
  				var vEnd = new Vector3();
  				var interSegment = new Vector3();
  				var interRay = new Vector3();
  				var step = ( this && this.isLineSegments ) ? 2 : 1;

  				if ( geometry.isBufferGeometry ) {

  					var index = geometry.index;
  					var attributes = geometry.attributes;
  					var positions = attributes.position.array;

  					if ( index !== null ) {

  						var indices = index.array;

  						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

  							var a = indices[ i ];
  							var b = indices[ i + 1 ];

  							vStart.fromArray( positions, a * 3 );
  							vEnd.fromArray( positions, b * 3 );

  							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  							if ( distSq > localPrecisionSq ) continue;

  							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

  							var distance = raycaster.ray.origin.distanceTo( interRay );

  							if ( distance < raycaster.near || distance > raycaster.far ) continue;

  							intersects.push( {

  								distance: distance,
  								// What do we want? intersection point on the ray or on the segment??
  								// point: raycaster.ray.at( distance ),
  								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
  								index: i,
  								face: null,
  								faceIndex: null,
  								object: this

  							} );

  						}

  					} else {

  						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

  							vStart.fromArray( positions, 3 * i );
  							vEnd.fromArray( positions, 3 * i + 3 );

  							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  							if ( distSq > localPrecisionSq ) continue;

  							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

  							var distance = raycaster.ray.origin.distanceTo( interRay );

  							if ( distance < raycaster.near || distance > raycaster.far ) continue;

  							intersects.push( {

  								distance: distance,
  								// What do we want? intersection point on the ray or on the segment??
  								// point: raycaster.ray.at( distance ),
  								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
  								index: i,
  								face: null,
  								faceIndex: null,
  								object: this

  							} );

  						}

  					}

  				} else if ( geometry.isGeometry ) {

  					var vertices = geometry.vertices;
  					var nbVertices = vertices.length;

  					for ( var i = 0; i < nbVertices - 1; i += step ) {

  						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

  						if ( distSq > localPrecisionSq ) continue;

  						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) continue;

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this

  						} );

  					}

  				}

  			};

  		}() ),

  		clone: function () {

  			return new this.constructor( this.geometry, this.material ).copy( this );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function LineSegments( geometry, material ) {

  		Line.call( this, geometry, material );

  		this.type = 'LineSegments';

  	}

  	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

  		constructor: LineSegments,

  		isLineSegments: true,

  		computeLineDistances: ( function () {

  			var start = new Vector3();
  			var end = new Vector3();

  			return function computeLineDistances() {

  				var geometry = this.geometry;

  				if ( geometry.isBufferGeometry ) {

  					// we assume non-indexed geometry

  					if ( geometry.index === null ) {

  						var positionAttribute = geometry.attributes.position;
  						var lineDistances = [];

  						for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

  							start.fromBufferAttribute( positionAttribute, i );
  							end.fromBufferAttribute( positionAttribute, i + 1 );

  							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
  							lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

  						}

  						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

  					} else {

  						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

  					}

  				} else if ( geometry.isGeometry ) {

  					var vertices = geometry.vertices;
  					var lineDistances = geometry.lineDistances;

  					for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

  						start.copy( vertices[ i ] );
  						end.copy( vertices[ i + 1 ] );

  						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
  						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

  					}

  				}

  				return this;

  			};

  		}() )

  	} );

  	/**
  	 * @author mgreter / http://github.com/mgreter
  	 */

  	function LineLoop( geometry, material ) {

  		Line.call( this, geometry, material );

  		this.type = 'LineLoop';

  	}

  	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

  		constructor: LineLoop,

  		isLineLoop: true,

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  opacity: <float>,
  	 *  map: new THREE.Texture( <Image> ),
  	 *
  	 *  size: <float>,
  	 *  sizeAttenuation: <bool>
  	 *
  	 *  morphTargets: <bool>
  	 * }
  	 */

  	function PointsMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'PointsMaterial';

  		this.color = new Color( 0xffffff );

  		this.map = null;

  		this.size = 1;
  		this.sizeAttenuation = true;

  		this.morphTargets = false;

  		this.lights = false;

  		this.setValues( parameters );

  	}

  	PointsMaterial.prototype = Object.create( Material.prototype );
  	PointsMaterial.prototype.constructor = PointsMaterial;

  	PointsMaterial.prototype.isPointsMaterial = true;

  	PointsMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.size = source.size;
  		this.sizeAttenuation = source.sizeAttenuation;

  		this.morphTargets = source.morphTargets;

  		return this;

  	};

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function Points( geometry, material ) {

  		Object3D.call( this );

  		this.type = 'Points';

  		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

  	}

  	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Points,

  		isPoints: true,

  		raycast: ( function () {

  			var inverseMatrix = new Matrix4();
  			var ray = new Ray();
  			var sphere = new Sphere();

  			return function raycast( raycaster, intersects ) {

  				var object = this;
  				var geometry = this.geometry;
  				var matrixWorld = this.matrixWorld;
  				var threshold = raycaster.params.Points.threshold;

  				// Checking boundingSphere distance to ray

  				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  				sphere.copy( geometry.boundingSphere );
  				sphere.applyMatrix4( matrixWorld );
  				sphere.radius += threshold;

  				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

  				//

  				inverseMatrix.getInverse( matrixWorld );
  				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  				var localThresholdSq = localThreshold * localThreshold;
  				var position = new Vector3();
  				var intersectPoint = new Vector3();

  				function testPoint( point, index ) {

  					var rayPointDistanceSq = ray.distanceSqToPoint( point );

  					if ( rayPointDistanceSq < localThresholdSq ) {

  						ray.closestPointToPoint( point, intersectPoint );
  						intersectPoint.applyMatrix4( matrixWorld );

  						var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  						if ( distance < raycaster.near || distance > raycaster.far ) return;

  						intersects.push( {

  							distance: distance,
  							distanceToRay: Math.sqrt( rayPointDistanceSq ),
  							point: intersectPoint.clone(),
  							index: index,
  							face: null,
  							object: object

  						} );

  					}

  				}

  				if ( geometry.isBufferGeometry ) {

  					var index = geometry.index;
  					var attributes = geometry.attributes;
  					var positions = attributes.position.array;

  					if ( index !== null ) {

  						var indices = index.array;

  						for ( var i = 0, il = indices.length; i < il; i ++ ) {

  							var a = indices[ i ];

  							position.fromArray( positions, a * 3 );

  							testPoint( position, a );

  						}

  					} else {

  						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

  							position.fromArray( positions, i * 3 );

  							testPoint( position, i );

  						}

  					}

  				} else {

  					var vertices = geometry.vertices;

  					for ( var i = 0, l = vertices.length; i < l; i ++ ) {

  						testPoint( vertices[ i ], i );

  					}

  				}

  			};

  		}() ),

  		clone: function () {

  			return new this.constructor( this.geometry, this.material ).copy( this );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.format = format !== undefined ? format : RGBFormat;

  		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
  		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

  		this.generateMipmaps = false;

  	}

  	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

  		constructor: VideoTexture,

  		isVideoTexture: true,

  		update: function () {

  			var video = this.image;

  			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

  				this.needsUpdate = true;

  			}

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  		this.image = { width: width, height: height };
  		this.mipmaps = mipmaps;

  		// no flipping for cube textures
  		// (also flipping doesn't work for compressed textures )

  		this.flipY = false;

  		// can't generate mipmaps for compressed textures
  		// mips must be embedded in DDS files

  		this.generateMipmaps = false;

  	}

  	CompressedTexture.prototype = Object.create( Texture.prototype );
  	CompressedTexture.prototype.constructor = CompressedTexture;

  	CompressedTexture.prototype.isCompressedTexture = true;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.needsUpdate = true;

  	}

  	CanvasTexture.prototype = Object.create( Texture.prototype );
  	CanvasTexture.prototype.constructor = CanvasTexture;
  	CanvasTexture.prototype.isCanvasTexture = true;

  	/**
  	 * @author Matt DesLauriers / @mattdesl
  	 * @author atix / arthursilber.de
  	 */

  	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

  		format = format !== undefined ? format : DepthFormat;

  		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

  			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

  		}

  		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
  		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

  		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  		this.image = { width: width, height: height };

  		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

  		this.flipY = false;
  		this.generateMipmaps	= false;

  	}

  	DepthTexture.prototype = Object.create( Texture.prototype );
  	DepthTexture.prototype.constructor = DepthTexture;
  	DepthTexture.prototype.isDepthTexture = true;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	function WireframeGeometry( geometry ) {

  		BufferGeometry.call( this );

  		this.type = 'WireframeGeometry';

  		// buffer

  		var vertices = [];

  		// helper variables

  		var i, j, l, o, ol;
  		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
  		var key, keys = [ 'a', 'b', 'c' ];
  		var vertex;

  		// different logic for Geometry and BufferGeometry

  		if ( geometry && geometry.isGeometry ) {

  			// create a data structure that contains all edges without duplicates

  			var faces = geometry.faces;

  			for ( i = 0, l = faces.length; i < l; i ++ ) {

  				var face = faces[ i ];

  				for ( j = 0; j < 3; j ++ ) {

  					edge1 = face[ keys[ j ] ];
  					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  					edge[ 1 ] = Math.max( edge1, edge2 );

  					key = edge[ 0 ] + ',' + edge[ 1 ];

  					if ( edges[ key ] === undefined ) {

  						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  					}

  				}

  			}

  			// generate vertices

  			for ( key in edges ) {

  				e = edges[ key ];

  				vertex = geometry.vertices[ e.index1 ];
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				vertex = geometry.vertices[ e.index2 ];
  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		} else if ( geometry && geometry.isBufferGeometry ) {

  			var position, indices, groups;
  			var group, start, count;
  			var index1, index2;

  			vertex = new Vector3();

  			if ( geometry.index !== null ) {

  				// indexed BufferGeometry

  				position = geometry.attributes.position;
  				indices = geometry.index;
  				groups = geometry.groups;

  				if ( groups.length === 0 ) {

  					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

  				}

  				// create a data structure that contains all eges without duplicates

  				for ( o = 0, ol = groups.length; o < ol; ++ o ) {

  					group = groups[ o ];

  					start = group.start;
  					count = group.count;

  					for ( i = start, l = ( start + count ); i < l; i += 3 ) {

  						for ( j = 0; j < 3; j ++ ) {

  							edge1 = indices.getX( i + j );
  							edge2 = indices.getX( i + ( j + 1 ) % 3 );
  							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  							edge[ 1 ] = Math.max( edge1, edge2 );

  							key = edge[ 0 ] + ',' + edge[ 1 ];

  							if ( edges[ key ] === undefined ) {

  								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  							}

  						}

  					}

  				}

  				// generate vertices

  				for ( key in edges ) {

  					e = edges[ key ];

  					vertex.fromBufferAttribute( position, e.index1 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					vertex.fromBufferAttribute( position, e.index2 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  				}

  			} else {

  				// non-indexed BufferGeometry

  				position = geometry.attributes.position;

  				for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

  					for ( j = 0; j < 3; j ++ ) {

  						// three edges per triangle, an edge is represented as (index1, index2)
  						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

  						index1 = 3 * i + j;
  						vertex.fromBufferAttribute( position, index1 );
  						vertices.push( vertex.x, vertex.y, vertex.z );

  						index2 = 3 * i + ( ( j + 1 ) % 3 );
  						vertex.fromBufferAttribute( position, index2 );
  						vertices.push( vertex.x, vertex.y, vertex.z );

  					}

  				}

  			}

  		}

  		// build geometry

  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  	}

  	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
  	WireframeGeometry.prototype.constructor = WireframeGeometry;

  	/**
  	 * @author zz85 / https://github.com/zz85
  	 * @author Mugen87 / https://github.com/Mugen87
  	 *
  	 * Parametric Surfaces Geometry
  	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
  	 */

  	// ParametricGeometry

  	function ParametricGeometry( func, slices, stacks ) {

  		Geometry.call( this );

  		this.type = 'ParametricGeometry';

  		this.parameters = {
  			func: func,
  			slices: slices,
  			stacks: stacks
  		};

  		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
  		this.mergeVertices();

  	}

  	ParametricGeometry.prototype = Object.create( Geometry.prototype );
  	ParametricGeometry.prototype.constructor = ParametricGeometry;

  	// ParametricBufferGeometry

  	function ParametricBufferGeometry( func, slices, stacks ) {

  		BufferGeometry.call( this );

  		this.type = 'ParametricBufferGeometry';

  		this.parameters = {
  			func: func,
  			slices: slices,
  			stacks: stacks
  		};

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		var EPS = 0.00001;

  		var normal = new Vector3();

  		var p0 = new Vector3(), p1 = new Vector3();
  		var pu = new Vector3(), pv = new Vector3();

  		var i, j;

  		if ( func.length < 3 ) {

  			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

  		}

  		// generate vertices, normals and uvs

  		var sliceCount = slices + 1;

  		for ( i = 0; i <= stacks; i ++ ) {

  			var v = i / stacks;

  			for ( j = 0; j <= slices; j ++ ) {

  				var u = j / slices;

  				// vertex

  				func( u, v, p0 );
  				vertices.push( p0.x, p0.y, p0.z );

  				// normal

  				// approximate tangent vectors via finite differences

  				if ( u - EPS >= 0 ) {

  					func( u - EPS, v, p1 );
  					pu.subVectors( p0, p1 );

  				} else {

  					func( u + EPS, v, p1 );
  					pu.subVectors( p1, p0 );

  				}

  				if ( v - EPS >= 0 ) {

  					func( u, v - EPS, p1 );
  					pv.subVectors( p0, p1 );

  				} else {

  					func( u, v + EPS, p1 );
  					pv.subVectors( p1, p0 );

  				}

  				// cross product of tangent vectors returns surface normal

  				normal.crossVectors( pu, pv ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u, v );

  			}

  		}

  		// generate indices

  		for ( i = 0; i < stacks; i ++ ) {

  			for ( j = 0; j < slices; j ++ ) {

  				var a = i * sliceCount + j;
  				var b = i * sliceCount + j + 1;
  				var c = ( i + 1 ) * sliceCount + j + 1;
  				var d = ( i + 1 ) * sliceCount + j;

  				// faces one and two

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

  	/**
  	 * @author clockworkgeek / https://github.com/clockworkgeek
  	 * @author timothypratley / https://github.com/timothypratley
  	 * @author WestLangley / http://github.com/WestLangley
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// PolyhedronGeometry

  	function PolyhedronGeometry( vertices, indices, radius, detail ) {

  		Geometry.call( this );

  		this.type = 'PolyhedronGeometry';

  		this.parameters = {
  			vertices: vertices,
  			indices: indices,
  			radius: radius,
  			detail: detail
  		};

  		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
  		this.mergeVertices();

  	}

  	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
  	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

  	// PolyhedronBufferGeometry

  	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

  		BufferGeometry.call( this );

  		this.type = 'PolyhedronBufferGeometry';

  		this.parameters = {
  			vertices: vertices,
  			indices: indices,
  			radius: radius,
  			detail: detail
  		};

  		radius = radius || 1;
  		detail = detail || 0;

  		// default buffer data

  		var vertexBuffer = [];
  		var uvBuffer = [];

  		// the subdivision creates the vertex buffer data

  		subdivide( detail );

  		// all vertices should lie on a conceptual sphere with a given radius

  		appplyRadius( radius );

  		// finally, create the uv data

  		generateUVs();

  		// build non-indexed geometry

  		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

  		if ( detail === 0 ) {

  			this.computeVertexNormals(); // flat normals

  		} else {

  			this.normalizeNormals(); // smooth normals

  		}

  		// helper functions

  		function subdivide( detail ) {

  			var a = new Vector3();
  			var b = new Vector3();
  			var c = new Vector3();

  			// iterate over all faces and apply a subdivison with the given detail value

  			for ( var i = 0; i < indices.length; i += 3 ) {

  				// get the vertices of the face

  				getVertexByIndex( indices[ i + 0 ], a );
  				getVertexByIndex( indices[ i + 1 ], b );
  				getVertexByIndex( indices[ i + 2 ], c );

  				// perform subdivision

  				subdivideFace( a, b, c, detail );

  			}

  		}

  		function subdivideFace( a, b, c, detail ) {

  			var cols = Math.pow( 2, detail );

  			// we use this multidimensional array as a data structure for creating the subdivision

  			var v = [];

  			var i, j;

  			// construct all of the vertices for this subdivision

  			for ( i = 0; i <= cols; i ++ ) {

  				v[ i ] = [];

  				var aj = a.clone().lerp( c, i / cols );
  				var bj = b.clone().lerp( c, i / cols );

  				var rows = cols - i;

  				for ( j = 0; j <= rows; j ++ ) {

  					if ( j === 0 && i === cols ) {

  						v[ i ][ j ] = aj;

  					} else {

  						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

  					}

  				}

  			}

  			// construct all of the faces

  			for ( i = 0; i < cols; i ++ ) {

  				for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

  					var k = Math.floor( j / 2 );

  					if ( j % 2 === 0 ) {

  						pushVertex( v[ i ][ k + 1 ] );
  						pushVertex( v[ i + 1 ][ k ] );
  						pushVertex( v[ i ][ k ] );

  					} else {

  						pushVertex( v[ i ][ k + 1 ] );
  						pushVertex( v[ i + 1 ][ k + 1 ] );
  						pushVertex( v[ i + 1 ][ k ] );

  					}

  				}

  			}

  		}

  		function appplyRadius( radius ) {

  			var vertex = new Vector3();

  			// iterate over the entire buffer and apply the radius to each vertex

  			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  				vertex.x = vertexBuffer[ i + 0 ];
  				vertex.y = vertexBuffer[ i + 1 ];
  				vertex.z = vertexBuffer[ i + 2 ];

  				vertex.normalize().multiplyScalar( radius );

  				vertexBuffer[ i + 0 ] = vertex.x;
  				vertexBuffer[ i + 1 ] = vertex.y;
  				vertexBuffer[ i + 2 ] = vertex.z;

  			}

  		}

  		function generateUVs() {

  			var vertex = new Vector3();

  			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  				vertex.x = vertexBuffer[ i + 0 ];
  				vertex.y = vertexBuffer[ i + 1 ];
  				vertex.z = vertexBuffer[ i + 2 ];

  				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
  				var v = inclination( vertex ) / Math.PI + 0.5;
  				uvBuffer.push( u, 1 - v );

  			}

  			correctUVs();

  			correctSeam();

  		}

  		function correctSeam() {

  			// handle case when face straddles the seam, see #3269

  			for ( var i = 0; i < uvBuffer.length; i += 6 ) {

  				// uv data of a single face

  				var x0 = uvBuffer[ i + 0 ];
  				var x1 = uvBuffer[ i + 2 ];
  				var x2 = uvBuffer[ i + 4 ];

  				var max = Math.max( x0, x1, x2 );
  				var min = Math.min( x0, x1, x2 );

  				// 0.9 is somewhat arbitrary

  				if ( max > 0.9 && min < 0.1 ) {

  					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
  					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
  					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

  				}

  			}

  		}

  		function pushVertex( vertex ) {

  			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

  		}

  		function getVertexByIndex( index, vertex ) {

  			var stride = index * 3;

  			vertex.x = vertices[ stride + 0 ];
  			vertex.y = vertices[ stride + 1 ];
  			vertex.z = vertices[ stride + 2 ];

  		}

  		function correctUVs() {

  			var a = new Vector3();
  			var b = new Vector3();
  			var c = new Vector3();

  			var centroid = new Vector3();

  			var uvA = new Vector2();
  			var uvB = new Vector2();
  			var uvC = new Vector2();

  			for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

  				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
  				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
  				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

  				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
  				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
  				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

  				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

  				var azi = azimuth( centroid );

  				correctUV( uvA, j + 0, a, azi );
  				correctUV( uvB, j + 2, b, azi );
  				correctUV( uvC, j + 4, c, azi );

  			}

  		}

  		function correctUV( uv, stride, vector, azimuth ) {

  			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

  				uvBuffer[ stride ] = uv.x - 1;

  			}

  			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

  				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

  			}

  		}

  		// Angle around the Y axis, counter-clockwise when looking from above.

  		function azimuth( vector ) {

  			return Math.atan2( vector.z, - vector.x );

  		}


  		// Angle above the XZ plane.

  		function inclination( vector ) {

  			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  		}

  	}

  	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

  	/**
  	 * @author timothypratley / https://github.com/timothypratley
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// TetrahedronGeometry

  	function TetrahedronGeometry( radius, detail ) {

  		Geometry.call( this );

  		this.type = 'TetrahedronGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
  		this.mergeVertices();

  	}

  	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
  	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

  	// TetrahedronBufferGeometry

  	function TetrahedronBufferGeometry( radius, detail ) {

  		var vertices = [
  			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
  		];

  		var indices = [
  			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
  		];

  		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  		this.type = 'TetrahedronBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  	}

  	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

  	/**
  	 * @author timothypratley / https://github.com/timothypratley
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// OctahedronGeometry

  	function OctahedronGeometry( radius, detail ) {

  		Geometry.call( this );

  		this.type = 'OctahedronGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
  		this.mergeVertices();

  	}

  	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
  	OctahedronGeometry.prototype.constructor = OctahedronGeometry;

  	// OctahedronBufferGeometry

  	function OctahedronBufferGeometry( radius, detail ) {

  		var vertices = [
  			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
  			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
  		];

  		var indices = [
  			0, 2, 4,	0, 4, 3,	0, 3, 5,
  			0, 5, 2,	1, 2, 5,	1, 5, 3,
  			1, 3, 4,	1, 4, 2
  		];

  		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  		this.type = 'OctahedronBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  	}

  	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

  	/**
  	 * @author timothypratley / https://github.com/timothypratley
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// IcosahedronGeometry

  	function IcosahedronGeometry( radius, detail ) {

  		Geometry.call( this );

  		this.type = 'IcosahedronGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
  		this.mergeVertices();

  	}

  	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
  	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

  	// IcosahedronBufferGeometry

  	function IcosahedronBufferGeometry( radius, detail ) {

  		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  		var vertices = [
  			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
  			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
  			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
  		];

  		var indices = [
  			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
  			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
  			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
  			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
  		];

  		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  		this.type = 'IcosahedronBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  	}

  	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

  	/**
  	 * @author Abe Pazos / https://hamoid.com
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// DodecahedronGeometry

  	function DodecahedronGeometry( radius, detail ) {

  		Geometry.call( this );

  		this.type = 'DodecahedronGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
  		this.mergeVertices();

  	}

  	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
  	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

  	// DodecahedronBufferGeometry

  	function DodecahedronBufferGeometry( radius, detail ) {

  		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  		var r = 1 / t;

  		var vertices = [

  			// (Â±1, Â±1, Â±1)
  			- 1, - 1, - 1,	- 1, - 1, 1,
  			- 1, 1, - 1, - 1, 1, 1,
  			1, - 1, - 1, 1, - 1, 1,
  			1, 1, - 1, 1, 1, 1,

  			// (0, Â±1/Ï†, Â±Ï†)
  			 0, - r, - t, 0, - r, t,
  			 0, r, - t, 0, r, t,

  			// (Â±1/Ï†, Â±Ï†, 0)
  			- r, - t, 0, - r, t, 0,
  			 r, - t, 0, r, t, 0,

  			// (Â±Ï†, 0, Â±1/Ï†)
  			- t, 0, - r, t, 0, - r,
  			- t, 0, r, t, 0, r
  		];

  		var indices = [
  			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
  			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
  			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
  			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
  			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
  			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
  			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
  			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
  			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
  			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
  			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
  			1, 12, 14, 	1, 14, 5, 	1, 5, 9
  		];

  		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

  		this.type = 'DodecahedronBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			detail: detail
  		};

  	}

  	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
  	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

  	/**
  	 * @author oosmoxiecode / https://github.com/oosmoxiecode
  	 * @author WestLangley / https://github.com/WestLangley
  	 * @author zz85 / https://github.com/zz85
  	 * @author miningold / https://github.com/miningold
  	 * @author jonobr1 / https://github.com/jonobr1
  	 * @author Mugen87 / https://github.com/Mugen87
  	 *
  	 */

  	// TubeGeometry

  	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

  		Geometry.call( this );

  		this.type = 'TubeGeometry';

  		this.parameters = {
  			path: path,
  			tubularSegments: tubularSegments,
  			radius: radius,
  			radialSegments: radialSegments,
  			closed: closed
  		};

  		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

  		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

  		// expose internals

  		this.tangents = bufferGeometry.tangents;
  		this.normals = bufferGeometry.normals;
  		this.binormals = bufferGeometry.binormals;

  		// create geometry

  		this.fromBufferGeometry( bufferGeometry );
  		this.mergeVertices();

  	}

  	TubeGeometry.prototype = Object.create( Geometry.prototype );
  	TubeGeometry.prototype.constructor = TubeGeometry;

  	// TubeBufferGeometry

  	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

  		BufferGeometry.call( this );

  		this.type = 'TubeBufferGeometry';

  		this.parameters = {
  			path: path,
  			tubularSegments: tubularSegments,
  			radius: radius,
  			radialSegments: radialSegments,
  			closed: closed
  		};

  		tubularSegments = tubularSegments || 64;
  		radius = radius || 1;
  		radialSegments = radialSegments || 8;
  		closed = closed || false;

  		var frames = path.computeFrenetFrames( tubularSegments, closed );

  		// expose internals

  		this.tangents = frames.tangents;
  		this.normals = frames.normals;
  		this.binormals = frames.binormals;

  		// helper variables

  		var vertex = new Vector3();
  		var normal = new Vector3();
  		var uv = new Vector2();
  		var P = new Vector3();

  		var i, j;

  		// buffer

  		var vertices = [];
  		var normals = [];
  		var uvs = [];
  		var indices = [];

  		// create buffer data

  		generateBufferData();

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		// functions

  		function generateBufferData() {

  			for ( i = 0; i < tubularSegments; i ++ ) {

  				generateSegment( i );

  			}

  			// if the geometry is not closed, generate the last row of vertices and normals
  			// at the regular position on the given path
  			//
  			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

  			generateSegment( ( closed === false ) ? tubularSegments : 0 );

  			// uvs are generated in a separate function.
  			// this makes it easy compute correct values for closed geometries

  			generateUVs();

  			// finally create faces

  			generateIndices();

  		}

  		function generateSegment( i ) {

  			// we use getPointAt to sample evenly distributed points from the given path

  			P = path.getPointAt( i / tubularSegments, P );

  			// retrieve corresponding normal and binormal

  			var N = frames.normals[ i ];
  			var B = frames.binormals[ i ];

  			// generate normals and vertices for the current segment

  			for ( j = 0; j <= radialSegments; j ++ ) {

  				var v = j / radialSegments * Math.PI * 2;

  				var sin = Math.sin( v );
  				var cos = - Math.cos( v );

  				// normal

  				normal.x = ( cos * N.x + sin * B.x );
  				normal.y = ( cos * N.y + sin * B.y );
  				normal.z = ( cos * N.z + sin * B.z );
  				normal.normalize();

  				normals.push( normal.x, normal.y, normal.z );

  				// vertex

  				vertex.x = P.x + radius * normal.x;
  				vertex.y = P.y + radius * normal.y;
  				vertex.z = P.z + radius * normal.z;

  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		}

  		function generateIndices() {

  			for ( j = 1; j <= tubularSegments; j ++ ) {

  				for ( i = 1; i <= radialSegments; i ++ ) {

  					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  					var b = ( radialSegments + 1 ) * j + ( i - 1 );
  					var c = ( radialSegments + 1 ) * j + i;
  					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  				}

  			}

  		}

  		function generateUVs() {

  			for ( i = 0; i <= tubularSegments; i ++ ) {

  				for ( j = 0; j <= radialSegments; j ++ ) {

  					uv.x = i / tubularSegments;
  					uv.y = j / radialSegments;

  					uvs.push( uv.x, uv.y );

  				}

  			}

  		}

  	}

  	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

  	TubeBufferGeometry.prototype.toJSON = function () {

  		var data = BufferGeometry.prototype.toJSON.call( this );

  		data.path = this.parameters.path.toJSON();

  		return data;

  	};

  	/**
  	 * @author oosmoxiecode
  	 * @author Mugen87 / https://github.com/Mugen87
  	 *
  	 * based on http://www.blackpawn.com/texts/pqtorus/
  	 */

  	// TorusKnotGeometry

  	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

  		Geometry.call( this );

  		this.type = 'TorusKnotGeometry';

  		this.parameters = {
  			radius: radius,
  			tube: tube,
  			tubularSegments: tubularSegments,
  			radialSegments: radialSegments,
  			p: p,
  			q: q
  		};

  		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

  		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
  		this.mergeVertices();

  	}

  	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
  	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

  	// TorusKnotBufferGeometry

  	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

  		BufferGeometry.call( this );

  		this.type = 'TorusKnotBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			tube: tube,
  			tubularSegments: tubularSegments,
  			radialSegments: radialSegments,
  			p: p,
  			q: q
  		};

  		radius = radius || 1;
  		tube = tube || 0.4;
  		tubularSegments = Math.floor( tubularSegments ) || 64;
  		radialSegments = Math.floor( radialSegments ) || 8;
  		p = p || 2;
  		q = q || 3;

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// helper variables

  		var i, j;

  		var vertex = new Vector3();
  		var normal = new Vector3();

  		var P1 = new Vector3();
  		var P2 = new Vector3();

  		var B = new Vector3();
  		var T = new Vector3();
  		var N = new Vector3();

  		// generate vertices, normals and uvs

  		for ( i = 0; i <= tubularSegments; ++ i ) {

  			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

  			var u = i / tubularSegments * p * Math.PI * 2;

  			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
  			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

  			calculatePositionOnCurve( u, p, q, radius, P1 );
  			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

  			// calculate orthonormal basis

  			T.subVectors( P2, P1 );
  			N.addVectors( P2, P1 );
  			B.crossVectors( T, N );
  			N.crossVectors( B, T );

  			// normalize B, N. T can be ignored, we don't use it

  			B.normalize();
  			N.normalize();

  			for ( j = 0; j <= radialSegments; ++ j ) {

  				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
  				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

  				var v = j / radialSegments * Math.PI * 2;
  				var cx = - tube * Math.cos( v );
  				var cy = tube * Math.sin( v );

  				// now calculate the final vertex position.
  				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

  				vertex.x = P1.x + ( cx * N.x + cy * B.x );
  				vertex.y = P1.y + ( cx * N.y + cy * B.y );
  				vertex.z = P1.z + ( cx * N.z + cy * B.z );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

  				normal.subVectors( vertex, P1 ).normalize();

  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( i / tubularSegments );
  				uvs.push( j / radialSegments );

  			}

  		}

  		// generate indices

  		for ( j = 1; j <= tubularSegments; j ++ ) {

  			for ( i = 1; i <= radialSegments; i ++ ) {

  				// indices

  				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  				var b = ( radialSegments + 1 ) * j + ( i - 1 );
  				var c = ( radialSegments + 1 ) * j + i;
  				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		// this function calculates the current position on the torus curve

  		function calculatePositionOnCurve( u, p, q, radius, position ) {

  			var cu = Math.cos( u );
  			var su = Math.sin( u );
  			var quOverP = q / p * u;
  			var cs = Math.cos( quOverP );

  			position.x = radius * ( 2 + cs ) * 0.5 * cu;
  			position.y = radius * ( 2 + cs ) * su * 0.5;
  			position.z = radius * Math.sin( quOverP ) * 0.5;

  		}

  	}

  	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

  	/**
  	 * @author oosmoxiecode
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// TorusGeometry

  	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

  		Geometry.call( this );

  		this.type = 'TorusGeometry';

  		this.parameters = {
  			radius: radius,
  			tube: tube,
  			radialSegments: radialSegments,
  			tubularSegments: tubularSegments,
  			arc: arc
  		};

  		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
  		this.mergeVertices();

  	}

  	TorusGeometry.prototype = Object.create( Geometry.prototype );
  	TorusGeometry.prototype.constructor = TorusGeometry;

  	// TorusBufferGeometry

  	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

  		BufferGeometry.call( this );

  		this.type = 'TorusBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			tube: tube,
  			radialSegments: radialSegments,
  			tubularSegments: tubularSegments,
  			arc: arc
  		};

  		radius = radius || 1;
  		tube = tube || 0.4;
  		radialSegments = Math.floor( radialSegments ) || 8;
  		tubularSegments = Math.floor( tubularSegments ) || 6;
  		arc = arc || Math.PI * 2;

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// helper variables

  		var center = new Vector3();
  		var vertex = new Vector3();
  		var normal = new Vector3();

  		var j, i;

  		// generate vertices, normals and uvs

  		for ( j = 0; j <= radialSegments; j ++ ) {

  			for ( i = 0; i <= tubularSegments; i ++ ) {

  				var u = i / tubularSegments * arc;
  				var v = j / radialSegments * Math.PI * 2;

  				// vertex

  				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
  				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
  				vertex.z = tube * Math.sin( v );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				center.x = radius * Math.cos( u );
  				center.y = radius * Math.sin( u );
  				normal.subVectors( vertex, center ).normalize();

  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( i / tubularSegments );
  				uvs.push( j / radialSegments );

  			}

  		}

  		// generate indices

  		for ( j = 1; j <= radialSegments; j ++ ) {

  			for ( i = 1; i <= tubularSegments; i ++ ) {

  				// indices

  				var a = ( tubularSegments + 1 ) * j + i - 1;
  				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
  				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
  				var d = ( tubularSegments + 1 ) * j + i;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

  	/**
  	 * @author Mugen87 / https://github.com/Mugen87
  	 * Port from https://github.com/mapbox/earcut (v2.1.2)
  	 */

  	var Earcut = {

  		triangulate: function ( data, holeIndices, dim ) {

  			dim = dim || 2;

  			var hasHoles = holeIndices && holeIndices.length,
  				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
  				outerNode = linkedList( data, 0, outerLen, dim, true ),
  				triangles = [];

  			if ( ! outerNode ) return triangles;

  			var minX, minY, maxX, maxY, x, y, invSize;

  			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

  			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

  			if ( data.length > 80 * dim ) {

  				minX = maxX = data[ 0 ];
  				minY = maxY = data[ 1 ];

  				for ( var i = dim; i < outerLen; i += dim ) {

  					x = data[ i ];
  					y = data[ i + 1 ];
  					if ( x < minX ) minX = x;
  					if ( y < minY ) minY = y;
  					if ( x > maxX ) maxX = x;
  					if ( y > maxY ) maxY = y;

  				}

  				// minX, minY and invSize are later used to transform coords into integers for z-order calculation

  				invSize = Math.max( maxX - minX, maxY - minY );
  				invSize = invSize !== 0 ? 1 / invSize : 0;

  			}

  			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

  			return triangles;

  		}

  	};

  	// create a circular doubly linked list from polygon points in the specified winding order

  	function linkedList( data, start, end, dim, clockwise ) {

  		var i, last;

  		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

  			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

  		} else {

  			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

  		}

  		if ( last && equals( last, last.next ) ) {

  			removeNode( last );
  			last = last.next;

  		}

  		return last;

  	}

  	// eliminate colinear or duplicate points

  	function filterPoints( start, end ) {

  		if ( ! start ) return start;
  		if ( ! end ) end = start;

  		var p = start, again;

  		do {

  			again = false;

  			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

  				removeNode( p );
  				p = end = p.prev;
  				if ( p === p.next ) break;
  				again = true;

  			} else {

  				p = p.next;

  			}

  		} while ( again || p !== end );

  		return end;

  	}

  	// main ear slicing loop which triangulates a polygon (given as a linked list)

  	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

  		if ( ! ear ) return;

  		// interlink polygon nodes in z-order

  		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

  		var stop = ear, prev, next;

  		// iterate through ears, slicing them one by one

  		while ( ear.prev !== ear.next ) {

  			prev = ear.prev;
  			next = ear.next;

  			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

  				// cut off the triangle
  				triangles.push( prev.i / dim );
  				triangles.push( ear.i / dim );
  				triangles.push( next.i / dim );

  				removeNode( ear );

  				// skipping the next vertice leads to less sliver triangles
  				ear = next.next;
  				stop = next.next;

  				continue;

  			}

  			ear = next;

  			// if we looped through the whole remaining polygon and can't find any more ears

  			if ( ear === stop ) {

  				// try filtering points and slicing again

  				if ( ! pass ) {

  					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

  					// if this didn't work, try curing all small self-intersections locally

  				} else if ( pass === 1 ) {

  					ear = cureLocalIntersections( ear, triangles, dim );
  					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

  					// as a last resort, try splitting the remaining polygon into two

  				} else if ( pass === 2 ) {

  					splitEarcut( ear, triangles, dim, minX, minY, invSize );

  				}

  				break;

  			}

  		}

  	}

  	// check whether a polygon node forms a valid ear with adjacent nodes

  	function isEar( ear ) {

  		var a = ear.prev,
  			b = ear,
  			c = ear.next;

  		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

  		// now make sure we don't have other points inside the potential ear
  		var p = ear.next.next;

  		while ( p !== ear.prev ) {

  			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {

  				return false;

  			}

  			p = p.next;

  		}

  		return true;

  	}

  	function isEarHashed( ear, minX, minY, invSize ) {

  		var a = ear.prev,
  			b = ear,
  			c = ear.next;

  		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

  		// triangle bbox; min & max are calculated like this for speed

  		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
  			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
  			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
  			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

  		// z-order range for the current triangle bbox;

  		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
  			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

  		// first look for points inside the triangle in increasing z-order

  		var p = ear.nextZ;

  		while ( p && p.z <= maxZ ) {

  			if ( p !== ear.prev && p !== ear.next &&
  					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
  					area( p.prev, p, p.next ) >= 0 ) return false;
  			p = p.nextZ;

  		}

  		// then look for points in decreasing z-order

  		p = ear.prevZ;

  		while ( p && p.z >= minZ ) {

  			if ( p !== ear.prev && p !== ear.next &&
  					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
  					area( p.prev, p, p.next ) >= 0 ) return false;

  			p = p.prevZ;

  		}

  		return true;

  	}

  	// go through all polygon nodes and cure small local self-intersections

  	function cureLocalIntersections( start, triangles, dim ) {

  		var p = start;

  		do {

  			var a = p.prev, b = p.next.next;

  			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

  				triangles.push( a.i / dim );
  				triangles.push( p.i / dim );
  				triangles.push( b.i / dim );

  				// remove two nodes involved

  				removeNode( p );
  				removeNode( p.next );

  				p = start = b;

  			}

  			p = p.next;

  		} while ( p !== start );

  		return p;

  	}

  	// try splitting polygon into two and triangulate them independently

  	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

  		// look for a valid diagonal that divides the polygon into two

  		var a = start;

  		do {

  			var b = a.next.next;

  			while ( b !== a.prev ) {

  				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

  					// split the polygon in two by the diagonal

  					var c = splitPolygon( a, b );

  					// filter colinear points around the cuts

  					a = filterPoints( a, a.next );
  					c = filterPoints( c, c.next );

  					// run earcut on each half

  					earcutLinked( a, triangles, dim, minX, minY, invSize );
  					earcutLinked( c, triangles, dim, minX, minY, invSize );
  					return;

  				}

  				b = b.next;

  			}

  			a = a.next;

  		} while ( a !== start );

  	}

  	// link every hole into the outer loop, producing a single-ring polygon without holes

  	function eliminateHoles( data, holeIndices, outerNode, dim ) {

  		var queue = [], i, len, start, end, list;

  		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

  			start = holeIndices[ i ] * dim;
  			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
  			list = linkedList( data, start, end, dim, false );
  			if ( list === list.next ) list.steiner = true;
  			queue.push( getLeftmost( list ) );

  		}

  		queue.sort( compareX );

  		// process holes from left to right

  		for ( i = 0; i < queue.length; i ++ ) {

  			eliminateHole( queue[ i ], outerNode );
  			outerNode = filterPoints( outerNode, outerNode.next );

  		}

  		return outerNode;

  	}

  	function compareX( a, b ) {

  		return a.x - b.x;

  	}

  	// find a bridge between vertices that connects hole with an outer ring and and link it

  	function eliminateHole( hole, outerNode ) {

  		outerNode = findHoleBridge( hole, outerNode );

  		if ( outerNode ) {

  			var b = splitPolygon( outerNode, hole );

  			filterPoints( b, b.next );

  		}

  	}

  	// David Eberly's algorithm for finding a bridge between hole and outer polygon

  	function findHoleBridge( hole, outerNode ) {

  		var p = outerNode,
  			hx = hole.x,
  			hy = hole.y,
  			qx = - Infinity,
  			m;

  		// find a segment intersected by a ray from the hole's leftmost point to the left;
  		// segment's endpoint with lesser x will be potential connection point

  		do {

  			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

  				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );

  				if ( x <= hx && x > qx ) {

  					qx = x;

  					if ( x === hx ) {

  						if ( hy === p.y ) return p;
  						if ( hy === p.next.y ) return p.next;

  					}

  					m = p.x < p.next.x ? p : p.next;

  				}

  			}

  			p = p.next;

  		} while ( p !== outerNode );

  		if ( ! m ) return null;

  		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

  		// look for points inside the triangle of hole point, segment intersection and endpoint;
  		// if there are no points found, we have a valid connection;
  		// otherwise choose the point of the minimum angle with the ray as connection point

  		var stop = m,
  			mx = m.x,
  			my = m.y,
  			tanMin = Infinity,
  			tan;

  		p = m.next;

  		while ( p !== stop ) {

  			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
  							pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

  				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

  				if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

  					m = p;
  					tanMin = tan;

  				}

  			}

  			p = p.next;

  		}

  		return m;

  	}

  	// interlink polygon nodes in z-order

  	function indexCurve( start, minX, minY, invSize ) {

  		var p = start;

  		do {

  			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
  			p.prevZ = p.prev;
  			p.nextZ = p.next;
  			p = p.next;

  		} while ( p !== start );

  		p.prevZ.nextZ = null;
  		p.prevZ = null;

  		sortLinked( p );

  	}

  	// Simon Tatham's linked list merge sort algorithm
  	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

  	function sortLinked( list ) {

  		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;

  		do {

  			p = list;
  			list = null;
  			tail = null;
  			numMerges = 0;

  			while ( p ) {

  				numMerges ++;
  				q = p;
  				pSize = 0;

  				for ( i = 0; i < inSize; i ++ ) {

  					pSize ++;
  					q = q.nextZ;
  					if ( ! q ) break;

  				}

  				qSize = inSize;

  				while ( pSize > 0 || ( qSize > 0 && q ) ) {

  					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

  						e = p;
  						p = p.nextZ;
  						pSize --;

  					} else {

  						e = q;
  						q = q.nextZ;
  						qSize --;

  					}

  					if ( tail ) tail.nextZ = e;
  					else list = e;

  					e.prevZ = tail;
  					tail = e;

  				}

  				p = q;

  			}

  			tail.nextZ = null;
  			inSize *= 2;

  		} while ( numMerges > 1 );

  		return list;

  	}

  	// z-order of a point given coords and inverse of the longer side of data bbox

  	function zOrder( x, y, minX, minY, invSize ) {

  		// coords are transformed into non-negative 15-bit integer range

  		x = 32767 * ( x - minX ) * invSize;
  		y = 32767 * ( y - minY ) * invSize;

  		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
  		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
  		x = ( x | ( x << 2 ) ) & 0x33333333;
  		x = ( x | ( x << 1 ) ) & 0x55555555;

  		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
  		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
  		y = ( y | ( y << 2 ) ) & 0x33333333;
  		y = ( y | ( y << 1 ) ) & 0x55555555;

  		return x | ( y << 1 );

  	}

  	// find the leftmost node of a polygon ring

  	function getLeftmost( start ) {

  		var p = start, leftmost = start;

  		do {

  			if ( p.x < leftmost.x ) leftmost = p;
  			p = p.next;

  		} while ( p !== start );

  		return leftmost;

  	}

  	// check if a point lies within a convex triangle

  	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

  		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
  		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
  		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

  	}

  	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

  	function isValidDiagonal( a, b ) {

  		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
  			locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

  	}

  	// signed area of a triangle

  	function area( p, q, r ) {

  		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

  	}

  	// check if two points are equal

  	function equals( p1, p2 ) {

  		return p1.x === p2.x && p1.y === p2.y;

  	}

  	// check if two segments intersect

  	function intersects( p1, q1, p2, q2 ) {

  		if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
  				( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;

  		return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
  					 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

  	}

  	// check if a polygon diagonal intersects any polygon segments

  	function intersectsPolygon( a, b ) {

  		var p = a;

  		do {

  			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
  							intersects( p, p.next, a, b ) ) {

  				return true;

  			}

  			p = p.next;

  		} while ( p !== a );

  		return false;

  	}

  	// check if a polygon diagonal is locally inside the polygon

  	function locallyInside( a, b ) {

  		return area( a.prev, a, a.next ) < 0 ?
  			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
  			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

  	}

  	// check if the middle point of a polygon diagonal is inside the polygon

  	function middleInside( a, b ) {

  		var p = a,
  			inside = false,
  			px = ( a.x + b.x ) / 2,
  			py = ( a.y + b.y ) / 2;

  		do {

  			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
  							( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {

  				inside = ! inside;

  			}

  			p = p.next;

  		} while ( p !== a );

  		return inside;

  	}

  	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  	// if one belongs to the outer ring and another to a hole, it merges it into a single ring

  	function splitPolygon( a, b ) {

  		var a2 = new Node( a.i, a.x, a.y ),
  			b2 = new Node( b.i, b.x, b.y ),
  			an = a.next,
  			bp = b.prev;

  		a.next = b;
  		b.prev = a;

  		a2.next = an;
  		an.prev = a2;

  		b2.next = a2;
  		a2.prev = b2;

  		bp.next = b2;
  		b2.prev = bp;

  		return b2;

  	}

  	// create a node and optionally link it with previous one (in a circular doubly linked list)

  	function insertNode( i, x, y, last ) {

  		var p = new Node( i, x, y );

  		if ( ! last ) {

  			p.prev = p;
  			p.next = p;

  		} else {

  			p.next = last.next;
  			p.prev = last;
  			last.next.prev = p;
  			last.next = p;

  		}

  		return p;

  	}

  	function removeNode( p ) {

  		p.next.prev = p.prev;
  		p.prev.next = p.next;

  		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
  		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

  	}

  	function Node( i, x, y ) {

  		// vertice index in coordinates array
  		this.i = i;

  		// vertex coordinates
  		this.x = x;
  		this.y = y;

  		// previous and next vertice nodes in a polygon ring
  		this.prev = null;
  		this.next = null;

  		// z-order curve value
  		this.z = null;

  		// previous and next nodes in z-order
  		this.prevZ = null;
  		this.nextZ = null;

  		// indicates whether this is a steiner point
  		this.steiner = false;

  	}

  	function signedArea( data, start, end, dim ) {

  		var sum = 0;

  		for ( var i = start, j = end - dim; i < end; i += dim ) {

  			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
  			j = i;

  		}

  		return sum;

  	}

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 */

  	var ShapeUtils = {

  		// calculate area of the contour polygon

  		area: function ( contour ) {

  			var n = contour.length;
  			var a = 0.0;

  			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

  				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

  			}

  			return a * 0.5;

  		},

  		isClockWise: function ( pts ) {

  			return ShapeUtils.area( pts ) < 0;

  		},

  		triangulateShape: function ( contour, holes ) {

  			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
  			var holeIndices = []; // array of hole indices
  			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

  			removeDupEndPts( contour );
  			addContour( vertices, contour );

  			//

  			var holeIndex = contour.length;

  			holes.forEach( removeDupEndPts );

  			for ( var i = 0; i < holes.length; i ++ ) {

  				holeIndices.push( holeIndex );
  				holeIndex += holes[ i ].length;
  				addContour( vertices, holes[ i ] );

  			}

  			//

  			var triangles = Earcut.triangulate( vertices, holeIndices );

  			//

  			for ( var i = 0; i < triangles.length; i += 3 ) {

  				faces.push( triangles.slice( i, i + 3 ) );

  			}

  			return faces;

  		}

  	};

  	function removeDupEndPts( points ) {

  		var l = points.length;

  		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

  			points.pop();

  		}

  	}

  	function addContour( vertices, contour ) {

  		for ( var i = 0; i < contour.length; i ++ ) {

  			vertices.push( contour[ i ].x );
  			vertices.push( contour[ i ].y );

  		}

  	}

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 *
  	 * Creates extruded geometry from a path shape.
  	 *
  	 * parameters = {
  	 *
  	 *  curveSegments: <int>, // number of points on the curves
  	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
  	 *  depth: <float>, // Depth to extrude the shape
  	 *
  	 *  bevelEnabled: <bool>, // turn on bevel
  	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
  	 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
  	 *  bevelOffset: <float>, // how far from shape outline does bevel start
  	 *  bevelSegments: <int>, // number of bevel layers
  	 *
  	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
  	 *
  	 *  UVGenerator: <Object> // object that provides UV generator functions
  	 *
  	 * }
  	 */

  	// ExtrudeGeometry

  	function ExtrudeGeometry( shapes, options ) {

  		Geometry.call( this );

  		this.type = 'ExtrudeGeometry';

  		this.parameters = {
  			shapes: shapes,
  			options: options
  		};

  		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
  		this.mergeVertices();

  	}

  	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
  	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

  	ExtrudeGeometry.prototype.toJSON = function () {

  		var data = Geometry.prototype.toJSON.call( this );

  		var shapes = this.parameters.shapes;
  		var options = this.parameters.options;

  		return toJSON( shapes, options, data );

  	};

  	// ExtrudeBufferGeometry

  	function ExtrudeBufferGeometry( shapes, options ) {

  		BufferGeometry.call( this );

  		this.type = 'ExtrudeBufferGeometry';

  		this.parameters = {
  			shapes: shapes,
  			options: options
  		};

  		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  		var scope = this;

  		var verticesArray = [];
  		var uvArray = [];

  		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

  			var shape = shapes[ i ];
  			addShape( shape );

  		}

  		// build geometry

  		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

  		this.computeVertexNormals();

  		// functions

  		function addShape( shape ) {

  			var placeholder = [];

  			// options

  			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
  			var steps = options.steps !== undefined ? options.steps : 1;
  			var depth = options.depth !== undefined ? options.depth : 100;

  			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
  			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
  			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
  			var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
  			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  			var extrudePath = options.extrudePath;

  			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

  			// deprecated options

  			if ( options.amount !== undefined ) {

  				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
  				depth = options.amount;

  			}

  			//

  			var extrudePts, extrudeByPath = false;
  			var splineTube, binormal, normal, position2;

  			if ( extrudePath ) {

  				extrudePts = extrudePath.getSpacedPoints( steps );

  				extrudeByPath = true;
  				bevelEnabled = false; // bevels not supported for path extrusion

  				// SETUP TNB variables

  				// TODO1 - have a .isClosed in spline?

  				splineTube = extrudePath.computeFrenetFrames( steps, false );

  				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

  				binormal = new Vector3();
  				normal = new Vector3();
  				position2 = new Vector3();

  			}

  			// Safeguards if bevels are not enabled

  			if ( ! bevelEnabled ) {

  				bevelSegments = 0;
  				bevelThickness = 0;
  				bevelSize = 0;
  				bevelOffset = 0;

  			}

  			// Variables initialization

  			var ahole, h, hl; // looping of holes

  			var shapePoints = shape.extractPoints( curveSegments );

  			var vertices = shapePoints.shape;
  			var holes = shapePoints.holes;

  			var reverse = ! ShapeUtils.isClockWise( vertices );

  			if ( reverse ) {

  				vertices = vertices.reverse();

  				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

  				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  					ahole = holes[ h ];

  					if ( ShapeUtils.isClockWise( ahole ) ) {

  						holes[ h ] = ahole.reverse();

  					}

  				}

  			}


  			var faces = ShapeUtils.triangulateShape( vertices, holes );

  			/* Vertices */

  			var contour = vertices; // vertices has all points but contour has only points of circumference

  			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  				ahole = holes[ h ];

  				vertices = vertices.concat( ahole );

  			}


  			function scalePt2( pt, vec, size ) {

  				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

  				return vec.clone().multiplyScalar( size ).add( pt );

  			}

  			var b, bs, t, z,
  				vert, vlen = vertices.length,
  				face, flen = faces.length;


  			// Find directions for point movement


  			function getBevelVec( inPt, inPrev, inNext ) {

  				// computes for inPt the corresponding point inPt' on a new contour
  				//   shifted by 1 unit (length of normalized vector) to the left
  				// if we walk along contour clockwise, this new contour is outside the old one
  				//
  				// inPt' is the intersection of the two lines parallel to the two
  				//  adjacent edges of inPt at a distance of 1 unit on the left side.

  				var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

  				// good reading for geometry algorithms (here: line-line intersection)
  				// http://geomalgorithms.com/a05-_intersect-1.html

  				var v_prev_x = inPt.x - inPrev.x,
  					v_prev_y = inPt.y - inPrev.y;
  				var v_next_x = inNext.x - inPt.x,
  					v_next_y = inNext.y - inPt.y;

  				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

  				// check for collinear edges
  				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

  				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

  					// not collinear

  					// length of vectors for normalizing

  					var v_prev_len = Math.sqrt( v_prev_lensq );
  					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

  					// shift adjacent points by unit vectors to the left

  					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
  					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

  					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
  					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

  					// scaling factor for v_prev to intersection point

  					var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
  							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
  						( v_prev_x * v_next_y - v_prev_y * v_next_x );

  					// vector from inPt to intersection point

  					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
  					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

  					// Don't normalize!, otherwise sharp corners become ugly
  					//  but prevent crazy spikes
  					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
  					if ( v_trans_lensq <= 2 ) {

  						return new Vector2( v_trans_x, v_trans_y );

  					} else {

  						shrink_by = Math.sqrt( v_trans_lensq / 2 );

  					}

  				} else {

  					// handle special case of collinear edges

  					var direction_eq = false; // assumes: opposite
  					if ( v_prev_x > Number.EPSILON ) {

  						if ( v_next_x > Number.EPSILON ) {

  							direction_eq = true;

  						}

  					} else {

  						if ( v_prev_x < - Number.EPSILON ) {

  							if ( v_next_x < - Number.EPSILON ) {

  								direction_eq = true;

  							}

  						} else {

  							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

  								direction_eq = true;

  							}

  						}

  					}

  					if ( direction_eq ) {

  						// console.log("Warning: lines are a straight sequence");
  						v_trans_x = - v_prev_y;
  						v_trans_y = v_prev_x;
  						shrink_by = Math.sqrt( v_prev_lensq );

  					} else {

  						// console.log("Warning: lines are a straight spike");
  						v_trans_x = v_prev_x;
  						v_trans_y = v_prev_y;
  						shrink_by = Math.sqrt( v_prev_lensq / 2 );

  					}

  				}

  				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  			}


  			var contourMovements = [];

  			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  				if ( j === il ) j = 0;
  				if ( k === il ) k = 0;

  				//  (j)---(i)---(k)
  				// console.log('i,j,k', i, j , k)

  				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  			}

  			var holesMovements = [],
  				oneHoleMovements, verticesMovements = contourMovements.concat();

  			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  				ahole = holes[ h ];

  				oneHoleMovements = [];

  				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  					if ( j === il ) j = 0;
  					if ( k === il ) k = 0;

  					//  (j)---(i)---(k)
  					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

  				}

  				holesMovements.push( oneHoleMovements );
  				verticesMovements = verticesMovements.concat( oneHoleMovements );

  			}


  			// Loop bevelSegments, 1 for the front, 1 for the back

  			for ( b = 0; b < bevelSegments; b ++ ) {

  				//for ( b = bevelSegments; b > 0; b -- ) {

  				t = b / bevelSegments;
  				z = bevelThickness * Math.cos( t * Math.PI / 2 );
  				bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

  				// contract shape

  				for ( i = 0, il = contour.length; i < il; i ++ ) {

  					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

  					v( vert.x, vert.y, - z );

  				}

  				// expand holes

  				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  					ahole = holes[ h ];
  					oneHoleMovements = holesMovements[ h ];

  					for ( i = 0, il = ahole.length; i < il; i ++ ) {

  						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  						v( vert.x, vert.y, - z );

  					}

  				}

  			}

  			bs = bevelSize + bevelOffset;

  			// Back facing vertices

  			for ( i = 0; i < vlen; i ++ ) {

  				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  				if ( ! extrudeByPath ) {

  					v( vert.x, vert.y, 0 );

  				} else {

  					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

  					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
  					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

  					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

  					v( position2.x, position2.y, position2.z );

  				}

  			}

  			// Add stepped vertices...
  			// Including front facing vertices

  			var s;

  			for ( s = 1; s <= steps; s ++ ) {

  				for ( i = 0; i < vlen; i ++ ) {

  					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  					if ( ! extrudeByPath ) {

  						v( vert.x, vert.y, depth / steps * s );

  					} else {

  						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

  						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
  						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

  						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

  						v( position2.x, position2.y, position2.z );

  					}

  				}

  			}


  			// Add bevel segments planes

  			//for ( b = 1; b <= bevelSegments; b ++ ) {
  			for ( b = bevelSegments - 1; b >= 0; b -- ) {

  				t = b / bevelSegments;
  				z = bevelThickness * Math.cos( t * Math.PI / 2 );
  				bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

  				// contract shape

  				for ( i = 0, il = contour.length; i < il; i ++ ) {

  					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
  					v( vert.x, vert.y, depth + z );

  				}

  				// expand holes

  				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  					ahole = holes[ h ];
  					oneHoleMovements = holesMovements[ h ];

  					for ( i = 0, il = ahole.length; i < il; i ++ ) {

  						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  						if ( ! extrudeByPath ) {

  							v( vert.x, vert.y, depth + z );

  						} else {

  							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

  						}

  					}

  				}

  			}

  			/* Faces */

  			// Top and bottom faces

  			buildLidFaces();

  			// Sides faces

  			buildSideFaces();


  			/////  Internal functions

  			function buildLidFaces() {

  				var start = verticesArray.length / 3;

  				if ( bevelEnabled ) {

  					var layer = 0; // steps + 1
  					var offset = vlen * layer;

  					// Bottom faces

  					for ( i = 0; i < flen; i ++ ) {

  						face = faces[ i ];
  						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

  					}

  					layer = steps + bevelSegments * 2;
  					offset = vlen * layer;

  					// Top faces

  					for ( i = 0; i < flen; i ++ ) {

  						face = faces[ i ];
  						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

  					}

  				} else {

  					// Bottom faces

  					for ( i = 0; i < flen; i ++ ) {

  						face = faces[ i ];
  						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

  					}

  					// Top faces

  					for ( i = 0; i < flen; i ++ ) {

  						face = faces[ i ];
  						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

  					}

  				}

  				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

  			}

  			// Create faces for the z-sides of the shape

  			function buildSideFaces() {

  				var start = verticesArray.length / 3;
  				var layeroffset = 0;
  				sidewalls( contour, layeroffset );
  				layeroffset += contour.length;

  				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  					ahole = holes[ h ];
  					sidewalls( ahole, layeroffset );

  					//, true
  					layeroffset += ahole.length;

  				}


  				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


  			}

  			function sidewalls( contour, layeroffset ) {

  				var j, k;
  				i = contour.length;

  				while ( -- i >= 0 ) {

  					j = i;
  					k = i - 1;
  					if ( k < 0 ) k = contour.length - 1;

  					//console.log('b', i,j, i-1, k,vertices.length);

  					var s = 0,
  						sl = steps + bevelSegments * 2;

  					for ( s = 0; s < sl; s ++ ) {

  						var slen1 = vlen * s;
  						var slen2 = vlen * ( s + 1 );

  						var a = layeroffset + j + slen1,
  							b = layeroffset + k + slen1,
  							c = layeroffset + k + slen2,
  							d = layeroffset + j + slen2;

  						f4( a, b, c, d );

  					}

  				}

  			}

  			function v( x, y, z ) {

  				placeholder.push( x );
  				placeholder.push( y );
  				placeholder.push( z );

  			}


  			function f3( a, b, c ) {

  				addVertex( a );
  				addVertex( b );
  				addVertex( c );

  				var nextIndex = verticesArray.length / 3;
  				var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  				addUV( uvs[ 0 ] );
  				addUV( uvs[ 1 ] );
  				addUV( uvs[ 2 ] );

  			}

  			function f4( a, b, c, d ) {

  				addVertex( a );
  				addVertex( b );
  				addVertex( d );

  				addVertex( b );
  				addVertex( c );
  				addVertex( d );


  				var nextIndex = verticesArray.length / 3;
  				var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  				addUV( uvs[ 0 ] );
  				addUV( uvs[ 1 ] );
  				addUV( uvs[ 3 ] );

  				addUV( uvs[ 1 ] );
  				addUV( uvs[ 2 ] );
  				addUV( uvs[ 3 ] );

  			}

  			function addVertex( index ) {

  				verticesArray.push( placeholder[ index * 3 + 0 ] );
  				verticesArray.push( placeholder[ index * 3 + 1 ] );
  				verticesArray.push( placeholder[ index * 3 + 2 ] );

  			}


  			function addUV( vector2 ) {

  				uvArray.push( vector2.x );
  				uvArray.push( vector2.y );

  			}

  		}

  	}

  	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

  	ExtrudeBufferGeometry.prototype.toJSON = function () {

  		var data = BufferGeometry.prototype.toJSON.call( this );

  		var shapes = this.parameters.shapes;
  		var options = this.parameters.options;

  		return toJSON( shapes, options, data );

  	};

  	//

  	var WorldUVGenerator = {

  		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

  			var a_x = vertices[ indexA * 3 ];
  			var a_y = vertices[ indexA * 3 + 1 ];
  			var b_x = vertices[ indexB * 3 ];
  			var b_y = vertices[ indexB * 3 + 1 ];
  			var c_x = vertices[ indexC * 3 ];
  			var c_y = vertices[ indexC * 3 + 1 ];

  			return [
  				new Vector2( a_x, a_y ),
  				new Vector2( b_x, b_y ),
  				new Vector2( c_x, c_y )
  			];

  		},

  		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

  			var a_x = vertices[ indexA * 3 ];
  			var a_y = vertices[ indexA * 3 + 1 ];
  			var a_z = vertices[ indexA * 3 + 2 ];
  			var b_x = vertices[ indexB * 3 ];
  			var b_y = vertices[ indexB * 3 + 1 ];
  			var b_z = vertices[ indexB * 3 + 2 ];
  			var c_x = vertices[ indexC * 3 ];
  			var c_y = vertices[ indexC * 3 + 1 ];
  			var c_z = vertices[ indexC * 3 + 2 ];
  			var d_x = vertices[ indexD * 3 ];
  			var d_y = vertices[ indexD * 3 + 1 ];
  			var d_z = vertices[ indexD * 3 + 2 ];

  			if ( Math.abs( a_y - b_y ) < 0.01 ) {

  				return [
  					new Vector2( a_x, 1 - a_z ),
  					new Vector2( b_x, 1 - b_z ),
  					new Vector2( c_x, 1 - c_z ),
  					new Vector2( d_x, 1 - d_z )
  				];

  			} else {

  				return [
  					new Vector2( a_y, 1 - a_z ),
  					new Vector2( b_y, 1 - b_z ),
  					new Vector2( c_y, 1 - c_z ),
  					new Vector2( d_y, 1 - d_z )
  				];

  			}

  		}
  	};

  	function toJSON( shapes, options, data ) {

  		//

  		data.shapes = [];

  		if ( Array.isArray( shapes ) ) {

  			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

  				var shape = shapes[ i ];

  				data.shapes.push( shape.uuid );

  			}

  		} else {

  			data.shapes.push( shapes.uuid );

  		}

  		//

  		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

  		return data;

  	}

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * Text = 3D Text
  	 *
  	 * parameters = {
  	 *  font: <THREE.Font>, // font
  	 *
  	 *  size: <float>, // size of the text
  	 *  height: <float>, // thickness to extrude text
  	 *  curveSegments: <int>, // number of points on the curves
  	 *
  	 *  bevelEnabled: <bool>, // turn on bevel
  	 *  bevelThickness: <float>, // how deep into text bevel goes
  	 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
  	 *  bevelOffset: <float> // how far from text outline does bevel start
  	 * }
  	 */

  	// TextGeometry

  	function TextGeometry( text, parameters ) {

  		Geometry.call( this );

  		this.type = 'TextGeometry';

  		this.parameters = {
  			text: text,
  			parameters: parameters
  		};

  		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
  		this.mergeVertices();

  	}

  	TextGeometry.prototype = Object.create( Geometry.prototype );
  	TextGeometry.prototype.constructor = TextGeometry;

  	// TextBufferGeometry

  	function TextBufferGeometry( text, parameters ) {

  		parameters = parameters || {};

  		var font = parameters.font;

  		if ( ! ( font && font.isFont ) ) {

  			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
  			return new Geometry();

  		}

  		var shapes = font.generateShapes( text, parameters.size );

  		// translate parameters to ExtrudeGeometry API

  		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

  		// defaults

  		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
  		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
  		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

  		ExtrudeBufferGeometry.call( this, shapes, parameters );

  		this.type = 'TextBufferGeometry';

  	}

  	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
  	TextBufferGeometry.prototype.constructor = TextBufferGeometry;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author benaadams / https://twitter.com/ben_a_adams
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// SphereGeometry

  	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  		Geometry.call( this );

  		this.type = 'SphereGeometry';

  		this.parameters = {
  			radius: radius,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			phiStart: phiStart,
  			phiLength: phiLength,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
  		this.mergeVertices();

  	}

  	SphereGeometry.prototype = Object.create( Geometry.prototype );
  	SphereGeometry.prototype.constructor = SphereGeometry;

  	// SphereBufferGeometry

  	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  		BufferGeometry.call( this );

  		this.type = 'SphereBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			widthSegments: widthSegments,
  			heightSegments: heightSegments,
  			phiStart: phiStart,
  			phiLength: phiLength,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		radius = radius || 1;

  		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  		phiStart = phiStart !== undefined ? phiStart : 0;
  		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  		thetaStart = thetaStart !== undefined ? thetaStart : 0;
  		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  		var thetaEnd = thetaStart + thetaLength;

  		var ix, iy;

  		var index = 0;
  		var grid = [];

  		var vertex = new Vector3();
  		var normal = new Vector3();

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// generate vertices, normals and uvs

  		for ( iy = 0; iy <= heightSegments; iy ++ ) {

  			var verticesRow = [];

  			var v = iy / heightSegments;

  			// special case for the poles

  			var uOffset = ( iy == 0 ) ? 0.5 / widthSegments : ( ( iy == heightSegments ) ? - 0.5 / widthSegments : 0 );

  			for ( ix = 0; ix <= widthSegments; ix ++ ) {

  				var u = ix / widthSegments;

  				// vertex

  				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
  				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
  				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normal.copy( vertex ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u + uOffset, 1 - v );

  				verticesRow.push( index ++ );

  			}

  			grid.push( verticesRow );

  		}

  		// indices

  		for ( iy = 0; iy < heightSegments; iy ++ ) {

  			for ( ix = 0; ix < widthSegments; ix ++ ) {

  				var a = grid[ iy ][ ix + 1 ];
  				var b = grid[ iy ][ ix ];
  				var c = grid[ iy + 1 ][ ix ];
  				var d = grid[ iy + 1 ][ ix + 1 ];

  				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
  				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

  	/**
  	 * @author Kaleb Murphy
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// RingGeometry

  	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  		Geometry.call( this );

  		this.type = 'RingGeometry';

  		this.parameters = {
  			innerRadius: innerRadius,
  			outerRadius: outerRadius,
  			thetaSegments: thetaSegments,
  			phiSegments: phiSegments,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
  		this.mergeVertices();

  	}

  	RingGeometry.prototype = Object.create( Geometry.prototype );
  	RingGeometry.prototype.constructor = RingGeometry;

  	// RingBufferGeometry

  	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  		BufferGeometry.call( this );

  		this.type = 'RingBufferGeometry';

  		this.parameters = {
  			innerRadius: innerRadius,
  			outerRadius: outerRadius,
  			thetaSegments: thetaSegments,
  			phiSegments: phiSegments,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		innerRadius = innerRadius || 0.5;
  		outerRadius = outerRadius || 1;

  		thetaStart = thetaStart !== undefined ? thetaStart : 0;
  		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// some helper variables

  		var segment;
  		var radius = innerRadius;
  		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
  		var vertex = new Vector3();
  		var uv = new Vector2();
  		var j, i;

  		// generate vertices, normals and uvs

  		for ( j = 0; j <= phiSegments; j ++ ) {

  			for ( i = 0; i <= thetaSegments; i ++ ) {

  				// values are generate from the inside of the ring to the outside

  				segment = thetaStart + i / thetaSegments * thetaLength;

  				// vertex

  				vertex.x = radius * Math.cos( segment );
  				vertex.y = radius * Math.sin( segment );

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normals.push( 0, 0, 1 );

  				// uv

  				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
  				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

  				uvs.push( uv.x, uv.y );

  			}

  			// increase the radius for next row of vertices

  			radius += radiusStep;

  		}

  		// indices

  		for ( j = 0; j < phiSegments; j ++ ) {

  			var thetaSegmentLevel = j * ( thetaSegments + 1 );

  			for ( i = 0; i < thetaSegments; i ++ ) {

  				segment = i + thetaSegmentLevel;

  				var a = segment;
  				var b = segment + thetaSegments + 1;
  				var c = segment + thetaSegments + 2;
  				var d = segment + 1;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	RingBufferGeometry.prototype.constructor = RingBufferGeometry;

  	/**
  	 * @author zz85 / https://github.com/zz85
  	 * @author bhouston / http://clara.io
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// LatheGeometry

  	function LatheGeometry( points, segments, phiStart, phiLength ) {

  		Geometry.call( this );

  		this.type = 'LatheGeometry';

  		this.parameters = {
  			points: points,
  			segments: segments,
  			phiStart: phiStart,
  			phiLength: phiLength
  		};

  		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
  		this.mergeVertices();

  	}

  	LatheGeometry.prototype = Object.create( Geometry.prototype );
  	LatheGeometry.prototype.constructor = LatheGeometry;

  	// LatheBufferGeometry

  	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

  		BufferGeometry.call( this );

  		this.type = 'LatheBufferGeometry';

  		this.parameters = {
  			points: points,
  			segments: segments,
  			phiStart: phiStart,
  			phiLength: phiLength
  		};

  		segments = Math.floor( segments ) || 12;
  		phiStart = phiStart || 0;
  		phiLength = phiLength || Math.PI * 2;

  		// clamp phiLength so it's in range of [ 0, 2PI ]

  		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


  		// buffers

  		var indices = [];
  		var vertices = [];
  		var uvs = [];

  		// helper variables

  		var base;
  		var inverseSegments = 1.0 / segments;
  		var vertex = new Vector3();
  		var uv = new Vector2();
  		var i, j;

  		// generate vertices and uvs

  		for ( i = 0; i <= segments; i ++ ) {

  			var phi = phiStart + i * inverseSegments * phiLength;

  			var sin = Math.sin( phi );
  			var cos = Math.cos( phi );

  			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

  				// vertex

  				vertex.x = points[ j ].x * sin;
  				vertex.y = points[ j ].y;
  				vertex.z = points[ j ].x * cos;

  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// uv

  				uv.x = i / segments;
  				uv.y = j / ( points.length - 1 );

  				uvs.push( uv.x, uv.y );


  			}

  		}

  		// indices

  		for ( i = 0; i < segments; i ++ ) {

  			for ( j = 0; j < ( points.length - 1 ); j ++ ) {

  				base = j + i * points.length;

  				var a = base;
  				var b = base + points.length;
  				var c = base + points.length + 1;
  				var d = base + 1;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		// generate normals

  		this.computeVertexNormals();

  		// if the geometry is closed, we need to average the normals along the seam.
  		// because the corresponding vertices are identical (but still have different UVs).

  		if ( phiLength === Math.PI * 2 ) {

  			var normals = this.attributes.normal.array;
  			var n1 = new Vector3();
  			var n2 = new Vector3();
  			var n = new Vector3();

  			// this is the buffer offset for the last line of vertices

  			base = segments * points.length * 3;

  			for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

  				// select the normal of the vertex in the first line

  				n1.x = normals[ j + 0 ];
  				n1.y = normals[ j + 1 ];
  				n1.z = normals[ j + 2 ];

  				// select the normal of the vertex in the last line

  				n2.x = normals[ base + j + 0 ];
  				n2.y = normals[ base + j + 1 ];
  				n2.z = normals[ base + j + 2 ];

  				// average normals

  				n.addVectors( n1, n2 ).normalize();

  				// assign the new values to both normals

  				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
  				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
  				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

  			}

  		}

  	}

  	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

  	/**
  	 * @author jonobr1 / http://jonobr1.com
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// ShapeGeometry

  	function ShapeGeometry( shapes, curveSegments ) {

  		Geometry.call( this );

  		this.type = 'ShapeGeometry';

  		if ( typeof curveSegments === 'object' ) {

  			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

  			curveSegments = curveSegments.curveSegments;

  		}

  		this.parameters = {
  			shapes: shapes,
  			curveSegments: curveSegments
  		};

  		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
  		this.mergeVertices();

  	}

  	ShapeGeometry.prototype = Object.create( Geometry.prototype );
  	ShapeGeometry.prototype.constructor = ShapeGeometry;

  	ShapeGeometry.prototype.toJSON = function () {

  		var data = Geometry.prototype.toJSON.call( this );

  		var shapes = this.parameters.shapes;

  		return toJSON$1( shapes, data );

  	};

  	// ShapeBufferGeometry

  	function ShapeBufferGeometry( shapes, curveSegments ) {

  		BufferGeometry.call( this );

  		this.type = 'ShapeBufferGeometry';

  		this.parameters = {
  			shapes: shapes,
  			curveSegments: curveSegments
  		};

  		curveSegments = curveSegments || 12;

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// helper variables

  		var groupStart = 0;
  		var groupCount = 0;

  		// allow single and array values for "shapes" parameter

  		if ( Array.isArray( shapes ) === false ) {

  			addShape( shapes );

  		} else {

  			for ( var i = 0; i < shapes.length; i ++ ) {

  				addShape( shapes[ i ] );

  				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

  				groupStart += groupCount;
  				groupCount = 0;

  			}

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


  		// helper functions

  		function addShape( shape ) {

  			var i, l, shapeHole;

  			var indexOffset = vertices.length / 3;
  			var points = shape.extractPoints( curveSegments );

  			var shapeVertices = points.shape;
  			var shapeHoles = points.holes;

  			// check direction of vertices

  			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

  				shapeVertices = shapeVertices.reverse();

  			}

  			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  				shapeHole = shapeHoles[ i ];

  				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

  					shapeHoles[ i ] = shapeHole.reverse();

  				}

  			}

  			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

  			// join vertices of inner and outer paths to a single array

  			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  				shapeHole = shapeHoles[ i ];
  				shapeVertices = shapeVertices.concat( shapeHole );

  			}

  			// vertices, normals, uvs

  			for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

  				var vertex = shapeVertices[ i ];

  				vertices.push( vertex.x, vertex.y, 0 );
  				normals.push( 0, 0, 1 );
  				uvs.push( vertex.x, vertex.y ); // world uvs

  			}

  			// incides

  			for ( i = 0, l = faces.length; i < l; i ++ ) {

  				var face = faces[ i ];

  				var a = face[ 0 ] + indexOffset;
  				var b = face[ 1 ] + indexOffset;
  				var c = face[ 2 ] + indexOffset;

  				indices.push( a, b, c );
  				groupCount += 3;

  			}

  		}

  	}

  	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

  	ShapeBufferGeometry.prototype.toJSON = function () {

  		var data = BufferGeometry.prototype.toJSON.call( this );

  		var shapes = this.parameters.shapes;

  		return toJSON$1( shapes, data );

  	};

  	//

  	function toJSON$1( shapes, data ) {

  		data.shapes = [];

  		if ( Array.isArray( shapes ) ) {

  			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

  				var shape = shapes[ i ];

  				data.shapes.push( shape.uuid );

  			}

  		} else {

  			data.shapes.push( shapes.uuid );

  		}

  		return data;

  	}

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	function EdgesGeometry( geometry, thresholdAngle ) {

  		BufferGeometry.call( this );

  		this.type = 'EdgesGeometry';

  		this.parameters = {
  			thresholdAngle: thresholdAngle
  		};

  		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  		// buffer

  		var vertices = [];

  		// helper variables

  		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
  		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
  		var key, keys = [ 'a', 'b', 'c' ];

  		// prepare source geometry

  		var geometry2;

  		if ( geometry.isBufferGeometry ) {

  			geometry2 = new Geometry();
  			geometry2.fromBufferGeometry( geometry );

  		} else {

  			geometry2 = geometry.clone();

  		}

  		geometry2.mergeVertices();
  		geometry2.computeFaceNormals();

  		var sourceVertices = geometry2.vertices;
  		var faces = geometry2.faces;

  		// now create a data structure where each entry represents an edge with its adjoining faces

  		for ( var i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			for ( var j = 0; j < 3; j ++ ) {

  				edge1 = face[ keys[ j ] ];
  				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  				edge[ 0 ] = Math.min( edge1, edge2 );
  				edge[ 1 ] = Math.max( edge1, edge2 );

  				key = edge[ 0 ] + ',' + edge[ 1 ];

  				if ( edges[ key ] === undefined ) {

  					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

  				} else {

  					edges[ key ].face2 = i;

  				}

  			}

  		}

  		// generate vertices

  		for ( key in edges ) {

  			var e = edges[ key ];

  			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

  			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

  				var vertex = sourceVertices[ e.index1 ];
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				vertex = sourceVertices[ e.index2 ];
  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		}

  		// build geometry

  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

  	}

  	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
  	EdgesGeometry.prototype.constructor = EdgesGeometry;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	// CylinderGeometry

  	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  		Geometry.call( this );

  		this.type = 'CylinderGeometry';

  		this.parameters = {
  			radiusTop: radiusTop,
  			radiusBottom: radiusBottom,
  			height: height,
  			radialSegments: radialSegments,
  			heightSegments: heightSegments,
  			openEnded: openEnded,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
  		this.mergeVertices();

  	}

  	CylinderGeometry.prototype = Object.create( Geometry.prototype );
  	CylinderGeometry.prototype.constructor = CylinderGeometry;

  	// CylinderBufferGeometry

  	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  		BufferGeometry.call( this );

  		this.type = 'CylinderBufferGeometry';

  		this.parameters = {
  			radiusTop: radiusTop,
  			radiusBottom: radiusBottom,
  			height: height,
  			radialSegments: radialSegments,
  			heightSegments: heightSegments,
  			openEnded: openEnded,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		var scope = this;

  		radiusTop = radiusTop !== undefined ? radiusTop : 1;
  		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
  		height = height || 1;

  		radialSegments = Math.floor( radialSegments ) || 8;
  		heightSegments = Math.floor( heightSegments ) || 1;

  		openEnded = openEnded !== undefined ? openEnded : false;
  		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// helper variables

  		var index = 0;
  		var indexArray = [];
  		var halfHeight = height / 2;
  		var groupStart = 0;

  		// generate geometry

  		generateTorso();

  		if ( openEnded === false ) {

  			if ( radiusTop > 0 ) generateCap( true );
  			if ( radiusBottom > 0 ) generateCap( false );

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  		function generateTorso() {

  			var x, y;
  			var normal = new Vector3();
  			var vertex = new Vector3();

  			var groupCount = 0;

  			// this will be used to calculate the normal
  			var slope = ( radiusBottom - radiusTop ) / height;

  			// generate vertices, normals and uvs

  			for ( y = 0; y <= heightSegments; y ++ ) {

  				var indexRow = [];

  				var v = y / heightSegments;

  				// calculate the radius of the current row

  				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

  				for ( x = 0; x <= radialSegments; x ++ ) {

  					var u = x / radialSegments;

  					var theta = u * thetaLength + thetaStart;

  					var sinTheta = Math.sin( theta );
  					var cosTheta = Math.cos( theta );

  					// vertex

  					vertex.x = radius * sinTheta;
  					vertex.y = - v * height + halfHeight;
  					vertex.z = radius * cosTheta;
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					// normal

  					normal.set( sinTheta, slope, cosTheta ).normalize();
  					normals.push( normal.x, normal.y, normal.z );

  					// uv

  					uvs.push( u, 1 - v );

  					// save index of vertex in respective row

  					indexRow.push( index ++ );

  				}

  				// now save vertices of the row in our index array

  				indexArray.push( indexRow );

  			}

  			// generate indices

  			for ( x = 0; x < radialSegments; x ++ ) {

  				for ( y = 0; y < heightSegments; y ++ ) {

  					// we use the index array to access the correct indices

  					var a = indexArray[ y ][ x ];
  					var b = indexArray[ y + 1 ][ x ];
  					var c = indexArray[ y + 1 ][ x + 1 ];
  					var d = indexArray[ y ][ x + 1 ];

  					// faces

  					indices.push( a, b, d );
  					indices.push( b, c, d );

  					// update group counter

  					groupCount += 6;

  				}

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, 0 );

  			// calculate new start value for groups

  			groupStart += groupCount;

  		}

  		function generateCap( top ) {

  			var x, centerIndexStart, centerIndexEnd;

  			var uv = new Vector2();
  			var vertex = new Vector3();

  			var groupCount = 0;

  			var radius = ( top === true ) ? radiusTop : radiusBottom;
  			var sign = ( top === true ) ? 1 : - 1;

  			// save the index of the first center vertex
  			centerIndexStart = index;

  			// first we generate the center vertex data of the cap.
  			// because the geometry needs one set of uvs per face,
  			// we must generate a center vertex per face/segment

  			for ( x = 1; x <= radialSegments; x ++ ) {

  				// vertex

  				vertices.push( 0, halfHeight * sign, 0 );

  				// normal

  				normals.push( 0, sign, 0 );

  				// uv

  				uvs.push( 0.5, 0.5 );

  				// increase index

  				index ++;

  			}

  			// save the index of the last center vertex

  			centerIndexEnd = index;

  			// now we generate the surrounding vertices, normals and uvs

  			for ( x = 0; x <= radialSegments; x ++ ) {

  				var u = x / radialSegments;
  				var theta = u * thetaLength + thetaStart;

  				var cosTheta = Math.cos( theta );
  				var sinTheta = Math.sin( theta );

  				// vertex

  				vertex.x = radius * sinTheta;
  				vertex.y = halfHeight * sign;
  				vertex.z = radius * cosTheta;
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normals.push( 0, sign, 0 );

  				// uv

  				uv.x = ( cosTheta * 0.5 ) + 0.5;
  				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
  				uvs.push( uv.x, uv.y );

  				// increase index

  				index ++;

  			}

  			// generate indices

  			for ( x = 0; x < radialSegments; x ++ ) {

  				var c = centerIndexStart + x;
  				var i = centerIndexEnd + x;

  				if ( top === true ) {

  					// face top

  					indices.push( i, i + 1, c );

  				} else {

  					// face bottom

  					indices.push( i + 1, i, c );

  				}

  				groupCount += 3;

  			}

  			// add a group to the geometry. this will ensure multi material support

  			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

  			// calculate new start value for groups

  			groupStart += groupCount;

  		}

  	}

  	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

  	/**
  	 * @author abelnation / http://github.com/abelnation
  	 */

  	// ConeGeometry

  	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  		this.type = 'ConeGeometry';

  		this.parameters = {
  			radius: radius,
  			height: height,
  			radialSegments: radialSegments,
  			heightSegments: heightSegments,
  			openEnded: openEnded,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  	}

  	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
  	ConeGeometry.prototype.constructor = ConeGeometry;

  	// ConeBufferGeometry

  	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  		this.type = 'ConeBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			height: height,
  			radialSegments: radialSegments,
  			heightSegments: heightSegments,
  			openEnded: openEnded,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  	}

  	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
  	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

  	/**
  	 * @author benaadams / https://twitter.com/ben_a_adams
  	 * @author Mugen87 / https://github.com/Mugen87
  	 * @author hughes
  	 */

  	// CircleGeometry

  	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

  		Geometry.call( this );

  		this.type = 'CircleGeometry';

  		this.parameters = {
  			radius: radius,
  			segments: segments,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
  		this.mergeVertices();

  	}

  	CircleGeometry.prototype = Object.create( Geometry.prototype );
  	CircleGeometry.prototype.constructor = CircleGeometry;

  	// CircleBufferGeometry

  	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

  		BufferGeometry.call( this );

  		this.type = 'CircleBufferGeometry';

  		this.parameters = {
  			radius: radius,
  			segments: segments,
  			thetaStart: thetaStart,
  			thetaLength: thetaLength
  		};

  		radius = radius || 1;
  		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  		thetaStart = thetaStart !== undefined ? thetaStart : 0;
  		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  		// buffers

  		var indices = [];
  		var vertices = [];
  		var normals = [];
  		var uvs = [];

  		// helper variables

  		var i, s;
  		var vertex = new Vector3();
  		var uv = new Vector2();

  		// center point

  		vertices.push( 0, 0, 0 );
  		normals.push( 0, 0, 1 );
  		uvs.push( 0.5, 0.5 );

  		for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

  			var segment = thetaStart + s / segments * thetaLength;

  			// vertex

  			vertex.x = radius * Math.cos( segment );
  			vertex.y = radius * Math.sin( segment );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, 0, 1 );

  			// uvs

  			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
  			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

  			uvs.push( uv.x, uv.y );

  		}

  		// indices

  		for ( i = 1; i <= segments; i ++ ) {

  			indices.push( i, i + 1, 0 );

  		}

  		// build geometry

  		this.setIndex( indices );
  		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

  	}

  	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
  	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



  	var Geometries = /*#__PURE__*/Object.freeze({
  		WireframeGeometry: WireframeGeometry,
  		ParametricGeometry: ParametricGeometry,
  		ParametricBufferGeometry: ParametricBufferGeometry,
  		TetrahedronGeometry: TetrahedronGeometry,
  		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
  		OctahedronGeometry: OctahedronGeometry,
  		OctahedronBufferGeometry: OctahedronBufferGeometry,
  		IcosahedronGeometry: IcosahedronGeometry,
  		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
  		DodecahedronGeometry: DodecahedronGeometry,
  		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
  		PolyhedronGeometry: PolyhedronGeometry,
  		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
  		TubeGeometry: TubeGeometry,
  		TubeBufferGeometry: TubeBufferGeometry,
  		TorusKnotGeometry: TorusKnotGeometry,
  		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
  		TorusGeometry: TorusGeometry,
  		TorusBufferGeometry: TorusBufferGeometry,
  		TextGeometry: TextGeometry,
  		TextBufferGeometry: TextBufferGeometry,
  		SphereGeometry: SphereGeometry,
  		SphereBufferGeometry: SphereBufferGeometry,
  		RingGeometry: RingGeometry,
  		RingBufferGeometry: RingBufferGeometry,
  		PlaneGeometry: PlaneGeometry,
  		PlaneBufferGeometry: PlaneBufferGeometry,
  		LatheGeometry: LatheGeometry,
  		LatheBufferGeometry: LatheBufferGeometry,
  		ShapeGeometry: ShapeGeometry,
  		ShapeBufferGeometry: ShapeBufferGeometry,
  		ExtrudeGeometry: ExtrudeGeometry,
  		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
  		EdgesGeometry: EdgesGeometry,
  		ConeGeometry: ConeGeometry,
  		ConeBufferGeometry: ConeBufferGeometry,
  		CylinderGeometry: CylinderGeometry,
  		CylinderBufferGeometry: CylinderBufferGeometry,
  		CircleGeometry: CircleGeometry,
  		CircleBufferGeometry: CircleBufferGeometry,
  		BoxGeometry: BoxGeometry,
  		BoxBufferGeometry: BoxBufferGeometry
  	});

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 *
  	 * parameters = {
  	 *  color: <THREE.Color>
  	 * }
  	 */

  	function ShadowMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'ShadowMaterial';

  		this.color = new Color( 0x000000 );
  		this.transparent = true;

  		this.setValues( parameters );

  	}

  	ShadowMaterial.prototype = Object.create( Material.prototype );
  	ShadowMaterial.prototype.constructor = ShadowMaterial;

  	ShadowMaterial.prototype.isShadowMaterial = true;

  	ShadowMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.color.copy( source.color );

  		return this;

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function RawShaderMaterial( parameters ) {

  		ShaderMaterial.call( this, parameters );

  		this.type = 'RawShaderMaterial';

  	}

  	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
  	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

  	RawShaderMaterial.prototype.isRawShaderMaterial = true;

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  roughness: <float>,
  	 *  metalness: <float>,
  	 *  opacity: <float>,
  	 *
  	 *  map: new THREE.Texture( <Image> ),
  	 *
  	 *  lightMap: new THREE.Texture( <Image> ),
  	 *  lightMapIntensity: <float>
  	 *
  	 *  aoMap: new THREE.Texture( <Image> ),
  	 *  aoMapIntensity: <float>
  	 *
  	 *  emissive: <hex>,
  	 *  emissiveIntensity: <float>
  	 *  emissiveMap: new THREE.Texture( <Image> ),
  	 *
  	 *  bumpMap: new THREE.Texture( <Image> ),
  	 *  bumpScale: <float>,
  	 *
  	 *  normalMap: new THREE.Texture( <Image> ),
  	 *  normalMapType: THREE.TangentSpaceNormalMap,
  	 *  normalScale: <Vector2>,
  	 *
  	 *  displacementMap: new THREE.Texture( <Image> ),
  	 *  displacementScale: <float>,
  	 *  displacementBias: <float>,
  	 *
  	 *  roughnessMap: new THREE.Texture( <Image> ),
  	 *
  	 *  metalnessMap: new THREE.Texture( <Image> ),
  	 *
  	 *  alphaMap: new THREE.Texture( <Image> ),
  	 *
  	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
  	 *  envMapIntensity: <float>
  	 *
  	 *  refractionRatio: <float>,
  	 *
  	 *  wireframe: <boolean>,
  	 *  wireframeLinewidth: <float>,
  	 *
  	 *  skinning: <bool>,
  	 *  morphTargets: <bool>,
  	 *  morphNormals: <bool>
  	 * }
  	 */

  	function MeshStandardMaterial( parameters ) {

  		Material.call( this );

  		this.defines = { 'STANDARD': '' };

  		this.type = 'MeshStandardMaterial';

  		this.color = new Color( 0xffffff ); // diffuse
  		this.roughness = 0.5;
  		this.metalness = 0.5;

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.roughnessMap = null;

  		this.metalnessMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.envMapIntensity = 1.0;

  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.skinning = false;
  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.setValues( parameters );

  	}

  	MeshStandardMaterial.prototype = Object.create( Material.prototype );
  	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

  	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

  	MeshStandardMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.defines = { 'STANDARD': '' };

  		this.color.copy( source.color );
  		this.roughness = source.roughness;
  		this.metalness = source.metalness;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.roughnessMap = source.roughnessMap;

  		this.metalnessMap = source.metalnessMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.envMapIntensity = source.envMapIntensity;

  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.skinning = source.skinning;
  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		return this;

  	};

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * parameters = {
  	 *  reflectivity: <float>
  	 *  clearCoat: <float>
  	 *  clearCoatRoughness: <float>
  	 * }
  	 */

  	function MeshPhysicalMaterial( parameters ) {

  		MeshStandardMaterial.call( this );

  		this.defines = { 'PHYSICAL': '' };

  		this.type = 'MeshPhysicalMaterial';

  		this.reflectivity = 0.5; // maps to F0 = 0.04

  		this.clearCoat = 0.0;
  		this.clearCoatRoughness = 0.0;

  		this.setValues( parameters );

  	}

  	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
  	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

  	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

  	MeshPhysicalMaterial.prototype.copy = function ( source ) {

  		MeshStandardMaterial.prototype.copy.call( this, source );

  		this.defines = { 'PHYSICAL': '' };

  		this.reflectivity = source.reflectivity;

  		this.clearCoat = source.clearCoat;
  		this.clearCoatRoughness = source.clearCoatRoughness;

  		return this;

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  specular: <hex>,
  	 *  shininess: <float>,
  	 *  opacity: <float>,
  	 *
  	 *  map: new THREE.Texture( <Image> ),
  	 *
  	 *  lightMap: new THREE.Texture( <Image> ),
  	 *  lightMapIntensity: <float>
  	 *
  	 *  aoMap: new THREE.Texture( <Image> ),
  	 *  aoMapIntensity: <float>
  	 *
  	 *  emissive: <hex>,
  	 *  emissiveIntensity: <float>
  	 *  emissiveMap: new THREE.Texture( <Image> ),
  	 *
  	 *  bumpMap: new THREE.Texture( <Image> ),
  	 *  bumpScale: <float>,
  	 *
  	 *  normalMap: new THREE.Texture( <Image> ),
  	 *  normalMapType: THREE.TangentSpaceNormalMap,
  	 *  normalScale: <Vector2>,
  	 *
  	 *  displacementMap: new THREE.Texture( <Image> ),
  	 *  displacementScale: <float>,
  	 *  displacementBias: <float>,
  	 *
  	 *  specularMap: new THREE.Texture( <Image> ),
  	 *
  	 *  alphaMap: new THREE.Texture( <Image> ),
  	 *
  	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
  	 *  combine: THREE.Multiply,
  	 *  reflectivity: <float>,
  	 *  refractionRatio: <float>,
  	 *
  	 *  wireframe: <boolean>,
  	 *  wireframeLinewidth: <float>,
  	 *
  	 *  skinning: <bool>,
  	 *  morphTargets: <bool>,
  	 *  morphNormals: <bool>
  	 * }
  	 */

  	function MeshPhongMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'MeshPhongMaterial';

  		this.color = new Color( 0xffffff ); // diffuse
  		this.specular = new Color( 0x111111 );
  		this.shininess = 30;

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.skinning = false;
  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.setValues( parameters );

  	}

  	MeshPhongMaterial.prototype = Object.create( Material.prototype );
  	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

  	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

  	MeshPhongMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.color.copy( source.color );
  		this.specular.copy( source.specular );
  		this.shininess = source.shininess;

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.skinning = source.skinning;
  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		return this;

  	};

  	/**
  	 * @author takahirox / http://github.com/takahirox
  	 *
  	 * parameters = {
  	 *  gradientMap: new THREE.Texture( <Image> )
  	 * }
  	 */

  	function MeshToonMaterial( parameters ) {

  		MeshPhongMaterial.call( this );

  		this.defines = { 'TOON': '' };

  		this.type = 'MeshToonMaterial';

  		this.gradientMap = null;

  		this.setValues( parameters );

  	}

  	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
  	MeshToonMaterial.prototype.constructor = MeshToonMaterial;

  	MeshToonMaterial.prototype.isMeshToonMaterial = true;

  	MeshToonMaterial.prototype.copy = function ( source ) {

  		MeshPhongMaterial.prototype.copy.call( this, source );

  		this.gradientMap = source.gradientMap;

  		return this;

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * parameters = {
  	 *  opacity: <float>,
  	 *
  	 *  bumpMap: new THREE.Texture( <Image> ),
  	 *  bumpScale: <float>,
  	 *
  	 *  normalMap: new THREE.Texture( <Image> ),
  	 *  normalMapType: THREE.TangentSpaceNormalMap,
  	 *  normalScale: <Vector2>,
  	 *
  	 *  displacementMap: new THREE.Texture( <Image> ),
  	 *  displacementScale: <float>,
  	 *  displacementBias: <float>,
  	 *
  	 *  wireframe: <boolean>,
  	 *  wireframeLinewidth: <float>
  	 *
  	 *  skinning: <bool>,
  	 *  morphTargets: <bool>,
  	 *  morphNormals: <bool>
  	 * }
  	 */

  	function MeshNormalMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'MeshNormalMaterial';

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;

  		this.fog = false;
  		this.lights = false;

  		this.skinning = false;
  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.setValues( parameters );

  	}

  	MeshNormalMaterial.prototype = Object.create( Material.prototype );
  	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

  	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

  	MeshNormalMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;

  		this.skinning = source.skinning;
  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		return this;

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  opacity: <float>,
  	 *
  	 *  map: new THREE.Texture( <Image> ),
  	 *
  	 *  lightMap: new THREE.Texture( <Image> ),
  	 *  lightMapIntensity: <float>
  	 *
  	 *  aoMap: new THREE.Texture( <Image> ),
  	 *  aoMapIntensity: <float>
  	 *
  	 *  emissive: <hex>,
  	 *  emissiveIntensity: <float>
  	 *  emissiveMap: new THREE.Texture( <Image> ),
  	 *
  	 *  specularMap: new THREE.Texture( <Image> ),
  	 *
  	 *  alphaMap: new THREE.Texture( <Image> ),
  	 *
  	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
  	 *  combine: THREE.Multiply,
  	 *  reflectivity: <float>,
  	 *  refractionRatio: <float>,
  	 *
  	 *  wireframe: <boolean>,
  	 *  wireframeLinewidth: <float>,
  	 *
  	 *  skinning: <bool>,
  	 *  morphTargets: <bool>,
  	 *  morphNormals: <bool>
  	 * }
  	 */

  	function MeshLambertMaterial( parameters ) {

  		Material.call( this );

  		this.type = 'MeshLambertMaterial';

  		this.color = new Color( 0xffffff ); // diffuse

  		this.map = null;

  		this.lightMap = null;
  		this.lightMapIntensity = 1.0;

  		this.aoMap = null;
  		this.aoMapIntensity = 1.0;

  		this.emissive = new Color( 0x000000 );
  		this.emissiveIntensity = 1.0;
  		this.emissiveMap = null;

  		this.specularMap = null;

  		this.alphaMap = null;

  		this.envMap = null;
  		this.combine = MultiplyOperation;
  		this.reflectivity = 1;
  		this.refractionRatio = 0.98;

  		this.wireframe = false;
  		this.wireframeLinewidth = 1;
  		this.wireframeLinecap = 'round';
  		this.wireframeLinejoin = 'round';

  		this.skinning = false;
  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.setValues( parameters );

  	}

  	MeshLambertMaterial.prototype = Object.create( Material.prototype );
  	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

  	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

  	MeshLambertMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.color.copy( source.color );

  		this.map = source.map;

  		this.lightMap = source.lightMap;
  		this.lightMapIntensity = source.lightMapIntensity;

  		this.aoMap = source.aoMap;
  		this.aoMapIntensity = source.aoMapIntensity;

  		this.emissive.copy( source.emissive );
  		this.emissiveMap = source.emissiveMap;
  		this.emissiveIntensity = source.emissiveIntensity;

  		this.specularMap = source.specularMap;

  		this.alphaMap = source.alphaMap;

  		this.envMap = source.envMap;
  		this.combine = source.combine;
  		this.reflectivity = source.reflectivity;
  		this.refractionRatio = source.refractionRatio;

  		this.wireframe = source.wireframe;
  		this.wireframeLinewidth = source.wireframeLinewidth;
  		this.wireframeLinecap = source.wireframeLinecap;
  		this.wireframeLinejoin = source.wireframeLinejoin;

  		this.skinning = source.skinning;
  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		return this;

  	};

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  opacity: <float>,
  	 *
  	 *  matcap: new THREE.Texture( <Image> ),
  	 *
  	 *  map: new THREE.Texture( <Image> ),
  	 *
  	 *  bumpMap: new THREE.Texture( <Image> ),
  	 *  bumpScale: <float>,
  	 *
  	 *  normalMap: new THREE.Texture( <Image> ),
  	 *  normalMapType: THREE.TangentSpaceNormalMap,
  	 *  normalScale: <Vector2>,
  	 *
  	 *  displacementMap: new THREE.Texture( <Image> ),
  	 *  displacementScale: <float>,
  	 *  displacementBias: <float>,
  	 *
  	 *  alphaMap: new THREE.Texture( <Image> ),
  	 *
  	 *  skinning: <bool>,
  	 *  morphTargets: <bool>,
  	 *  morphNormals: <bool>
  	 * }
  	 */

  	function MeshMatcapMaterial( parameters ) {

  		Material.call( this );

  		this.defines = { 'MATCAP': '' };

  		this.type = 'MeshMatcapMaterial';

  		this.color = new Color( 0xffffff ); // diffuse

  		this.matcap = null;

  		this.map = null;

  		this.bumpMap = null;
  		this.bumpScale = 1;

  		this.normalMap = null;
  		this.normalMapType = TangentSpaceNormalMap;
  		this.normalScale = new Vector2( 1, 1 );

  		this.displacementMap = null;
  		this.displacementScale = 1;
  		this.displacementBias = 0;

  		this.alphaMap = null;

  		this.skinning = false;
  		this.morphTargets = false;
  		this.morphNormals = false;

  		this.lights = false;

  		this.setValues( parameters );

  	}

  	MeshMatcapMaterial.prototype = Object.create( Material.prototype );
  	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

  	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

  	MeshMatcapMaterial.prototype.copy = function ( source ) {

  		Material.prototype.copy.call( this, source );

  		this.defines = { 'MATCAP': '' };

  		this.color.copy( source.color );

  		this.matcap = source.matcap;

  		this.map = source.map;

  		this.bumpMap = source.bumpMap;
  		this.bumpScale = source.bumpScale;

  		this.normalMap = source.normalMap;
  		this.normalMapType = source.normalMapType;
  		this.normalScale.copy( source.normalScale );

  		this.displacementMap = source.displacementMap;
  		this.displacementScale = source.displacementScale;
  		this.displacementBias = source.displacementBias;

  		this.alphaMap = source.alphaMap;

  		this.skinning = source.skinning;
  		this.morphTargets = source.morphTargets;
  		this.morphNormals = source.morphNormals;

  		return this;

  	};

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 *
  	 * parameters = {
  	 *  color: <hex>,
  	 *  opacity: <float>,
  	 *
  	 *  linewidth: <float>,
  	 *
  	 *  scale: <float>,
  	 *  dashSize: <float>,
  	 *  gapSize: <float>
  	 * }
  	 */

  	function LineDashedMaterial( parameters ) {

  		LineBasicMaterial.call( this );

  		this.type = 'LineDashedMaterial';

  		this.scale = 1;
  		this.dashSize = 3;
  		this.gapSize = 1;

  		this.setValues( parameters );

  	}

  	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
  	LineDashedMaterial.prototype.constructor = LineDashedMaterial;

  	LineDashedMaterial.prototype.isLineDashedMaterial = true;

  	LineDashedMaterial.prototype.copy = function ( source ) {

  		LineBasicMaterial.prototype.copy.call( this, source );

  		this.scale = source.scale;
  		this.dashSize = source.dashSize;
  		this.gapSize = source.gapSize;

  		return this;

  	};



  	var Materials = /*#__PURE__*/Object.freeze({
  		ShadowMaterial: ShadowMaterial,
  		SpriteMaterial: SpriteMaterial,
  		RawShaderMaterial: RawShaderMaterial,
  		ShaderMaterial: ShaderMaterial,
  		PointsMaterial: PointsMaterial,
  		MeshPhysicalMaterial: MeshPhysicalMaterial,
  		MeshStandardMaterial: MeshStandardMaterial,
  		MeshPhongMaterial: MeshPhongMaterial,
  		MeshToonMaterial: MeshToonMaterial,
  		MeshNormalMaterial: MeshNormalMaterial,
  		MeshLambertMaterial: MeshLambertMaterial,
  		MeshDepthMaterial: MeshDepthMaterial,
  		MeshDistanceMaterial: MeshDistanceMaterial,
  		MeshBasicMaterial: MeshBasicMaterial,
  		MeshMatcapMaterial: MeshMatcapMaterial,
  		LineDashedMaterial: LineDashedMaterial,
  		LineBasicMaterial: LineBasicMaterial,
  		Material: Material
  	});

  	/**
  	 * @author tschw
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 */

  	var AnimationUtils = {

  		// same as Array.prototype.slice, but also works on typed arrays
  		arraySlice: function ( array, from, to ) {

  			if ( AnimationUtils.isTypedArray( array ) ) {

  				// in ios9 array.subarray(from, undefined) will return empty array
  				// but array.subarray(from) or array.subarray(from, len) is correct
  				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

  			}

  			return array.slice( from, to );

  		},

  		// converts an array to a specific type
  		convertArray: function ( array, type, forceClone ) {

  			if ( ! array || // let 'undefined' and 'null' pass
  				! forceClone && array.constructor === type ) return array;

  			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

  				return new type( array ); // create typed array

  			}

  			return Array.prototype.slice.call( array ); // create Array

  		},

  		isTypedArray: function ( object ) {

  			return ArrayBuffer.isView( object ) &&
  				! ( object instanceof DataView );

  		},

  		// returns an array by which times and values can be sorted
  		getKeyframeOrder: function ( times ) {

  			function compareTime( i, j ) {

  				return times[ i ] - times[ j ];

  			}

  			var n = times.length;
  			var result = new Array( n );
  			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

  			result.sort( compareTime );

  			return result;

  		},

  		// uses the array previously returned by 'getKeyframeOrder' to sort data
  		sortedArray: function ( values, stride, order ) {

  			var nValues = values.length;
  			var result = new values.constructor( nValues );

  			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

  				var srcOffset = order[ i ] * stride;

  				for ( var j = 0; j !== stride; ++ j ) {

  					result[ dstOffset ++ ] = values[ srcOffset + j ];

  				}

  			}

  			return result;

  		},

  		// function for parsing AOS keyframe formats
  		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

  			var i = 1, key = jsonKeys[ 0 ];

  			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

  				key = jsonKeys[ i ++ ];

  			}

  			if ( key === undefined ) return; // no data

  			var value = key[ valuePropertyName ];
  			if ( value === undefined ) return; // no data

  			if ( Array.isArray( value ) ) {

  				do {

  					value = key[ valuePropertyName ];

  					if ( value !== undefined ) {

  						times.push( key.time );
  						values.push.apply( values, value ); // push all elements

  					}

  					key = jsonKeys[ i ++ ];

  				} while ( key !== undefined );

  			} else if ( value.toArray !== undefined ) {

  				// ...assume THREE.Math-ish

  				do {

  					value = key[ valuePropertyName ];

  					if ( value !== undefined ) {

  						times.push( key.time );
  						value.toArray( values, values.length );

  					}

  					key = jsonKeys[ i ++ ];

  				} while ( key !== undefined );

  			} else {

  				// otherwise push as-is

  				do {

  					value = key[ valuePropertyName ];

  					if ( value !== undefined ) {

  						times.push( key.time );
  						values.push( value );

  					}

  					key = jsonKeys[ i ++ ];

  				} while ( key !== undefined );

  			}

  		}

  	};

  	/**
  	 * Abstract base class of interpolants over parametric samples.
  	 *
  	 * The parameter domain is one dimensional, typically the time or a path
  	 * along a curve defined by the data.
  	 *
  	 * The sample values can have any dimensionality and derived classes may
  	 * apply special interpretations to the data.
  	 *
  	 * This class provides the interval seek in a Template Method, deferring
  	 * the actual interpolation to derived classes.
  	 *
  	 * Time complexity is O(1) for linear access crossing at most two points
  	 * and O(log N) for random access, where N is the number of positions.
  	 *
  	 * References:
  	 *
  	 * 		http://www.oodesign.com/template-method-pattern.html
  	 *
  	 * @author tschw
  	 */

  	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		this.parameterPositions = parameterPositions;
  		this._cachedIndex = 0;

  		this.resultBuffer = resultBuffer !== undefined ?
  			resultBuffer : new sampleValues.constructor( sampleSize );
  		this.sampleValues = sampleValues;
  		this.valueSize = sampleSize;

  	}

  	Object.assign( Interpolant.prototype, {

  		evaluate: function ( t ) {

  			var pp = this.parameterPositions,
  				i1 = this._cachedIndex,

  				t1 = pp[ i1 ],
  				t0 = pp[ i1 - 1 ];

  			validate_interval: {

  				seek: {

  					var right;

  					linear_scan: {

  						//- See http://jsperf.com/comparison-to-undefined/3
  						//- slower code:
  						//-
  						//- 				if ( t >= t1 || t1 === undefined ) {
  						forward_scan: if ( ! ( t < t1 ) ) {

  							for ( var giveUpAt = i1 + 2; ; ) {

  								if ( t1 === undefined ) {

  									if ( t < t0 ) break forward_scan;

  									// after end

  									i1 = pp.length;
  									this._cachedIndex = i1;
  									return this.afterEnd_( i1 - 1, t, t0 );

  								}

  								if ( i1 === giveUpAt ) break; // this loop

  								t0 = t1;
  								t1 = pp[ ++ i1 ];

  								if ( t < t1 ) {

  									// we have arrived at the sought interval
  									break seek;

  								}

  							}

  							// prepare binary search on the right side of the index
  							right = pp.length;
  							break linear_scan;

  						}

  						//- slower code:
  						//-					if ( t < t0 || t0 === undefined ) {
  						if ( ! ( t >= t0 ) ) {

  							// looping?

  							var t1global = pp[ 1 ];

  							if ( t < t1global ) {

  								i1 = 2; // + 1, using the scan for the details
  								t0 = t1global;

  							}

  							// linear reverse scan

  							for ( var giveUpAt = i1 - 2; ; ) {

  								if ( t0 === undefined ) {

  									// before start

  									this._cachedIndex = 0;
  									return this.beforeStart_( 0, t, t1 );

  								}

  								if ( i1 === giveUpAt ) break; // this loop

  								t1 = t0;
  								t0 = pp[ -- i1 - 1 ];

  								if ( t >= t0 ) {

  									// we have arrived at the sought interval
  									break seek;

  								}

  							}

  							// prepare binary search on the left side of the index
  							right = i1;
  							i1 = 0;
  							break linear_scan;

  						}

  						// the interval is valid

  						break validate_interval;

  					} // linear scan

  					// binary search

  					while ( i1 < right ) {

  						var mid = ( i1 + right ) >>> 1;

  						if ( t < pp[ mid ] ) {

  							right = mid;

  						} else {

  							i1 = mid + 1;

  						}

  					}

  					t1 = pp[ i1 ];
  					t0 = pp[ i1 - 1 ];

  					// check boundary cases, again

  					if ( t0 === undefined ) {

  						this._cachedIndex = 0;
  						return this.beforeStart_( 0, t, t1 );

  					}

  					if ( t1 === undefined ) {

  						i1 = pp.length;
  						this._cachedIndex = i1;
  						return this.afterEnd_( i1 - 1, t0, t );

  					}

  				} // seek

  				this._cachedIndex = i1;

  				this.intervalChanged_( i1, t0, t1 );

  			} // validate_interval

  			return this.interpolate_( i1, t0, t, t1 );

  		},

  		settings: null, // optional, subclass-specific settings structure
  		// Note: The indirection allows central control of many interpolants.

  		// --- Protected interface

  		DefaultSettings_: {},

  		getSettings_: function () {

  			return this.settings || this.DefaultSettings_;

  		},

  		copySampleValue_: function ( index ) {

  			// copies a sample value to the result buffer

  			var result = this.resultBuffer,
  				values = this.sampleValues,
  				stride = this.valueSize,
  				offset = index * stride;

  			for ( var i = 0; i !== stride; ++ i ) {

  				result[ i ] = values[ offset + i ];

  			}

  			return result;

  		},

  		// Template methods for derived classes:

  		interpolate_: function ( /* i1, t0, t, t1 */ ) {

  			throw new Error( 'call to abstract method' );
  			// implementations shall return this.resultBuffer

  		},

  		intervalChanged_: function ( /* i1, t0, t1 */ ) {

  			// empty

  		}

  	} );

  	//!\ DECLARE ALIAS AFTER assign prototype !
  	Object.assign( Interpolant.prototype, {

  		//( 0, t, t0 ), returns this.resultBuffer
  		beforeStart_: Interpolant.prototype.copySampleValue_,

  		//( N-1, tN-1, t ), returns this.resultBuffer
  		afterEnd_: Interpolant.prototype.copySampleValue_,

  	} );

  	/**
  	 * Fast and simple cubic spline interpolant.
  	 *
  	 * It was derived from a Hermitian construction setting the first derivative
  	 * at each sample position to the linear slope between neighboring positions
  	 * over their parameter interval.
  	 *
  	 * @author tschw
  	 */

  	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  		this._weightPrev = - 0;
  		this._offsetPrev = - 0;
  		this._weightNext = - 0;
  		this._offsetNext = - 0;

  	}

  	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  		constructor: CubicInterpolant,

  		DefaultSettings_: {

  			endingStart: ZeroCurvatureEnding,
  			endingEnd: ZeroCurvatureEnding

  		},

  		intervalChanged_: function ( i1, t0, t1 ) {

  			var pp = this.parameterPositions,
  				iPrev = i1 - 2,
  				iNext = i1 + 1,

  				tPrev = pp[ iPrev ],
  				tNext = pp[ iNext ];

  			if ( tPrev === undefined ) {

  				switch ( this.getSettings_().endingStart ) {

  					case ZeroSlopeEnding:

  						// f'(t0) = 0
  						iPrev = i1;
  						tPrev = 2 * t0 - t1;

  						break;

  					case WrapAroundEnding:

  						// use the other end of the curve
  						iPrev = pp.length - 2;
  						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

  						break;

  					default: // ZeroCurvatureEnding

  						// f''(t0) = 0 a.k.a. Natural Spline
  						iPrev = i1;
  						tPrev = t1;

  				}

  			}

  			if ( tNext === undefined ) {

  				switch ( this.getSettings_().endingEnd ) {

  					case ZeroSlopeEnding:

  						// f'(tN) = 0
  						iNext = i1;
  						tNext = 2 * t1 - t0;

  						break;

  					case WrapAroundEnding:

  						// use the other end of the curve
  						iNext = 1;
  						tNext = t1 + pp[ 1 ] - pp[ 0 ];

  						break;

  					default: // ZeroCurvatureEnding

  						// f''(tN) = 0, a.k.a. Natural Spline
  						iNext = i1 - 1;
  						tNext = t0;

  				}

  			}

  			var halfDt = ( t1 - t0 ) * 0.5,
  				stride = this.valueSize;

  			this._weightPrev = halfDt / ( t0 - tPrev );
  			this._weightNext = halfDt / ( tNext - t1 );
  			this._offsetPrev = iPrev * stride;
  			this._offsetNext = iNext * stride;

  		},

  		interpolate_: function ( i1, t0, t, t1 ) {

  			var result = this.resultBuffer,
  				values = this.sampleValues,
  				stride = this.valueSize,

  				o1 = i1 * stride,		o0 = o1 - stride,
  				oP = this._offsetPrev, 	oN = this._offsetNext,
  				wP = this._weightPrev,	wN = this._weightNext,

  				p = ( t - t0 ) / ( t1 - t0 ),
  				pp = p * p,
  				ppp = pp * p;

  			// evaluate polynomials

  			var sP = - wP * ppp + 2 * wP * pp - wP * p;
  			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
  			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
  			var sN = wN * ppp - wN * pp;

  			// combine data linearly

  			for ( var i = 0; i !== stride; ++ i ) {

  				result[ i ] =
  						sP * values[ oP + i ] +
  						s0 * values[ o0 + i ] +
  						s1 * values[ o1 + i ] +
  						sN * values[ oN + i ];

  			}

  			return result;

  		}

  	} );

  	/**
  	 * @author tschw
  	 */

  	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  		constructor: LinearInterpolant,

  		interpolate_: function ( i1, t0, t, t1 ) {

  			var result = this.resultBuffer,
  				values = this.sampleValues,
  				stride = this.valueSize,

  				offset1 = i1 * stride,
  				offset0 = offset1 - stride,

  				weight1 = ( t - t0 ) / ( t1 - t0 ),
  				weight0 = 1 - weight1;

  			for ( var i = 0; i !== stride; ++ i ) {

  				result[ i ] =
  						values[ offset0 + i ] * weight0 +
  						values[ offset1 + i ] * weight1;

  			}

  			return result;

  		}

  	} );

  	/**
  	 *
  	 * Interpolant that evaluates to the sample value at the position preceeding
  	 * the parameter.
  	 *
  	 * @author tschw
  	 */

  	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  		constructor: DiscreteInterpolant,

  		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

  			return this.copySampleValue_( i1 - 1 );

  		}

  	} );

  	/**
  	 *
  	 * A timed sequence of keyframes for a specific property.
  	 *
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function KeyframeTrack( name, times, values, interpolation ) {

  		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
  		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

  		this.name = name;

  		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
  		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

  		this.setInterpolation( interpolation || this.DefaultInterpolation );

  	}

  	// Static methods

  	Object.assign( KeyframeTrack, {

  		// Serialization (in static context, because of constructor invocation
  		// and automatic invocation of .toJSON):

  		toJSON: function ( track ) {

  			var trackType = track.constructor;

  			var json;

  			// derived classes can define a static toJSON method
  			if ( trackType.toJSON !== undefined ) {

  				json = trackType.toJSON( track );

  			} else {

  				// by default, we assume the data can be serialized as-is
  				json = {

  					'name': track.name,
  					'times': AnimationUtils.convertArray( track.times, Array ),
  					'values': AnimationUtils.convertArray( track.values, Array )

  				};

  				var interpolation = track.getInterpolation();

  				if ( interpolation !== track.DefaultInterpolation ) {

  					json.interpolation = interpolation;

  				}

  			}

  			json.type = track.ValueTypeName; // mandatory

  			return json;

  		}

  	} );

  	Object.assign( KeyframeTrack.prototype, {

  		constructor: KeyframeTrack,

  		TimeBufferType: Float32Array,

  		ValueBufferType: Float32Array,

  		DefaultInterpolation: InterpolateLinear,

  		InterpolantFactoryMethodDiscrete: function ( result ) {

  			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

  		},

  		InterpolantFactoryMethodLinear: function ( result ) {

  			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

  		},

  		InterpolantFactoryMethodSmooth: function ( result ) {

  			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

  		},

  		setInterpolation: function ( interpolation ) {

  			var factoryMethod;

  			switch ( interpolation ) {

  				case InterpolateDiscrete:

  					factoryMethod = this.InterpolantFactoryMethodDiscrete;

  					break;

  				case InterpolateLinear:

  					factoryMethod = this.InterpolantFactoryMethodLinear;

  					break;

  				case InterpolateSmooth:

  					factoryMethod = this.InterpolantFactoryMethodSmooth;

  					break;

  			}

  			if ( factoryMethod === undefined ) {

  				var message = "unsupported interpolation for " +
  					this.ValueTypeName + " keyframe track named " + this.name;

  				if ( this.createInterpolant === undefined ) {

  					// fall back to default, unless the default itself is messed up
  					if ( interpolation !== this.DefaultInterpolation ) {

  						this.setInterpolation( this.DefaultInterpolation );

  					} else {

  						throw new Error( message ); // fatal, in this case

  					}

  				}

  				console.warn( 'THREE.KeyframeTrack:', message );
  				return this;

  			}

  			this.createInterpolant = factoryMethod;

  			return this;

  		},

  		getInterpolation: function () {

  			switch ( this.createInterpolant ) {

  				case this.InterpolantFactoryMethodDiscrete:

  					return InterpolateDiscrete;

  				case this.InterpolantFactoryMethodLinear:

  					return InterpolateLinear;

  				case this.InterpolantFactoryMethodSmooth:

  					return InterpolateSmooth;

  			}

  		},

  		getValueSize: function () {

  			return this.values.length / this.times.length;

  		},

  		// move all keyframes either forwards or backwards in time
  		shift: function ( timeOffset ) {

  			if ( timeOffset !== 0.0 ) {

  				var times = this.times;

  				for ( var i = 0, n = times.length; i !== n; ++ i ) {

  					times[ i ] += timeOffset;

  				}

  			}

  			return this;

  		},

  		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  		scale: function ( timeScale ) {

  			if ( timeScale !== 1.0 ) {

  				var times = this.times;

  				for ( var i = 0, n = times.length; i !== n; ++ i ) {

  					times[ i ] *= timeScale;

  				}

  			}

  			return this;

  		},

  		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  		trim: function ( startTime, endTime ) {

  			var times = this.times,
  				nKeys = times.length,
  				from = 0,
  				to = nKeys - 1;

  			while ( from !== nKeys && times[ from ] < startTime ) {

  				++ from;

  			}

  			while ( to !== - 1 && times[ to ] > endTime ) {

  				-- to;

  			}

  			++ to; // inclusive -> exclusive bound

  			if ( from !== 0 || to !== nKeys ) {

  				// empty tracks are forbidden, so keep at least one keyframe
  				if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

  				var stride = this.getValueSize();
  				this.times = AnimationUtils.arraySlice( times, from, to );
  				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

  			}

  			return this;

  		},

  		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  		validate: function () {

  			var valid = true;

  			var valueSize = this.getValueSize();
  			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

  				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
  				valid = false;

  			}

  			var times = this.times,
  				values = this.values,

  				nKeys = times.length;

  			if ( nKeys === 0 ) {

  				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
  				valid = false;

  			}

  			var prevTime = null;

  			for ( var i = 0; i !== nKeys; i ++ ) {

  				var currTime = times[ i ];

  				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

  					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
  					valid = false;
  					break;

  				}

  				if ( prevTime !== null && prevTime > currTime ) {

  					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
  					valid = false;
  					break;

  				}

  				prevTime = currTime;

  			}

  			if ( values !== undefined ) {

  				if ( AnimationUtils.isTypedArray( values ) ) {

  					for ( var i = 0, n = values.length; i !== n; ++ i ) {

  						var value = values[ i ];

  						if ( isNaN( value ) ) {

  							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
  							valid = false;
  							break;

  						}

  					}

  				}

  			}

  			return valid;

  		},

  		// removes equivalent sequential keys as common in morph target sequences
  		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  		optimize: function () {

  			var times = this.times,
  				values = this.values,
  				stride = this.getValueSize(),

  				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

  				writeIndex = 1,
  				lastIndex = times.length - 1;

  			for ( var i = 1; i < lastIndex; ++ i ) {

  				var keep = false;

  				var time = times[ i ];
  				var timeNext = times[ i + 1 ];

  				// remove adjacent keyframes scheduled at the same time

  				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

  					if ( ! smoothInterpolation ) {

  						// remove unnecessary keyframes same as their neighbors

  						var offset = i * stride,
  							offsetP = offset - stride,
  							offsetN = offset + stride;

  						for ( var j = 0; j !== stride; ++ j ) {

  							var value = values[ offset + j ];

  							if ( value !== values[ offsetP + j ] ||
  								value !== values[ offsetN + j ] ) {

  								keep = true;
  								break;

  							}

  						}

  					} else {

  						keep = true;

  					}

  				}

  				// in-place compaction

  				if ( keep ) {

  					if ( i !== writeIndex ) {

  						times[ writeIndex ] = times[ i ];

  						var readOffset = i * stride,
  							writeOffset = writeIndex * stride;

  						for ( var j = 0; j !== stride; ++ j ) {

  							values[ writeOffset + j ] = values[ readOffset + j ];

  						}

  					}

  					++ writeIndex;

  				}

  			}

  			// flush last keyframe (compaction looks ahead)

  			if ( lastIndex > 0 ) {

  				times[ writeIndex ] = times[ lastIndex ];

  				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

  					values[ writeOffset + j ] = values[ readOffset + j ];

  				}

  				++ writeIndex;

  			}

  			if ( writeIndex !== times.length ) {

  				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
  				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

  			}

  			return this;

  		},

  		clone: function () {

  			var times = AnimationUtils.arraySlice( this.times, 0 );
  			var values = AnimationUtils.arraySlice( this.values, 0 );

  			var TypedKeyframeTrack = this.constructor;
  			var track = new TypedKeyframeTrack( this.name, times, values );

  			// Interpolant argument to constructor is not saved, so copy the factory method directly.
  			track.createInterpolant = this.createInterpolant;

  			return track;

  		}

  	} );

  	/**
  	 *
  	 * A Track of Boolean keyframe values.
  	 *
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function BooleanKeyframeTrack( name, times, values ) {

  		KeyframeTrack.call( this, name, times, values );

  	}

  	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  		constructor: BooleanKeyframeTrack,

  		ValueTypeName: 'bool',
  		ValueBufferType: Array,

  		DefaultInterpolation: InterpolateDiscrete,

  		InterpolantFactoryMethodLinear: undefined,
  		InterpolantFactoryMethodSmooth: undefined

  		// Note: Actually this track could have a optimized / compressed
  		// representation of a single value and a custom interpolant that
  		// computes "firstValue ^ isOdd( index )".

  	} );

  	/**
  	 *
  	 * A Track of keyframe values that represent color.
  	 *
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function ColorKeyframeTrack( name, times, values, interpolation ) {

  		KeyframeTrack.call( this, name, times, values, interpolation );

  	}

  	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  		constructor: ColorKeyframeTrack,

  		ValueTypeName: 'color'

  		// ValueBufferType is inherited

  		// DefaultInterpolation is inherited

  		// Note: Very basic implementation and nothing special yet.
  		// However, this is the place for color space parameterization.

  	} );

  	/**
  	 *
  	 * A Track of numeric keyframe values.
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function NumberKeyframeTrack( name, times, values, interpolation ) {

  		KeyframeTrack.call( this, name, times, values, interpolation );

  	}

  	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  		constructor: NumberKeyframeTrack,

  		ValueTypeName: 'number'

  		// ValueBufferType is inherited

  		// DefaultInterpolation is inherited

  	} );

  	/**
  	 * Spherical linear unit quaternion interpolant.
  	 *
  	 * @author tschw
  	 */

  	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	}

  	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

  		constructor: QuaternionLinearInterpolant,

  		interpolate_: function ( i1, t0, t, t1 ) {

  			var result = this.resultBuffer,
  				values = this.sampleValues,
  				stride = this.valueSize,

  				offset = i1 * stride,

  				alpha = ( t - t0 ) / ( t1 - t0 );

  			for ( var end = offset + stride; offset !== end; offset += 4 ) {

  				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

  			}

  			return result;

  		}

  	} );

  	/**
  	 *
  	 * A Track of quaternion keyframe values.
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function QuaternionKeyframeTrack( name, times, values, interpolation ) {

  		KeyframeTrack.call( this, name, times, values, interpolation );

  	}

  	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  		constructor: QuaternionKeyframeTrack,

  		ValueTypeName: 'quaternion',

  		// ValueBufferType is inherited

  		DefaultInterpolation: InterpolateLinear,

  		InterpolantFactoryMethodLinear: function ( result ) {

  			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

  		},

  		InterpolantFactoryMethodSmooth: undefined // not yet implemented

  	} );

  	/**
  	 *
  	 * A Track that interpolates Strings
  	 *
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function StringKeyframeTrack( name, times, values, interpolation ) {

  		KeyframeTrack.call( this, name, times, values, interpolation );

  	}

  	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  		constructor: StringKeyframeTrack,

  		ValueTypeName: 'string',
  		ValueBufferType: Array,

  		DefaultInterpolation: InterpolateDiscrete,

  		InterpolantFactoryMethodLinear: undefined,

  		InterpolantFactoryMethodSmooth: undefined

  	} );

  	/**
  	 *
  	 * A Track of vectored keyframe values.
  	 *
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function VectorKeyframeTrack( name, times, values, interpolation ) {

  		KeyframeTrack.call( this, name, times, values, interpolation );

  	}

  	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

  		constructor: VectorKeyframeTrack,

  		ValueTypeName: 'vector'

  		// ValueBufferType is inherited

  		// DefaultInterpolation is inherited

  	} );

  	/**
  	 *
  	 * Reusable set of Tracks that represent an animation.
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 */

  	function AnimationClip( name, duration, tracks ) {

  		this.name = name;
  		this.tracks = tracks;
  		this.duration = ( duration !== undefined ) ? duration : - 1;

  		this.uuid = _Math.generateUUID();

  		// this means it should figure out its duration by scanning the tracks
  		if ( this.duration < 0 ) {

  			this.resetDuration();

  		}

  	}

  	function getTrackTypeForValueTypeName( typeName ) {

  		switch ( typeName.toLowerCase() ) {

  			case 'scalar':
  			case 'double':
  			case 'float':
  			case 'number':
  			case 'integer':

  				return NumberKeyframeTrack;

  			case 'vector':
  			case 'vector2':
  			case 'vector3':
  			case 'vector4':

  				return VectorKeyframeTrack;

  			case 'color':

  				return ColorKeyframeTrack;

  			case 'quaternion':

  				return QuaternionKeyframeTrack;

  			case 'bool':
  			case 'boolean':

  				return BooleanKeyframeTrack;

  			case 'string':

  				return StringKeyframeTrack;

  		}

  		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

  	}

  	function parseKeyframeTrack( json ) {

  		if ( json.type === undefined ) {

  			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

  		}

  		var trackType = getTrackTypeForValueTypeName( json.type );

  		if ( json.times === undefined ) {

  			var times = [], values = [];

  			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

  			json.times = times;
  			json.values = values;

  		}

  		// derived classes can define a static parse method
  		if ( trackType.parse !== undefined ) {

  			return trackType.parse( json );

  		} else {

  			// by default, we assume a constructor compatible with the base
  			return new trackType( json.name, json.times, json.values, json.interpolation );

  		}

  	}

  	Object.assign( AnimationClip, {

  		parse: function ( json ) {

  			var tracks = [],
  				jsonTracks = json.tracks,
  				frameTime = 1.0 / ( json.fps || 1.0 );

  			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

  				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

  			}

  			return new AnimationClip( json.name, json.duration, tracks );

  		},

  		toJSON: function ( clip ) {

  			var tracks = [],
  				clipTracks = clip.tracks;

  			var json = {

  				'name': clip.name,
  				'duration': clip.duration,
  				'tracks': tracks,
  				'uuid': clip.uuid

  			};

  			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

  				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

  			}

  			return json;

  		},

  		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

  			var numMorphTargets = morphTargetSequence.length;
  			var tracks = [];

  			for ( var i = 0; i < numMorphTargets; i ++ ) {

  				var times = [];
  				var values = [];

  				times.push(
  					( i + numMorphTargets - 1 ) % numMorphTargets,
  					i,
  					( i + 1 ) % numMorphTargets );

  				values.push( 0, 1, 0 );

  				var order = AnimationUtils.getKeyframeOrder( times );
  				times = AnimationUtils.sortedArray( times, 1, order );
  				values = AnimationUtils.sortedArray( values, 1, order );

  				// if there is a key at the first frame, duplicate it as the
  				// last frame as well for perfect loop.
  				if ( ! noLoop && times[ 0 ] === 0 ) {

  					times.push( numMorphTargets );
  					values.push( values[ 0 ] );

  				}

  				tracks.push(
  					new NumberKeyframeTrack(
  						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
  						times, values
  					).scale( 1.0 / fps ) );

  			}

  			return new AnimationClip( name, - 1, tracks );

  		},

  		findByName: function ( objectOrClipArray, name ) {

  			var clipArray = objectOrClipArray;

  			if ( ! Array.isArray( objectOrClipArray ) ) {

  				var o = objectOrClipArray;
  				clipArray = o.geometry && o.geometry.animations || o.animations;

  			}

  			for ( var i = 0; i < clipArray.length; i ++ ) {

  				if ( clipArray[ i ].name === name ) {

  					return clipArray[ i ];

  				}

  			}

  			return null;

  		},

  		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

  			var animationToMorphTargets = {};

  			// tested with https://regex101.com/ on trick sequences
  			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  			var pattern = /^([\w-]*?)([\d]+)$/;

  			// sort morph target names into animation groups based
  			// patterns like Walk_001, Walk_002, Run_001, Run_002
  			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

  				var morphTarget = morphTargets[ i ];
  				var parts = morphTarget.name.match( pattern );

  				if ( parts && parts.length > 1 ) {

  					var name = parts[ 1 ];

  					var animationMorphTargets = animationToMorphTargets[ name ];
  					if ( ! animationMorphTargets ) {

  						animationToMorphTargets[ name ] = animationMorphTargets = [];

  					}

  					animationMorphTargets.push( morphTarget );

  				}

  			}

  			var clips = [];

  			for ( var name in animationToMorphTargets ) {

  				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

  			}

  			return clips;

  		},

  		// parse the animation.hierarchy format
  		parseAnimation: function ( animation, bones ) {

  			if ( ! animation ) {

  				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
  				return null;

  			}

  			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

  				// only return track if there are actually keys.
  				if ( animationKeys.length !== 0 ) {

  					var times = [];
  					var values = [];

  					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

  					// empty keys are filtered out, so check again
  					if ( times.length !== 0 ) {

  						destTracks.push( new trackType( trackName, times, values ) );

  					}

  				}

  			};

  			var tracks = [];

  			var clipName = animation.name || 'default';
  			// automatic length determination in AnimationClip.
  			var duration = animation.length || - 1;
  			var fps = animation.fps || 30;

  			var hierarchyTracks = animation.hierarchy || [];

  			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

  				var animationKeys = hierarchyTracks[ h ].keys;

  				// skip empty tracks
  				if ( ! animationKeys || animationKeys.length === 0 ) continue;

  				// process morph targets
  				if ( animationKeys[ 0 ].morphTargets ) {

  					// figure out all morph targets used in this track
  					var morphTargetNames = {};

  					for ( var k = 0; k < animationKeys.length; k ++ ) {

  						if ( animationKeys[ k ].morphTargets ) {

  							for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

  								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

  							}

  						}

  					}

  					// create a track for each morph target with all zero
  					// morphTargetInfluences except for the keys in which
  					// the morphTarget is named.
  					for ( var morphTargetName in morphTargetNames ) {

  						var times = [];
  						var values = [];

  						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

  							var animationKey = animationKeys[ k ];

  							times.push( animationKey.time );
  							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

  						}

  						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

  					}

  					duration = morphTargetNames.length * ( fps || 1.0 );

  				} else {

  					// ...assume skeletal animation

  					var boneName = '.bones[' + bones[ h ].name + ']';

  					addNonemptyTrack(
  						VectorKeyframeTrack, boneName + '.position',
  						animationKeys, 'pos', tracks );

  					addNonemptyTrack(
  						QuaternionKeyframeTrack, boneName + '.quaternion',
  						animationKeys, 'rot', tracks );

  					addNonemptyTrack(
  						VectorKeyframeTrack, boneName + '.scale',
  						animationKeys, 'scl', tracks );

  				}

  			}

  			if ( tracks.length === 0 ) {

  				return null;

  			}

  			var clip = new AnimationClip( clipName, duration, tracks );

  			return clip;

  		}

  	} );

  	Object.assign( AnimationClip.prototype, {

  		resetDuration: function () {

  			var tracks = this.tracks, duration = 0;

  			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

  				var track = this.tracks[ i ];

  				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

  			}

  			this.duration = duration;

  			return this;

  		},

  		trim: function () {

  			for ( var i = 0; i < this.tracks.length; i ++ ) {

  				this.tracks[ i ].trim( 0, this.duration );

  			}

  			return this;

  		},

  		validate: function () {

  			var valid = true;

  			for ( var i = 0; i < this.tracks.length; i ++ ) {

  				valid = valid && this.tracks[ i ].validate();

  			}

  			return valid;

  		},

  		optimize: function () {

  			for ( var i = 0; i < this.tracks.length; i ++ ) {

  				this.tracks[ i ].optimize();

  			}

  			return this;

  		},


  		clone: function () {

  			var tracks = [];

  			for ( var i = 0; i < this.tracks.length; i ++ ) {

  				tracks.push( this.tracks[ i ].clone() );

  			}

  			return new AnimationClip( this.name, this.duration, tracks );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	var Cache = {

  		enabled: false,

  		files: {},

  		add: function ( key, file ) {

  			if ( this.enabled === false ) return;

  			// console.log( 'THREE.Cache', 'Adding key:', key );

  			this.files[ key ] = file;

  		},

  		get: function ( key ) {

  			if ( this.enabled === false ) return;

  			// console.log( 'THREE.Cache', 'Checking key:', key );

  			return this.files[ key ];

  		},

  		remove: function ( key ) {

  			delete this.files[ key ];

  		},

  		clear: function () {

  			this.files = {};

  		}

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function LoadingManager( onLoad, onProgress, onError ) {

  		var scope = this;

  		var isLoading = false;
  		var itemsLoaded = 0;
  		var itemsTotal = 0;
  		var urlModifier = undefined;

  		// Refer to #5689 for the reason why we don't set .onStart
  		// in the constructor

  		this.onStart = undefined;
  		this.onLoad = onLoad;
  		this.onProgress = onProgress;
  		this.onError = onError;

  		this.itemStart = function ( url ) {

  			itemsTotal ++;

  			if ( isLoading === false ) {

  				if ( scope.onStart !== undefined ) {

  					scope.onStart( url, itemsLoaded, itemsTotal );

  				}

  			}

  			isLoading = true;

  		};

  		this.itemEnd = function ( url ) {

  			itemsLoaded ++;

  			if ( scope.onProgress !== undefined ) {

  				scope.onProgress( url, itemsLoaded, itemsTotal );

  			}

  			if ( itemsLoaded === itemsTotal ) {

  				isLoading = false;

  				if ( scope.onLoad !== undefined ) {

  					scope.onLoad();

  				}

  			}

  		};

  		this.itemError = function ( url ) {

  			if ( scope.onError !== undefined ) {

  				scope.onError( url );

  			}

  		};

  		this.resolveURL = function ( url ) {

  			if ( urlModifier ) {

  				return urlModifier( url );

  			}

  			return url;

  		};

  		this.setURLModifier = function ( transform ) {

  			urlModifier = transform;
  			return this;

  		};

  	}

  	var DefaultLoadingManager = new LoadingManager();

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	var loading = {};

  	function FileLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	Object.assign( FileLoader.prototype, {

  		load: function ( url, onLoad, onProgress, onError ) {

  			if ( url === undefined ) url = '';

  			if ( this.path !== undefined ) url = this.path + url;

  			url = this.manager.resolveURL( url );

  			var scope = this;

  			var cached = Cache.get( url );

  			if ( cached !== undefined ) {

  				scope.manager.itemStart( url );

  				setTimeout( function () {

  					if ( onLoad ) onLoad( cached );

  					scope.manager.itemEnd( url );

  				}, 0 );

  				return cached;

  			}

  			// Check if request is duplicate

  			if ( loading[ url ] !== undefined ) {

  				loading[ url ].push( {

  					onLoad: onLoad,
  					onProgress: onProgress,
  					onError: onError

  				} );

  				return;

  			}

  			// Check for data: URI
  			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  			var dataUriRegexResult = url.match( dataUriRegex );

  			// Safari can not handle Data URIs through XMLHttpRequest so process manually
  			if ( dataUriRegexResult ) {

  				var mimeType = dataUriRegexResult[ 1 ];
  				var isBase64 = !! dataUriRegexResult[ 2 ];
  				var data = dataUriRegexResult[ 3 ];

  				data = decodeURIComponent( data );

  				if ( isBase64 ) data = atob( data );

  				try {

  					var response;
  					var responseType = ( this.responseType || '' ).toLowerCase();

  					switch ( responseType ) {

  						case 'arraybuffer':
  						case 'blob':

  							var view = new Uint8Array( data.length );

  							for ( var i = 0; i < data.length; i ++ ) {

  								view[ i ] = data.charCodeAt( i );

  							}

  							if ( responseType === 'blob' ) {

  								response = new Blob( [ view.buffer ], { type: mimeType } );

  							} else {

  								response = view.buffer;

  							}

  							break;

  						case 'document':

  							var parser = new DOMParser();
  							response = parser.parseFromString( data, mimeType );

  							break;

  						case 'json':

  							response = JSON.parse( data );

  							break;

  						default: // 'text' or other

  							response = data;

  							break;

  					}

  					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  					setTimeout( function () {

  						if ( onLoad ) onLoad( response );

  						scope.manager.itemEnd( url );

  					}, 0 );

  				} catch ( error ) {

  					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  					setTimeout( function () {

  						if ( onError ) onError( error );

  						scope.manager.itemError( url );
  						scope.manager.itemEnd( url );

  					}, 0 );

  				}

  			} else {

  				// Initialise array for duplicate requests

  				loading[ url ] = [];

  				loading[ url ].push( {

  					onLoad: onLoad,
  					onProgress: onProgress,
  					onError: onError

  				} );

  				var request = new XMLHttpRequest();

  				request.open( 'GET', url, true );

  				request.addEventListener( 'load', function ( event ) {

  					var response = this.response;

  					Cache.add( url, response );

  					var callbacks = loading[ url ];

  					delete loading[ url ];

  					if ( this.status === 200 || this.status === 0 ) {

  						// Some browsers return HTTP Status 0 when using non-http protocol
  						// e.g. 'file://' or 'data://'. Handle as success.

  						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

  						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  							var callback = callbacks[ i ];
  							if ( callback.onLoad ) callback.onLoad( response );

  						}

  						scope.manager.itemEnd( url );

  					} else {

  						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  							var callback = callbacks[ i ];
  							if ( callback.onError ) callback.onError( event );

  						}

  						scope.manager.itemError( url );
  						scope.manager.itemEnd( url );

  					}

  				}, false );

  				request.addEventListener( 'progress', function ( event ) {

  					var callbacks = loading[ url ];

  					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  						var callback = callbacks[ i ];
  						if ( callback.onProgress ) callback.onProgress( event );

  					}

  				}, false );

  				request.addEventListener( 'error', function ( event ) {

  					var callbacks = loading[ url ];

  					delete loading[ url ];

  					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  						var callback = callbacks[ i ];
  						if ( callback.onError ) callback.onError( event );

  					}

  					scope.manager.itemError( url );
  					scope.manager.itemEnd( url );

  				}, false );

  				request.addEventListener( 'abort', function ( event ) {

  					var callbacks = loading[ url ];

  					delete loading[ url ];

  					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

  						var callback = callbacks[ i ];
  						if ( callback.onError ) callback.onError( event );

  					}

  					scope.manager.itemError( url );
  					scope.manager.itemEnd( url );

  				}, false );

  				if ( this.responseType !== undefined ) request.responseType = this.responseType;
  				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

  				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

  				for ( var header in this.requestHeader ) {

  					request.setRequestHeader( header, this.requestHeader[ header ] );

  				}

  				request.send( null );

  			}

  			scope.manager.itemStart( url );

  			return request;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		},

  		setResponseType: function ( value ) {

  			this.responseType = value;
  			return this;

  		},

  		setWithCredentials: function ( value ) {

  			this.withCredentials = value;
  			return this;

  		},

  		setMimeType: function ( value ) {

  			this.mimeType = value;
  			return this;

  		},

  		setRequestHeader: function ( value ) {

  			this.requestHeader = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author bhouston / http://clara.io/
  	 */

  	function AnimationLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	Object.assign( AnimationLoader.prototype, {

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var loader = new FileLoader( scope.manager );
  			loader.setPath( scope.path );
  			loader.load( url, function ( text ) {

  				onLoad( scope.parse( JSON.parse( text ) ) );

  			}, onProgress, onError );

  		},

  		parse: function ( json ) {

  			var animations = [];

  			for ( var i = 0; i < json.length; i ++ ) {

  				var clip = AnimationClip.parse( json[ i ] );

  				animations.push( clip );

  			}

  			return animations;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 *
  	 * Abstract Base class to block based textures loader (dds, pvr, ...)
  	 */

  	function CompressedTextureLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		// override in sub classes
  		this._parser = null;

  	}

  	Object.assign( CompressedTextureLoader.prototype, {

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var images = [];

  			var texture = new CompressedTexture();
  			texture.image = images;

  			var loader = new FileLoader( this.manager );
  			loader.setPath( this.path );
  			loader.setResponseType( 'arraybuffer' );

  			function loadTexture( i ) {

  				loader.load( url[ i ], function ( buffer ) {

  					var texDatas = scope._parser( buffer, true );

  					images[ i ] = {
  						width: texDatas.width,
  						height: texDatas.height,
  						format: texDatas.format,
  						mipmaps: texDatas.mipmaps
  					};

  					loaded += 1;

  					if ( loaded === 6 ) {

  						if ( texDatas.mipmapCount === 1 )
  							texture.minFilter = LinearFilter;

  						texture.format = texDatas.format;
  						texture.needsUpdate = true;

  						if ( onLoad ) onLoad( texture );

  					}

  				}, onProgress, onError );

  			}

  			if ( Array.isArray( url ) ) {

  				var loaded = 0;

  				for ( var i = 0, il = url.length; i < il; ++ i ) {

  					loadTexture( i );

  				}

  			} else {

  				// compressed cubemap texture stored in a single DDS file

  				loader.load( url, function ( buffer ) {

  					var texDatas = scope._parser( buffer, true );

  					if ( texDatas.isCubemap ) {

  						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

  						for ( var f = 0; f < faces; f ++ ) {

  							images[ f ] = { mipmaps: [] };

  							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

  								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
  								images[ f ].format = texDatas.format;
  								images[ f ].width = texDatas.width;
  								images[ f ].height = texDatas.height;

  							}

  						}

  					} else {

  						texture.image.width = texDatas.width;
  						texture.image.height = texDatas.height;
  						texture.mipmaps = texDatas.mipmaps;

  					}

  					if ( texDatas.mipmapCount === 1 ) {

  						texture.minFilter = LinearFilter;

  					}

  					texture.format = texDatas.format;
  					texture.needsUpdate = true;

  					if ( onLoad ) onLoad( texture );

  				}, onProgress, onError );

  			}

  			return texture;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author Nikos M. / https://github.com/foo123/
  	 *
  	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
  	 */

  	function DataTextureLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  		// override in sub classes
  		this._parser = null;

  	}

  	Object.assign( DataTextureLoader.prototype, {

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var texture = new DataTexture();

  			var loader = new FileLoader( this.manager );
  			loader.setResponseType( 'arraybuffer' );
  			loader.setPath( this.path );
  			loader.load( url, function ( buffer ) {

  				var texData = scope._parser( buffer );

  				if ( ! texData ) return;

  				if ( texData.image !== undefined ) {

  					texture.image = texData.image;

  				} else if ( texData.data !== undefined ) {

  					texture.image.width = texData.width;
  					texture.image.height = texData.height;
  					texture.image.data = texData.data;

  				}

  				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
  				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

  				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
  				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;

  				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

  				if ( texData.format !== undefined ) {

  					texture.format = texData.format;

  				}
  				if ( texData.type !== undefined ) {

  					texture.type = texData.type;

  				}

  				if ( texData.mipmaps !== undefined ) {

  					texture.mipmaps = texData.mipmaps;

  				}

  				if ( texData.mipmapCount === 1 ) {

  					texture.minFilter = LinearFilter;

  				}

  				texture.needsUpdate = true;

  				if ( onLoad ) onLoad( texture, texData );

  			}, onProgress, onError );


  			return texture;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */


  	function ImageLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	Object.assign( ImageLoader.prototype, {

  		crossOrigin: 'anonymous',

  		load: function ( url, onLoad, onProgress, onError ) {

  			if ( url === undefined ) url = '';

  			if ( this.path !== undefined ) url = this.path + url;

  			url = this.manager.resolveURL( url );

  			var scope = this;

  			var cached = Cache.get( url );

  			if ( cached !== undefined ) {

  				scope.manager.itemStart( url );

  				setTimeout( function () {

  					if ( onLoad ) onLoad( cached );

  					scope.manager.itemEnd( url );

  				}, 0 );

  				return cached;

  			}

  			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

  			function onImageLoad() {

  				image.removeEventListener( 'load', onImageLoad, false );
  				image.removeEventListener( 'error', onImageError, false );

  				Cache.add( url, this );

  				if ( onLoad ) onLoad( this );

  				scope.manager.itemEnd( url );

  			}

  			function onImageError( event ) {

  				image.removeEventListener( 'load', onImageLoad, false );
  				image.removeEventListener( 'error', onImageError, false );

  				if ( onError ) onError( event );

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			}

  			image.addEventListener( 'load', onImageLoad, false );
  			image.addEventListener( 'error', onImageError, false );

  			if ( url.substr( 0, 5 ) !== 'data:' ) {

  				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

  			}

  			scope.manager.itemStart( url );

  			image.src = url;

  			return image;

  		},

  		setCrossOrigin: function ( value ) {

  			this.crossOrigin = value;
  			return this;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */


  	function CubeTextureLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	Object.assign( CubeTextureLoader.prototype, {

  		crossOrigin: 'anonymous',

  		load: function ( urls, onLoad, onProgress, onError ) {

  			var texture = new CubeTexture();

  			var loader = new ImageLoader( this.manager );
  			loader.setCrossOrigin( this.crossOrigin );
  			loader.setPath( this.path );

  			var loaded = 0;

  			function loadTexture( i ) {

  				loader.load( urls[ i ], function ( image ) {

  					texture.images[ i ] = image;

  					loaded ++;

  					if ( loaded === 6 ) {

  						texture.needsUpdate = true;

  						if ( onLoad ) onLoad( texture );

  					}

  				}, undefined, onError );

  			}

  			for ( var i = 0; i < urls.length; ++ i ) {

  				loadTexture( i );

  			}

  			return texture;

  		},

  		setCrossOrigin: function ( value ) {

  			this.crossOrigin = value;
  			return this;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */


  	function TextureLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	Object.assign( TextureLoader.prototype, {

  		crossOrigin: 'anonymous',

  		load: function ( url, onLoad, onProgress, onError ) {

  			var texture = new Texture();

  			var loader = new ImageLoader( this.manager );
  			loader.setCrossOrigin( this.crossOrigin );
  			loader.setPath( this.path );

  			loader.load( url, function ( image ) {

  				texture.image = image;

  				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
  				var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

  				texture.format = isJPEG ? RGBFormat : RGBAFormat;
  				texture.needsUpdate = true;

  				if ( onLoad !== undefined ) {

  					onLoad( texture );

  				}

  			}, onProgress, onError );

  			return texture;

  		},

  		setCrossOrigin: function ( value ) {

  			this.crossOrigin = value;
  			return this;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 * Extensible curve object
  	 *
  	 * Some common of curve methods:
  	 * .getPoint( t, optionalTarget ), .getTangent( t )
  	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
  	 * .getPoints(), .getSpacedPoints()
  	 * .getLength()
  	 * .updateArcLengths()
  	 *
  	 * This following curves inherit from THREE.Curve:
  	 *
  	 * -- 2D curves --
  	 * THREE.ArcCurve
  	 * THREE.CubicBezierCurve
  	 * THREE.EllipseCurve
  	 * THREE.LineCurve
  	 * THREE.QuadraticBezierCurve
  	 * THREE.SplineCurve
  	 *
  	 * -- 3D curves --
  	 * THREE.CatmullRomCurve3
  	 * THREE.CubicBezierCurve3
  	 * THREE.LineCurve3
  	 * THREE.QuadraticBezierCurve3
  	 *
  	 * A series of curves can be represented as a THREE.CurvePath.
  	 *
  	 **/

  	/**************************************************************
  	 *	Abstract Curve base class
  	 **************************************************************/

  	function Curve() {

  		this.type = 'Curve';

  		this.arcLengthDivisions = 200;

  	}

  	Object.assign( Curve.prototype, {

  		// Virtual base class method to overwrite and implement in subclasses
  		//	- t [0 .. 1]

  		getPoint: function ( /* t, optionalTarget */ ) {

  			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
  			return null;

  		},

  		// Get point at relative position in curve according to arc length
  		// - u [0 .. 1]

  		getPointAt: function ( u, optionalTarget ) {

  			var t = this.getUtoTmapping( u );
  			return this.getPoint( t, optionalTarget );

  		},

  		// Get sequence of points using getPoint( t )

  		getPoints: function ( divisions ) {

  			if ( divisions === undefined ) divisions = 5;

  			var points = [];

  			for ( var d = 0; d <= divisions; d ++ ) {

  				points.push( this.getPoint( d / divisions ) );

  			}

  			return points;

  		},

  		// Get sequence of points using getPointAt( u )

  		getSpacedPoints: function ( divisions ) {

  			if ( divisions === undefined ) divisions = 5;

  			var points = [];

  			for ( var d = 0; d <= divisions; d ++ ) {

  				points.push( this.getPointAt( d / divisions ) );

  			}

  			return points;

  		},

  		// Get total curve arc length

  		getLength: function () {

  			var lengths = this.getLengths();
  			return lengths[ lengths.length - 1 ];

  		},

  		// Get list of cumulative segment lengths

  		getLengths: function ( divisions ) {

  			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

  			if ( this.cacheArcLengths &&
  				( this.cacheArcLengths.length === divisions + 1 ) &&
  				! this.needsUpdate ) {

  				return this.cacheArcLengths;

  			}

  			this.needsUpdate = false;

  			var cache = [];
  			var current, last = this.getPoint( 0 );
  			var p, sum = 0;

  			cache.push( 0 );

  			for ( p = 1; p <= divisions; p ++ ) {

  				current = this.getPoint( p / divisions );
  				sum += current.distanceTo( last );
  				cache.push( sum );
  				last = current;

  			}

  			this.cacheArcLengths = cache;

  			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

  		},

  		updateArcLengths: function () {

  			this.needsUpdate = true;
  			this.getLengths();

  		},

  		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  		getUtoTmapping: function ( u, distance ) {

  			var arcLengths = this.getLengths();

  			var i = 0, il = arcLengths.length;

  			var targetArcLength; // The targeted u distance value to get

  			if ( distance ) {

  				targetArcLength = distance;

  			} else {

  				targetArcLength = u * arcLengths[ il - 1 ];

  			}

  			// binary search for the index with largest value smaller than target u distance

  			var low = 0, high = il - 1, comparison;

  			while ( low <= high ) {

  				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

  				comparison = arcLengths[ i ] - targetArcLength;

  				if ( comparison < 0 ) {

  					low = i + 1;

  				} else if ( comparison > 0 ) {

  					high = i - 1;

  				} else {

  					high = i;
  					break;

  					// DONE

  				}

  			}

  			i = high;

  			if ( arcLengths[ i ] === targetArcLength ) {

  				return i / ( il - 1 );

  			}

  			// we could get finer grain at lengths, or use simple interpolation between two points

  			var lengthBefore = arcLengths[ i ];
  			var lengthAfter = arcLengths[ i + 1 ];

  			var segmentLength = lengthAfter - lengthBefore;

  			// determine where we are between the 'before' and 'after' points

  			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

  			// add that fractional amount to t

  			var t = ( i + segmentFraction ) / ( il - 1 );

  			return t;

  		},

  		// Returns a unit vector tangent at t
  		// In case any sub curve does not implement its tangent derivation,
  		// 2 points a small delta apart will be used to find its gradient
  		// which seems to give a reasonable approximation

  		getTangent: function ( t ) {

  			var delta = 0.0001;
  			var t1 = t - delta;
  			var t2 = t + delta;

  			// Capping in case of danger

  			if ( t1 < 0 ) t1 = 0;
  			if ( t2 > 1 ) t2 = 1;

  			var pt1 = this.getPoint( t1 );
  			var pt2 = this.getPoint( t2 );

  			var vec = pt2.clone().sub( pt1 );
  			return vec.normalize();

  		},

  		getTangentAt: function ( u ) {

  			var t = this.getUtoTmapping( u );
  			return this.getTangent( t );

  		},

  		computeFrenetFrames: function ( segments, closed ) {

  			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

  			var normal = new Vector3();

  			var tangents = [];
  			var normals = [];
  			var binormals = [];

  			var vec = new Vector3();
  			var mat = new Matrix4();

  			var i, u, theta;

  			// compute the tangent vectors for each segment on the curve

  			for ( i = 0; i <= segments; i ++ ) {

  				u = i / segments;

  				tangents[ i ] = this.getTangentAt( u );
  				tangents[ i ].normalize();

  			}

  			// select an initial normal vector perpendicular to the first tangent vector,
  			// and in the direction of the minimum tangent xyz component

  			normals[ 0 ] = new Vector3();
  			binormals[ 0 ] = new Vector3();
  			var min = Number.MAX_VALUE;
  			var tx = Math.abs( tangents[ 0 ].x );
  			var ty = Math.abs( tangents[ 0 ].y );
  			var tz = Math.abs( tangents[ 0 ].z );

  			if ( tx <= min ) {

  				min = tx;
  				normal.set( 1, 0, 0 );

  			}

  			if ( ty <= min ) {

  				min = ty;
  				normal.set( 0, 1, 0 );

  			}

  			if ( tz <= min ) {

  				normal.set( 0, 0, 1 );

  			}

  			vec.crossVectors( tangents[ 0 ], normal ).normalize();

  			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
  			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


  			// compute the slowly-varying normal and binormal vectors for each segment on the curve

  			for ( i = 1; i <= segments; i ++ ) {

  				normals[ i ] = normals[ i - 1 ].clone();

  				binormals[ i ] = binormals[ i - 1 ].clone();

  				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

  				if ( vec.length() > Number.EPSILON ) {

  					vec.normalize();

  					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

  					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

  				}

  				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  			}

  			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  			if ( closed === true ) {

  				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
  				theta /= segments;

  				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

  					theta = - theta;

  				}

  				for ( i = 1; i <= segments; i ++ ) {

  					// twist a little...
  					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
  					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  				}

  			}

  			return {
  				tangents: tangents,
  				normals: normals,
  				binormals: binormals
  			};

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( source ) {

  			this.arcLengthDivisions = source.arcLengthDivisions;

  			return this;

  		},

  		toJSON: function () {

  			var data = {
  				metadata: {
  					version: 4.5,
  					type: 'Curve',
  					generator: 'Curve.toJSON'
  				}
  			};

  			data.arcLengthDivisions = this.arcLengthDivisions;
  			data.type = this.type;

  			return data;

  		},

  		fromJSON: function ( json ) {

  			this.arcLengthDivisions = json.arcLengthDivisions;

  			return this;

  		}

  	} );

  	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		Curve.call( this );

  		this.type = 'EllipseCurve';

  		this.aX = aX || 0;
  		this.aY = aY || 0;

  		this.xRadius = xRadius || 1;
  		this.yRadius = yRadius || 1;

  		this.aStartAngle = aStartAngle || 0;
  		this.aEndAngle = aEndAngle || 2 * Math.PI;

  		this.aClockwise = aClockwise || false;

  		this.aRotation = aRotation || 0;

  	}

  	EllipseCurve.prototype = Object.create( Curve.prototype );
  	EllipseCurve.prototype.constructor = EllipseCurve;

  	EllipseCurve.prototype.isEllipseCurve = true;

  	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector2();

  		var twoPi = Math.PI * 2;
  		var deltaAngle = this.aEndAngle - this.aStartAngle;
  		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

  		// ensures that deltaAngle is 0 .. 2 PI
  		while ( deltaAngle < 0 ) deltaAngle += twoPi;
  		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

  		if ( deltaAngle < Number.EPSILON ) {

  			if ( samePoints ) {

  				deltaAngle = 0;

  			} else {

  				deltaAngle = twoPi;

  			}

  		}

  		if ( this.aClockwise === true && ! samePoints ) {

  			if ( deltaAngle === twoPi ) {

  				deltaAngle = - twoPi;

  			} else {

  				deltaAngle = deltaAngle - twoPi;

  			}

  		}

  		var angle = this.aStartAngle + t * deltaAngle;
  		var x = this.aX + this.xRadius * Math.cos( angle );
  		var y = this.aY + this.yRadius * Math.sin( angle );

  		if ( this.aRotation !== 0 ) {

  			var cos = Math.cos( this.aRotation );
  			var sin = Math.sin( this.aRotation );

  			var tx = x - this.aX;
  			var ty = y - this.aY;

  			// Rotate the point about the center of the ellipse.
  			x = tx * cos - ty * sin + this.aX;
  			y = tx * sin + ty * cos + this.aY;

  		}

  		return point.set( x, y );

  	};

  	EllipseCurve.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.aX = source.aX;
  		this.aY = source.aY;

  		this.xRadius = source.xRadius;
  		this.yRadius = source.yRadius;

  		this.aStartAngle = source.aStartAngle;
  		this.aEndAngle = source.aEndAngle;

  		this.aClockwise = source.aClockwise;

  		this.aRotation = source.aRotation;

  		return this;

  	};


  	EllipseCurve.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.aX = this.aX;
  		data.aY = this.aY;

  		data.xRadius = this.xRadius;
  		data.yRadius = this.yRadius;

  		data.aStartAngle = this.aStartAngle;
  		data.aEndAngle = this.aEndAngle;

  		data.aClockwise = this.aClockwise;

  		data.aRotation = this.aRotation;

  		return data;

  	};

  	EllipseCurve.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.aX = json.aX;
  		this.aY = json.aY;

  		this.xRadius = json.xRadius;
  		this.yRadius = json.yRadius;

  		this.aStartAngle = json.aStartAngle;
  		this.aEndAngle = json.aEndAngle;

  		this.aClockwise = json.aClockwise;

  		this.aRotation = json.aRotation;

  		return this;

  	};

  	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  		this.type = 'ArcCurve';

  	}

  	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
  	ArcCurve.prototype.constructor = ArcCurve;

  	ArcCurve.prototype.isArcCurve = true;

  	/**
  	 * @author zz85 https://github.com/zz85
  	 *
  	 * Centripetal CatmullRom Curve - which is useful for avoiding
  	 * cusps and self-intersections in non-uniform catmull rom curves.
  	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
  	 *
  	 * curve.type accepts centripetal(default), chordal and catmullrom
  	 * curve.tension is used for catmullrom which defaults to 0.5
  	 */


  	/*
  	Based on an optimized c++ solution in
  	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
  	 - http://ideone.com/NoEbVM

  	This CubicPoly class could be used for reusing some variables and calculations,
  	but for three.js curve use, it could be possible inlined and flatten into a single function call
  	which can be placed in CurveUtils.
  	*/

  	function CubicPoly() {

  		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

  		/*
  		 * Compute coefficients for a cubic polynomial
  		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
  		 * such that
  		 *   p(0) = x0, p(1) = x1
  		 *  and
  		 *   p'(0) = t0, p'(1) = t1.
  		 */
  		function init( x0, x1, t0, t1 ) {

  			c0 = x0;
  			c1 = t0;
  			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
  			c3 = 2 * x0 - 2 * x1 + t0 + t1;

  		}

  		return {

  			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

  				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  			},

  			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

  				// compute tangents when parameterized in [t1,t2]
  				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
  				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

  				// rescale tangents for parametrization in [0,1]
  				t1 *= dt1;
  				t2 *= dt1;

  				init( x1, x2, t1, t2 );

  			},

  			calc: function ( t ) {

  				var t2 = t * t;
  				var t3 = t2 * t;
  				return c0 + c1 * t + c2 * t2 + c3 * t3;

  			}

  		};

  	}

  	//

  	var tmp = new Vector3();
  	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

  	function CatmullRomCurve3( points, closed, curveType, tension ) {

  		Curve.call( this );

  		this.type = 'CatmullRomCurve3';

  		this.points = points || [];
  		this.closed = closed || false;
  		this.curveType = curveType || 'centripetal';
  		this.tension = tension || 0.5;

  	}

  	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
  	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

  	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

  	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var points = this.points;
  		var l = points.length;

  		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
  		var intPoint = Math.floor( p );
  		var weight = p - intPoint;

  		if ( this.closed ) {

  			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

  		} else if ( weight === 0 && intPoint === l - 1 ) {

  			intPoint = l - 2;
  			weight = 1;

  		}

  		var p0, p1, p2, p3; // 4 points

  		if ( this.closed || intPoint > 0 ) {

  			p0 = points[ ( intPoint - 1 ) % l ];

  		} else {

  			// extrapolate first point
  			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
  			p0 = tmp;

  		}

  		p1 = points[ intPoint % l ];
  		p2 = points[ ( intPoint + 1 ) % l ];

  		if ( this.closed || intPoint + 2 < l ) {

  			p3 = points[ ( intPoint + 2 ) % l ];

  		} else {

  			// extrapolate last point
  			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
  			p3 = tmp;

  		}

  		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

  			// init Centripetal / Chordal Catmull-Rom
  			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
  			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
  			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
  			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

  			// safety check for repeated points
  			if ( dt1 < 1e-4 ) dt1 = 1.0;
  			if ( dt0 < 1e-4 ) dt0 = dt1;
  			if ( dt2 < 1e-4 ) dt2 = dt1;

  			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
  			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
  			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

  		} else if ( this.curveType === 'catmullrom' ) {

  			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
  			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
  			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

  		}

  		point.set(
  			px.calc( weight ),
  			py.calc( weight ),
  			pz.calc( weight )
  		);

  		return point;

  	};

  	CatmullRomCurve3.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.points = [];

  		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

  			var point = source.points[ i ];

  			this.points.push( point.clone() );

  		}

  		this.closed = source.closed;
  		this.curveType = source.curveType;
  		this.tension = source.tension;

  		return this;

  	};

  	CatmullRomCurve3.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.points = [];

  		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

  			var point = this.points[ i ];
  			data.points.push( point.toArray() );

  		}

  		data.closed = this.closed;
  		data.curveType = this.curveType;
  		data.tension = this.tension;

  		return data;

  	};

  	CatmullRomCurve3.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.points = [];

  		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

  			var point = json.points[ i ];
  			this.points.push( new Vector3().fromArray( point ) );

  		}

  		this.closed = json.closed;
  		this.curveType = json.curveType;
  		this.tension = json.tension;

  		return this;

  	};

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 *
  	 * Bezier Curves formulas obtained from
  	 * http://en.wikipedia.org/wiki/BÃ©zier_curve
  	 */

  	function CatmullRom( t, p0, p1, p2, p3 ) {

  		var v0 = ( p2 - p0 ) * 0.5;
  		var v1 = ( p3 - p1 ) * 0.5;
  		var t2 = t * t;
  		var t3 = t * t2;
  		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  	}

  	//

  	function QuadraticBezierP0( t, p ) {

  		var k = 1 - t;
  		return k * k * p;

  	}

  	function QuadraticBezierP1( t, p ) {

  		return 2 * ( 1 - t ) * t * p;

  	}

  	function QuadraticBezierP2( t, p ) {

  		return t * t * p;

  	}

  	function QuadraticBezier( t, p0, p1, p2 ) {

  		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
  			QuadraticBezierP2( t, p2 );

  	}

  	//

  	function CubicBezierP0( t, p ) {

  		var k = 1 - t;
  		return k * k * k * p;

  	}

  	function CubicBezierP1( t, p ) {

  		var k = 1 - t;
  		return 3 * k * k * t * p;

  	}

  	function CubicBezierP2( t, p ) {

  		return 3 * ( 1 - t ) * t * t * p;

  	}

  	function CubicBezierP3( t, p ) {

  		return t * t * t * p;

  	}

  	function CubicBezier( t, p0, p1, p2, p3 ) {

  		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
  			CubicBezierP3( t, p3 );

  	}

  	function CubicBezierCurve( v0, v1, v2, v3 ) {

  		Curve.call( this );

  		this.type = 'CubicBezierCurve';

  		this.v0 = v0 || new Vector2();
  		this.v1 = v1 || new Vector2();
  		this.v2 = v2 || new Vector2();
  		this.v3 = v3 || new Vector2();

  	}

  	CubicBezierCurve.prototype = Object.create( Curve.prototype );
  	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

  	CubicBezierCurve.prototype.isCubicBezierCurve = true;

  	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector2();

  		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  		point.set(
  			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
  			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
  		);

  		return point;

  	};

  	CubicBezierCurve.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.v0.copy( source.v0 );
  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );
  		this.v3.copy( source.v3 );

  		return this;

  	};

  	CubicBezierCurve.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.v0 = this.v0.toArray();
  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();
  		data.v3 = this.v3.toArray();

  		return data;

  	};

  	CubicBezierCurve.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.v0.fromArray( json.v0 );
  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );
  		this.v3.fromArray( json.v3 );

  		return this;

  	};

  	function CubicBezierCurve3( v0, v1, v2, v3 ) {

  		Curve.call( this );

  		this.type = 'CubicBezierCurve3';

  		this.v0 = v0 || new Vector3();
  		this.v1 = v1 || new Vector3();
  		this.v2 = v2 || new Vector3();
  		this.v3 = v3 || new Vector3();

  	}

  	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
  	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

  	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

  	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  		point.set(
  			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
  			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
  			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
  		);

  		return point;

  	};

  	CubicBezierCurve3.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.v0.copy( source.v0 );
  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );
  		this.v3.copy( source.v3 );

  		return this;

  	};

  	CubicBezierCurve3.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.v0 = this.v0.toArray();
  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();
  		data.v3 = this.v3.toArray();

  		return data;

  	};

  	CubicBezierCurve3.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.v0.fromArray( json.v0 );
  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );
  		this.v3.fromArray( json.v3 );

  		return this;

  	};

  	function LineCurve( v1, v2 ) {

  		Curve.call( this );

  		this.type = 'LineCurve';

  		this.v1 = v1 || new Vector2();
  		this.v2 = v2 || new Vector2();

  	}

  	LineCurve.prototype = Object.create( Curve.prototype );
  	LineCurve.prototype.constructor = LineCurve;

  	LineCurve.prototype.isLineCurve = true;

  	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector2();

  		if ( t === 1 ) {

  			point.copy( this.v2 );

  		} else {

  			point.copy( this.v2 ).sub( this.v1 );
  			point.multiplyScalar( t ).add( this.v1 );

  		}

  		return point;

  	};

  	// Line curve is linear, so we can overwrite default getPointAt

  	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

  		return this.getPoint( u, optionalTarget );

  	};

  	LineCurve.prototype.getTangent = function ( /* t */ ) {

  		var tangent = this.v2.clone().sub( this.v1 );

  		return tangent.normalize();

  	};

  	LineCurve.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );

  		return this;

  	};

  	LineCurve.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();

  		return data;

  	};

  	LineCurve.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );

  		return this;

  	};

  	function LineCurve3( v1, v2 ) {

  		Curve.call( this );

  		this.type = 'LineCurve3';

  		this.v1 = v1 || new Vector3();
  		this.v2 = v2 || new Vector3();

  	}

  	LineCurve3.prototype = Object.create( Curve.prototype );
  	LineCurve3.prototype.constructor = LineCurve3;

  	LineCurve3.prototype.isLineCurve3 = true;

  	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		if ( t === 1 ) {

  			point.copy( this.v2 );

  		} else {

  			point.copy( this.v2 ).sub( this.v1 );
  			point.multiplyScalar( t ).add( this.v1 );

  		}

  		return point;

  	};

  	// Line curve is linear, so we can overwrite default getPointAt

  	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

  		return this.getPoint( u, optionalTarget );

  	};

  	LineCurve3.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );

  		return this;

  	};

  	LineCurve3.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();

  		return data;

  	};

  	LineCurve3.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );

  		return this;

  	};

  	function QuadraticBezierCurve( v0, v1, v2 ) {

  		Curve.call( this );

  		this.type = 'QuadraticBezierCurve';

  		this.v0 = v0 || new Vector2();
  		this.v1 = v1 || new Vector2();
  		this.v2 = v2 || new Vector2();

  	}

  	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
  	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

  	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

  	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector2();

  		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

  		point.set(
  			QuadraticBezier( t, v0.x, v1.x, v2.x ),
  			QuadraticBezier( t, v0.y, v1.y, v2.y )
  		);

  		return point;

  	};

  	QuadraticBezierCurve.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.v0.copy( source.v0 );
  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );

  		return this;

  	};

  	QuadraticBezierCurve.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.v0 = this.v0.toArray();
  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();

  		return data;

  	};

  	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.v0.fromArray( json.v0 );
  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );

  		return this;

  	};

  	function QuadraticBezierCurve3( v0, v1, v2 ) {

  		Curve.call( this );

  		this.type = 'QuadraticBezierCurve3';

  		this.v0 = v0 || new Vector3();
  		this.v1 = v1 || new Vector3();
  		this.v2 = v2 || new Vector3();

  	}

  	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
  	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

  	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

  	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector3();

  		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

  		point.set(
  			QuadraticBezier( t, v0.x, v1.x, v2.x ),
  			QuadraticBezier( t, v0.y, v1.y, v2.y ),
  			QuadraticBezier( t, v0.z, v1.z, v2.z )
  		);

  		return point;

  	};

  	QuadraticBezierCurve3.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.v0.copy( source.v0 );
  		this.v1.copy( source.v1 );
  		this.v2.copy( source.v2 );

  		return this;

  	};

  	QuadraticBezierCurve3.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.v0 = this.v0.toArray();
  		data.v1 = this.v1.toArray();
  		data.v2 = this.v2.toArray();

  		return data;

  	};

  	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.v0.fromArray( json.v0 );
  		this.v1.fromArray( json.v1 );
  		this.v2.fromArray( json.v2 );

  		return this;

  	};

  	function SplineCurve( points /* array of Vector2 */ ) {

  		Curve.call( this );

  		this.type = 'SplineCurve';

  		this.points = points || [];

  	}

  	SplineCurve.prototype = Object.create( Curve.prototype );
  	SplineCurve.prototype.constructor = SplineCurve;

  	SplineCurve.prototype.isSplineCurve = true;

  	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

  		var point = optionalTarget || new Vector2();

  		var points = this.points;
  		var p = ( points.length - 1 ) * t;

  		var intPoint = Math.floor( p );
  		var weight = p - intPoint;

  		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  		var p1 = points[ intPoint ];
  		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  		point.set(
  			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
  			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
  		);

  		return point;

  	};

  	SplineCurve.prototype.copy = function ( source ) {

  		Curve.prototype.copy.call( this, source );

  		this.points = [];

  		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

  			var point = source.points[ i ];

  			this.points.push( point.clone() );

  		}

  		return this;

  	};

  	SplineCurve.prototype.toJSON = function () {

  		var data = Curve.prototype.toJSON.call( this );

  		data.points = [];

  		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

  			var point = this.points[ i ];
  			data.points.push( point.toArray() );

  		}

  		return data;

  	};

  	SplineCurve.prototype.fromJSON = function ( json ) {

  		Curve.prototype.fromJSON.call( this, json );

  		this.points = [];

  		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

  			var point = json.points[ i ];
  			this.points.push( new Vector2().fromArray( point ) );

  		}

  		return this;

  	};



  	var Curves = /*#__PURE__*/Object.freeze({
  		ArcCurve: ArcCurve,
  		CatmullRomCurve3: CatmullRomCurve3,
  		CubicBezierCurve: CubicBezierCurve,
  		CubicBezierCurve3: CubicBezierCurve3,
  		EllipseCurve: EllipseCurve,
  		LineCurve: LineCurve,
  		LineCurve3: LineCurve3,
  		QuadraticBezierCurve: QuadraticBezierCurve,
  		QuadraticBezierCurve3: QuadraticBezierCurve3,
  		SplineCurve: SplineCurve
  	});

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 *
  	 **/

  	/**************************************************************
  	 *	Curved Path - a curve path is simply a array of connected
  	 *  curves, but retains the api of a curve
  	 **************************************************************/

  	function CurvePath() {

  		Curve.call( this );

  		this.type = 'CurvePath';

  		this.curves = [];
  		this.autoClose = false; // Automatically closes the path

  	}

  	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

  		constructor: CurvePath,

  		add: function ( curve ) {

  			this.curves.push( curve );

  		},

  		closePath: function () {

  			// Add a line curve if start and end of lines are not connected
  			var startPoint = this.curves[ 0 ].getPoint( 0 );
  			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

  			if ( ! startPoint.equals( endPoint ) ) {

  				this.curves.push( new LineCurve( endPoint, startPoint ) );

  			}

  		},

  		// To get accurate point with reference to
  		// entire path distance at time t,
  		// following has to be done:

  		// 1. Length of each sub path have to be known
  		// 2. Locate and identify type of curve
  		// 3. Get t for the curve
  		// 4. Return curve.getPointAt(t')

  		getPoint: function ( t ) {

  			var d = t * this.getLength();
  			var curveLengths = this.getCurveLengths();
  			var i = 0;

  			// To think about boundaries points.

  			while ( i < curveLengths.length ) {

  				if ( curveLengths[ i ] >= d ) {

  					var diff = curveLengths[ i ] - d;
  					var curve = this.curves[ i ];

  					var segmentLength = curve.getLength();
  					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

  					return curve.getPointAt( u );

  				}

  				i ++;

  			}

  			return null;

  			// loop where sum != 0, sum > d , sum+1 <d

  		},

  		// We cannot use the default THREE.Curve getPoint() with getLength() because in
  		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  		// getPoint() depends on getLength

  		getLength: function () {

  			var lens = this.getCurveLengths();
  			return lens[ lens.length - 1 ];

  		},

  		// cacheLengths must be recalculated.
  		updateArcLengths: function () {

  			this.needsUpdate = true;
  			this.cacheLengths = null;
  			this.getCurveLengths();

  		},

  		// Compute lengths and cache them
  		// We cannot overwrite getLengths() because UtoT mapping uses it.

  		getCurveLengths: function () {

  			// We use cache values if curves and cache array are same length

  			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

  				return this.cacheLengths;

  			}

  			// Get length of sub-curve
  			// Push sums into cached array

  			var lengths = [], sums = 0;

  			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

  				sums += this.curves[ i ].getLength();
  				lengths.push( sums );

  			}

  			this.cacheLengths = lengths;

  			return lengths;

  		},

  		getSpacedPoints: function ( divisions ) {

  			if ( divisions === undefined ) divisions = 40;

  			var points = [];

  			for ( var i = 0; i <= divisions; i ++ ) {

  				points.push( this.getPoint( i / divisions ) );

  			}

  			if ( this.autoClose ) {

  				points.push( points[ 0 ] );

  			}

  			return points;

  		},

  		getPoints: function ( divisions ) {

  			divisions = divisions || 12;

  			var points = [], last;

  			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

  				var curve = curves[ i ];
  				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
  					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
  						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
  							: divisions;

  				var pts = curve.getPoints( resolution );

  				for ( var j = 0; j < pts.length; j ++ ) {

  					var point = pts[ j ];

  					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

  					points.push( point );
  					last = point;

  				}

  			}

  			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

  				points.push( points[ 0 ] );

  			}

  			return points;

  		},

  		copy: function ( source ) {

  			Curve.prototype.copy.call( this, source );

  			this.curves = [];

  			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

  				var curve = source.curves[ i ];

  				this.curves.push( curve.clone() );

  			}

  			this.autoClose = source.autoClose;

  			return this;

  		},

  		toJSON: function () {

  			var data = Curve.prototype.toJSON.call( this );

  			data.autoClose = this.autoClose;
  			data.curves = [];

  			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

  				var curve = this.curves[ i ];
  				data.curves.push( curve.toJSON() );

  			}

  			return data;

  		},

  		fromJSON: function ( json ) {

  			Curve.prototype.fromJSON.call( this, json );

  			this.autoClose = json.autoClose;
  			this.curves = [];

  			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

  				var curve = json.curves[ i ];
  				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

  			}

  			return this;

  		}

  	} );

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 * Creates free form 2d path using series of points, lines or curves.
  	 **/

  	function Path( points ) {

  		CurvePath.call( this );

  		this.type = 'Path';

  		this.currentPoint = new Vector2();

  		if ( points ) {

  			this.setFromPoints( points );

  		}

  	}

  	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

  		constructor: Path,

  		setFromPoints: function ( points ) {

  			this.moveTo( points[ 0 ].x, points[ 0 ].y );

  			for ( var i = 1, l = points.length; i < l; i ++ ) {

  				this.lineTo( points[ i ].x, points[ i ].y );

  			}

  		},

  		moveTo: function ( x, y ) {

  			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

  		},

  		lineTo: function ( x, y ) {

  			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
  			this.curves.push( curve );

  			this.currentPoint.set( x, y );

  		},

  		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

  			var curve = new QuadraticBezierCurve(
  				this.currentPoint.clone(),
  				new Vector2( aCPx, aCPy ),
  				new Vector2( aX, aY )
  			);

  			this.curves.push( curve );

  			this.currentPoint.set( aX, aY );

  		},

  		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  			var curve = new CubicBezierCurve(
  				this.currentPoint.clone(),
  				new Vector2( aCP1x, aCP1y ),
  				new Vector2( aCP2x, aCP2y ),
  				new Vector2( aX, aY )
  			);

  			this.curves.push( curve );

  			this.currentPoint.set( aX, aY );

  		},

  		splineThru: function ( pts /*Array of Vector*/ ) {

  			var npts = [ this.currentPoint.clone() ].concat( pts );

  			var curve = new SplineCurve( npts );
  			this.curves.push( curve );

  			this.currentPoint.copy( pts[ pts.length - 1 ] );

  		},

  		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  			var x0 = this.currentPoint.x;
  			var y0 = this.currentPoint.y;

  			this.absarc( aX + x0, aY + y0, aRadius,
  				aStartAngle, aEndAngle, aClockwise );

  		},

  		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  		},

  		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  			var x0 = this.currentPoint.x;
  			var y0 = this.currentPoint.y;

  			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  		},

  		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  			if ( this.curves.length > 0 ) {

  				// if a previous curve is present, attempt to join
  				var firstPoint = curve.getPoint( 0 );

  				if ( ! firstPoint.equals( this.currentPoint ) ) {

  					this.lineTo( firstPoint.x, firstPoint.y );

  				}

  			}

  			this.curves.push( curve );

  			var lastPoint = curve.getPoint( 1 );
  			this.currentPoint.copy( lastPoint );

  		},

  		copy: function ( source ) {

  			CurvePath.prototype.copy.call( this, source );

  			this.currentPoint.copy( source.currentPoint );

  			return this;

  		},

  		toJSON: function () {

  			var data = CurvePath.prototype.toJSON.call( this );

  			data.currentPoint = this.currentPoint.toArray();

  			return data;

  		},

  		fromJSON: function ( json ) {

  			CurvePath.prototype.fromJSON.call( this, json );

  			this.currentPoint.fromArray( json.currentPoint );

  			return this;

  		}

  	} );

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 * Defines a 2d shape plane using paths.
  	 **/

  	// STEP 1 Create a path.
  	// STEP 2 Turn path into shape.
  	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
  	// STEP 3a - Extract points from each shape, turn to vertices
  	// STEP 3b - Triangulate each shape, add faces.

  	function Shape( points ) {

  		Path.call( this, points );

  		this.uuid = _Math.generateUUID();

  		this.type = 'Shape';

  		this.holes = [];

  	}

  	Shape.prototype = Object.assign( Object.create( Path.prototype ), {

  		constructor: Shape,

  		getPointsHoles: function ( divisions ) {

  			var holesPts = [];

  			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

  				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

  			}

  			return holesPts;

  		},

  		// get points of shape and holes (keypoints based on segments parameter)

  		extractPoints: function ( divisions ) {

  			return {

  				shape: this.getPoints( divisions ),
  				holes: this.getPointsHoles( divisions )

  			};

  		},

  		copy: function ( source ) {

  			Path.prototype.copy.call( this, source );

  			this.holes = [];

  			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

  				var hole = source.holes[ i ];

  				this.holes.push( hole.clone() );

  			}

  			return this;

  		},

  		toJSON: function () {

  			var data = Path.prototype.toJSON.call( this );

  			data.uuid = this.uuid;
  			data.holes = [];

  			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

  				var hole = this.holes[ i ];
  				data.holes.push( hole.toJSON() );

  			}

  			return data;

  		},

  		fromJSON: function ( json ) {

  			Path.prototype.fromJSON.call( this, json );

  			this.uuid = json.uuid;
  			this.holes = [];

  			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

  				var hole = json.holes[ i ];
  				this.holes.push( new Path().fromJSON( hole ) );

  			}

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function Light( color, intensity ) {

  		Object3D.call( this );

  		this.type = 'Light';

  		this.color = new Color( color );
  		this.intensity = intensity !== undefined ? intensity : 1;

  		this.receiveShadow = undefined;

  	}

  	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Light,

  		isLight: true,

  		copy: function ( source ) {

  			Object3D.prototype.copy.call( this, source );

  			this.color.copy( source.color );
  			this.intensity = source.intensity;

  			return this;

  		},

  		toJSON: function ( meta ) {

  			var data = Object3D.prototype.toJSON.call( this, meta );

  			data.object.color = this.color.getHex();
  			data.object.intensity = this.intensity;

  			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

  			if ( this.distance !== undefined ) data.object.distance = this.distance;
  			if ( this.angle !== undefined ) data.object.angle = this.angle;
  			if ( this.decay !== undefined ) data.object.decay = this.decay;
  			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

  			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

  			return data;

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function HemisphereLight( skyColor, groundColor, intensity ) {

  		Light.call( this, skyColor, intensity );

  		this.type = 'HemisphereLight';

  		this.castShadow = undefined;

  		this.position.copy( Object3D.DefaultUp );
  		this.updateMatrix();

  		this.groundColor = new Color( groundColor );

  	}

  	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

  		constructor: HemisphereLight,

  		isHemisphereLight: true,

  		copy: function ( source ) {

  			Light.prototype.copy.call( this, source );

  			this.groundColor.copy( source.groundColor );

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function LightShadow( camera ) {

  		this.camera = camera;

  		this.bias = 0;
  		this.radius = 1;

  		this.mapSize = new Vector2( 512, 512 );

  		this.map = null;
  		this.matrix = new Matrix4();

  	}

  	Object.assign( LightShadow.prototype, {

  		copy: function ( source ) {

  			this.camera = source.camera.clone();

  			this.bias = source.bias;
  			this.radius = source.radius;

  			this.mapSize.copy( source.mapSize );

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		toJSON: function () {

  			var object = {};

  			if ( this.bias !== 0 ) object.bias = this.bias;
  			if ( this.radius !== 1 ) object.radius = this.radius;
  			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

  			object.camera = this.camera.toJSON( false ).object;
  			delete object.camera.matrix;

  			return object;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function SpotLightShadow() {

  		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

  	}

  	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

  		constructor: SpotLightShadow,

  		isSpotLightShadow: true,

  		update: function ( light ) {

  			var camera = this.camera;

  			var fov = _Math.RAD2DEG * 2 * light.angle;
  			var aspect = this.mapSize.width / this.mapSize.height;
  			var far = light.distance || camera.far;

  			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  				camera.fov = fov;
  				camera.aspect = aspect;
  				camera.far = far;
  				camera.updateProjectionMatrix();

  			}

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

  		Light.call( this, color, intensity );

  		this.type = 'SpotLight';

  		this.position.copy( Object3D.DefaultUp );
  		this.updateMatrix();

  		this.target = new Object3D();

  		Object.defineProperty( this, 'power', {
  			get: function () {

  				// intensity = power per solid angle.
  				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  				return this.intensity * Math.PI;

  			},
  			set: function ( power ) {

  				// intensity = power per solid angle.
  				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  				this.intensity = power / Math.PI;

  			}
  		} );

  		this.distance = ( distance !== undefined ) ? distance : 0;
  		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
  		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  		this.shadow = new SpotLightShadow();

  	}

  	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

  		constructor: SpotLight,

  		isSpotLight: true,

  		copy: function ( source ) {

  			Light.prototype.copy.call( this, source );

  			this.distance = source.distance;
  			this.angle = source.angle;
  			this.penumbra = source.penumbra;
  			this.decay = source.decay;

  			this.target = source.target.clone();

  			this.shadow = source.shadow.clone();

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */


  	function PointLight( color, intensity, distance, decay ) {

  		Light.call( this, color, intensity );

  		this.type = 'PointLight';

  		Object.defineProperty( this, 'power', {
  			get: function () {

  				// intensity = power per solid angle.
  				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  				return this.intensity * 4 * Math.PI;

  			},
  			set: function ( power ) {

  				// intensity = power per solid angle.
  				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  				this.intensity = power / ( 4 * Math.PI );

  			}
  		} );

  		this.distance = ( distance !== undefined ) ? distance : 0;
  		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

  	}

  	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

  		constructor: PointLight,

  		isPointLight: true,

  		copy: function ( source ) {

  			Light.prototype.copy.call( this, source );

  			this.distance = source.distance;
  			this.decay = source.decay;

  			this.shadow = source.shadow.clone();

  			return this;

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author arose / http://github.com/arose
  	 */

  	function OrthographicCamera( left, right, top, bottom, near, far ) {

  		Camera.call( this );

  		this.type = 'OrthographicCamera';

  		this.zoom = 1;
  		this.view = null;

  		this.left = ( left !== undefined ) ? left : - 1;
  		this.right = ( right !== undefined ) ? right : 1;
  		this.top = ( top !== undefined ) ? top : 1;
  		this.bottom = ( bottom !== undefined ) ? bottom : - 1;

  		this.near = ( near !== undefined ) ? near : 0.1;
  		this.far = ( far !== undefined ) ? far : 2000;

  		this.updateProjectionMatrix();

  	}

  	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

  		constructor: OrthographicCamera,

  		isOrthographicCamera: true,

  		copy: function ( source, recursive ) {

  			Camera.prototype.copy.call( this, source, recursive );

  			this.left = source.left;
  			this.right = source.right;
  			this.top = source.top;
  			this.bottom = source.bottom;
  			this.near = source.near;
  			this.far = source.far;

  			this.zoom = source.zoom;
  			this.view = source.view === null ? null : Object.assign( {}, source.view );

  			return this;

  		},

  		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  			if ( this.view === null ) {

  				this.view = {
  					enabled: true,
  					fullWidth: 1,
  					fullHeight: 1,
  					offsetX: 0,
  					offsetY: 0,
  					width: 1,
  					height: 1
  				};

  			}

  			this.view.enabled = true;
  			this.view.fullWidth = fullWidth;
  			this.view.fullHeight = fullHeight;
  			this.view.offsetX = x;
  			this.view.offsetY = y;
  			this.view.width = width;
  			this.view.height = height;

  			this.updateProjectionMatrix();

  		},

  		clearViewOffset: function () {

  			if ( this.view !== null ) {

  				this.view.enabled = false;

  			}

  			this.updateProjectionMatrix();

  		},

  		updateProjectionMatrix: function () {

  			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  			var cx = ( this.right + this.left ) / 2;
  			var cy = ( this.top + this.bottom ) / 2;

  			var left = cx - dx;
  			var right = cx + dx;
  			var top = cy + dy;
  			var bottom = cy - dy;

  			if ( this.view !== null && this.view.enabled ) {

  				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
  				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
  				var scaleW = ( this.right - this.left ) / this.view.width;
  				var scaleH = ( this.top - this.bottom ) / this.view.height;

  				left += scaleW * ( this.view.offsetX / zoomW );
  				right = left + scaleW * ( this.view.width / zoomW );
  				top -= scaleH * ( this.view.offsetY / zoomH );
  				bottom = top - scaleH * ( this.view.height / zoomH );

  			}

  			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

  			this.projectionMatrixInverse.getInverse( this.projectionMatrix );

  		},

  		toJSON: function ( meta ) {

  			var data = Object3D.prototype.toJSON.call( this, meta );

  			data.object.zoom = this.zoom;
  			data.object.left = this.left;
  			data.object.right = this.right;
  			data.object.top = this.top;
  			data.object.bottom = this.bottom;
  			data.object.near = this.near;
  			data.object.far = this.far;

  			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  			return data;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function DirectionalLightShadow( ) {

  		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

  	}

  	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

  		constructor: DirectionalLightShadow

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function DirectionalLight( color, intensity ) {

  		Light.call( this, color, intensity );

  		this.type = 'DirectionalLight';

  		this.position.copy( Object3D.DefaultUp );
  		this.updateMatrix();

  		this.target = new Object3D();

  		this.shadow = new DirectionalLightShadow();

  	}

  	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

  		constructor: DirectionalLight,

  		isDirectionalLight: true,

  		copy: function ( source ) {

  			Light.prototype.copy.call( this, source );

  			this.target = source.target.clone();

  			this.shadow = source.shadow.clone();

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function AmbientLight( color, intensity ) {

  		Light.call( this, color, intensity );

  		this.type = 'AmbientLight';

  		this.castShadow = undefined;

  	}

  	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

  		constructor: AmbientLight,

  		isAmbientLight: true

  	} );

  	/**
  	 * @author abelnation / http://github.com/abelnation
  	 */

  	function RectAreaLight( color, intensity, width, height ) {

  		Light.call( this, color, intensity );

  		this.type = 'RectAreaLight';

  		this.width = ( width !== undefined ) ? width : 10;
  		this.height = ( height !== undefined ) ? height : 10;

  	}

  	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

  		constructor: RectAreaLight,

  		isRectAreaLight: true,

  		copy: function ( source ) {

  			Light.prototype.copy.call( this, source );

  			this.width = source.width;
  			this.height = source.height;

  			return this;

  		},

  		toJSON: function ( meta ) {

  			var data = Light.prototype.toJSON.call( this, meta );

  			data.object.width = this.width;
  			data.object.height = this.height;

  			return data;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function MaterialLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  		this.textures = {};

  	}

  	Object.assign( MaterialLoader.prototype, {

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var loader = new FileLoader( scope.manager );
  			loader.setPath( scope.path );
  			loader.load( url, function ( text ) {

  				onLoad( scope.parse( JSON.parse( text ) ) );

  			}, onProgress, onError );

  		},

  		parse: function ( json ) {

  			var textures = this.textures;

  			function getTexture( name ) {

  				if ( textures[ name ] === undefined ) {

  					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

  				}

  				return textures[ name ];

  			}

  			var material = new Materials[ json.type ]();

  			if ( json.uuid !== undefined ) material.uuid = json.uuid;
  			if ( json.name !== undefined ) material.name = json.name;
  			if ( json.color !== undefined ) material.color.setHex( json.color );
  			if ( json.roughness !== undefined ) material.roughness = json.roughness;
  			if ( json.metalness !== undefined ) material.metalness = json.metalness;
  			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
  			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
  			if ( json.shininess !== undefined ) material.shininess = json.shininess;
  			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
  			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
  			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
  			if ( json.fog !== undefined ) material.fog = json.fog;
  			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
  			if ( json.blending !== undefined ) material.blending = json.blending;
  			if ( json.combine !== undefined ) material.combine = json.combine;
  			if ( json.side !== undefined ) material.side = json.side;
  			if ( json.opacity !== undefined ) material.opacity = json.opacity;
  			if ( json.transparent !== undefined ) material.transparent = json.transparent;
  			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
  			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
  			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
  			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
  			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
  			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
  			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
  			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

  			if ( json.rotation !== undefined ) material.rotation = json.rotation;

  			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
  			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
  			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
  			if ( json.scale !== undefined ) material.scale = json.scale;

  			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
  			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
  			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

  			if ( json.skinning !== undefined ) material.skinning = json.skinning;
  			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
  			if ( json.dithering !== undefined ) material.dithering = json.dithering;

  			if ( json.visible !== undefined ) material.visible = json.visible;
  			if ( json.userData !== undefined ) material.userData = json.userData;

  			// Shader Material

  			if ( json.uniforms !== undefined ) {

  				for ( var name in json.uniforms ) {

  					var uniform = json.uniforms[ name ];

  					material.uniforms[ name ] = {};

  					switch ( uniform.type ) {

  						case 't':
  							material.uniforms[ name ].value = getTexture( uniform.value );
  							break;

  						case 'c':
  							material.uniforms[ name ].value = new Color().setHex( uniform.value );
  							break;

  						case 'v2':
  							material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
  							break;

  						case 'v3':
  							material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
  							break;

  						case 'v4':
  							material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
  							break;

  						case 'm3':
  							material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );

  						case 'm4':
  							material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
  							break;

  						default:
  							material.uniforms[ name ].value = uniform.value;

  					}

  				}

  			}

  			if ( json.defines !== undefined ) material.defines = json.defines;
  			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
  			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

  			if ( json.extensions !== undefined ) {

  				for ( var key in json.extensions ) {

  					material.extensions[ key ] = json.extensions[ key ];

  				}

  			}

  			// Deprecated

  			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

  			// for PointsMaterial

  			if ( json.size !== undefined ) material.size = json.size;
  			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

  			// maps

  			if ( json.map !== undefined ) material.map = getTexture( json.map );
  			if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

  			if ( json.alphaMap !== undefined ) {

  				material.alphaMap = getTexture( json.alphaMap );
  				material.transparent = true;

  			}

  			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
  			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

  			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
  			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
  			if ( json.normalScale !== undefined ) {

  				var normalScale = json.normalScale;

  				if ( Array.isArray( normalScale ) === false ) {

  					// Blender exporter used to export a scalar. See #7459

  					normalScale = [ normalScale, normalScale ];

  				}

  				material.normalScale = new Vector2().fromArray( normalScale );

  			}

  			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
  			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
  			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

  			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
  			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

  			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
  			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

  			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

  			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
  			if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

  			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

  			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
  			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

  			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
  			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

  			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

  			return material;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		},

  		setTextures: function ( value ) {

  			this.textures = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author Don McCurdy / https://www.donmccurdy.com
  	 */

  	var LoaderUtils = {

  		decodeText: function ( array ) {

  			if ( typeof TextDecoder !== 'undefined' ) {

  				return new TextDecoder().decode( array );

  			}

  			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
  			// throws a "maximum call stack size exceeded" error for large arrays.

  			var s = '';

  			for ( var i = 0, il = array.length; i < il; i ++ ) {

  				// Implicitly assumes little-endian.
  				s += String.fromCharCode( array[ i ] );

  			}

  			// Merges multi-byte utf-8 characters.
  			return decodeURIComponent( escape( s ) );

  		},

  		extractUrlBase: function ( url ) {

  			var index = url.lastIndexOf( '/' );

  			if ( index === - 1 ) return './';

  			return url.substr( 0, index + 1 );

  		}

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function BufferGeometryLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	Object.assign( BufferGeometryLoader.prototype, {

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var loader = new FileLoader( scope.manager );
  			loader.setPath( scope.path );
  			loader.load( url, function ( text ) {

  				onLoad( scope.parse( JSON.parse( text ) ) );

  			}, onProgress, onError );

  		},

  		parse: function ( json ) {

  			var geometry = new BufferGeometry();

  			var index = json.data.index;

  			if ( index !== undefined ) {

  				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
  				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

  			}

  			var attributes = json.data.attributes;

  			for ( var key in attributes ) {

  				var attribute = attributes[ key ];
  				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

  				var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
  				if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
  				geometry.addAttribute( key, bufferAttribute );

  			}

  			var morphAttributes = json.data.morphAttributes;

  			if ( morphAttributes ) {

  				for ( var key in morphAttributes ) {

  					var attributeArray = morphAttributes[ key ];

  					var array = [];

  					for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

  						var attribute = attributeArray[ i ];
  						var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

  						var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
  						if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
  						array.push( bufferAttribute );

  					}

  					geometry.morphAttributes[ key ] = array;

  				}

  			}

  			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

  			if ( groups !== undefined ) {

  				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

  					var group = groups[ i ];

  					geometry.addGroup( group.start, group.count, group.materialIndex );

  				}

  			}

  			var boundingSphere = json.data.boundingSphere;

  			if ( boundingSphere !== undefined ) {

  				var center = new Vector3();

  				if ( boundingSphere.center !== undefined ) {

  					center.fromArray( boundingSphere.center );

  				}

  				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

  			}

  			if ( json.name ) geometry.name = json.name;
  			if ( json.userData ) geometry.userData = json.userData;

  			return geometry;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	var TYPED_ARRAYS = {
  		Int8Array: Int8Array,
  		Uint8Array: Uint8Array,
  		// Workaround for IE11 pre KB2929437. See #11440
  		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  		Int16Array: Int16Array,
  		Uint16Array: Uint16Array,
  		Int32Array: Int32Array,
  		Uint32Array: Uint32Array,
  		Float32Array: Float32Array,
  		Float64Array: Float64Array
  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function ObjectLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
  		this.resourcePath = '';

  	}

  	Object.assign( ObjectLoader.prototype, {

  		crossOrigin: 'anonymous',

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;
  			this.resourcePath = this.resourcePath || path;

  			var loader = new FileLoader( scope.manager );
  			loader.setPath( this.path );
  			loader.load( url, function ( text ) {

  				var json = null;

  				try {

  					json = JSON.parse( text );

  				} catch ( error ) {

  					if ( onError !== undefined ) onError( error );

  					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

  					return;

  				}

  				var metadata = json.metadata;

  				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

  					console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
  					return;

  				}

  				scope.parse( json, onLoad );

  			}, onProgress, onError );

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		},

  		setResourcePath: function ( value ) {

  			this.resourcePath = value;
  			return this;

  		},

  		setCrossOrigin: function ( value ) {

  			this.crossOrigin = value;
  			return this;

  		},

  		parse: function ( json, onLoad ) {

  			var shapes = this.parseShape( json.shapes );
  			var geometries = this.parseGeometries( json.geometries, shapes );

  			var images = this.parseImages( json.images, function () {

  				if ( onLoad !== undefined ) onLoad( object );

  			} );

  			var textures = this.parseTextures( json.textures, images );
  			var materials = this.parseMaterials( json.materials, textures );

  			var object = this.parseObject( json.object, geometries, materials );

  			if ( json.animations ) {

  				object.animations = this.parseAnimations( json.animations );

  			}

  			if ( json.images === undefined || json.images.length === 0 ) {

  				if ( onLoad !== undefined ) onLoad( object );

  			}

  			return object;

  		},

  		parseShape: function ( json ) {

  			var shapes = {};

  			if ( json !== undefined ) {

  				for ( var i = 0, l = json.length; i < l; i ++ ) {

  					var shape = new Shape().fromJSON( json[ i ] );

  					shapes[ shape.uuid ] = shape;

  				}

  			}

  			return shapes;

  		},

  		parseGeometries: function ( json, shapes ) {

  			var geometries = {};

  			if ( json !== undefined ) {

  				var bufferGeometryLoader = new BufferGeometryLoader();

  				for ( var i = 0, l = json.length; i < l; i ++ ) {

  					var geometry;
  					var data = json[ i ];

  					switch ( data.type ) {

  						case 'PlaneGeometry':
  						case 'PlaneBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.width,
  								data.height,
  								data.widthSegments,
  								data.heightSegments
  							);

  							break;

  						case 'BoxGeometry':
  						case 'BoxBufferGeometry':
  						case 'CubeGeometry': // backwards compatible

  							geometry = new Geometries[ data.type ](
  								data.width,
  								data.height,
  								data.depth,
  								data.widthSegments,
  								data.heightSegments,
  								data.depthSegments
  							);

  							break;

  						case 'CircleGeometry':
  						case 'CircleBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.radius,
  								data.segments,
  								data.thetaStart,
  								data.thetaLength
  							);

  							break;

  						case 'CylinderGeometry':
  						case 'CylinderBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.radiusTop,
  								data.radiusBottom,
  								data.height,
  								data.radialSegments,
  								data.heightSegments,
  								data.openEnded,
  								data.thetaStart,
  								data.thetaLength
  							);

  							break;

  						case 'ConeGeometry':
  						case 'ConeBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.radius,
  								data.height,
  								data.radialSegments,
  								data.heightSegments,
  								data.openEnded,
  								data.thetaStart,
  								data.thetaLength
  							);

  							break;

  						case 'SphereGeometry':
  						case 'SphereBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.radius,
  								data.widthSegments,
  								data.heightSegments,
  								data.phiStart,
  								data.phiLength,
  								data.thetaStart,
  								data.thetaLength
  							);

  							break;

  						case 'DodecahedronGeometry':
  						case 'DodecahedronBufferGeometry':
  						case 'IcosahedronGeometry':
  						case 'IcosahedronBufferGeometry':
  						case 'OctahedronGeometry':
  						case 'OctahedronBufferGeometry':
  						case 'TetrahedronGeometry':
  						case 'TetrahedronBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.radius,
  								data.detail
  							);

  							break;

  						case 'RingGeometry':
  						case 'RingBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.innerRadius,
  								data.outerRadius,
  								data.thetaSegments,
  								data.phiSegments,
  								data.thetaStart,
  								data.thetaLength
  							);

  							break;

  						case 'TorusGeometry':
  						case 'TorusBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.radius,
  								data.tube,
  								data.radialSegments,
  								data.tubularSegments,
  								data.arc
  							);

  							break;

  						case 'TorusKnotGeometry':
  						case 'TorusKnotBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.radius,
  								data.tube,
  								data.tubularSegments,
  								data.radialSegments,
  								data.p,
  								data.q
  							);

  							break;

  						case 'TubeGeometry':
  						case 'TubeBufferGeometry':

  							// This only works for built-in curves (e.g. CatmullRomCurve3).
  							// User defined curves or instances of CurvePath will not be deserialized.
  							geometry = new Geometries[ data.type ](
  								new Curves[ data.path.type ]().fromJSON( data.path ),
  								data.tubularSegments,
  								data.radius,
  								data.radialSegments,
  								data.closed
  							);

  							break;

  						case 'LatheGeometry':
  						case 'LatheBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.points,
  								data.segments,
  								data.phiStart,
  								data.phiLength
  							);

  							break;

  						case 'PolyhedronGeometry':
  						case 'PolyhedronBufferGeometry':

  							geometry = new Geometries[ data.type ](
  								data.vertices,
  								data.indices,
  								data.radius,
  								data.details
  							);

  							break;

  						case 'ShapeGeometry':
  						case 'ShapeBufferGeometry':

  							var geometryShapes = [];

  							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

  								var shape = shapes[ data.shapes[ j ] ];

  								geometryShapes.push( shape );

  							}

  							geometry = new Geometries[ data.type ](
  								geometryShapes,
  								data.curveSegments
  							);

  							break;


  						case 'ExtrudeGeometry':
  						case 'ExtrudeBufferGeometry':

  							var geometryShapes = [];

  							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

  								var shape = shapes[ data.shapes[ j ] ];

  								geometryShapes.push( shape );

  							}

  							var extrudePath = data.options.extrudePath;

  							if ( extrudePath !== undefined ) {

  								data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

  							}

  							geometry = new Geometries[ data.type ](
  								geometryShapes,
  								data.options
  							);

  							break;

  						case 'BufferGeometry':

  							geometry = bufferGeometryLoader.parse( data );

  							break;

  						case 'Geometry':

  							if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) {

  								var geometryLoader = new THREE.LegacyJSONLoader();
  								geometry = geometryLoader.parse( data, this.resourcePath ).geometry;


  							} else {

  								console.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".' );

  							}

  							break;

  						default:

  							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

  							continue;

  					}

  					geometry.uuid = data.uuid;

  					if ( data.name !== undefined ) geometry.name = data.name;
  					if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

  					geometries[ data.uuid ] = geometry;

  				}

  			}

  			return geometries;

  		},

  		parseMaterials: function ( json, textures ) {

  			var cache = {}; // MultiMaterial
  			var materials = {};

  			if ( json !== undefined ) {

  				var loader = new MaterialLoader();
  				loader.setTextures( textures );

  				for ( var i = 0, l = json.length; i < l; i ++ ) {

  					var data = json[ i ];

  					if ( data.type === 'MultiMaterial' ) {

  						// Deprecated

  						var array = [];

  						for ( var j = 0; j < data.materials.length; j ++ ) {

  							var material = data.materials[ j ];

  							if ( cache[ material.uuid ] === undefined ) {

  								cache[ material.uuid ] = loader.parse( material );

  							}

  							array.push( cache[ material.uuid ] );

  						}

  						materials[ data.uuid ] = array;

  					} else {

  						if ( cache[ data.uuid ] === undefined ) {

  							cache[ data.uuid ] = loader.parse( data );

  						}

  						materials[ data.uuid ] = cache[ data.uuid ];

  					}

  				}

  			}

  			return materials;

  		},

  		parseAnimations: function ( json ) {

  			var animations = [];

  			for ( var i = 0; i < json.length; i ++ ) {

  				var data = json[ i ];

  				var clip = AnimationClip.parse( data );

  				if ( data.uuid !== undefined ) clip.uuid = data.uuid;

  				animations.push( clip );

  			}

  			return animations;

  		},

  		parseImages: function ( json, onLoad ) {

  			var scope = this;
  			var images = {};

  			function loadImage( url ) {

  				scope.manager.itemStart( url );

  				return loader.load( url, function () {

  					scope.manager.itemEnd( url );

  				}, undefined, function () {

  					scope.manager.itemError( url );
  					scope.manager.itemEnd( url );

  				} );

  			}

  			if ( json !== undefined && json.length > 0 ) {

  				var manager = new LoadingManager( onLoad );

  				var loader = new ImageLoader( manager );
  				loader.setCrossOrigin( this.crossOrigin );

  				for ( var i = 0, il = json.length; i < il; i ++ ) {

  					var image = json[ i ];
  					var url = image.url;

  					if ( Array.isArray( url ) ) {

  						// load array of images e.g CubeTexture

  						images[ image.uuid ] = [];

  						for ( var j = 0, jl = url.length; j < jl; j ++ ) {

  							var currentUrl = url[ j ];

  							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;

  							images[ image.uuid ].push( loadImage( path ) );

  						}

  					} else {

  						// load single image

  						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;

  						images[ image.uuid ] = loadImage( path );

  					}

  				}

  			}

  			return images;

  		},

  		parseTextures: function ( json, images ) {

  			function parseConstant( value, type ) {

  				if ( typeof value === 'number' ) return value;

  				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

  				return type[ value ];

  			}

  			var textures = {};

  			if ( json !== undefined ) {

  				for ( var i = 0, l = json.length; i < l; i ++ ) {

  					var data = json[ i ];

  					if ( data.image === undefined ) {

  						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

  					}

  					if ( images[ data.image ] === undefined ) {

  						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

  					}

  					var texture;

  					if ( Array.isArray( images[ data.image ] ) ) {

  						texture = new CubeTexture( images[ data.image ] );

  					} else {

  						texture = new Texture( images[ data.image ] );

  					}

  					texture.needsUpdate = true;

  					texture.uuid = data.uuid;

  					if ( data.name !== undefined ) texture.name = data.name;

  					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

  					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
  					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
  					if ( data.center !== undefined ) texture.center.fromArray( data.center );
  					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

  					if ( data.wrap !== undefined ) {

  						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
  						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

  					}

  					if ( data.format !== undefined ) texture.format = data.format;
  					if ( data.type !== undefined ) texture.type = data.type;
  					if ( data.encoding !== undefined ) texture.encoding = data.encoding;

  					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
  					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
  					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

  					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

  					if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
  					if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

  					textures[ data.uuid ] = texture;

  				}

  			}

  			return textures;

  		},

  		parseObject: function ( data, geometries, materials ) {

  			var object;

  			function getGeometry( name ) {

  				if ( geometries[ name ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

  				}

  				return geometries[ name ];

  			}

  			function getMaterial( name ) {

  				if ( name === undefined ) return undefined;

  				if ( Array.isArray( name ) ) {

  					var array = [];

  					for ( var i = 0, l = name.length; i < l; i ++ ) {

  						var uuid = name[ i ];

  						if ( materials[ uuid ] === undefined ) {

  							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

  						}

  						array.push( materials[ uuid ] );

  					}

  					return array;

  				}

  				if ( materials[ name ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined material', name );

  				}

  				return materials[ name ];

  			}

  			switch ( data.type ) {

  				case 'Scene':

  					object = new Scene();

  					if ( data.background !== undefined ) {

  						if ( Number.isInteger( data.background ) ) {

  							object.background = new Color( data.background );

  						}

  					}

  					if ( data.fog !== undefined ) {

  						if ( data.fog.type === 'Fog' ) {

  							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

  						} else if ( data.fog.type === 'FogExp2' ) {

  							object.fog = new FogExp2( data.fog.color, data.fog.density );

  						}

  					}

  					break;

  				case 'PerspectiveCamera':

  					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

  					if ( data.focus !== undefined ) object.focus = data.focus;
  					if ( data.zoom !== undefined ) object.zoom = data.zoom;
  					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
  					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
  					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

  					break;

  				case 'OrthographicCamera':

  					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

  					if ( data.zoom !== undefined ) object.zoom = data.zoom;
  					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

  					break;

  				case 'AmbientLight':

  					object = new AmbientLight( data.color, data.intensity );

  					break;

  				case 'DirectionalLight':

  					object = new DirectionalLight( data.color, data.intensity );

  					break;

  				case 'PointLight':

  					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

  					break;

  				case 'RectAreaLight':

  					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

  					break;

  				case 'SpotLight':

  					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

  					break;

  				case 'HemisphereLight':

  					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

  					break;

  				case 'SkinnedMesh':

  					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

  				case 'Mesh':

  					var geometry = getGeometry( data.geometry );
  					var material = getMaterial( data.material );

  					if ( geometry.bones && geometry.bones.length > 0 ) {

  						object = new SkinnedMesh( geometry, material );

  					} else {

  						object = new Mesh( geometry, material );

  					}

  					if ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode );

  					break;

  				case 'LOD':

  					object = new LOD();

  					break;

  				case 'Line':

  					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

  					break;

  				case 'LineLoop':

  					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'LineSegments':

  					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'PointCloud':
  				case 'Points':

  					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'Sprite':

  					object = new Sprite( getMaterial( data.material ) );

  					break;

  				case 'Group':

  					object = new Group();

  					break;

  				default:

  					object = new Object3D();

  			}

  			object.uuid = data.uuid;

  			if ( data.name !== undefined ) object.name = data.name;

  			if ( data.matrix !== undefined ) {

  				object.matrix.fromArray( data.matrix );

  				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
  				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

  			} else {

  				if ( data.position !== undefined ) object.position.fromArray( data.position );
  				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
  				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
  				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

  			}

  			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
  			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

  			if ( data.shadow ) {

  				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
  				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
  				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
  				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

  			}

  			if ( data.visible !== undefined ) object.visible = data.visible;
  			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
  			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
  			if ( data.userData !== undefined ) object.userData = data.userData;
  			if ( data.layers !== undefined ) object.layers.mask = data.layers;

  			if ( data.children !== undefined ) {

  				var children = data.children;

  				for ( var i = 0; i < children.length; i ++ ) {

  					object.add( this.parseObject( children[ i ], geometries, materials ) );

  				}

  			}

  			if ( data.type === 'LOD' ) {

  				var levels = data.levels;

  				for ( var l = 0; l < levels.length; l ++ ) {

  					var level = levels[ l ];
  					var child = object.getObjectByProperty( 'uuid', level.object );

  					if ( child !== undefined ) {

  						object.addLevel( child, level.distance );

  					}

  				}

  			}

  			return object;

  		}

  	} );

  	var TEXTURE_MAPPING = {
  		UVMapping: UVMapping,
  		CubeReflectionMapping: CubeReflectionMapping,
  		CubeRefractionMapping: CubeRefractionMapping,
  		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  		SphericalReflectionMapping: SphericalReflectionMapping,
  		CubeUVReflectionMapping: CubeUVReflectionMapping,
  		CubeUVRefractionMapping: CubeUVRefractionMapping
  	};

  	var TEXTURE_WRAPPING = {
  		RepeatWrapping: RepeatWrapping,
  		ClampToEdgeWrapping: ClampToEdgeWrapping,
  		MirroredRepeatWrapping: MirroredRepeatWrapping
  	};

  	var TEXTURE_FILTER = {
  		NearestFilter: NearestFilter,
  		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
  		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
  		LinearFilter: LinearFilter,
  		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
  		LinearMipMapLinearFilter: LinearMipMapLinearFilter
  	};

  	/**
  	 * @author thespite / http://clicktorelease.com/
  	 */


  	function ImageBitmapLoader( manager ) {

  		if ( typeof createImageBitmap === 'undefined' ) {

  			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

  		}

  		if ( typeof fetch === 'undefined' ) {

  			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

  		}

  		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  		this.options = undefined;

  	}

  	ImageBitmapLoader.prototype = {

  		constructor: ImageBitmapLoader,

  		setOptions: function setOptions( options ) {

  			this.options = options;

  			return this;

  		},

  		load: function ( url, onLoad, onProgress, onError ) {

  			if ( url === undefined ) url = '';

  			if ( this.path !== undefined ) url = this.path + url;

  			url = this.manager.resolveURL( url );

  			var scope = this;

  			var cached = Cache.get( url );

  			if ( cached !== undefined ) {

  				scope.manager.itemStart( url );

  				setTimeout( function () {

  					if ( onLoad ) onLoad( cached );

  					scope.manager.itemEnd( url );

  				}, 0 );

  				return cached;

  			}

  			fetch( url ).then( function ( res ) {

  				return res.blob();

  			} ).then( function ( blob ) {

  				if ( scope.options === undefined ) {

  					// Workaround for FireFox. It causes an error if you pass options.
  					return createImageBitmap( blob );

  				} else {

  					return createImageBitmap( blob, scope.options );

  				}

  			} ).then( function ( imageBitmap ) {

  				Cache.add( url, imageBitmap );

  				if ( onLoad ) onLoad( imageBitmap );

  				scope.manager.itemEnd( url );

  			} ).catch( function ( e ) {

  				if ( onError ) onError( e );

  				scope.manager.itemError( url );
  				scope.manager.itemEnd( url );

  			} );

  			scope.manager.itemStart( url );

  		},

  		setCrossOrigin: function ( /* value */ ) {

  			return this;

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	};

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
  	 **/

  	function ShapePath() {

  		this.type = 'ShapePath';

  		this.color = new Color();

  		this.subPaths = [];
  		this.currentPath = null;

  	}

  	Object.assign( ShapePath.prototype, {

  		moveTo: function ( x, y ) {

  			this.currentPath = new Path();
  			this.subPaths.push( this.currentPath );
  			this.currentPath.moveTo( x, y );

  		},

  		lineTo: function ( x, y ) {

  			this.currentPath.lineTo( x, y );

  		},

  		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

  			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

  		},

  		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

  		},

  		splineThru: function ( pts ) {

  			this.currentPath.splineThru( pts );

  		},

  		toShapes: function ( isCCW, noHoles ) {

  			function toShapesNoHoles( inSubpaths ) {

  				var shapes = [];

  				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

  					var tmpPath = inSubpaths[ i ];

  					var tmpShape = new Shape();
  					tmpShape.curves = tmpPath.curves;

  					shapes.push( tmpShape );

  				}

  				return shapes;

  			}

  			function isPointInsidePolygon( inPt, inPolygon ) {

  				var polyLen = inPolygon.length;

  				// inPt on polygon contour => immediate success    or
  				// toggling of inside/outside at every single! intersection point of an edge
  				//  with the horizontal line through inPt, left of inPt
  				//  not counting lowerY endpoints of edges and whole edges on that line
  				var inside = false;
  				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

  					var edgeLowPt = inPolygon[ p ];
  					var edgeHighPt = inPolygon[ q ];

  					var edgeDx = edgeHighPt.x - edgeLowPt.x;
  					var edgeDy = edgeHighPt.y - edgeLowPt.y;

  					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

  						// not parallel
  						if ( edgeDy < 0 ) {

  							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
  							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

  						}
  						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

  						if ( inPt.y === edgeLowPt.y ) {

  							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
  							// continue;				// no intersection or edgeLowPt => doesn't count !!!

  						} else {

  							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
  							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
  							if ( perpEdge < 0 ) 				continue;
  							inside = ! inside;		// true intersection left of inPt

  						}

  					} else {

  						// parallel or collinear
  						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
  						// edge lies on the same horizontal line as inPt
  						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
  							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
  						// continue;

  					}

  				}

  				return	inside;

  			}

  			var isClockWise = ShapeUtils.isClockWise;

  			var subPaths = this.subPaths;
  			if ( subPaths.length === 0 ) return [];

  			if ( noHoles === true )	return	toShapesNoHoles( subPaths );


  			var solid, tmpPath, tmpShape, shapes = [];

  			if ( subPaths.length === 1 ) {

  				tmpPath = subPaths[ 0 ];
  				tmpShape = new Shape();
  				tmpShape.curves = tmpPath.curves;
  				shapes.push( tmpShape );
  				return shapes;

  			}

  			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
  			holesFirst = isCCW ? ! holesFirst : holesFirst;

  			// console.log("Holes first", holesFirst);

  			var betterShapeHoles = [];
  			var newShapes = [];
  			var newShapeHoles = [];
  			var mainIdx = 0;
  			var tmpPoints;

  			newShapes[ mainIdx ] = undefined;
  			newShapeHoles[ mainIdx ] = [];

  			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

  				tmpPath = subPaths[ i ];
  				tmpPoints = tmpPath.getPoints();
  				solid = isClockWise( tmpPoints );
  				solid = isCCW ? ! solid : solid;

  				if ( solid ) {

  					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

  					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
  					newShapes[ mainIdx ].s.curves = tmpPath.curves;

  					if ( holesFirst )	mainIdx ++;
  					newShapeHoles[ mainIdx ] = [];

  					//console.log('cw', i);

  				} else {

  					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

  					//console.log('ccw', i);

  				}

  			}

  			// only Holes? -> probably all Shapes with wrong orientation
  			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


  			if ( newShapes.length > 1 ) {

  				var ambiguous = false;
  				var toChange = [];

  				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  					betterShapeHoles[ sIdx ] = [];

  				}

  				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  					var sho = newShapeHoles[ sIdx ];

  					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

  						var ho = sho[ hIdx ];
  						var hole_unassigned = true;

  						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

  							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

  								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
  								if ( hole_unassigned ) {

  									hole_unassigned = false;
  									betterShapeHoles[ s2Idx ].push( ho );

  								} else {

  									ambiguous = true;

  								}

  							}

  						}
  						if ( hole_unassigned ) {

  							betterShapeHoles[ sIdx ].push( ho );

  						}

  					}

  				}
  				// console.log("ambiguous: ", ambiguous);
  				if ( toChange.length > 0 ) {

  					// console.log("to change: ", toChange);
  					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

  				}

  			}

  			var tmpHoles;

  			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

  				tmpShape = newShapes[ i ].s;
  				shapes.push( tmpShape );
  				tmpHoles = newShapeHoles[ i ];

  				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

  					tmpShape.holes.push( tmpHoles[ j ].h );

  				}

  			}

  			//console.log("shape", shapes);

  			return shapes;

  		}

  	} );

  	/**
  	 * @author zz85 / http://www.lab4games.net/zz85/blog
  	 * @author mrdoob / http://mrdoob.com/
  	 */


  	function Font( data ) {

  		this.type = 'Font';

  		this.data = data;

  	}

  	Object.assign( Font.prototype, {

  		isFont: true,

  		generateShapes: function ( text, size ) {

  			if ( size === undefined ) size = 100;

  			var shapes = [];
  			var paths = createPaths( text, size, this.data );

  			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

  				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  			}

  			return shapes;

  		}

  	} );

  	function createPaths( text, size, data ) {

  		var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988
  		var scale = size / data.resolution;
  		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

  		var paths = [];

  		var offsetX = 0, offsetY = 0;

  		for ( var i = 0; i < chars.length; i ++ ) {

  			var char = chars[ i ];

  			if ( char === '\n' ) {

  				offsetX = 0;
  				offsetY -= line_height;

  			} else {

  				var ret = createPath( char, scale, offsetX, offsetY, data );
  				offsetX += ret.offsetX;
  				paths.push( ret.path );

  			}

  		}

  		return paths;

  	}

  	function createPath( char, scale, offsetX, offsetY, data ) {

  		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

  		if ( ! glyph ) return;

  		var path = new ShapePath();

  		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

  		if ( glyph.o ) {

  			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

  			for ( var i = 0, l = outline.length; i < l; ) {

  				var action = outline[ i ++ ];

  				switch ( action ) {

  					case 'm': // moveTo

  						x = outline[ i ++ ] * scale + offsetX;
  						y = outline[ i ++ ] * scale + offsetY;

  						path.moveTo( x, y );

  						break;

  					case 'l': // lineTo

  						x = outline[ i ++ ] * scale + offsetX;
  						y = outline[ i ++ ] * scale + offsetY;

  						path.lineTo( x, y );

  						break;

  					case 'q': // quadraticCurveTo

  						cpx = outline[ i ++ ] * scale + offsetX;
  						cpy = outline[ i ++ ] * scale + offsetY;
  						cpx1 = outline[ i ++ ] * scale + offsetX;
  						cpy1 = outline[ i ++ ] * scale + offsetY;

  						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

  						break;

  					case 'b': // bezierCurveTo

  						cpx = outline[ i ++ ] * scale + offsetX;
  						cpy = outline[ i ++ ] * scale + offsetY;
  						cpx1 = outline[ i ++ ] * scale + offsetX;
  						cpy1 = outline[ i ++ ] * scale + offsetY;
  						cpx2 = outline[ i ++ ] * scale + offsetX;
  						cpy2 = outline[ i ++ ] * scale + offsetY;

  						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

  						break;

  				}

  			}

  		}

  		return { offsetX: glyph.ha * scale, path: path };

  	}

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function FontLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	Object.assign( FontLoader.prototype, {

  		load: function ( url, onLoad, onProgress, onError ) {

  			var scope = this;

  			var loader = new FileLoader( this.manager );
  			loader.setPath( this.path );
  			loader.load( url, function ( text ) {

  				var json;

  				try {

  					json = JSON.parse( text );

  				} catch ( e ) {

  					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
  					json = JSON.parse( text.substring( 65, text.length - 2 ) );

  				}

  				var font = scope.parse( json );

  				if ( onLoad ) onLoad( font );

  			}, onProgress, onError );

  		},

  		parse: function ( json ) {

  			return new Font( json );

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function Loader() {}

  	Loader.Handlers = {

  		handlers: [],

  		add: function ( regex, loader ) {

  			this.handlers.push( regex, loader );

  		},

  		get: function ( file ) {

  			var handlers = this.handlers;

  			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

  				var regex = handlers[ i ];
  				var loader = handlers[ i + 1 ];

  				if ( regex.test( file ) ) {

  					return loader;

  				}

  			}

  			return null;

  		}

  	};

  	Object.assign( Loader.prototype, {

  		crossOrigin: 'anonymous',

  		onLoadStart: function () {},

  		onLoadProgress: function () {},

  		onLoadComplete: function () {},

  		initMaterials: function ( materials, texturePath, crossOrigin ) {

  			var array = [];

  			for ( var i = 0; i < materials.length; ++ i ) {

  				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

  			}

  			return array;

  		},

  		createMaterial: ( function () {

  			var BlendingMode = {
  				NoBlending: NoBlending,
  				NormalBlending: NormalBlending,
  				AdditiveBlending: AdditiveBlending,
  				SubtractiveBlending: SubtractiveBlending,
  				MultiplyBlending: MultiplyBlending,
  				CustomBlending: CustomBlending
  			};

  			var color = new Color();
  			var textureLoader = new TextureLoader();
  			var materialLoader = new MaterialLoader();

  			return function createMaterial( m, texturePath, crossOrigin ) {

  				// convert from old material format

  				var textures = {};

  				function loadTexture( path, repeat, offset, wrap, anisotropy ) {

  					var fullPath = texturePath + path;
  					var loader = Loader.Handlers.get( fullPath );

  					var texture;

  					if ( loader !== null ) {

  						texture = loader.load( fullPath );

  					} else {

  						textureLoader.setCrossOrigin( crossOrigin );
  						texture = textureLoader.load( fullPath );

  					}

  					if ( repeat !== undefined ) {

  						texture.repeat.fromArray( repeat );

  						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
  						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

  					}

  					if ( offset !== undefined ) {

  						texture.offset.fromArray( offset );

  					}

  					if ( wrap !== undefined ) {

  						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
  						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

  						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
  						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

  					}

  					if ( anisotropy !== undefined ) {

  						texture.anisotropy = anisotropy;

  					}

  					var uuid = _Math.generateUUID();

  					textures[ uuid ] = texture;

  					return uuid;

  				}

  				//

  				var json = {
  					uuid: _Math.generateUUID(),
  					type: 'MeshLambertMaterial'
  				};

  				for ( var name in m ) {

  					var value = m[ name ];

  					switch ( name ) {

  						case 'DbgColor':
  						case 'DbgIndex':
  						case 'opticalDensity':
  						case 'illumination':
  							break;
  						case 'DbgName':
  							json.name = value;
  							break;
  						case 'blending':
  							json.blending = BlendingMode[ value ];
  							break;
  						case 'colorAmbient':
  						case 'mapAmbient':
  							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
  							break;
  						case 'colorDiffuse':
  							json.color = color.fromArray( value ).getHex();
  							break;
  						case 'colorSpecular':
  							json.specular = color.fromArray( value ).getHex();
  							break;
  						case 'colorEmissive':
  							json.emissive = color.fromArray( value ).getHex();
  							break;
  						case 'specularCoef':
  							json.shininess = value;
  							break;
  						case 'shading':
  							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
  							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
  							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
  							break;
  						case 'mapDiffuse':
  							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
  							break;
  						case 'mapDiffuseRepeat':
  						case 'mapDiffuseOffset':
  						case 'mapDiffuseWrap':
  						case 'mapDiffuseAnisotropy':
  							break;
  						case 'mapEmissive':
  							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
  							break;
  						case 'mapEmissiveRepeat':
  						case 'mapEmissiveOffset':
  						case 'mapEmissiveWrap':
  						case 'mapEmissiveAnisotropy':
  							break;
  						case 'mapLight':
  							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
  							break;
  						case 'mapLightRepeat':
  						case 'mapLightOffset':
  						case 'mapLightWrap':
  						case 'mapLightAnisotropy':
  							break;
  						case 'mapAO':
  							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
  							break;
  						case 'mapAORepeat':
  						case 'mapAOOffset':
  						case 'mapAOWrap':
  						case 'mapAOAnisotropy':
  							break;
  						case 'mapBump':
  							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
  							break;
  						case 'mapBumpScale':
  							json.bumpScale = value;
  							break;
  						case 'mapBumpRepeat':
  						case 'mapBumpOffset':
  						case 'mapBumpWrap':
  						case 'mapBumpAnisotropy':
  							break;
  						case 'mapNormal':
  							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
  							break;
  						case 'mapNormalFactor':
  							json.normalScale = value;
  							break;
  						case 'mapNormalRepeat':
  						case 'mapNormalOffset':
  						case 'mapNormalWrap':
  						case 'mapNormalAnisotropy':
  							break;
  						case 'mapSpecular':
  							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
  							break;
  						case 'mapSpecularRepeat':
  						case 'mapSpecularOffset':
  						case 'mapSpecularWrap':
  						case 'mapSpecularAnisotropy':
  							break;
  						case 'mapMetalness':
  							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
  							break;
  						case 'mapMetalnessRepeat':
  						case 'mapMetalnessOffset':
  						case 'mapMetalnessWrap':
  						case 'mapMetalnessAnisotropy':
  							break;
  						case 'mapRoughness':
  							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
  							break;
  						case 'mapRoughnessRepeat':
  						case 'mapRoughnessOffset':
  						case 'mapRoughnessWrap':
  						case 'mapRoughnessAnisotropy':
  							break;
  						case 'mapAlpha':
  							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
  							break;
  						case 'mapAlphaRepeat':
  						case 'mapAlphaOffset':
  						case 'mapAlphaWrap':
  						case 'mapAlphaAnisotropy':
  							break;
  						case 'flipSided':
  							json.side = BackSide;
  							break;
  						case 'doubleSided':
  							json.side = DoubleSide;
  							break;
  						case 'transparency':
  							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
  							json.opacity = value;
  							break;
  						case 'depthTest':
  						case 'depthWrite':
  						case 'colorWrite':
  						case 'opacity':
  						case 'reflectivity':
  						case 'transparent':
  						case 'visible':
  						case 'wireframe':
  							json[ name ] = value;
  							break;
  						case 'vertexColors':
  							if ( value === true ) json.vertexColors = VertexColors;
  							if ( value === 'face' ) json.vertexColors = FaceColors;
  							break;
  						default:
  							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
  							break;

  					}

  				}

  				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
  				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

  				if ( json.opacity < 1 ) json.transparent = true;

  				materialLoader.setTextures( textures );

  				return materialLoader.parse( json );

  			};

  		} )()

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	var context;

  	var AudioContext = {

  		getContext: function () {

  			if ( context === undefined ) {

  				context = new ( window.AudioContext || window.webkitAudioContext )();

  			}

  			return context;

  		},

  		setContext: function ( value ) {

  			context = value;

  		}

  	};

  	/**
  	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
  	 */

  	function AudioLoader( manager ) {

  		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

  	}

  	Object.assign( AudioLoader.prototype, {

  		load: function ( url, onLoad, onProgress, onError ) {

  			var loader = new FileLoader( this.manager );
  			loader.setResponseType( 'arraybuffer' );
  			loader.setPath( this.path );
  			loader.load( url, function ( buffer ) {

  				// Create a copy of the buffer. The `decodeAudioData` method
  				// detaches the buffer when complete, preventing reuse.
  				var bufferCopy = buffer.slice( 0 );

  				var context = AudioContext.getContext();
  				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

  					onLoad( audioBuffer );

  				} );

  			}, onProgress, onError );

  		},

  		setPath: function ( value ) {

  			this.path = value;
  			return this;

  		}

  	} );

  	/**
  	 * @author bhouston / http://clara.io
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * Primary reference:
  	 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
  	 *
  	 * Secondary reference:
  	 *   https://www.ppsloan.org/publications/StupidSH36.pdf
  	 */

  	// 3-band SH defined by 9 coefficients

  	function SphericalHarmonics3() {

  		this.coefficients = [];

  		for ( var i = 0; i < 9; i ++ ) {

  			this.coefficients.push( new Vector3() );

  		}

  	}

  	Object.assign( SphericalHarmonics3.prototype, {

  		isSphericalHarmonics3: true,

  		set: function ( coefficients ) {

  			for ( var i = 0; i < 9; i ++ ) {

  				this.coefficients[ i ].copy( coefficients[ i ] );

  			}

  			return this;

  		},

  		zero: function () {

  			for ( var i = 0; i < 9; i ++ ) {

  				this.coefficients[ i ].set( 0, 0, 0 );

  			}

  			return this;

  		},

  		// get the radiance in the direction of the normal
  		// target is a Vector3
  		getAt: function ( normal, target ) {

  			// normal is assumed to be unit length

  			var x = normal.x, y = normal.y, z = normal.z;

  			var coeff = this.coefficients;

  			// band 0
  			target = coeff[ 0 ] * 0.282095;

  			// band 1
  			target += coeff[ 1 ] * 0.488603 * y;
  			target += coeff[ 2 ] * 0.488603 * z;
  			target += coeff[ 3 ] * 0.488603 * x;

  			// band 2
  			target += coeff[ 4 ] * 1.092548 * ( x * y );
  			target += coeff[ 5 ] * 1.092548 * ( y * z );
  			target += coeff[ 6 ] * 0.315392 * ( 3.0 * z * z - 1.0 );
  			target += coeff[ 7 ] * 1.092548 * ( x * z );
  			target += coeff[ 8 ] * 0.546274 * ( x * x - y * y );

  			return target;

  		},

  		// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  		// target is a Vector3
  		// https://graphics.stanford.edu/papers/envmap/envmap.pdf
  		getIrradianceAt: function ( normal, target ) {

  			// normal is assumed to be unit length

  			var x = normal.x, y = normal.y, z = normal.z;

  			var coeff = this.coefficients;

  			// band 0
  			target = coeff[ 0 ] * 0.886227; // Ï€ * 0.282095

  			// band 1
  			target += coeff[ 1 ] * 2.0 * 0.511664 * y; // ( 2 * Ï€ / 3 ) * 0.488603
  			target += coeff[ 2 ] * 2.0 * 0.511664 * z;
  			target += coeff[ 3 ] * 2.0 * 0.511664 * x;

  			// band 2
  			target += coeff[ 4 ] * 2.0 * 0.429043 * x * y; // ( Ï€ / 4 ) * 1.092548
  			target += coeff[ 5 ] * 2.0 * 0.429043 * y * z;
  			target += coeff[ 6 ] * ( 0.743125 * z * z - 0.247708 ); // ( Ï€ / 4 ) * 0.315392 * 3
  			target += coeff[ 7 ] * 2.0 * 0.429043 * x * z;
  			target += coeff[ 8 ] * 0.429043 * ( x * x - y * y ); // ( Ï€ / 4 ) * 0.546274

  			return target;

  		},

  		add: function ( sh ) {

  			for ( var i = 0; i < 9; i ++ ) {

  				this.coefficients[ i ].add( sh.coefficients[ i ] );

  			}

  			return this;

  		},


  		scale: function ( s ) {

  			for ( var i = 0; i < 9; i ++ ) {

  				this.coefficients[ i ].multiplyScalar( s );

  			}

  			return this;

  		},

  		lerp: function ( sh, alpha ) {

  			for ( var i = 0; i < 9; i ++ ) {

  				this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

  			}

  			return this;

  		},

  		equals: function ( sh ) {

  			for ( var i = 0; i < 9; i ++ ) {

  				if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

  					return false;

  				}

  			}

  			return true;

  		},

  		copy: function ( sh ) {

  			return this.set( sh.coefficients );

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		fromArray: function ( array ) {

  			var coefficients = this.coefficients;

  			for ( var i = 0; i < 9; i ++ ) {

  				coefficients[ i ].fromArray( array, i * 3 );

  			}

  			return this;

  		},

  		toArray: function () {

  			var array = [];
  			var coefficients = this.coefficients;

  			for ( var i = 0; i < 9; i ++ ) {

  				coefficients[ i ].toArray( array, i * 3 );

  			}

  			return array;

  		}

  	} );

  	Object.assign( SphericalHarmonics3, {

  		// evaluate the basis functions
  		// shBasis is an Array[ 9 ]
  		getBasisAt: function ( normal, shBasis ) {

  			// normal is assumed to be unit length

  			var x = normal.x, y = normal.y, z = normal.z;

  			// band 0
  			shBasis[ 0 ] = 0.282095;

  			// band 1
  			shBasis[ 1 ] = 0.488603 * y;
  			shBasis[ 2 ] = 0.488603 * z;
  			shBasis[ 3 ] = 0.488603 * x;

  			// band 2
  			shBasis[ 4 ] = 1.092548 * x * y;
  			shBasis[ 5 ] = 1.092548 * y * z;
  			shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
  			shBasis[ 7 ] = 1.092548 * x * z;
  			shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

  		}

  	} );

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * A LightProbe is a source of indirect-diffuse light
  	 */

  	function LightProbe( sh, intensity ) {

  		Light.call( this, undefined, intensity );

  		this.sh = ( sh !== undefined ) ? sh : new SphericalHarmonics3();

  	}

  	LightProbe.prototype = Object.assign( Object.create( Light.prototype ), {

  		constructor: LightProbe,

  		isLightProbe: true,

  		copy: function ( source ) {

  			Light.prototype.copy.call( this, source );

  			this.sh.copy( source.sh );
  			this.intensity = source.intensity;

  			return this;

  		},

  		toJSON: function ( meta ) {

  			var data = Light.prototype.toJSON.call( this, meta );

  			// data.sh = this.sh.toArray(); // todo

  			return data;

  		}

  	} );

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function HemisphereLightProbe( skyColor, groundColor, intensity ) {

  		LightProbe.call( this, undefined, intensity );

  		var color1 = new Color().set( skyColor );
  		var color2 = new Color().set( groundColor );

  		var sky = new Vector3( color1.r, color1.g, color1.b );
  		var ground = new Vector3( color2.r, color2.g, color2.b );

  		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
  		var c0 = Math.sqrt( Math.PI );
  		var c1 = c0 * Math.sqrt( 0.75 );

  		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
  		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

  	}

  	HemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

  		constructor: HemisphereLightProbe,

  		isHemisphereLightProbe: true,

  		copy: function ( source ) { // modifying colors not currently supported

  			LightProbe.prototype.copy.call( this, source );

  			return this;

  		},

  		toJSON: function ( meta ) {

  			var data = LightProbe.prototype.toJSON.call( this, meta );

  			// data.sh = this.sh.toArray(); // todo

  			return data;

  		}

  	} );

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function AmbientLightProbe( color, intensity ) {

  		LightProbe.call( this, undefined, intensity );

  		var color1 = new Color().set( color );

  		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
  		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

  	}

  	AmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

  		constructor: AmbientLightProbe,

  		isAmbientLightProbe: true,

  		copy: function ( source ) { // modifying color not currently supported

  			LightProbe.prototype.copy.call( this, source );

  			return this;

  		},

  		toJSON: function ( meta ) {

  			var data = LightProbe.prototype.toJSON.call( this, meta );

  			// data.sh = this.sh.toArray(); // todo

  			return data;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function StereoCamera() {

  		this.type = 'StereoCamera';

  		this.aspect = 1;

  		this.eyeSep = 0.064;

  		this.cameraL = new PerspectiveCamera();
  		this.cameraL.layers.enable( 1 );
  		this.cameraL.matrixAutoUpdate = false;

  		this.cameraR = new PerspectiveCamera();
  		this.cameraR.layers.enable( 2 );
  		this.cameraR.matrixAutoUpdate = false;

  	}

  	Object.assign( StereoCamera.prototype, {

  		update: ( function () {

  			var instance, focus, fov, aspect, near, far, zoom, eyeSep;

  			var eyeRight = new Matrix4();
  			var eyeLeft = new Matrix4();

  			return function update( camera ) {

  				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
  													aspect !== camera.aspect * this.aspect || near !== camera.near ||
  													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

  				if ( needsUpdate ) {

  					instance = this;
  					focus = camera.focus;
  					fov = camera.fov;
  					aspect = camera.aspect * this.aspect;
  					near = camera.near;
  					far = camera.far;
  					zoom = camera.zoom;

  					// Off-axis stereoscopic effect based on
  					// http://paulbourke.net/stereographics/stereorender/

  					var projectionMatrix = camera.projectionMatrix.clone();
  					eyeSep = this.eyeSep / 2;
  					var eyeSepOnProjection = eyeSep * near / focus;
  					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
  					var xmin, xmax;

  					// translate xOffset

  					eyeLeft.elements[ 12 ] = - eyeSep;
  					eyeRight.elements[ 12 ] = eyeSep;

  					// for left eye

  					xmin = - ymax * aspect + eyeSepOnProjection;
  					xmax = ymax * aspect + eyeSepOnProjection;

  					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  					this.cameraL.projectionMatrix.copy( projectionMatrix );

  					// for right eye

  					xmin = - ymax * aspect - eyeSepOnProjection;
  					xmax = ymax * aspect - eyeSepOnProjection;

  					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  					this.cameraR.projectionMatrix.copy( projectionMatrix );

  				}

  				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
  				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

  			};

  		} )()

  	} );

  	/**
  	 * Camera for rendering cube maps
  	 *	- renders scene into axis-aligned cube
  	 *
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	var fov = 90, aspect = 1;

  	function CubeCamera( near, far, cubeResolution, options ) {

  		Object3D.call( this );

  		this.type = 'CubeCamera';

  		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPX.up.set( 0, - 1, 0 );
  		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
  		this.add( cameraPX );

  		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNX.up.set( 0, - 1, 0 );
  		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
  		this.add( cameraNX );

  		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPY.up.set( 0, 0, 1 );
  		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
  		this.add( cameraPY );

  		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNY.up.set( 0, 0, - 1 );
  		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
  		this.add( cameraNY );

  		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraPZ.up.set( 0, - 1, 0 );
  		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
  		this.add( cameraPZ );

  		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
  		cameraNZ.up.set( 0, - 1, 0 );
  		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
  		this.add( cameraNZ );

  		options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

  		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
  		this.renderTarget.texture.name = "CubeCamera";

  		this.update = function ( renderer, scene ) {

  			if ( this.parent === null ) this.updateMatrixWorld();

  			var currentRenderTarget = renderer.getRenderTarget();

  			var renderTarget = this.renderTarget;
  			var generateMipmaps = renderTarget.texture.generateMipmaps;

  			renderTarget.texture.generateMipmaps = false;

  			renderer.setRenderTarget( renderTarget, 0 );
  			renderer.render( scene, cameraPX );

  			renderer.setRenderTarget( renderTarget, 1 );
  			renderer.render( scene, cameraNX );

  			renderer.setRenderTarget( renderTarget, 2 );
  			renderer.render( scene, cameraPY );

  			renderer.setRenderTarget( renderTarget, 3 );
  			renderer.render( scene, cameraNY );

  			renderer.setRenderTarget( renderTarget, 4 );
  			renderer.render( scene, cameraPZ );

  			renderTarget.texture.generateMipmaps = generateMipmaps;

  			renderer.setRenderTarget( renderTarget, 5 );
  			renderer.render( scene, cameraNZ );

  			renderer.setRenderTarget( currentRenderTarget );

  		};

  		this.clear = function ( renderer, color, depth, stencil ) {

  			var currentRenderTarget = renderer.getRenderTarget();

  			var renderTarget = this.renderTarget;

  			for ( var i = 0; i < 6; i ++ ) {

  				renderer.setRenderTarget( renderTarget, i );

  				renderer.clear( color, depth, stencil );

  			}

  			renderer.setRenderTarget( currentRenderTarget );

  		};

  	}

  	CubeCamera.prototype = Object.create( Object3D.prototype );
  	CubeCamera.prototype.constructor = CubeCamera;

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function Clock( autoStart ) {

  		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  		this.startTime = 0;
  		this.oldTime = 0;
  		this.elapsedTime = 0;

  		this.running = false;

  	}

  	Object.assign( Clock.prototype, {

  		start: function () {

  			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

  			this.oldTime = this.startTime;
  			this.elapsedTime = 0;
  			this.running = true;

  		},

  		stop: function () {

  			this.getElapsedTime();
  			this.running = false;
  			this.autoStart = false;

  		},

  		getElapsedTime: function () {

  			this.getDelta();
  			return this.elapsedTime;

  		},

  		getDelta: function () {

  			var diff = 0;

  			if ( this.autoStart && ! this.running ) {

  				this.start();
  				return 0;

  			}

  			if ( this.running ) {

  				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

  				diff = ( newTime - this.oldTime ) / 1000;
  				this.oldTime = newTime;

  				this.elapsedTime += diff;

  			}

  			return diff;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function AudioListener() {

  		Object3D.call( this );

  		this.type = 'AudioListener';

  		this.context = AudioContext.getContext();

  		this.gain = this.context.createGain();
  		this.gain.connect( this.context.destination );

  		this.filter = null;

  		this.timeDelta = 0;

  	}

  	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: AudioListener,

  		getInput: function () {

  			return this.gain;

  		},

  		removeFilter: function ( ) {

  			if ( this.filter !== null ) {

  				this.gain.disconnect( this.filter );
  				this.filter.disconnect( this.context.destination );
  				this.gain.connect( this.context.destination );
  				this.filter = null;

  			}

  			return this;

  		},

  		getFilter: function () {

  			return this.filter;

  		},

  		setFilter: function ( value ) {

  			if ( this.filter !== null ) {

  				this.gain.disconnect( this.filter );
  				this.filter.disconnect( this.context.destination );

  			} else {

  				this.gain.disconnect( this.context.destination );

  			}

  			this.filter = value;
  			this.gain.connect( this.filter );
  			this.filter.connect( this.context.destination );

  			return this;

  		},

  		getMasterVolume: function () {

  			return this.gain.gain.value;

  		},

  		setMasterVolume: function ( value ) {

  			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

  			return this;

  		},

  		updateMatrixWorld: ( function () {

  			var position = new Vector3();
  			var quaternion = new Quaternion();
  			var scale = new Vector3();

  			var orientation = new Vector3();
  			var clock = new Clock();

  			return function updateMatrixWorld( force ) {

  				Object3D.prototype.updateMatrixWorld.call( this, force );

  				var listener = this.context.listener;
  				var up = this.up;

  				this.timeDelta = clock.getDelta();

  				this.matrixWorld.decompose( position, quaternion, scale );

  				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  				if ( listener.positionX ) {

  					// code path for Chrome (see #14393)

  					var endTime = this.context.currentTime + this.timeDelta;

  					listener.positionX.linearRampToValueAtTime( position.x, endTime );
  					listener.positionY.linearRampToValueAtTime( position.y, endTime );
  					listener.positionZ.linearRampToValueAtTime( position.z, endTime );
  					listener.forwardX.linearRampToValueAtTime( orientation.x, endTime );
  					listener.forwardY.linearRampToValueAtTime( orientation.y, endTime );
  					listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime );
  					listener.upX.linearRampToValueAtTime( up.x, endTime );
  					listener.upY.linearRampToValueAtTime( up.y, endTime );
  					listener.upZ.linearRampToValueAtTime( up.z, endTime );

  				} else {

  					listener.setPosition( position.x, position.y, position.z );
  					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

  				}

  			};

  		} )()

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
  	 */

  	function Audio( listener ) {

  		Object3D.call( this );

  		this.type = 'Audio';

  		this.listener = listener;
  		this.context = listener.context;

  		this.gain = this.context.createGain();
  		this.gain.connect( listener.getInput() );

  		this.autoplay = false;

  		this.buffer = null;
  		this.detune = 0;
  		this.loop = false;
  		this.startTime = 0;
  		this.offset = 0;
  		this.playbackRate = 1;
  		this.isPlaying = false;
  		this.hasPlaybackControl = true;
  		this.sourceType = 'empty';

  		this.filters = [];

  	}

  	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

  		constructor: Audio,

  		getOutput: function () {

  			return this.gain;

  		},

  		setNodeSource: function ( audioNode ) {

  			this.hasPlaybackControl = false;
  			this.sourceType = 'audioNode';
  			this.source = audioNode;
  			this.connect();

  			return this;

  		},

  		setMediaElementSource: function ( mediaElement ) {

  			this.hasPlaybackControl = false;
  			this.sourceType = 'mediaNode';
  			this.source = this.context.createMediaElementSource( mediaElement );
  			this.connect();

  			return this;

  		},

  		setBuffer: function ( audioBuffer ) {

  			this.buffer = audioBuffer;
  			this.sourceType = 'buffer';

  			if ( this.autoplay ) this.play();

  			return this;

  		},

  		play: function () {

  			if ( this.isPlaying === true ) {

  				console.warn( 'THREE.Audio: Audio is already playing.' );
  				return;

  			}

  			if ( this.hasPlaybackControl === false ) {

  				console.warn( 'THREE.Audio: this Audio has no playback control.' );
  				return;

  			}

  			var source = this.context.createBufferSource();

  			source.buffer = this.buffer;
  			source.loop = this.loop;
  			source.onended = this.onEnded.bind( this );
  			this.startTime = this.context.currentTime;
  			source.start( this.startTime, this.offset );

  			this.isPlaying = true;

  			this.source = source;

  			this.setDetune( this.detune );
  			this.setPlaybackRate( this.playbackRate );

  			return this.connect();

  		},

  		pause: function () {

  			if ( this.hasPlaybackControl === false ) {

  				console.warn( 'THREE.Audio: this Audio has no playback control.' );
  				return;

  			}

  			if ( this.isPlaying === true ) {

  				this.source.stop();
  				this.source.onended = null;
  				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
  				this.isPlaying = false;

  			}

  			return this;

  		},

  		stop: function () {

  			if ( this.hasPlaybackControl === false ) {

  				console.warn( 'THREE.Audio: this Audio has no playback control.' );
  				return;

  			}

  			this.source.stop();
  			this.source.onended = null;
  			this.offset = 0;
  			this.isPlaying = false;

  			return this;

  		},

  		connect: function () {

  			if ( this.filters.length > 0 ) {

  				this.source.connect( this.filters[ 0 ] );

  				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

  					this.filters[ i - 1 ].connect( this.filters[ i ] );

  				}

  				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

  			} else {

  				this.source.connect( this.getOutput() );

  			}

  			return this;

  		},

  		disconnect: function () {

  			if ( this.filters.length > 0 ) {

  				this.source.disconnect( this.filters[ 0 ] );

  				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

  					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

  				}

  				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

  			} else {

  				this.source.disconnect( this.getOutput() );

  			}

  			return this;

  		},

  		getFilters: function () {

  			return this.filters;

  		},

  		setFilters: function ( value ) {

  			if ( ! value ) value = [];

  			if ( this.isPlaying === true ) {

  				this.disconnect();
  				this.filters = value;
  				this.connect();

  			} else {

  				this.filters = value;

  			}

  			return this;

  		},

  		setDetune: function ( value ) {

  			this.detune = value;

  			if ( this.source.detune === undefined ) return; // only set detune when available

  			if ( this.isPlaying === true ) {

  				this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

  			}

  			return this;

  		},

  		getDetune: function () {

  			return this.detune;

  		},

  		getFilter: function () {

  			return this.getFilters()[ 0 ];

  		},

  		setFilter: function ( filter ) {

  			return this.setFilters( filter ? [ filter ] : [] );

  		},

  		setPlaybackRate: function ( value ) {

  			if ( this.hasPlaybackControl === false ) {

  				console.warn( 'THREE.Audio: this Audio has no playback control.' );
  				return;

  			}

  			this.playbackRate = value;

  			if ( this.isPlaying === true ) {

  				this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

  			}

  			return this;

  		},

  		getPlaybackRate: function () {

  			return this.playbackRate;

  		},

  		onEnded: function () {

  			this.isPlaying = false;

  		},

  		getLoop: function () {

  			if ( this.hasPlaybackControl === false ) {

  				console.warn( 'THREE.Audio: this Audio has no playback control.' );
  				return false;

  			}

  			return this.loop;

  		},

  		setLoop: function ( value ) {

  			if ( this.hasPlaybackControl === false ) {

  				console.warn( 'THREE.Audio: this Audio has no playback control.' );
  				return;

  			}

  			this.loop = value;

  			if ( this.isPlaying === true ) {

  				this.source.loop = this.loop;

  			}

  			return this;

  		},

  		getVolume: function () {

  			return this.gain.gain.value;

  		},

  		setVolume: function ( value ) {

  			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function PositionalAudio( listener ) {

  		Audio.call( this, listener );

  		this.panner = this.context.createPanner();
  		this.panner.connect( this.gain );

  	}

  	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

  		constructor: PositionalAudio,

  		getOutput: function () {

  			return this.panner;

  		},

  		getRefDistance: function () {

  			return this.panner.refDistance;

  		},

  		setRefDistance: function ( value ) {

  			this.panner.refDistance = value;

  			return this;

  		},

  		getRolloffFactor: function () {

  			return this.panner.rolloffFactor;

  		},

  		setRolloffFactor: function ( value ) {

  			this.panner.rolloffFactor = value;

  			return this;

  		},

  		getDistanceModel: function () {

  			return this.panner.distanceModel;

  		},

  		setDistanceModel: function ( value ) {

  			this.panner.distanceModel = value;

  			return this;

  		},

  		getMaxDistance: function () {

  			return this.panner.maxDistance;

  		},

  		setMaxDistance: function ( value ) {

  			this.panner.maxDistance = value;

  			return this;

  		},

  		setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

  			this.panner.coneInnerAngle = coneInnerAngle;
  			this.panner.coneOuterAngle = coneOuterAngle;
  			this.panner.coneOuterGain = coneOuterGain;

  			return this;

  		},

  		updateMatrixWorld: ( function () {

  			var position = new Vector3();
  			var quaternion = new Quaternion();
  			var scale = new Vector3();

  			var orientation = new Vector3();

  			return function updateMatrixWorld( force ) {

  				Object3D.prototype.updateMatrixWorld.call( this, force );

  				if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

  				this.matrixWorld.decompose( position, quaternion, scale );

  				orientation.set( 0, 0, 1 ).applyQuaternion( quaternion );

  				var panner = this.panner;

  				if ( panner.positionX ) {

  					// code path for Chrome and Firefox (see #14393)

  					var endTime = this.context.currentTime + this.listener.timeDelta;

  					panner.positionX.linearRampToValueAtTime( position.x, endTime );
  					panner.positionY.linearRampToValueAtTime( position.y, endTime );
  					panner.positionZ.linearRampToValueAtTime( position.z, endTime );
  					panner.orientationX.linearRampToValueAtTime( orientation.x, endTime );
  					panner.orientationY.linearRampToValueAtTime( orientation.y, endTime );
  					panner.orientationZ.linearRampToValueAtTime( orientation.z, endTime );

  				} else {

  					panner.setPosition( position.x, position.y, position.z );
  					panner.setOrientation( orientation.x, orientation.y, orientation.z );

  				}

  			};

  		} )()


  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function AudioAnalyser( audio, fftSize ) {

  		this.analyser = audio.context.createAnalyser();
  		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

  		this.data = new Uint8Array( this.analyser.frequencyBinCount );

  		audio.getOutput().connect( this.analyser );

  	}

  	Object.assign( AudioAnalyser.prototype, {

  		getFrequencyData: function () {

  			this.analyser.getByteFrequencyData( this.data );

  			return this.data;

  		},

  		getAverageFrequency: function () {

  			var value = 0, data = this.getFrequencyData();

  			for ( var i = 0; i < data.length; i ++ ) {

  				value += data[ i ];

  			}

  			return value / data.length;

  		}

  	} );

  	/**
  	 *
  	 * Buffered scene graph property that allows weighted accumulation.
  	 *
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function PropertyMixer( binding, typeName, valueSize ) {

  		this.binding = binding;
  		this.valueSize = valueSize;

  		var bufferType = Float64Array,
  			mixFunction;

  		switch ( typeName ) {

  			case 'quaternion':
  				mixFunction = this._slerp;
  				break;

  			case 'string':
  			case 'bool':
  				bufferType = Array;
  				mixFunction = this._select;
  				break;

  			default:
  				mixFunction = this._lerp;

  		}

  		this.buffer = new bufferType( valueSize * 4 );
  		// layout: [ incoming | accu0 | accu1 | orig ]
  		//
  		// interpolators can use .buffer as their .result
  		// the data then goes to 'incoming'
  		//
  		// 'accu0' and 'accu1' are used frame-interleaved for
  		// the cumulative result and are compared to detect
  		// changes
  		//
  		// 'orig' stores the original state of the property

  		this._mixBufferRegion = mixFunction;

  		this.cumulativeWeight = 0;

  		this.useCount = 0;
  		this.referenceCount = 0;

  	}

  	Object.assign( PropertyMixer.prototype, {

  		// accumulate data in the 'incoming' region into 'accu<i>'
  		accumulate: function ( accuIndex, weight ) {

  			// note: happily accumulating nothing when weight = 0, the caller knows
  			// the weight and shouldn't have made the call in the first place

  			var buffer = this.buffer,
  				stride = this.valueSize,
  				offset = accuIndex * stride + stride,

  				currentWeight = this.cumulativeWeight;

  			if ( currentWeight === 0 ) {

  				// accuN := incoming * weight

  				for ( var i = 0; i !== stride; ++ i ) {

  					buffer[ offset + i ] = buffer[ i ];

  				}

  				currentWeight = weight;

  			} else {

  				// accuN := accuN + incoming * weight

  				currentWeight += weight;
  				var mix = weight / currentWeight;
  				this._mixBufferRegion( buffer, offset, 0, mix, stride );

  			}

  			this.cumulativeWeight = currentWeight;

  		},

  		// apply the state of 'accu<i>' to the binding when accus differ
  		apply: function ( accuIndex ) {

  			var stride = this.valueSize,
  				buffer = this.buffer,
  				offset = accuIndex * stride + stride,

  				weight = this.cumulativeWeight,

  				binding = this.binding;

  			this.cumulativeWeight = 0;

  			if ( weight < 1 ) {

  				// accuN := accuN + original * ( 1 - cumulativeWeight )

  				var originalValueOffset = stride * 3;

  				this._mixBufferRegion(
  					buffer, offset, originalValueOffset, 1 - weight, stride );

  			}

  			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

  				if ( buffer[ i ] !== buffer[ i + stride ] ) {

  					// value has changed -> update scene graph

  					binding.setValue( buffer, offset );
  					break;

  				}

  			}

  		},

  		// remember the state of the bound property and copy it to both accus
  		saveOriginalState: function () {

  			var binding = this.binding;

  			var buffer = this.buffer,
  				stride = this.valueSize,

  				originalValueOffset = stride * 3;

  			binding.getValue( buffer, originalValueOffset );

  			// accu[0..1] := orig -- initially detect changes against the original
  			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

  				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

  			}

  			this.cumulativeWeight = 0;

  		},

  		// apply the state previously taken via 'saveOriginalState' to the binding
  		restoreOriginalState: function () {

  			var originalValueOffset = this.valueSize * 3;
  			this.binding.setValue( this.buffer, originalValueOffset );

  		},


  		// mix functions

  		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

  			if ( t >= 0.5 ) {

  				for ( var i = 0; i !== stride; ++ i ) {

  					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

  				}

  			}

  		},

  		_slerp: function ( buffer, dstOffset, srcOffset, t ) {

  			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

  		},

  		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

  			var s = 1 - t;

  			for ( var i = 0; i !== stride; ++ i ) {

  				var j = dstOffset + i;

  				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

  			}

  		}

  	} );

  	/**
  	 *
  	 * A reference to a real property in the scene graph.
  	 *
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	// Characters [].:/ are reserved for track binding syntax.
  	var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

  	function Composite( targetGroup, path, optionalParsedPath ) {

  		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

  		this._targetGroup = targetGroup;
  		this._bindings = targetGroup.subscribe_( path, parsedPath );

  	}

  	Object.assign( Composite.prototype, {

  		getValue: function ( array, offset ) {

  			this.bind(); // bind all binding

  			var firstValidIndex = this._targetGroup.nCachedObjects_,
  				binding = this._bindings[ firstValidIndex ];

  			// and only call .getValue on the first
  			if ( binding !== undefined ) binding.getValue( array, offset );

  		},

  		setValue: function ( array, offset ) {

  			var bindings = this._bindings;

  			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  				bindings[ i ].setValue( array, offset );

  			}

  		},

  		bind: function () {

  			var bindings = this._bindings;

  			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  				bindings[ i ].bind();

  			}

  		},

  		unbind: function () {

  			var bindings = this._bindings;

  			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

  				bindings[ i ].unbind();

  			}

  		}

  	} );


  	function PropertyBinding( rootNode, path, parsedPath ) {

  		this.path = path;
  		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

  		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

  		this.rootNode = rootNode;

  	}

  	Object.assign( PropertyBinding, {

  		Composite: Composite,

  		create: function ( root, path, parsedPath ) {

  			if ( ! ( root && root.isAnimationObjectGroup ) ) {

  				return new PropertyBinding( root, path, parsedPath );

  			} else {

  				return new PropertyBinding.Composite( root, path, parsedPath );

  			}

  		},

  		/**
  		 * Replaces spaces with underscores and removes unsupported characters from
  		 * node names, to ensure compatibility with parseTrackName().
  		 *
  		 * @param {string} name Node name to be sanitized.
  		 * @return {string}
  		 */
  		sanitizeNodeName: ( function () {

  			var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );

  			return function sanitizeNodeName( name ) {

  				return name.replace( /\s/g, '_' ).replace( reservedRe, '' );

  			};

  		}() ),

  		parseTrackName: function () {

  			// Attempts to allow node names from any language. ES5's `\w` regexp matches
  			// only latin characters, and the unicode \p{L} is not yet supported. So
  			// instead, we exclude reserved characters and match everything else.
  			var wordChar = '[^' + RESERVED_CHARS_RE + ']';
  			var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

  			// Parent directories, delimited by '/' or ':'. Currently unused, but must
  			// be matched to parse the rest of the track name.
  			var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );

  			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  			var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );

  			// Object on target node, and accessor. May not contain reserved
  			// characters. Accessor may contain any character except closing bracket.
  			var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );

  			// Property and accessor. May not contain reserved characters. Accessor may
  			// contain any non-bracket characters.
  			var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );

  			var trackRe = new RegExp( ''
  				+ '^'
  				+ directoryRe
  				+ nodeRe
  				+ objectRe
  				+ propertyRe
  				+ '$'
  			);

  			var supportedObjectNames = [ 'material', 'materials', 'bones' ];

  			return function parseTrackName( trackName ) {

  				var matches = trackRe.exec( trackName );

  				if ( ! matches ) {

  					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

  				}

  				var results = {
  					// directoryName: matches[ 1 ], // (tschw) currently unused
  					nodeName: matches[ 2 ],
  					objectName: matches[ 3 ],
  					objectIndex: matches[ 4 ],
  					propertyName: matches[ 5 ], // required
  					propertyIndex: matches[ 6 ]
  				};

  				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

  				if ( lastDot !== undefined && lastDot !== - 1 ) {

  					var objectName = results.nodeName.substring( lastDot + 1 );

  					// Object names must be checked against a whitelist. Otherwise, there
  					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  					// 'bar' could be the objectName, or part of a nodeName (which can
  					// include '.' characters).
  					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

  						results.nodeName = results.nodeName.substring( 0, lastDot );
  						results.objectName = objectName;

  					}

  				}

  				if ( results.propertyName === null || results.propertyName.length === 0 ) {

  					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

  				}

  				return results;

  			};

  		}(),

  		findNode: function ( root, nodeName ) {

  			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

  				return root;

  			}

  			// search into skeleton bones.
  			if ( root.skeleton ) {

  				var bone = root.skeleton.getBoneByName( nodeName );

  				if ( bone !== undefined ) {

  					return bone;

  				}

  			}

  			// search into node subtree.
  			if ( root.children ) {

  				var searchNodeSubtree = function ( children ) {

  					for ( var i = 0; i < children.length; i ++ ) {

  						var childNode = children[ i ];

  						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

  							return childNode;

  						}

  						var result = searchNodeSubtree( childNode.children );

  						if ( result ) return result;

  					}

  					return null;

  				};

  				var subTreeNode = searchNodeSubtree( root.children );

  				if ( subTreeNode ) {

  					return subTreeNode;

  				}

  			}

  			return null;

  		}

  	} );

  	Object.assign( PropertyBinding.prototype, { // prototype, continued

  		// these are used to "bind" a nonexistent property
  		_getValue_unavailable: function () {},
  		_setValue_unavailable: function () {},

  		BindingType: {
  			Direct: 0,
  			EntireArray: 1,
  			ArrayElement: 2,
  			HasFromToArray: 3
  		},

  		Versioning: {
  			None: 0,
  			NeedsUpdate: 1,
  			MatrixWorldNeedsUpdate: 2
  		},

  		GetterByBindingType: [

  			function getValue_direct( buffer, offset ) {

  				buffer[ offset ] = this.node[ this.propertyName ];

  			},

  			function getValue_array( buffer, offset ) {

  				var source = this.resolvedProperty;

  				for ( var i = 0, n = source.length; i !== n; ++ i ) {

  					buffer[ offset ++ ] = source[ i ];

  				}

  			},

  			function getValue_arrayElement( buffer, offset ) {

  				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

  			},

  			function getValue_toArray( buffer, offset ) {

  				this.resolvedProperty.toArray( buffer, offset );

  			}

  		],

  		SetterByBindingTypeAndVersioning: [

  			[
  				// Direct

  				function setValue_direct( buffer, offset ) {

  					this.targetObject[ this.propertyName ] = buffer[ offset ];

  				},

  				function setValue_direct_setNeedsUpdate( buffer, offset ) {

  					this.targetObject[ this.propertyName ] = buffer[ offset ];
  					this.targetObject.needsUpdate = true;

  				},

  				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

  					this.targetObject[ this.propertyName ] = buffer[ offset ];
  					this.targetObject.matrixWorldNeedsUpdate = true;

  				}

  			], [

  				// EntireArray

  				function setValue_array( buffer, offset ) {

  					var dest = this.resolvedProperty;

  					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  						dest[ i ] = buffer[ offset ++ ];

  					}

  				},

  				function setValue_array_setNeedsUpdate( buffer, offset ) {

  					var dest = this.resolvedProperty;

  					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  						dest[ i ] = buffer[ offset ++ ];

  					}

  					this.targetObject.needsUpdate = true;

  				},

  				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

  					var dest = this.resolvedProperty;

  					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  						dest[ i ] = buffer[ offset ++ ];

  					}

  					this.targetObject.matrixWorldNeedsUpdate = true;

  				}

  			], [

  				// ArrayElement

  				function setValue_arrayElement( buffer, offset ) {

  					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

  				},

  				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

  					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  					this.targetObject.needsUpdate = true;

  				},

  				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

  					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  					this.targetObject.matrixWorldNeedsUpdate = true;

  				}

  			], [

  				// HasToFromArray

  				function setValue_fromArray( buffer, offset ) {

  					this.resolvedProperty.fromArray( buffer, offset );

  				},

  				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

  					this.resolvedProperty.fromArray( buffer, offset );
  					this.targetObject.needsUpdate = true;

  				},

  				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

  					this.resolvedProperty.fromArray( buffer, offset );
  					this.targetObject.matrixWorldNeedsUpdate = true;

  				}

  			]

  		],

  		getValue: function getValue_unbound( targetArray, offset ) {

  			this.bind();
  			this.getValue( targetArray, offset );

  			// Note: This class uses a State pattern on a per-method basis:
  			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
  			// prototype version of these methods with one that represents
  			// the bound state. When the property is not found, the methods
  			// become no-ops.

  		},

  		setValue: function getValue_unbound( sourceArray, offset ) {

  			this.bind();
  			this.setValue( sourceArray, offset );

  		},

  		// create getter / setter pair for a property in the scene graph
  		bind: function () {

  			var targetObject = this.node,
  				parsedPath = this.parsedPath,

  				objectName = parsedPath.objectName,
  				propertyName = parsedPath.propertyName,
  				propertyIndex = parsedPath.propertyIndex;

  			if ( ! targetObject ) {

  				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

  				this.node = targetObject;

  			}

  			// set fail state so we can just 'return' on error
  			this.getValue = this._getValue_unavailable;
  			this.setValue = this._setValue_unavailable;

  			// ensure there is a value node
  			if ( ! targetObject ) {

  				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
  				return;

  			}

  			if ( objectName ) {

  				var objectIndex = parsedPath.objectIndex;

  				// special cases were we need to reach deeper into the hierarchy to get the face materials....
  				switch ( objectName ) {

  					case 'materials':

  						if ( ! targetObject.material ) {

  							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
  							return;

  						}

  						if ( ! targetObject.material.materials ) {

  							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
  							return;

  						}

  						targetObject = targetObject.material.materials;

  						break;

  					case 'bones':

  						if ( ! targetObject.skeleton ) {

  							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
  							return;

  						}

  						// potential future optimization: skip this if propertyIndex is already an integer
  						// and convert the integer string to a true integer.

  						targetObject = targetObject.skeleton.bones;

  						// support resolving morphTarget names into indices.
  						for ( var i = 0; i < targetObject.length; i ++ ) {

  							if ( targetObject[ i ].name === objectIndex ) {

  								objectIndex = i;
  								break;

  							}

  						}

  						break;

  					default:

  						if ( targetObject[ objectName ] === undefined ) {

  							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
  							return;

  						}

  						targetObject = targetObject[ objectName ];

  				}


  				if ( objectIndex !== undefined ) {

  					if ( targetObject[ objectIndex ] === undefined ) {

  						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
  						return;

  					}

  					targetObject = targetObject[ objectIndex ];

  				}

  			}

  			// resolve property
  			var nodeProperty = targetObject[ propertyName ];

  			if ( nodeProperty === undefined ) {

  				var nodeName = parsedPath.nodeName;

  				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
  					'.' + propertyName + ' but it wasn\'t found.', targetObject );
  				return;

  			}

  			// determine versioning scheme
  			var versioning = this.Versioning.None;

  			this.targetObject = targetObject;

  			if ( targetObject.needsUpdate !== undefined ) { // material

  				versioning = this.Versioning.NeedsUpdate;

  			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

  				versioning = this.Versioning.MatrixWorldNeedsUpdate;

  			}

  			// determine how the property gets bound
  			var bindingType = this.BindingType.Direct;

  			if ( propertyIndex !== undefined ) {

  				// access a sub element of the property array (only primitives are supported right now)

  				if ( propertyName === "morphTargetInfluences" ) {

  					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

  					// support resolving morphTarget names into indices.
  					if ( ! targetObject.geometry ) {

  						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
  						return;

  					}

  					if ( targetObject.geometry.isBufferGeometry ) {

  						if ( ! targetObject.geometry.morphAttributes ) {

  							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
  							return;

  						}

  						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

  							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

  								propertyIndex = i;
  								break;

  							}

  						}


  					} else {

  						if ( ! targetObject.geometry.morphTargets ) {

  							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
  							return;

  						}

  						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

  							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

  								propertyIndex = i;
  								break;

  							}

  						}

  					}

  				}

  				bindingType = this.BindingType.ArrayElement;

  				this.resolvedProperty = nodeProperty;
  				this.propertyIndex = propertyIndex;

  			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

  				// must use copy for Object3D.Euler/Quaternion

  				bindingType = this.BindingType.HasFromToArray;

  				this.resolvedProperty = nodeProperty;

  			} else if ( Array.isArray( nodeProperty ) ) {

  				bindingType = this.BindingType.EntireArray;

  				this.resolvedProperty = nodeProperty;

  			} else {

  				this.propertyName = propertyName;

  			}

  			// select getter / setter
  			this.getValue = this.GetterByBindingType[ bindingType ];
  			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  		},

  		unbind: function () {

  			this.node = null;

  			// back to the prototype version of getValue / setValue
  			// note: avoiding to mutate the shape of 'this' via 'delete'
  			this.getValue = this._getValue_unbound;
  			this.setValue = this._setValue_unbound;

  		}

  	} );

  	//!\ DECLARE ALIAS AFTER assign prototype !
  	Object.assign( PropertyBinding.prototype, {

  		// initial state of these methods that calls 'bind'
  		_getValue_unbound: PropertyBinding.prototype.getValue,
  		_setValue_unbound: PropertyBinding.prototype.setValue,

  	} );

  	/**
  	 *
  	 * A group of objects that receives a shared animation state.
  	 *
  	 * Usage:
  	 *
  	 *  - Add objects you would otherwise pass as 'root' to the
  	 *    constructor or the .clipAction method of AnimationMixer.
  	 *
  	 *  - Instead pass this object as 'root'.
  	 *
  	 *  - You can also add and remove objects later when the mixer
  	 *    is running.
  	 *
  	 * Note:
  	 *
  	 *    Objects of this class appear as one object to the mixer,
  	 *    so cache control of the individual objects must be done
  	 *    on the group.
  	 *
  	 * Limitation:
  	 *
  	 *  - The animated properties must be compatible among the
  	 *    all objects in the group.
  	 *
  	 *  - A single property can either be controlled through a
  	 *    target group or directly, but not both.
  	 *
  	 * @author tschw
  	 */

  	function AnimationObjectGroup() {

  		this.uuid = _Math.generateUUID();

  		// cached objects followed by the active ones
  		this._objects = Array.prototype.slice.call( arguments );

  		this.nCachedObjects_ = 0; // threshold
  		// note: read by PropertyBinding.Composite

  		var indices = {};
  		this._indicesByUUID = indices; // for bookkeeping

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			indices[ arguments[ i ].uuid ] = i;

  		}

  		this._paths = []; // inside: string
  		this._parsedPaths = []; // inside: { we don't care, here }
  		this._bindings = []; // inside: Array< PropertyBinding >
  		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

  		var scope = this;

  		this.stats = {

  			objects: {
  				get total() {

  					return scope._objects.length;

  				},
  				get inUse() {

  					return this.total - scope.nCachedObjects_;

  				}
  			},
  			get bindingsPerObject() {

  				return scope._bindings.length;

  			}

  		};

  	}

  	Object.assign( AnimationObjectGroup.prototype, {

  		isAnimationObjectGroup: true,

  		add: function () {

  			var objects = this._objects,
  				nObjects = objects.length,
  				nCachedObjects = this.nCachedObjects_,
  				indicesByUUID = this._indicesByUUID,
  				paths = this._paths,
  				parsedPaths = this._parsedPaths,
  				bindings = this._bindings,
  				nBindings = bindings.length,
  				knownObject = undefined;

  			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  				var object = arguments[ i ],
  					uuid = object.uuid,
  					index = indicesByUUID[ uuid ];

  				if ( index === undefined ) {

  					// unknown object -> add it to the ACTIVE region

  					index = nObjects ++;
  					indicesByUUID[ uuid ] = index;
  					objects.push( object );

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

  					}

  				} else if ( index < nCachedObjects ) {

  					knownObject = objects[ index ];

  					// move existing object to the ACTIVE region

  					var firstActiveIndex = -- nCachedObjects,
  						lastCachedObject = objects[ firstActiveIndex ];

  					indicesByUUID[ lastCachedObject.uuid ] = index;
  					objects[ index ] = lastCachedObject;

  					indicesByUUID[ uuid ] = firstActiveIndex;
  					objects[ firstActiveIndex ] = object;

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						var bindingsForPath = bindings[ j ],
  							lastCached = bindingsForPath[ firstActiveIndex ],
  							binding = bindingsForPath[ index ];

  						bindingsForPath[ index ] = lastCached;

  						if ( binding === undefined ) {

  							// since we do not bother to create new bindings
  							// for objects that are cached, the binding may
  							// or may not exist

  							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

  						}

  						bindingsForPath[ firstActiveIndex ] = binding;

  					}

  				} else if ( objects[ index ] !== knownObject ) {

  					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
  						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

  				} // else the object is already where we want it to be

  			} // for arguments

  			this.nCachedObjects_ = nCachedObjects;

  		},

  		remove: function () {

  			var objects = this._objects,
  				nCachedObjects = this.nCachedObjects_,
  				indicesByUUID = this._indicesByUUID,
  				bindings = this._bindings,
  				nBindings = bindings.length;

  			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  				var object = arguments[ i ],
  					uuid = object.uuid,
  					index = indicesByUUID[ uuid ];

  				if ( index !== undefined && index >= nCachedObjects ) {

  					// move existing object into the CACHED region

  					var lastCachedIndex = nCachedObjects ++,
  						firstActiveObject = objects[ lastCachedIndex ];

  					indicesByUUID[ firstActiveObject.uuid ] = index;
  					objects[ index ] = firstActiveObject;

  					indicesByUUID[ uuid ] = lastCachedIndex;
  					objects[ lastCachedIndex ] = object;

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						var bindingsForPath = bindings[ j ],
  							firstActive = bindingsForPath[ lastCachedIndex ],
  							binding = bindingsForPath[ index ];

  						bindingsForPath[ index ] = firstActive;
  						bindingsForPath[ lastCachedIndex ] = binding;

  					}

  				}

  			} // for arguments

  			this.nCachedObjects_ = nCachedObjects;

  		},

  		// remove & forget
  		uncache: function () {

  			var objects = this._objects,
  				nObjects = objects.length,
  				nCachedObjects = this.nCachedObjects_,
  				indicesByUUID = this._indicesByUUID,
  				bindings = this._bindings,
  				nBindings = bindings.length;

  			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  				var object = arguments[ i ],
  					uuid = object.uuid,
  					index = indicesByUUID[ uuid ];

  				if ( index !== undefined ) {

  					delete indicesByUUID[ uuid ];

  					if ( index < nCachedObjects ) {

  						// object is cached, shrink the CACHED region

  						var firstActiveIndex = -- nCachedObjects,
  							lastCachedObject = objects[ firstActiveIndex ],
  							lastIndex = -- nObjects,
  							lastObject = objects[ lastIndex ];

  						// last cached object takes this object's place
  						indicesByUUID[ lastCachedObject.uuid ] = index;
  						objects[ index ] = lastCachedObject;

  						// last object goes to the activated slot and pop
  						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
  						objects[ firstActiveIndex ] = lastObject;
  						objects.pop();

  						// accounting is done, now do the same for all bindings

  						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  							var bindingsForPath = bindings[ j ],
  								lastCached = bindingsForPath[ firstActiveIndex ],
  								last = bindingsForPath[ lastIndex ];

  							bindingsForPath[ index ] = lastCached;
  							bindingsForPath[ firstActiveIndex ] = last;
  							bindingsForPath.pop();

  						}

  					} else {

  						// object is active, just swap with the last and pop

  						var lastIndex = -- nObjects,
  							lastObject = objects[ lastIndex ];

  						indicesByUUID[ lastObject.uuid ] = index;
  						objects[ index ] = lastObject;
  						objects.pop();

  						// accounting is done, now do the same for all bindings

  						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  							var bindingsForPath = bindings[ j ];

  							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
  							bindingsForPath.pop();

  						}

  					} // cached or active

  				} // if object is known

  			} // for arguments

  			this.nCachedObjects_ = nCachedObjects;

  		},

  		// Internal interface used by befriended PropertyBinding.Composite:

  		subscribe_: function ( path, parsedPath ) {

  			// returns an array of bindings for the given path that is changed
  			// according to the contained objects in the group

  			var indicesByPath = this._bindingsIndicesByPath,
  				index = indicesByPath[ path ],
  				bindings = this._bindings;

  			if ( index !== undefined ) return bindings[ index ];

  			var paths = this._paths,
  				parsedPaths = this._parsedPaths,
  				objects = this._objects,
  				nObjects = objects.length,
  				nCachedObjects = this.nCachedObjects_,
  				bindingsForPath = new Array( nObjects );

  			index = bindings.length;

  			indicesByPath[ path ] = index;

  			paths.push( path );
  			parsedPaths.push( parsedPath );
  			bindings.push( bindingsForPath );

  			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

  				var object = objects[ i ];
  				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

  			}

  			return bindingsForPath;

  		},

  		unsubscribe_: function ( path ) {

  			// tells the group to forget about a property path and no longer
  			// update the array previously obtained with 'subscribe_'

  			var indicesByPath = this._bindingsIndicesByPath,
  				index = indicesByPath[ path ];

  			if ( index !== undefined ) {

  				var paths = this._paths,
  					parsedPaths = this._parsedPaths,
  					bindings = this._bindings,
  					lastBindingsIndex = bindings.length - 1,
  					lastBindings = bindings[ lastBindingsIndex ],
  					lastBindingsPath = path[ lastBindingsIndex ];

  				indicesByPath[ lastBindingsPath ] = index;

  				bindings[ index ] = lastBindings;
  				bindings.pop();

  				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
  				parsedPaths.pop();

  				paths[ index ] = paths[ lastBindingsIndex ];
  				paths.pop();

  			}

  		}

  	} );

  	/**
  	 *
  	 * Action provided by AnimationMixer for scheduling clip playback on specific
  	 * objects.
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 *
  	 */

  	function AnimationAction( mixer, clip, localRoot ) {

  		this._mixer = mixer;
  		this._clip = clip;
  		this._localRoot = localRoot || null;

  		var tracks = clip.tracks,
  			nTracks = tracks.length,
  			interpolants = new Array( nTracks );

  		var interpolantSettings = {
  			endingStart: ZeroCurvatureEnding,
  			endingEnd: ZeroCurvatureEnding
  		};

  		for ( var i = 0; i !== nTracks; ++ i ) {

  			var interpolant = tracks[ i ].createInterpolant( null );
  			interpolants[ i ] = interpolant;
  			interpolant.settings = interpolantSettings;

  		}

  		this._interpolantSettings = interpolantSettings;

  		this._interpolants = interpolants; // bound by the mixer

  		// inside: PropertyMixer (managed by the mixer)
  		this._propertyBindings = new Array( nTracks );

  		this._cacheIndex = null; // for the memory manager
  		this._byClipCacheIndex = null; // for the memory manager

  		this._timeScaleInterpolant = null;
  		this._weightInterpolant = null;

  		this.loop = LoopRepeat;
  		this._loopCount = - 1;

  		// global mixer time when the action is to be started
  		// it's set back to 'null' upon start of the action
  		this._startTime = null;

  		// scaled local time of the action
  		// gets clamped or wrapped to 0..clip.duration according to loop
  		this.time = 0;

  		this.timeScale = 1;
  		this._effectiveTimeScale = 1;

  		this.weight = 1;
  		this._effectiveWeight = 1;

  		this.repetitions = Infinity; // no. of repetitions when looping

  		this.paused = false; // true -> zero effective time scale
  		this.enabled = true; // false -> zero effective weight

  		this.clampWhenFinished = false;// keep feeding the last frame?

  		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
  		this.zeroSlopeAtEnd = true;// clips for start, loop and end

  	}

  	Object.assign( AnimationAction.prototype, {

  		// State & Scheduling

  		play: function () {

  			this._mixer._activateAction( this );

  			return this;

  		},

  		stop: function () {

  			this._mixer._deactivateAction( this );

  			return this.reset();

  		},

  		reset: function () {

  			this.paused = false;
  			this.enabled = true;

  			this.time = 0; // restart clip
  			this._loopCount = - 1;// forget previous loops
  			this._startTime = null;// forget scheduling

  			return this.stopFading().stopWarping();

  		},

  		isRunning: function () {

  			return this.enabled && ! this.paused && this.timeScale !== 0 &&
  				this._startTime === null && this._mixer._isActiveAction( this );

  		},

  		// return true when play has been called
  		isScheduled: function () {

  			return this._mixer._isActiveAction( this );

  		},

  		startAt: function ( time ) {

  			this._startTime = time;

  			return this;

  		},

  		setLoop: function ( mode, repetitions ) {

  			this.loop = mode;
  			this.repetitions = repetitions;

  			return this;

  		},

  		// Weight

  		// set the weight stopping any scheduled fading
  		// although .enabled = false yields an effective weight of zero, this
  		// method does *not* change .enabled, because it would be confusing
  		setEffectiveWeight: function ( weight ) {

  			this.weight = weight;

  			// note: same logic as when updated at runtime
  			this._effectiveWeight = this.enabled ? weight : 0;

  			return this.stopFading();

  		},

  		// return the weight considering fading and .enabled
  		getEffectiveWeight: function () {

  			return this._effectiveWeight;

  		},

  		fadeIn: function ( duration ) {

  			return this._scheduleFading( duration, 0, 1 );

  		},

  		fadeOut: function ( duration ) {

  			return this._scheduleFading( duration, 1, 0 );

  		},

  		crossFadeFrom: function ( fadeOutAction, duration, warp ) {

  			fadeOutAction.fadeOut( duration );
  			this.fadeIn( duration );

  			if ( warp ) {

  				var fadeInDuration = this._clip.duration,
  					fadeOutDuration = fadeOutAction._clip.duration,

  					startEndRatio = fadeOutDuration / fadeInDuration,
  					endStartRatio = fadeInDuration / fadeOutDuration;

  				fadeOutAction.warp( 1.0, startEndRatio, duration );
  				this.warp( endStartRatio, 1.0, duration );

  			}

  			return this;

  		},

  		crossFadeTo: function ( fadeInAction, duration, warp ) {

  			return fadeInAction.crossFadeFrom( this, duration, warp );

  		},

  		stopFading: function () {

  			var weightInterpolant = this._weightInterpolant;

  			if ( weightInterpolant !== null ) {

  				this._weightInterpolant = null;
  				this._mixer._takeBackControlInterpolant( weightInterpolant );

  			}

  			return this;

  		},

  		// Time Scale Control

  		// set the time scale stopping any scheduled warping
  		// although .paused = true yields an effective time scale of zero, this
  		// method does *not* change .paused, because it would be confusing
  		setEffectiveTimeScale: function ( timeScale ) {

  			this.timeScale = timeScale;
  			this._effectiveTimeScale = this.paused ? 0 : timeScale;

  			return this.stopWarping();

  		},

  		// return the time scale considering warping and .paused
  		getEffectiveTimeScale: function () {

  			return this._effectiveTimeScale;

  		},

  		setDuration: function ( duration ) {

  			this.timeScale = this._clip.duration / duration;

  			return this.stopWarping();

  		},

  		syncWith: function ( action ) {

  			this.time = action.time;
  			this.timeScale = action.timeScale;

  			return this.stopWarping();

  		},

  		halt: function ( duration ) {

  			return this.warp( this._effectiveTimeScale, 0, duration );

  		},

  		warp: function ( startTimeScale, endTimeScale, duration ) {

  			var mixer = this._mixer, now = mixer.time,
  				interpolant = this._timeScaleInterpolant,

  				timeScale = this.timeScale;

  			if ( interpolant === null ) {

  				interpolant = mixer._lendControlInterpolant();
  				this._timeScaleInterpolant = interpolant;

  			}

  			var times = interpolant.parameterPositions,
  				values = interpolant.sampleValues;

  			times[ 0 ] = now;
  			times[ 1 ] = now + duration;

  			values[ 0 ] = startTimeScale / timeScale;
  			values[ 1 ] = endTimeScale / timeScale;

  			return this;

  		},

  		stopWarping: function () {

  			var timeScaleInterpolant = this._timeScaleInterpolant;

  			if ( timeScaleInterpolant !== null ) {

  				this._timeScaleInterpolant = null;
  				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

  			}

  			return this;

  		},

  		// Object Accessors

  		getMixer: function () {

  			return this._mixer;

  		},

  		getClip: function () {

  			return this._clip;

  		},

  		getRoot: function () {

  			return this._localRoot || this._mixer._root;

  		},

  		// Interna

  		_update: function ( time, deltaTime, timeDirection, accuIndex ) {

  			// called by the mixer

  			if ( ! this.enabled ) {

  				// call ._updateWeight() to update ._effectiveWeight

  				this._updateWeight( time );
  				return;

  			}

  			var startTime = this._startTime;

  			if ( startTime !== null ) {

  				// check for scheduled start of action

  				var timeRunning = ( time - startTime ) * timeDirection;
  				if ( timeRunning < 0 || timeDirection === 0 ) {

  					return; // yet to come / don't decide when delta = 0

  				}

  				// start

  				this._startTime = null; // unschedule
  				deltaTime = timeDirection * timeRunning;

  			}

  			// apply time scale and advance time

  			deltaTime *= this._updateTimeScale( time );
  			var clipTime = this._updateTime( deltaTime );

  			// note: _updateTime may disable the action resulting in
  			// an effective weight of 0

  			var weight = this._updateWeight( time );

  			if ( weight > 0 ) {

  				var interpolants = this._interpolants;
  				var propertyMixers = this._propertyBindings;

  				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

  					interpolants[ j ].evaluate( clipTime );
  					propertyMixers[ j ].accumulate( accuIndex, weight );

  				}

  			}

  		},

  		_updateWeight: function ( time ) {

  			var weight = 0;

  			if ( this.enabled ) {

  				weight = this.weight;
  				var interpolant = this._weightInterpolant;

  				if ( interpolant !== null ) {

  					var interpolantValue = interpolant.evaluate( time )[ 0 ];

  					weight *= interpolantValue;

  					if ( time > interpolant.parameterPositions[ 1 ] ) {

  						this.stopFading();

  						if ( interpolantValue === 0 ) {

  							// faded out, disable
  							this.enabled = false;

  						}

  					}

  				}

  			}

  			this._effectiveWeight = weight;
  			return weight;

  		},

  		_updateTimeScale: function ( time ) {

  			var timeScale = 0;

  			if ( ! this.paused ) {

  				timeScale = this.timeScale;

  				var interpolant = this._timeScaleInterpolant;

  				if ( interpolant !== null ) {

  					var interpolantValue = interpolant.evaluate( time )[ 0 ];

  					timeScale *= interpolantValue;

  					if ( time > interpolant.parameterPositions[ 1 ] ) {

  						this.stopWarping();

  						if ( timeScale === 0 ) {

  							// motion has halted, pause
  							this.paused = true;

  						} else {

  							// warp done - apply final time scale
  							this.timeScale = timeScale;

  						}

  					}

  				}

  			}

  			this._effectiveTimeScale = timeScale;
  			return timeScale;

  		},

  		_updateTime: function ( deltaTime ) {

  			var time = this.time + deltaTime;
  			var duration = this._clip.duration;
  			var loop = this.loop;
  			var loopCount = this._loopCount;

  			var pingPong = ( loop === LoopPingPong );

  			if ( deltaTime === 0 ) {

  				if ( loopCount === - 1 ) return time;

  				return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

  			}

  			if ( loop === LoopOnce ) {

  				if ( loopCount === - 1 ) {

  					// just started

  					this._loopCount = 0;
  					this._setEndings( true, true, false );

  				}

  				handle_stop: {

  					if ( time >= duration ) {

  						time = duration;

  					} else if ( time < 0 ) {

  						time = 0;

  					} else break handle_stop;

  					if ( this.clampWhenFinished ) this.paused = true;
  					else this.enabled = false;

  					this._mixer.dispatchEvent( {
  						type: 'finished', action: this,
  						direction: deltaTime < 0 ? - 1 : 1
  					} );

  				}

  			} else { // repetitive Repeat or PingPong

  				if ( loopCount === - 1 ) {

  					// just started

  					if ( deltaTime >= 0 ) {

  						loopCount = 0;

  						this._setEndings( true, this.repetitions === 0, pingPong );

  					} else {

  						// when looping in reverse direction, the initial
  						// transition through zero counts as a repetition,
  						// so leave loopCount at -1

  						this._setEndings( this.repetitions === 0, true, pingPong );

  					}

  				}

  				if ( time >= duration || time < 0 ) {

  					// wrap around

  					var loopDelta = Math.floor( time / duration ); // signed
  					time -= duration * loopDelta;

  					loopCount += Math.abs( loopDelta );

  					var pending = this.repetitions - loopCount;

  					if ( pending <= 0 ) {

  						// have to stop (switch state, clamp time, fire event)

  						if ( this.clampWhenFinished ) this.paused = true;
  						else this.enabled = false;

  						time = deltaTime > 0 ? duration : 0;

  						this._mixer.dispatchEvent( {
  							type: 'finished', action: this,
  							direction: deltaTime > 0 ? 1 : - 1
  						} );

  					} else {

  						// keep running

  						if ( pending === 1 ) {

  							// entering the last round

  							var atStart = deltaTime < 0;
  							this._setEndings( atStart, ! atStart, pingPong );

  						} else {

  							this._setEndings( false, false, pingPong );

  						}

  						this._loopCount = loopCount;

  						this._mixer.dispatchEvent( {
  							type: 'loop', action: this, loopDelta: loopDelta
  						} );

  					}

  				}

  				if ( pingPong && ( loopCount & 1 ) === 1 ) {

  					// invert time for the "pong round"

  					this.time = time;
  					return duration - time;

  				}

  			}

  			this.time = time;
  			return time;

  		},

  		_setEndings: function ( atStart, atEnd, pingPong ) {

  			var settings = this._interpolantSettings;

  			if ( pingPong ) {

  				settings.endingStart = ZeroSlopeEnding;
  				settings.endingEnd = ZeroSlopeEnding;

  			} else {

  				// assuming for LoopOnce atStart == atEnd == true

  				if ( atStart ) {

  					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

  				} else {

  					settings.endingStart = WrapAroundEnding;

  				}

  				if ( atEnd ) {

  					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

  				} else {

  					settings.endingEnd 	 = WrapAroundEnding;

  				}

  			}

  		},

  		_scheduleFading: function ( duration, weightNow, weightThen ) {

  			var mixer = this._mixer, now = mixer.time,
  				interpolant = this._weightInterpolant;

  			if ( interpolant === null ) {

  				interpolant = mixer._lendControlInterpolant();
  				this._weightInterpolant = interpolant;

  			}

  			var times = interpolant.parameterPositions,
  				values = interpolant.sampleValues;

  			times[ 0 ] = now;
  			values[ 0 ] = weightNow;
  			times[ 1 ] = now + duration;
  			values[ 1 ] = weightThen;

  			return this;

  		}

  	} );

  	/**
  	 *
  	 * Player for AnimationClips.
  	 *
  	 *
  	 * @author Ben Houston / http://clara.io/
  	 * @author David Sarno / http://lighthaus.us/
  	 * @author tschw
  	 */

  	function AnimationMixer( root ) {

  		this._root = root;
  		this._initMemoryManager();
  		this._accuIndex = 0;

  		this.time = 0;

  		this.timeScale = 1.0;

  	}

  	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

  		constructor: AnimationMixer,

  		_bindAction: function ( action, prototypeAction ) {

  			var root = action._localRoot || this._root,
  				tracks = action._clip.tracks,
  				nTracks = tracks.length,
  				bindings = action._propertyBindings,
  				interpolants = action._interpolants,
  				rootUuid = root.uuid,
  				bindingsByRoot = this._bindingsByRootAndName,
  				bindingsByName = bindingsByRoot[ rootUuid ];

  			if ( bindingsByName === undefined ) {

  				bindingsByName = {};
  				bindingsByRoot[ rootUuid ] = bindingsByName;

  			}

  			for ( var i = 0; i !== nTracks; ++ i ) {

  				var track = tracks[ i ],
  					trackName = track.name,
  					binding = bindingsByName[ trackName ];

  				if ( binding !== undefined ) {

  					bindings[ i ] = binding;

  				} else {

  					binding = bindings[ i ];

  					if ( binding !== undefined ) {

  						// existing binding, make sure the cache knows

  						if ( binding._cacheIndex === null ) {

  							++ binding.referenceCount;
  							this._addInactiveBinding( binding, rootUuid, trackName );

  						}

  						continue;

  					}

  					var path = prototypeAction && prototypeAction.
  						_propertyBindings[ i ].binding.parsedPath;

  					binding = new PropertyMixer(
  						PropertyBinding.create( root, trackName, path ),
  						track.ValueTypeName, track.getValueSize() );

  					++ binding.referenceCount;
  					this._addInactiveBinding( binding, rootUuid, trackName );

  					bindings[ i ] = binding;

  				}

  				interpolants[ i ].resultBuffer = binding.buffer;

  			}

  		},

  		_activateAction: function ( action ) {

  			if ( ! this._isActiveAction( action ) ) {

  				if ( action._cacheIndex === null ) {

  					// this action has been forgotten by the cache, but the user
  					// appears to be still using it -> rebind

  					var rootUuid = ( action._localRoot || this._root ).uuid,
  						clipUuid = action._clip.uuid,
  						actionsForClip = this._actionsByClip[ clipUuid ];

  					this._bindAction( action,
  						actionsForClip && actionsForClip.knownActions[ 0 ] );

  					this._addInactiveAction( action, clipUuid, rootUuid );

  				}

  				var bindings = action._propertyBindings;

  				// increment reference counts / sort out state
  				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  					var binding = bindings[ i ];

  					if ( binding.useCount ++ === 0 ) {

  						this._lendBinding( binding );
  						binding.saveOriginalState();

  					}

  				}

  				this._lendAction( action );

  			}

  		},

  		_deactivateAction: function ( action ) {

  			if ( this._isActiveAction( action ) ) {

  				var bindings = action._propertyBindings;

  				// decrement reference counts / sort out state
  				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  					var binding = bindings[ i ];

  					if ( -- binding.useCount === 0 ) {

  						binding.restoreOriginalState();
  						this._takeBackBinding( binding );

  					}

  				}

  				this._takeBackAction( action );

  			}

  		},

  		// Memory manager

  		_initMemoryManager: function () {

  			this._actions = []; // 'nActiveActions' followed by inactive ones
  			this._nActiveActions = 0;

  			this._actionsByClip = {};
  			// inside:
  			// {
  			// 	knownActions: Array< AnimationAction > - used as prototypes
  			// 	actionByRoot: AnimationAction - lookup
  			// }


  			this._bindings = []; // 'nActiveBindings' followed by inactive ones
  			this._nActiveBindings = 0;

  			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


  			this._controlInterpolants = []; // same game as above
  			this._nActiveControlInterpolants = 0;

  			var scope = this;

  			this.stats = {

  				actions: {
  					get total() {

  						return scope._actions.length;

  					},
  					get inUse() {

  						return scope._nActiveActions;

  					}
  				},
  				bindings: {
  					get total() {

  						return scope._bindings.length;

  					},
  					get inUse() {

  						return scope._nActiveBindings;

  					}
  				},
  				controlInterpolants: {
  					get total() {

  						return scope._controlInterpolants.length;

  					},
  					get inUse() {

  						return scope._nActiveControlInterpolants;

  					}
  				}

  			};

  		},

  		// Memory management for AnimationAction objects

  		_isActiveAction: function ( action ) {

  			var index = action._cacheIndex;
  			return index !== null && index < this._nActiveActions;

  		},

  		_addInactiveAction: function ( action, clipUuid, rootUuid ) {

  			var actions = this._actions,
  				actionsByClip = this._actionsByClip,
  				actionsForClip = actionsByClip[ clipUuid ];

  			if ( actionsForClip === undefined ) {

  				actionsForClip = {

  					knownActions: [ action ],
  					actionByRoot: {}

  				};

  				action._byClipCacheIndex = 0;

  				actionsByClip[ clipUuid ] = actionsForClip;

  			} else {

  				var knownActions = actionsForClip.knownActions;

  				action._byClipCacheIndex = knownActions.length;
  				knownActions.push( action );

  			}

  			action._cacheIndex = actions.length;
  			actions.push( action );

  			actionsForClip.actionByRoot[ rootUuid ] = action;

  		},

  		_removeInactiveAction: function ( action ) {

  			var actions = this._actions,
  				lastInactiveAction = actions[ actions.length - 1 ],
  				cacheIndex = action._cacheIndex;

  			lastInactiveAction._cacheIndex = cacheIndex;
  			actions[ cacheIndex ] = lastInactiveAction;
  			actions.pop();

  			action._cacheIndex = null;


  			var clipUuid = action._clip.uuid,
  				actionsByClip = this._actionsByClip,
  				actionsForClip = actionsByClip[ clipUuid ],
  				knownActionsForClip = actionsForClip.knownActions,

  				lastKnownAction =
  					knownActionsForClip[ knownActionsForClip.length - 1 ],

  				byClipCacheIndex = action._byClipCacheIndex;

  			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
  			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
  			knownActionsForClip.pop();

  			action._byClipCacheIndex = null;


  			var actionByRoot = actionsForClip.actionByRoot,
  				rootUuid = ( action._localRoot || this._root ).uuid;

  			delete actionByRoot[ rootUuid ];

  			if ( knownActionsForClip.length === 0 ) {

  				delete actionsByClip[ clipUuid ];

  			}

  			this._removeInactiveBindingsForAction( action );

  		},

  		_removeInactiveBindingsForAction: function ( action ) {

  			var bindings = action._propertyBindings;
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( -- binding.referenceCount === 0 ) {

  					this._removeInactiveBinding( binding );

  				}

  			}

  		},

  		_lendAction: function ( action ) {

  			// [ active actions |  inactive actions  ]
  			// [  active actions >| inactive actions ]
  			//                 s        a
  			//                  <-swap->
  			//                 a        s

  			var actions = this._actions,
  				prevIndex = action._cacheIndex,

  				lastActiveIndex = this._nActiveActions ++,

  				firstInactiveAction = actions[ lastActiveIndex ];

  			action._cacheIndex = lastActiveIndex;
  			actions[ lastActiveIndex ] = action;

  			firstInactiveAction._cacheIndex = prevIndex;
  			actions[ prevIndex ] = firstInactiveAction;

  		},

  		_takeBackAction: function ( action ) {

  			// [  active actions  | inactive actions ]
  			// [ active actions |< inactive actions  ]
  			//        a        s
  			//         <-swap->
  			//        s        a

  			var actions = this._actions,
  				prevIndex = action._cacheIndex,

  				firstInactiveIndex = -- this._nActiveActions,

  				lastActiveAction = actions[ firstInactiveIndex ];

  			action._cacheIndex = firstInactiveIndex;
  			actions[ firstInactiveIndex ] = action;

  			lastActiveAction._cacheIndex = prevIndex;
  			actions[ prevIndex ] = lastActiveAction;

  		},

  		// Memory management for PropertyMixer objects

  		_addInactiveBinding: function ( binding, rootUuid, trackName ) {

  			var bindingsByRoot = this._bindingsByRootAndName,
  				bindingByName = bindingsByRoot[ rootUuid ],

  				bindings = this._bindings;

  			if ( bindingByName === undefined ) {

  				bindingByName = {};
  				bindingsByRoot[ rootUuid ] = bindingByName;

  			}

  			bindingByName[ trackName ] = binding;

  			binding._cacheIndex = bindings.length;
  			bindings.push( binding );

  		},

  		_removeInactiveBinding: function ( binding ) {

  			var bindings = this._bindings,
  				propBinding = binding.binding,
  				rootUuid = propBinding.rootNode.uuid,
  				trackName = propBinding.path,
  				bindingsByRoot = this._bindingsByRootAndName,
  				bindingByName = bindingsByRoot[ rootUuid ],

  				lastInactiveBinding = bindings[ bindings.length - 1 ],
  				cacheIndex = binding._cacheIndex;

  			lastInactiveBinding._cacheIndex = cacheIndex;
  			bindings[ cacheIndex ] = lastInactiveBinding;
  			bindings.pop();

  			delete bindingByName[ trackName ];

  			remove_empty_map: {

  				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars

  				delete bindingsByRoot[ rootUuid ];

  			}

  		},

  		_lendBinding: function ( binding ) {

  			var bindings = this._bindings,
  				prevIndex = binding._cacheIndex,

  				lastActiveIndex = this._nActiveBindings ++,

  				firstInactiveBinding = bindings[ lastActiveIndex ];

  			binding._cacheIndex = lastActiveIndex;
  			bindings[ lastActiveIndex ] = binding;

  			firstInactiveBinding._cacheIndex = prevIndex;
  			bindings[ prevIndex ] = firstInactiveBinding;

  		},

  		_takeBackBinding: function ( binding ) {

  			var bindings = this._bindings,
  				prevIndex = binding._cacheIndex,

  				firstInactiveIndex = -- this._nActiveBindings,

  				lastActiveBinding = bindings[ firstInactiveIndex ];

  			binding._cacheIndex = firstInactiveIndex;
  			bindings[ firstInactiveIndex ] = binding;

  			lastActiveBinding._cacheIndex = prevIndex;
  			bindings[ prevIndex ] = lastActiveBinding;

  		},


  		// Memory management of Interpolants for weight and time scale

  		_lendControlInterpolant: function () {

  			var interpolants = this._controlInterpolants,
  				lastActiveIndex = this._nActiveControlInterpolants ++,
  				interpolant = interpolants[ lastActiveIndex ];

  			if ( interpolant === undefined ) {

  				interpolant = new LinearInterpolant(
  					new Float32Array( 2 ), new Float32Array( 2 ),
  					1, this._controlInterpolantsResultBuffer );

  				interpolant.__cacheIndex = lastActiveIndex;
  				interpolants[ lastActiveIndex ] = interpolant;

  			}

  			return interpolant;

  		},

  		_takeBackControlInterpolant: function ( interpolant ) {

  			var interpolants = this._controlInterpolants,
  				prevIndex = interpolant.__cacheIndex,

  				firstInactiveIndex = -- this._nActiveControlInterpolants,

  				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

  			interpolant.__cacheIndex = firstInactiveIndex;
  			interpolants[ firstInactiveIndex ] = interpolant;

  			lastActiveInterpolant.__cacheIndex = prevIndex;
  			interpolants[ prevIndex ] = lastActiveInterpolant;

  		},

  		_controlInterpolantsResultBuffer: new Float32Array( 1 ),

  		// return an action for a clip optionally using a custom root target
  		// object (this method allocates a lot of dynamic memory in case a
  		// previously unknown clip/root combination is specified)
  		clipAction: function ( clip, optionalRoot ) {

  			var root = optionalRoot || this._root,
  				rootUuid = root.uuid,

  				clipObject = typeof clip === 'string' ?
  					AnimationClip.findByName( root, clip ) : clip,

  				clipUuid = clipObject !== null ? clipObject.uuid : clip,

  				actionsForClip = this._actionsByClip[ clipUuid ],
  				prototypeAction = null;

  			if ( actionsForClip !== undefined ) {

  				var existingAction =
  						actionsForClip.actionByRoot[ rootUuid ];

  				if ( existingAction !== undefined ) {

  					return existingAction;

  				}

  				// we know the clip, so we don't have to parse all
  				// the bindings again but can just copy
  				prototypeAction = actionsForClip.knownActions[ 0 ];

  				// also, take the clip from the prototype action
  				if ( clipObject === null )
  					clipObject = prototypeAction._clip;

  			}

  			// clip must be known when specified via string
  			if ( clipObject === null ) return null;

  			// allocate all resources required to run it
  			var newAction = new AnimationAction( this, clipObject, optionalRoot );

  			this._bindAction( newAction, prototypeAction );

  			// and make the action known to the memory manager
  			this._addInactiveAction( newAction, clipUuid, rootUuid );

  			return newAction;

  		},

  		// get an existing action
  		existingAction: function ( clip, optionalRoot ) {

  			var root = optionalRoot || this._root,
  				rootUuid = root.uuid,

  				clipObject = typeof clip === 'string' ?
  					AnimationClip.findByName( root, clip ) : clip,

  				clipUuid = clipObject ? clipObject.uuid : clip,

  				actionsForClip = this._actionsByClip[ clipUuid ];

  			if ( actionsForClip !== undefined ) {

  				return actionsForClip.actionByRoot[ rootUuid ] || null;

  			}

  			return null;

  		},

  		// deactivates all previously scheduled actions
  		stopAllAction: function () {

  			var actions = this._actions,
  				nActions = this._nActiveActions,
  				bindings = this._bindings,
  				nBindings = this._nActiveBindings;

  			this._nActiveActions = 0;
  			this._nActiveBindings = 0;

  			for ( var i = 0; i !== nActions; ++ i ) {

  				actions[ i ].reset();

  			}

  			for ( var i = 0; i !== nBindings; ++ i ) {

  				bindings[ i ].useCount = 0;

  			}

  			return this;

  		},

  		// advance the time and update apply the animation
  		update: function ( deltaTime ) {

  			deltaTime *= this.timeScale;

  			var actions = this._actions,
  				nActions = this._nActiveActions,

  				time = this.time += deltaTime,
  				timeDirection = Math.sign( deltaTime ),

  				accuIndex = this._accuIndex ^= 1;

  			// run active actions

  			for ( var i = 0; i !== nActions; ++ i ) {

  				var action = actions[ i ];

  				action._update( time, deltaTime, timeDirection, accuIndex );

  			}

  			// update scene graph

  			var bindings = this._bindings,
  				nBindings = this._nActiveBindings;

  			for ( var i = 0; i !== nBindings; ++ i ) {

  				bindings[ i ].apply( accuIndex );

  			}

  			return this;

  		},

  		// return this mixer's root target object
  		getRoot: function () {

  			return this._root;

  		},

  		// free all resources specific to a particular clip
  		uncacheClip: function ( clip ) {

  			var actions = this._actions,
  				clipUuid = clip.uuid,
  				actionsByClip = this._actionsByClip,
  				actionsForClip = actionsByClip[ clipUuid ];

  			if ( actionsForClip !== undefined ) {

  				// note: just calling _removeInactiveAction would mess up the
  				// iteration state and also require updating the state we can
  				// just throw away

  				var actionsToRemove = actionsForClip.knownActions;

  				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

  					var action = actionsToRemove[ i ];

  					this._deactivateAction( action );

  					var cacheIndex = action._cacheIndex,
  						lastInactiveAction = actions[ actions.length - 1 ];

  					action._cacheIndex = null;
  					action._byClipCacheIndex = null;

  					lastInactiveAction._cacheIndex = cacheIndex;
  					actions[ cacheIndex ] = lastInactiveAction;
  					actions.pop();

  					this._removeInactiveBindingsForAction( action );

  				}

  				delete actionsByClip[ clipUuid ];

  			}

  		},

  		// free all resources specific to a particular root target object
  		uncacheRoot: function ( root ) {

  			var rootUuid = root.uuid,
  				actionsByClip = this._actionsByClip;

  			for ( var clipUuid in actionsByClip ) {

  				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
  					action = actionByRoot[ rootUuid ];

  				if ( action !== undefined ) {

  					this._deactivateAction( action );
  					this._removeInactiveAction( action );

  				}

  			}

  			var bindingsByRoot = this._bindingsByRootAndName,
  				bindingByName = bindingsByRoot[ rootUuid ];

  			if ( bindingByName !== undefined ) {

  				for ( var trackName in bindingByName ) {

  					var binding = bindingByName[ trackName ];
  					binding.restoreOriginalState();
  					this._removeInactiveBinding( binding );

  				}

  			}

  		},

  		// remove a targeted clip from the cache
  		uncacheAction: function ( clip, optionalRoot ) {

  			var action = this.existingAction( clip, optionalRoot );

  			if ( action !== null ) {

  				this._deactivateAction( action );
  				this._removeInactiveAction( action );

  			}

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function Uniform( value ) {

  		if ( typeof value === 'string' ) {

  			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
  			value = arguments[ 1 ];

  		}

  		this.value = value;

  	}

  	Uniform.prototype.clone = function () {

  		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

  	};

  	/**
  	 * @author benaadams / https://twitter.com/ben_a_adams
  	 */

  	function InstancedBufferGeometry() {

  		BufferGeometry.call( this );

  		this.type = 'InstancedBufferGeometry';
  		this.maxInstancedCount = undefined;

  	}

  	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

  		constructor: InstancedBufferGeometry,

  		isInstancedBufferGeometry: true,

  		copy: function ( source ) {

  			BufferGeometry.prototype.copy.call( this, source );

  			this.maxInstancedCount = source.maxInstancedCount;

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		}

  	} );

  	/**
  	 * @author benaadams / https://twitter.com/ben_a_adams
  	 */

  	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

  		InterleavedBuffer.call( this, array, stride );

  		this.meshPerAttribute = meshPerAttribute || 1;

  	}

  	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

  		constructor: InstancedInterleavedBuffer,

  		isInstancedInterleavedBuffer: true,

  		copy: function ( source ) {

  			InterleavedBuffer.prototype.copy.call( this, source );

  			this.meshPerAttribute = source.meshPerAttribute;

  			return this;

  		}

  	} );

  	/**
  	 * @author benaadams / https://twitter.com/ben_a_adams
  	 */

  	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

  		if ( typeof ( normalized ) === 'number' ) {

  			meshPerAttribute = normalized;

  			normalized = false;

  			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

  		}

  		BufferAttribute.call( this, array, itemSize, normalized );

  		this.meshPerAttribute = meshPerAttribute || 1;

  	}

  	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

  		constructor: InstancedBufferAttribute,

  		isInstancedBufferAttribute: true,

  		copy: function ( source ) {

  			BufferAttribute.prototype.copy.call( this, source );

  			this.meshPerAttribute = source.meshPerAttribute;

  			return this;

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author bhouston / http://clara.io/
  	 * @author stephomi / http://stephaneginier.com/
  	 */

  	function Raycaster( origin, direction, near, far ) {

  		this.ray = new Ray( origin, direction );
  		// direction is assumed to be normalized (for accurate distance calculations)

  		this.near = near || 0;
  		this.far = far || Infinity;

  		this.params = {
  			Mesh: {},
  			Line: {},
  			LOD: {},
  			Points: { threshold: 1 },
  			Sprite: {}
  		};

  		Object.defineProperties( this.params, {
  			PointCloud: {
  				get: function () {

  					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
  					return this.Points;

  				}
  			}
  		} );

  	}

  	function ascSort( a, b ) {

  		return a.distance - b.distance;

  	}

  	function intersectObject( object, raycaster, intersects, recursive ) {

  		if ( object.visible === false ) return;

  		object.raycast( raycaster, intersects );

  		if ( recursive === true ) {

  			var children = object.children;

  			for ( var i = 0, l = children.length; i < l; i ++ ) {

  				intersectObject( children[ i ], raycaster, intersects, true );

  			}

  		}

  	}

  	Object.assign( Raycaster.prototype, {

  		linePrecision: 1,

  		set: function ( origin, direction ) {

  			// direction is assumed to be normalized (for accurate distance calculations)

  			this.ray.set( origin, direction );

  		},

  		setFromCamera: function ( coords, camera ) {

  			if ( ( camera && camera.isPerspectiveCamera ) ) {

  				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
  				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

  			} else if ( ( camera && camera.isOrthographicCamera ) ) {

  				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
  				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

  			} else {

  				console.error( 'THREE.Raycaster: Unsupported camera type.' );

  			}

  		},

  		intersectObject: function ( object, recursive, optionalTarget ) {

  			var intersects = optionalTarget || [];

  			intersectObject( object, this, intersects, recursive );

  			intersects.sort( ascSort );

  			return intersects;

  		},

  		intersectObjects: function ( objects, recursive, optionalTarget ) {

  			var intersects = optionalTarget || [];

  			if ( Array.isArray( objects ) === false ) {

  				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
  				return intersects;

  			}

  			for ( var i = 0, l = objects.length; i < l; i ++ ) {

  				intersectObject( objects[ i ], this, intersects, recursive );

  			}

  			intersects.sort( ascSort );

  			return intersects;

  		}

  	} );

  	/**
  	 * @author bhouston / http://clara.io
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
  	 *
  	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
  	 * The azimuthal angle (theta) is measured from the positive z-axiz.
  	 */

  	function Spherical( radius, phi, theta ) {

  		this.radius = ( radius !== undefined ) ? radius : 1.0;
  		this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
  		this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle

  		return this;

  	}

  	Object.assign( Spherical.prototype, {

  		set: function ( radius, phi, theta ) {

  			this.radius = radius;
  			this.phi = phi;
  			this.theta = theta;

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( other ) {

  			this.radius = other.radius;
  			this.phi = other.phi;
  			this.theta = other.theta;

  			return this;

  		},

  		// restrict phi to be betwee EPS and PI-EPS
  		makeSafe: function () {

  			var EPS = 0.000001;
  			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

  			return this;

  		},

  		setFromVector3: function ( v ) {

  			return this.setFromCartesianCoords( v.x, v.y, v.z );

  		},

  		setFromCartesianCoords: function ( x, y, z ) {

  			this.radius = Math.sqrt( x * x + y * y + z * z );

  			if ( this.radius === 0 ) {

  				this.theta = 0;
  				this.phi = 0;

  			} else {

  				this.theta = Math.atan2( x, z );
  				this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );

  			}

  			return this;

  		}

  	} );

  	/**
  	 * @author Mugen87 / https://github.com/Mugen87
  	 *
  	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
  	 *
  	 */

  	function Cylindrical( radius, theta, y ) {

  		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
  		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
  		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

  		return this;

  	}

  	Object.assign( Cylindrical.prototype, {

  		set: function ( radius, theta, y ) {

  			this.radius = radius;
  			this.theta = theta;
  			this.y = y;

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( other ) {

  			this.radius = other.radius;
  			this.theta = other.theta;
  			this.y = other.y;

  			return this;

  		},

  		setFromVector3: function ( v ) {

  			return this.setFromCartesianCoords( v.x, v.y, v.z );

  		},

  		setFromCartesianCoords: function ( x, y, z ) {

  			this.radius = Math.sqrt( x * x + z * z );
  			this.theta = Math.atan2( x, z );
  			this.y = y;

  			return this;

  		}

  	} );

  	/**
  	 * @author bhouston / http://clara.io
  	 */

  	function Box2( min, max ) {

  		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
  		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

  	}

  	Object.assign( Box2.prototype, {

  		set: function ( min, max ) {

  			this.min.copy( min );
  			this.max.copy( max );

  			return this;

  		},

  		setFromPoints: function ( points ) {

  			this.makeEmpty();

  			for ( var i = 0, il = points.length; i < il; i ++ ) {

  				this.expandByPoint( points[ i ] );

  			}

  			return this;

  		},

  		setFromCenterAndSize: function () {

  			var v1 = new Vector2();

  			return function setFromCenterAndSize( center, size ) {

  				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
  				this.min.copy( center ).sub( halfSize );
  				this.max.copy( center ).add( halfSize );

  				return this;

  			};

  		}(),

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( box ) {

  			this.min.copy( box.min );
  			this.max.copy( box.max );

  			return this;

  		},

  		makeEmpty: function () {

  			this.min.x = this.min.y = + Infinity;
  			this.max.x = this.max.y = - Infinity;

  			return this;

  		},

  		isEmpty: function () {

  			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  		},

  		getCenter: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Box2: .getCenter() target is now required' );
  				target = new Vector2();

  			}

  			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  		},

  		getSize: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Box2: .getSize() target is now required' );
  				target = new Vector2();

  			}

  			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

  		},

  		expandByPoint: function ( point ) {

  			this.min.min( point );
  			this.max.max( point );

  			return this;

  		},

  		expandByVector: function ( vector ) {

  			this.min.sub( vector );
  			this.max.add( vector );

  			return this;

  		},

  		expandByScalar: function ( scalar ) {

  			this.min.addScalar( - scalar );
  			this.max.addScalar( scalar );

  			return this;

  		},

  		containsPoint: function ( point ) {

  			return point.x < this.min.x || point.x > this.max.x ||
  				point.y < this.min.y || point.y > this.max.y ? false : true;

  		},

  		containsBox: function ( box ) {

  			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  				this.min.y <= box.min.y && box.max.y <= this.max.y;

  		},

  		getParameter: function ( point, target ) {

  			// This can potentially have a divide by zero if the box
  			// has a size dimension of 0.

  			if ( target === undefined ) {

  				console.warn( 'THREE.Box2: .getParameter() target is now required' );
  				target = new Vector2();

  			}

  			return target.set(
  				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  				( point.y - this.min.y ) / ( this.max.y - this.min.y )
  			);

  		},

  		intersectsBox: function ( box ) {

  			// using 4 splitting planes to rule out intersections

  			return box.max.x < this.min.x || box.min.x > this.max.x ||
  				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

  		},

  		clampPoint: function ( point, target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
  				target = new Vector2();

  			}

  			return target.copy( point ).clamp( this.min, this.max );

  		},

  		distanceToPoint: function () {

  			var v1 = new Vector2();

  			return function distanceToPoint( point ) {

  				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  				return clampedPoint.sub( point ).length();

  			};

  		}(),

  		intersect: function ( box ) {

  			this.min.max( box.min );
  			this.max.min( box.max );

  			return this;

  		},

  		union: function ( box ) {

  			this.min.min( box.min );
  			this.max.max( box.max );

  			return this;

  		},

  		translate: function ( offset ) {

  			this.min.add( offset );
  			this.max.add( offset );

  			return this;

  		},

  		equals: function ( box ) {

  			return box.min.equals( this.min ) && box.max.equals( this.max );

  		}

  	} );

  	/**
  	 * @author bhouston / http://clara.io
  	 */

  	function Line3( start, end ) {

  		this.start = ( start !== undefined ) ? start : new Vector3();
  		this.end = ( end !== undefined ) ? end : new Vector3();

  	}

  	Object.assign( Line3.prototype, {

  		set: function ( start, end ) {

  			this.start.copy( start );
  			this.end.copy( end );

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		},

  		copy: function ( line ) {

  			this.start.copy( line.start );
  			this.end.copy( line.end );

  			return this;

  		},

  		getCenter: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Line3: .getCenter() target is now required' );
  				target = new Vector3();

  			}

  			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  		},

  		delta: function ( target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Line3: .delta() target is now required' );
  				target = new Vector3();

  			}

  			return target.subVectors( this.end, this.start );

  		},

  		distanceSq: function () {

  			return this.start.distanceToSquared( this.end );

  		},

  		distance: function () {

  			return this.start.distanceTo( this.end );

  		},

  		at: function ( t, target ) {

  			if ( target === undefined ) {

  				console.warn( 'THREE.Line3: .at() target is now required' );
  				target = new Vector3();

  			}

  			return this.delta( target ).multiplyScalar( t ).add( this.start );

  		},

  		closestPointToPointParameter: function () {

  			var startP = new Vector3();
  			var startEnd = new Vector3();

  			return function closestPointToPointParameter( point, clampToLine ) {

  				startP.subVectors( point, this.start );
  				startEnd.subVectors( this.end, this.start );

  				var startEnd2 = startEnd.dot( startEnd );
  				var startEnd_startP = startEnd.dot( startP );

  				var t = startEnd_startP / startEnd2;

  				if ( clampToLine ) {

  					t = _Math.clamp( t, 0, 1 );

  				}

  				return t;

  			};

  		}(),

  		closestPointToPoint: function ( point, clampToLine, target ) {

  			var t = this.closestPointToPointParameter( point, clampToLine );

  			if ( target === undefined ) {

  				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
  				target = new Vector3();

  			}

  			return this.delta( target ).multiplyScalar( t ).add( this.start );

  		},

  		applyMatrix4: function ( matrix ) {

  			this.start.applyMatrix4( matrix );
  			this.end.applyMatrix4( matrix );

  			return this;

  		},

  		equals: function ( line ) {

  			return line.start.equals( this.start ) && line.end.equals( this.end );

  		}

  	} );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 */

  	function ImmediateRenderObject( material ) {

  		Object3D.call( this );

  		this.material = material;
  		this.render = function ( /* renderCallback */ ) {};

  	}

  	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
  	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

  	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function VertexNormalsHelper( object, size, hex, linewidth ) {

  		this.object = object;

  		this.size = ( size !== undefined ) ? size : 1;

  		var color = ( hex !== undefined ) ? hex : 0xff0000;

  		var width = ( linewidth !== undefined ) ? linewidth : 1;

  		//

  		var nNormals = 0;

  		var objGeometry = this.object.geometry;

  		if ( objGeometry && objGeometry.isGeometry ) {

  			nNormals = objGeometry.faces.length * 3;

  		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

  			nNormals = objGeometry.attributes.normal.count;

  		}

  		//

  		var geometry = new BufferGeometry();

  		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

  		geometry.addAttribute( 'position', positions );

  		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

  		//

  		this.matrixAutoUpdate = false;

  		this.update();

  	}

  	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
  	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

  	VertexNormalsHelper.prototype.update = ( function () {

  		var v1 = new Vector3();
  		var v2 = new Vector3();
  		var normalMatrix = new Matrix3();

  		return function update() {

  			var keys = [ 'a', 'b', 'c' ];

  			this.object.updateMatrixWorld( true );

  			normalMatrix.getNormalMatrix( this.object.matrixWorld );

  			var matrixWorld = this.object.matrixWorld;

  			var position = this.geometry.attributes.position;

  			//

  			var objGeometry = this.object.geometry;

  			if ( objGeometry && objGeometry.isGeometry ) {

  				var vertices = objGeometry.vertices;

  				var faces = objGeometry.faces;

  				var idx = 0;

  				for ( var i = 0, l = faces.length; i < l; i ++ ) {

  					var face = faces[ i ];

  					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  						var vertex = vertices[ face[ keys[ j ] ] ];

  						var normal = face.vertexNormals[ j ];

  						v1.copy( vertex ).applyMatrix4( matrixWorld );

  						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

  						position.setXYZ( idx, v1.x, v1.y, v1.z );

  						idx = idx + 1;

  						position.setXYZ( idx, v2.x, v2.y, v2.z );

  						idx = idx + 1;

  					}

  				}

  			} else if ( objGeometry && objGeometry.isBufferGeometry ) {

  				var objPos = objGeometry.attributes.position;

  				var objNorm = objGeometry.attributes.normal;

  				var idx = 0;

  				// for simplicity, ignore index and drawcalls, and render every normal

  				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

  					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

  					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

  					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

  					position.setXYZ( idx, v1.x, v1.y, v1.z );

  					idx = idx + 1;

  					position.setXYZ( idx, v2.x, v2.y, v2.z );

  					idx = idx + 1;

  				}

  			}

  			position.needsUpdate = true;

  		};

  	}() );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function SpotLightHelper( light, color ) {

  		Object3D.call( this );

  		this.light = light;
  		this.light.updateMatrixWorld();

  		this.matrix = light.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.color = color;

  		var geometry = new BufferGeometry();

  		var positions = [
  			0, 0, 0, 	0, 0, 1,
  			0, 0, 0, 	1, 0, 1,
  			0, 0, 0,	- 1, 0, 1,
  			0, 0, 0, 	0, 1, 1,
  			0, 0, 0, 	0, - 1, 1
  		];

  		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

  			var p1 = ( i / l ) * Math.PI * 2;
  			var p2 = ( j / l ) * Math.PI * 2;

  			positions.push(
  				Math.cos( p1 ), Math.sin( p1 ), 1,
  				Math.cos( p2 ), Math.sin( p2 ), 1
  			);

  		}

  		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  		var material = new LineBasicMaterial( { fog: false } );

  		this.cone = new LineSegments( geometry, material );
  		this.add( this.cone );

  		this.update();

  	}

  	SpotLightHelper.prototype = Object.create( Object3D.prototype );
  	SpotLightHelper.prototype.constructor = SpotLightHelper;

  	SpotLightHelper.prototype.dispose = function () {

  		this.cone.geometry.dispose();
  		this.cone.material.dispose();

  	};

  	SpotLightHelper.prototype.update = function () {

  		var vector = new Vector3();

  		return function update() {

  			this.light.updateMatrixWorld();

  			var coneLength = this.light.distance ? this.light.distance : 1000;
  			var coneWidth = coneLength * Math.tan( this.light.angle );

  			this.cone.scale.set( coneWidth, coneWidth, coneLength );

  			vector.setFromMatrixPosition( this.light.target.matrixWorld );

  			this.cone.lookAt( vector );

  			if ( this.color !== undefined ) {

  				this.cone.material.color.set( this.color );

  			} else {

  				this.cone.material.color.copy( this.light.color );

  			}

  		};

  	}();

  	/**
  	 * @author Sean Griffin / http://twitter.com/sgrif
  	 * @author Michael Guerrero / http://realitymeltdown.com
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author ikerr / http://verold.com
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	function getBoneList( object ) {

  		var boneList = [];

  		if ( object && object.isBone ) {

  			boneList.push( object );

  		}

  		for ( var i = 0; i < object.children.length; i ++ ) {

  			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

  		}

  		return boneList;

  	}

  	function SkeletonHelper( object ) {

  		var bones = getBoneList( object );

  		var geometry = new BufferGeometry();

  		var vertices = [];
  		var colors = [];

  		var color1 = new Color( 0, 0, 1 );
  		var color2 = new Color( 0, 1, 0 );

  		for ( var i = 0; i < bones.length; i ++ ) {

  			var bone = bones[ i ];

  			if ( bone.parent && bone.parent.isBone ) {

  				vertices.push( 0, 0, 0 );
  				vertices.push( 0, 0, 0 );
  				colors.push( color1.r, color1.g, color1.b );
  				colors.push( color2.r, color2.g, color2.b );

  			}

  		}

  		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

  		LineSegments.call( this, geometry, material );

  		this.root = object;
  		this.bones = bones;

  		this.matrix = object.matrixWorld;
  		this.matrixAutoUpdate = false;

  	}

  	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
  	SkeletonHelper.prototype.constructor = SkeletonHelper;

  	SkeletonHelper.prototype.updateMatrixWorld = function () {

  		var vector = new Vector3();

  		var boneMatrix = new Matrix4();
  		var matrixWorldInv = new Matrix4();

  		return function updateMatrixWorld( force ) {

  			var bones = this.bones;

  			var geometry = this.geometry;
  			var position = geometry.getAttribute( 'position' );

  			matrixWorldInv.getInverse( this.root.matrixWorld );

  			for ( var i = 0, j = 0; i < bones.length; i ++ ) {

  				var bone = bones[ i ];

  				if ( bone.parent && bone.parent.isBone ) {

  					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
  					vector.setFromMatrixPosition( boneMatrix );
  					position.setXYZ( j, vector.x, vector.y, vector.z );

  					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
  					vector.setFromMatrixPosition( boneMatrix );
  					position.setXYZ( j + 1, vector.x, vector.y, vector.z );

  					j += 2;

  				}

  			}

  			geometry.getAttribute( 'position' ).needsUpdate = true;

  			Object3D.prototype.updateMatrixWorld.call( this, force );

  		};

  	}();

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function PointLightHelper( light, sphereSize, color ) {

  		this.light = light;
  		this.light.updateMatrixWorld();

  		this.color = color;

  		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
  		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

  		Mesh.call( this, geometry, material );

  		this.matrix = this.light.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.update();


  		/*
  		var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
  		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  		var d = light.distance;

  		if ( d === 0.0 ) {

  			this.lightDistance.visible = false;

  		} else {

  			this.lightDistance.scale.set( d, d, d );

  		}

  		this.add( this.lightDistance );
  		*/

  	}

  	PointLightHelper.prototype = Object.create( Mesh.prototype );
  	PointLightHelper.prototype.constructor = PointLightHelper;

  	PointLightHelper.prototype.dispose = function () {

  		this.geometry.dispose();
  		this.material.dispose();

  	};

  	PointLightHelper.prototype.update = function () {

  		if ( this.color !== undefined ) {

  			this.material.color.set( this.color );

  		} else {

  			this.material.color.copy( this.light.color );

  		}

  		/*
  		var d = this.light.distance;

  		if ( d === 0.0 ) {

  			this.lightDistance.visible = false;

  		} else {

  			this.lightDistance.visible = true;
  			this.lightDistance.scale.set( d, d, d );

  		}
  		*/

  	};

  	/**
  	 * @author abelnation / http://github.com/abelnation
  	 * @author Mugen87 / http://github.com/Mugen87
  	 * @author WestLangley / http://github.com/WestLangley
  	 *
  	 *  This helper must be added as a child of the light
  	 */

  	function RectAreaLightHelper( light, color ) {

  		this.type = 'RectAreaLightHelper';

  		this.light = light;

  		this.color = color; // optional hardwired color for the helper

  		var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

  		var geometry = new BufferGeometry();
  		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
  		geometry.computeBoundingSphere();

  		var material = new LineBasicMaterial( { fog: false } );

  		Line.call( this, geometry, material );

  		//

  		var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

  		var geometry2 = new BufferGeometry();
  		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
  		geometry2.computeBoundingSphere();

  		this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );

  		this.update();

  	}

  	RectAreaLightHelper.prototype = Object.create( Line.prototype );
  	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

  	RectAreaLightHelper.prototype.update = function () {

  		this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );

  		if ( this.color !== undefined ) {

  			this.material.color.set( this.color );
  			this.children[ 0 ].material.color.set( this.color );

  		} else {

  			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  			// prevent hue shift
  			var c = this.material.color;
  			var max = Math.max( c.r, c.g, c.b );
  			if ( max > 1 ) c.multiplyScalar( 1 / max );

  			this.children[ 0 ].material.color.copy( this.material.color );

  		}

  	};

  	RectAreaLightHelper.prototype.dispose = function () {

  		this.geometry.dispose();
  		this.material.dispose();
  		this.children[ 0 ].geometry.dispose();
  		this.children[ 0 ].material.dispose();

  	};

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Mugen87 / https://github.com/Mugen87
  	 */

  	function HemisphereLightHelper( light, size, color ) {

  		Object3D.call( this );

  		this.light = light;
  		this.light.updateMatrixWorld();

  		this.matrix = light.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.color = color;

  		var geometry = new OctahedronBufferGeometry( size );
  		geometry.rotateY( Math.PI * 0.5 );

  		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
  		if ( this.color === undefined ) this.material.vertexColors = VertexColors;

  		var position = geometry.getAttribute( 'position' );
  		var colors = new Float32Array( position.count * 3 );

  		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

  		this.add( new Mesh( geometry, this.material ) );

  		this.update();

  	}

  	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
  	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

  	HemisphereLightHelper.prototype.dispose = function () {

  		this.children[ 0 ].geometry.dispose();
  		this.children[ 0 ].material.dispose();

  	};

  	HemisphereLightHelper.prototype.update = function () {

  		var vector = new Vector3();

  		var color1 = new Color();
  		var color2 = new Color();

  		return function update() {

  			var mesh = this.children[ 0 ];

  			if ( this.color !== undefined ) {

  				this.material.color.set( this.color );

  			} else {

  				var colors = mesh.geometry.getAttribute( 'color' );

  				color1.copy( this.light.color );
  				color2.copy( this.light.groundColor );

  				for ( var i = 0, l = colors.count; i < l; i ++ ) {

  					var color = ( i < ( l / 2 ) ) ? color1 : color2;

  					colors.setXYZ( i, color.r, color.g, color.b );

  				}

  				colors.needsUpdate = true;

  			}

  			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

  		};

  	}();

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function LightProbeHelper( lightProbe, size ) {

  		this.lightProbe = lightProbe;

  		this.size = size;

  		var defines = {};
  		defines[ 'GAMMA_OUTPUT' ] = "";

  		// material
  		var material = new ShaderMaterial( {

  			defines: defines,

  			uniforms: {

  				sh: { value: this.lightProbe.sh.coefficients }, // by reference

  				intensity: { value: this.lightProbe.intensity }

  			},

  			vertexShader: [

  				'varying vec3 vNormal;',

  				'void main() {',

  				'	vNormal = normalize( normalMatrix * normal );',

  				'	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

  				'}',

  			].join( '\n' ),

  			fragmentShader: [

  				'#define RECIPROCAL_PI 0.318309886',

  				'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {',

  				'	// matrix is assumed to be orthogonal',

  				'	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );',

  				'}',

  				'vec3 linearToOutput( in vec3 a ) {',

  				'	#ifdef GAMMA_OUTPUT',

  				'		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );',

  				'	#else',

  				'		return a;',

  				'	#endif',

  				'}',

  				'// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf',
  				'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {',

  				'	// normal is assumed to have unit length',

  				'	float x = normal.x, y = normal.y, z = normal.z;',

  				'	// band 0',
  				'	vec3 result = shCoefficients[ 0 ] * 0.886227;',

  				'	// band 1',
  				'	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;',
  				'	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;',
  				'	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;',

  				'	// band 2',
  				'	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;',
  				'	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;',
  				'	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );',
  				'	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;',
  				'	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );',

  				'	return result;',

  				'}',

  				'uniform vec3 sh[ 9 ]; // sh coefficients',

  				'uniform float intensity; // light probe intensity',

  				'varying vec3 vNormal;',

  				'void main() {',

  				'	vec3 normal = normalize( vNormal );',

  				'	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );',

  				'	vec3 irradiance = shGetIrradianceAt( worldNormal, sh );',

  				'	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;',

  				'	outgoingLight = linearToOutput( outgoingLight );',

  				'	gl_FragColor = vec4( outgoingLight, 1.0 );',

  				'}'

  			].join( '\n' )

  		} );

  		var geometry = new SphereBufferGeometry( 1, 32, 16 );

  		Mesh.call( this, geometry, material );

  		this.onBeforeRender();

  	}

  	LightProbeHelper.prototype = Object.create( Mesh.prototype );
  	LightProbeHelper.prototype.constructor = LightProbeHelper;

  	LightProbeHelper.prototype.dispose = function () {

  		this.geometry.dispose();
  		this.material.dispose();

  	};

  	LightProbeHelper.prototype.onBeforeRender = function () {

  		return function update() {

  			this.position.copy( this.lightProbe.position );

  			this.scale.set( 1, 1, 1 ).multiplyScalar( this.size );

  			this.material.uniforms.intensity.value = this.lightProbe.intensity;

  		};

  	}();

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function GridHelper( size, divisions, color1, color2 ) {

  		size = size || 10;
  		divisions = divisions || 10;
  		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
  		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

  		var center = divisions / 2;
  		var step = size / divisions;
  		var halfSize = size / 2;

  		var vertices = [], colors = [];

  		for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

  			vertices.push( - halfSize, 0, k, halfSize, 0, k );
  			vertices.push( k, 0, - halfSize, k, 0, halfSize );

  			var color = i === center ? color1 : color2;

  			color.toArray( colors, j ); j += 3;
  			color.toArray( colors, j ); j += 3;
  			color.toArray( colors, j ); j += 3;
  			color.toArray( colors, j ); j += 3;

  		}

  		var geometry = new BufferGeometry();
  		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

  		LineSegments.call( this, geometry, material );

  	}

  	GridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {

  		constructor: GridHelper,

  		copy: function ( source ) {

  			LineSegments.prototype.copy.call( this, source );

  			this.geometry.copy( source.geometry );
  			this.material.copy( source.material );

  			return this;

  		},

  		clone: function () {

  			return new this.constructor().copy( this );

  		}

  	} );

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Mugen87 / http://github.com/Mugen87
  	 * @author Hectate / http://www.github.com/Hectate
  	 */

  	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

  		radius = radius || 10;
  		radials = radials || 16;
  		circles = circles || 8;
  		divisions = divisions || 64;
  		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
  		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

  		var vertices = [];
  		var colors = [];

  		var x, z;
  		var v, i, j, r, color;

  		// create the radials

  		for ( i = 0; i <= radials; i ++ ) {

  			v = ( i / radials ) * ( Math.PI * 2 );

  			x = Math.sin( v ) * radius;
  			z = Math.cos( v ) * radius;

  			vertices.push( 0, 0, 0 );
  			vertices.push( x, 0, z );

  			color = ( i & 1 ) ? color1 : color2;

  			colors.push( color.r, color.g, color.b );
  			colors.push( color.r, color.g, color.b );

  		}

  		// create the circles

  		for ( i = 0; i <= circles; i ++ ) {

  			color = ( i & 1 ) ? color1 : color2;

  			r = radius - ( radius / circles * i );

  			for ( j = 0; j < divisions; j ++ ) {

  				// first vertex

  				v = ( j / divisions ) * ( Math.PI * 2 );

  				x = Math.sin( v ) * r;
  				z = Math.cos( v ) * r;

  				vertices.push( x, 0, z );
  				colors.push( color.r, color.g, color.b );

  				// second vertex

  				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

  				x = Math.sin( v ) * r;
  				z = Math.cos( v ) * r;

  				vertices.push( x, 0, z );
  				colors.push( color.r, color.g, color.b );

  			}

  		}

  		var geometry = new BufferGeometry();
  		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

  		LineSegments.call( this, geometry, material );

  	}

  	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
  	PolarGridHelper.prototype.constructor = PolarGridHelper;

  	/**
  	 * @author Mugen87 / http://github.com/Mugen87
  	 */

  	function PositionalAudioHelper( audio, range, divisionsInnerAngle, divisionsOuterAngle ) {

  		this.audio = audio;
  		this.range = range || 1;
  		this.divisionsInnerAngle = divisionsInnerAngle || 16;
  		this.divisionsOuterAngle = divisionsOuterAngle || 2;

  		var geometry = new BufferGeometry();
  		var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
  		var positions = new Float32Array( ( divisions * 3 + 3 ) * 3 );
  		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

  		var materialInnerAngle = new LineBasicMaterial( { color: 0x00ff00 } );
  		var materialOuterAngle = new LineBasicMaterial( { color: 0xffff00 } );

  		Line.call( this, geometry, [ materialOuterAngle, materialInnerAngle ] );

  		this.update();

  	}

  	PositionalAudioHelper.prototype = Object.create( Line.prototype );
  	PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;

  	PositionalAudioHelper.prototype.update = function () {

  		var audio = this.audio;
  		var range = this.range;
  		var divisionsInnerAngle = this.divisionsInnerAngle;
  		var divisionsOuterAngle = this.divisionsOuterAngle;

  		var coneInnerAngle = _Math.degToRad( audio.panner.coneInnerAngle );
  		var coneOuterAngle = _Math.degToRad( audio.panner.coneOuterAngle );

  		var halfConeInnerAngle = coneInnerAngle / 2;
  		var halfConeOuterAngle = coneOuterAngle / 2;

  		var start = 0;
  		var count = 0;
  		var i, stride;

  		var geometry = this.geometry;
  		var positionAttribute = geometry.attributes.position;

  		geometry.clearGroups();

  		//

  		function generateSegment( from, to, divisions, materialIndex ) {

  			var step = ( to - from ) / divisions;

  			positionAttribute.setXYZ( start, 0, 0, 0 );
  			count ++;

  			for ( i = from; i < to; i += step ) {

  				stride = start + count;

  				positionAttribute.setXYZ( stride, Math.sin( i ) * range, 0, Math.cos( i ) * range );
  				positionAttribute.setXYZ( stride + 1, Math.sin( Math.min( i + step, to ) ) * range, 0, Math.cos( Math.min( i + step, to ) ) * range );
  				positionAttribute.setXYZ( stride + 2, 0, 0, 0 );

  				count += 3;

  			}

  			geometry.addGroup( start, count, materialIndex );

  			start += count;
  			count = 0;

  		}

  		//

  		generateSegment( - halfConeOuterAngle, - halfConeInnerAngle, divisionsOuterAngle, 0 );
  		generateSegment( - halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1 );
  		generateSegment( halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0 );

  		//

  		positionAttribute.needsUpdate = true;

  		if ( coneInnerAngle === coneOuterAngle ) this.material[ 0 ].visible = false;

  	};

  	PositionalAudioHelper.prototype.dispose = function () {

  		this.geometry.dispose();
  		this.material[ 0 ].dispose();
  		this.material[ 1 ].dispose();

  	};

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function FaceNormalsHelper( object, size, hex, linewidth ) {

  		// FaceNormalsHelper only supports THREE.Geometry

  		this.object = object;

  		this.size = ( size !== undefined ) ? size : 1;

  		var color = ( hex !== undefined ) ? hex : 0xffff00;

  		var width = ( linewidth !== undefined ) ? linewidth : 1;

  		//

  		var nNormals = 0;

  		var objGeometry = this.object.geometry;

  		if ( objGeometry && objGeometry.isGeometry ) {

  			nNormals = objGeometry.faces.length;

  		} else {

  			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

  		}

  		//

  		var geometry = new BufferGeometry();

  		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

  		geometry.addAttribute( 'position', positions );

  		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

  		//

  		this.matrixAutoUpdate = false;
  		this.update();

  	}

  	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
  	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

  	FaceNormalsHelper.prototype.update = ( function () {

  		var v1 = new Vector3();
  		var v2 = new Vector3();
  		var normalMatrix = new Matrix3();

  		return function update() {

  			this.object.updateMatrixWorld( true );

  			normalMatrix.getNormalMatrix( this.object.matrixWorld );

  			var matrixWorld = this.object.matrixWorld;

  			var position = this.geometry.attributes.position;

  			//

  			var objGeometry = this.object.geometry;

  			var vertices = objGeometry.vertices;

  			var faces = objGeometry.faces;

  			var idx = 0;

  			for ( var i = 0, l = faces.length; i < l; i ++ ) {

  				var face = faces[ i ];

  				var normal = face.normal;

  				v1.copy( vertices[ face.a ] )
  					.add( vertices[ face.b ] )
  					.add( vertices[ face.c ] )
  					.divideScalar( 3 )
  					.applyMatrix4( matrixWorld );

  				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

  				position.setXYZ( idx, v1.x, v1.y, v1.z );

  				idx = idx + 1;

  				position.setXYZ( idx, v2.x, v2.y, v2.z );

  				idx = idx + 1;

  			}

  			position.needsUpdate = true;

  		};

  	}() );

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function DirectionalLightHelper( light, size, color ) {

  		Object3D.call( this );

  		this.light = light;
  		this.light.updateMatrixWorld();

  		this.matrix = light.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.color = color;

  		if ( size === undefined ) size = 1;

  		var geometry = new BufferGeometry();
  		geometry.addAttribute( 'position', new Float32BufferAttribute( [
  			- size, size, 0,
  			size, size, 0,
  			size, - size, 0,
  			- size, - size, 0,
  			- size, size, 0
  		], 3 ) );

  		var material = new LineBasicMaterial( { fog: false } );

  		this.lightPlane = new Line( geometry, material );
  		this.add( this.lightPlane );

  		geometry = new BufferGeometry();
  		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

  		this.targetLine = new Line( geometry, material );
  		this.add( this.targetLine );

  		this.update();

  	}

  	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
  	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

  	DirectionalLightHelper.prototype.dispose = function () {

  		this.lightPlane.geometry.dispose();
  		this.lightPlane.material.dispose();
  		this.targetLine.geometry.dispose();
  		this.targetLine.material.dispose();

  	};

  	DirectionalLightHelper.prototype.update = function () {

  		var v1 = new Vector3();
  		var v2 = new Vector3();
  		var v3 = new Vector3();

  		return function update() {

  			v1.setFromMatrixPosition( this.light.matrixWorld );
  			v2.setFromMatrixPosition( this.light.target.matrixWorld );
  			v3.subVectors( v2, v1 );

  			this.lightPlane.lookAt( v2 );

  			if ( this.color !== undefined ) {

  				this.lightPlane.material.color.set( this.color );
  				this.targetLine.material.color.set( this.color );

  			} else {

  				this.lightPlane.material.color.copy( this.light.color );
  				this.targetLine.material.color.copy( this.light.color );

  			}

  			this.targetLine.lookAt( v2 );
  			this.targetLine.scale.z = v3.length();

  		};

  	}();

  	/**
  	 * @author alteredq / http://alteredqualia.com/
  	 * @author Mugen87 / https://github.com/Mugen87
  	 *
  	 *	- shows frustum, line of sight and up of the camera
  	 *	- suitable for fast updates
  	 * 	- based on frustum visualization in lightgl.js shadowmap example
  	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
  	 */

  	function CameraHelper( camera ) {

  		var geometry = new BufferGeometry();
  		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

  		var vertices = [];
  		var colors = [];

  		var pointMap = {};

  		// colors

  		var colorFrustum = new Color( 0xffaa00 );
  		var colorCone = new Color( 0xff0000 );
  		var colorUp = new Color( 0x00aaff );
  		var colorTarget = new Color( 0xffffff );
  		var colorCross = new Color( 0x333333 );

  		// near

  		addLine( 'n1', 'n2', colorFrustum );
  		addLine( 'n2', 'n4', colorFrustum );
  		addLine( 'n4', 'n3', colorFrustum );
  		addLine( 'n3', 'n1', colorFrustum );

  		// far

  		addLine( 'f1', 'f2', colorFrustum );
  		addLine( 'f2', 'f4', colorFrustum );
  		addLine( 'f4', 'f3', colorFrustum );
  		addLine( 'f3', 'f1', colorFrustum );

  		// sides

  		addLine( 'n1', 'f1', colorFrustum );
  		addLine( 'n2', 'f2', colorFrustum );
  		addLine( 'n3', 'f3', colorFrustum );
  		addLine( 'n4', 'f4', colorFrustum );

  		// cone

  		addLine( 'p', 'n1', colorCone );
  		addLine( 'p', 'n2', colorCone );
  		addLine( 'p', 'n3', colorCone );
  		addLine( 'p', 'n4', colorCone );

  		// up

  		addLine( 'u1', 'u2', colorUp );
  		addLine( 'u2', 'u3', colorUp );
  		addLine( 'u3', 'u1', colorUp );

  		// target

  		addLine( 'c', 't', colorTarget );
  		addLine( 'p', 'c', colorCross );

  		// cross

  		addLine( 'cn1', 'cn2', colorCross );
  		addLine( 'cn3', 'cn4', colorCross );

  		addLine( 'cf1', 'cf2', colorCross );
  		addLine( 'cf3', 'cf4', colorCross );

  		function addLine( a, b, color ) {

  			addPoint( a, color );
  			addPoint( b, color );

  		}

  		function addPoint( id, color ) {

  			vertices.push( 0, 0, 0 );
  			colors.push( color.r, color.g, color.b );

  			if ( pointMap[ id ] === undefined ) {

  				pointMap[ id ] = [];

  			}

  			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

  		}

  		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		LineSegments.call( this, geometry, material );

  		this.camera = camera;
  		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

  		this.matrix = camera.matrixWorld;
  		this.matrixAutoUpdate = false;

  		this.pointMap = pointMap;

  		this.update();

  	}

  	CameraHelper.prototype = Object.create( LineSegments.prototype );
  	CameraHelper.prototype.constructor = CameraHelper;

  	CameraHelper.prototype.update = function () {

  		var geometry, pointMap;

  		var vector = new Vector3();
  		var camera = new Camera();

  		function setPoint( point, x, y, z ) {

  			vector.set( x, y, z ).unproject( camera );

  			var points = pointMap[ point ];

  			if ( points !== undefined ) {

  				var position = geometry.getAttribute( 'position' );

  				for ( var i = 0, l = points.length; i < l; i ++ ) {

  					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

  				}

  			}

  		}

  		return function update() {

  			geometry = this.geometry;
  			pointMap = this.pointMap;

  			var w = 1, h = 1;

  			// we need just camera projection matrix inverse
  			// world matrix must be identity

  			camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

  			// center / target

  			setPoint( 'c', 0, 0, - 1 );
  			setPoint( 't', 0, 0, 1 );

  			// near

  			setPoint( 'n1', - w, - h, - 1 );
  			setPoint( 'n2', w, - h, - 1 );
  			setPoint( 'n3', - w, h, - 1 );
  			setPoint( 'n4', w, h, - 1 );

  			// far

  			setPoint( 'f1', - w, - h, 1 );
  			setPoint( 'f2', w, - h, 1 );
  			setPoint( 'f3', - w, h, 1 );
  			setPoint( 'f4', w, h, 1 );

  			// up

  			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
  			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
  			setPoint( 'u3', 0, h * 2, - 1 );

  			// cross

  			setPoint( 'cf1', - w, 0, 1 );
  			setPoint( 'cf2', w, 0, 1 );
  			setPoint( 'cf3', 0, - h, 1 );
  			setPoint( 'cf4', 0, h, 1 );

  			setPoint( 'cn1', - w, 0, - 1 );
  			setPoint( 'cn2', w, 0, - 1 );
  			setPoint( 'cn3', 0, - h, - 1 );
  			setPoint( 'cn4', 0, h, - 1 );

  			geometry.getAttribute( 'position' ).needsUpdate = true;

  		};

  	}();

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 * @author Mugen87 / http://github.com/Mugen87
  	 */

  	function BoxHelper( object, color ) {

  		this.object = object;

  		if ( color === undefined ) color = 0xffff00;

  		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
  		var positions = new Float32Array( 8 * 3 );

  		var geometry = new BufferGeometry();
  		geometry.setIndex( new BufferAttribute( indices, 1 ) );
  		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

  		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

  		this.matrixAutoUpdate = false;

  		this.update();

  	}

  	BoxHelper.prototype = Object.create( LineSegments.prototype );
  	BoxHelper.prototype.constructor = BoxHelper;

  	BoxHelper.prototype.update = ( function () {

  		var box = new Box3();

  		return function update( object ) {

  			if ( object !== undefined ) {

  				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

  			}

  			if ( this.object !== undefined ) {

  				box.setFromObject( this.object );

  			}

  			if ( box.isEmpty() ) return;

  			var min = box.min;
  			var max = box.max;

  			/*
  			  5____4
  			1/___0/|
  			| 6__|_7
  			2/___3/

  			0: max.x, max.y, max.z
  			1: min.x, max.y, max.z
  			2: min.x, min.y, max.z
  			3: max.x, min.y, max.z
  			4: max.x, max.y, min.z
  			5: min.x, max.y, min.z
  			6: min.x, min.y, min.z
  			7: max.x, min.y, min.z
  			*/

  			var position = this.geometry.attributes.position;
  			var array = position.array;

  			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
  			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
  			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
  			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
  			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
  			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
  			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
  			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

  			position.needsUpdate = true;

  			this.geometry.computeBoundingSphere();

  		};

  	} )();

  	BoxHelper.prototype.setFromObject = function ( object ) {

  		this.object = object;
  		this.update();

  		return this;

  	};

  	BoxHelper.prototype.copy = function ( source ) {

  		LineSegments.prototype.copy.call( this, source );

  		this.object = source.object;

  		return this;

  	};

  	BoxHelper.prototype.clone = function () {

  		return new this.constructor().copy( this );

  	};

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function Box3Helper( box, hex ) {

  		this.type = 'Box3Helper';

  		this.box = box;

  		var color = ( hex !== undefined ) ? hex : 0xffff00;

  		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

  		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

  		var geometry = new BufferGeometry();

  		geometry.setIndex( new BufferAttribute( indices, 1 ) );

  		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

  		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

  		this.geometry.computeBoundingSphere();

  	}

  	Box3Helper.prototype = Object.create( LineSegments.prototype );
  	Box3Helper.prototype.constructor = Box3Helper;

  	Box3Helper.prototype.updateMatrixWorld = function ( force ) {

  		var box = this.box;

  		if ( box.isEmpty() ) return;

  		box.getCenter( this.position );

  		box.getSize( this.scale );

  		this.scale.multiplyScalar( 0.5 );

  		Object3D.prototype.updateMatrixWorld.call( this, force );

  	};

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 */

  	function PlaneHelper( plane, size, hex ) {

  		this.type = 'PlaneHelper';

  		this.plane = plane;

  		this.size = ( size === undefined ) ? 1 : size;

  		var color = ( hex !== undefined ) ? hex : 0xffff00;

  		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

  		var geometry = new BufferGeometry();
  		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
  		geometry.computeBoundingSphere();

  		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

  		//

  		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

  		var geometry2 = new BufferGeometry();
  		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
  		geometry2.computeBoundingSphere();

  		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

  	}

  	PlaneHelper.prototype = Object.create( Line.prototype );
  	PlaneHelper.prototype.constructor = PlaneHelper;

  	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

  		var scale = - this.plane.constant;

  		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

  		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

  		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

  		this.lookAt( this.plane.normal );

  		Object3D.prototype.updateMatrixWorld.call( this, force );

  	};

  	/**
  	 * @author WestLangley / http://github.com/WestLangley
  	 * @author zz85 / http://github.com/zz85
  	 * @author bhouston / http://clara.io
  	 *
  	 * Creates an arrow for visualizing directions
  	 *
  	 * Parameters:
  	 *  dir - Vector3
  	 *  origin - Vector3
  	 *  length - Number
  	 *  color - color in hex value
  	 *  headLength - Number
  	 *  headWidth - Number
  	 */

  	var lineGeometry, coneGeometry;

  	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

  		// dir is assumed to be normalized

  		Object3D.call( this );

  		if ( dir === undefined ) dir = new Vector3( 0, 0, 1 );
  		if ( origin === undefined ) origin = new Vector3( 0, 0, 0 );
  		if ( length === undefined ) length = 1;
  		if ( color === undefined ) color = 0xffff00;
  		if ( headLength === undefined ) headLength = 0.2 * length;
  		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  		if ( lineGeometry === undefined ) {

  			lineGeometry = new BufferGeometry();
  			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

  			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
  			coneGeometry.translate( 0, - 0.5, 0 );

  		}

  		this.position.copy( origin );

  		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
  		this.line.matrixAutoUpdate = false;
  		this.add( this.line );

  		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
  		this.cone.matrixAutoUpdate = false;
  		this.add( this.cone );

  		this.setDirection( dir );
  		this.setLength( length, headLength, headWidth );

  	}

  	ArrowHelper.prototype = Object.create( Object3D.prototype );
  	ArrowHelper.prototype.constructor = ArrowHelper;

  	ArrowHelper.prototype.setDirection = ( function () {

  		var axis = new Vector3();
  		var radians;

  		return function setDirection( dir ) {

  			// dir is assumed to be normalized

  			if ( dir.y > 0.99999 ) {

  				this.quaternion.set( 0, 0, 0, 1 );

  			} else if ( dir.y < - 0.99999 ) {

  				this.quaternion.set( 1, 0, 0, 0 );

  			} else {

  				axis.set( dir.z, 0, - dir.x ).normalize();

  				radians = Math.acos( dir.y );

  				this.quaternion.setFromAxisAngle( axis, radians );

  			}

  		};

  	}() );

  	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

  		if ( headLength === undefined ) headLength = 0.2 * length;
  		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
  		this.line.updateMatrix();

  		this.cone.scale.set( headWidth, headLength, headWidth );
  		this.cone.position.y = length;
  		this.cone.updateMatrix();

  	};

  	ArrowHelper.prototype.setColor = function ( color ) {

  		this.line.material.color.copy( color );
  		this.cone.material.color.copy( color );

  	};

  	ArrowHelper.prototype.copy = function ( source ) {

  		Object3D.prototype.copy.call( this, source, false );

  		this.line.copy( source.line );
  		this.cone.copy( source.cone );

  		return this;

  	};

  	ArrowHelper.prototype.clone = function () {

  		return new this.constructor().copy( this );

  	};

  	/**
  	 * @author sroucheray / http://sroucheray.org/
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function AxesHelper( size ) {

  		size = size || 1;

  		var vertices = [
  			0, 0, 0,	size, 0, 0,
  			0, 0, 0,	0, size, 0,
  			0, 0, 0,	0, 0, size
  		];

  		var colors = [
  			1, 0, 0,	1, 0.6, 0,
  			0, 1, 0,	0.6, 1, 0,
  			0, 0, 1,	0, 0.6, 1
  		];

  		var geometry = new BufferGeometry();
  		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
  		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

  		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

  		LineSegments.call( this, geometry, material );

  	}

  	AxesHelper.prototype = Object.create( LineSegments.prototype );
  	AxesHelper.prototype.constructor = AxesHelper;

  	/**
  	 * @author mrdoob / http://mrdoob.com/
  	 */

  	function Face4( a, b, c, d, normal, color, materialIndex ) {

  		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
  		return new Face3( a, b, c, normal, color, materialIndex );

  	}

  	var LineStrip = 0;

  	var LinePieces = 1;

  	function MeshFaceMaterial( materials ) {

  		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
  		return materials;

  	}

  	function MultiMaterial( materials ) {

  		if ( materials === undefined ) materials = [];

  		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
  		materials.isMultiMaterial = true;
  		materials.materials = materials;
  		materials.clone = function () {

  			return materials.slice();

  		};
  		return materials;

  	}

  	function PointCloud( geometry, material ) {

  		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
  		return new Points( geometry, material );

  	}

  	function Particle( material ) {

  		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
  		return new Sprite( material );

  	}

  	function ParticleSystem( geometry, material ) {

  		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
  		return new Points( geometry, material );

  	}

  	function PointCloudMaterial( parameters ) {

  		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
  		return new PointsMaterial( parameters );

  	}

  	function ParticleBasicMaterial( parameters ) {

  		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
  		return new PointsMaterial( parameters );

  	}

  	function ParticleSystemMaterial( parameters ) {

  		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
  		return new PointsMaterial( parameters );

  	}

  	function Vertex( x, y, z ) {

  		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
  		return new Vector3( x, y, z );

  	}

  	//

  	function DynamicBufferAttribute( array, itemSize ) {

  		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
  		return new BufferAttribute( array, itemSize ).setDynamic( true );

  	}

  	function Int8Attribute( array, itemSize ) {

  		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
  		return new Int8BufferAttribute( array, itemSize );

  	}

  	function Uint8Attribute( array, itemSize ) {

  		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
  		return new Uint8BufferAttribute( array, itemSize );

  	}

  	function Uint8ClampedAttribute( array, itemSize ) {

  		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
  		return new Uint8ClampedBufferAttribute( array, itemSize );

  	}

  	function Int16Attribute( array, itemSize ) {

  		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
  		return new Int16BufferAttribute( array, itemSize );

  	}

  	function Uint16Attribute( array, itemSize ) {

  		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
  		return new Uint16BufferAttribute( array, itemSize );

  	}

  	function Int32Attribute( array, itemSize ) {

  		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
  		return new Int32BufferAttribute( array, itemSize );

  	}

  	function Uint32Attribute( array, itemSize ) {

  		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
  		return new Uint32BufferAttribute( array, itemSize );

  	}

  	function Float32Attribute( array, itemSize ) {

  		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
  		return new Float32BufferAttribute( array, itemSize );

  	}

  	function Float64Attribute( array, itemSize ) {

  		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
  		return new Float64BufferAttribute( array, itemSize );

  	}

  	//

  	Curve.create = function ( construct, getPoint ) {

  		console.log( 'THREE.Curve.create() has been deprecated' );

  		construct.prototype = Object.create( Curve.prototype );
  		construct.prototype.constructor = construct;
  		construct.prototype.getPoint = getPoint;

  		return construct;

  	};

  	//

  	Object.assign( CurvePath.prototype, {

  		createPointsGeometry: function ( divisions ) {

  			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

  			// generate geometry from path points (for Line or Points objects)

  			var pts = this.getPoints( divisions );
  			return this.createGeometry( pts );

  		},

  		createSpacedPointsGeometry: function ( divisions ) {

  			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

  			// generate geometry from equidistant sampling along the path

  			var pts = this.getSpacedPoints( divisions );
  			return this.createGeometry( pts );

  		},

  		createGeometry: function ( points ) {

  			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

  			var geometry = new Geometry();

  			for ( var i = 0, l = points.length; i < l; i ++ ) {

  				var point = points[ i ];
  				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

  			}

  			return geometry;

  		}

  	} );

  	//

  	Object.assign( Path.prototype, {

  		fromPoints: function ( points ) {

  			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
  			this.setFromPoints( points );

  		}

  	} );

  	//

  	function ClosedSplineCurve3( points ) {

  		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

  		CatmullRomCurve3.call( this, points );
  		this.type = 'catmullrom';
  		this.closed = true;

  	}

  	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

  	//

  	function SplineCurve3( points ) {

  		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

  		CatmullRomCurve3.call( this, points );
  		this.type = 'catmullrom';

  	}

  	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

  	//

  	function Spline( points ) {

  		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

  		CatmullRomCurve3.call( this, points );
  		this.type = 'catmullrom';

  	}

  	Spline.prototype = Object.create( CatmullRomCurve3.prototype );

  	Object.assign( Spline.prototype, {

  		initFromArray: function ( /* a */ ) {

  			console.error( 'THREE.Spline: .initFromArray() has been removed.' );

  		},
  		getControlPointsArray: function ( /* optionalTarget */ ) {

  			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

  		},
  		reparametrizeByArcLength: function ( /* samplingCoef */ ) {

  			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

  		}

  	} );

  	//

  	function AxisHelper( size ) {

  		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
  		return new AxesHelper( size );

  	}

  	function BoundingBoxHelper( object, color ) {

  		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
  		return new BoxHelper( object, color );

  	}

  	function EdgesHelper( object, hex ) {

  		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
  		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

  	}

  	GridHelper.prototype.setColors = function () {

  		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

  	};

  	SkeletonHelper.prototype.update = function () {

  		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

  	};

  	function WireframeHelper( object, hex ) {

  		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
  		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

  	}

  	//

  	Object.assign( Loader.prototype, {

  		extractUrlBase: function ( url ) {

  			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
  			return LoaderUtils.extractUrlBase( url );

  		}

  	} );

  	function XHRLoader( manager ) {

  		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
  		return new FileLoader( manager );

  	}

  	function BinaryTextureLoader( manager ) {

  		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
  		return new DataTextureLoader( manager );

  	}

  	Object.assign( ObjectLoader.prototype, {

  		setTexturePath: function ( value ) {

  			console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
  			return this.setResourcePath( value );

  		}

  	} );

  	//

  	Object.assign( Box2.prototype, {

  		center: function ( optionalTarget ) {

  			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
  			return this.getCenter( optionalTarget );

  		},
  		empty: function () {

  			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
  			return this.isEmpty();

  		},
  		isIntersectionBox: function ( box ) {

  			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
  			return this.intersectsBox( box );

  		},
  		size: function ( optionalTarget ) {

  			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
  			return this.getSize( optionalTarget );

  		}
  	} );

  	Object.assign( Box3.prototype, {

  		center: function ( optionalTarget ) {

  			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
  			return this.getCenter( optionalTarget );

  		},
  		empty: function () {

  			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
  			return this.isEmpty();

  		},
  		isIntersectionBox: function ( box ) {

  			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
  			return this.intersectsBox( box );

  		},
  		isIntersectionSphere: function ( sphere ) {

  			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
  			return this.intersectsSphere( sphere );

  		},
  		size: function ( optionalTarget ) {

  			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
  			return this.getSize( optionalTarget );

  		}
  	} );

  	Line3.prototype.center = function ( optionalTarget ) {

  		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
  		return this.getCenter( optionalTarget );

  	};

  	Object.assign( _Math, {

  		random16: function () {

  			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
  			return Math.random();

  		},

  		nearestPowerOfTwo: function ( value ) {

  			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
  			return _Math.floorPowerOfTwo( value );

  		},

  		nextPowerOfTwo: function ( value ) {

  			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
  			return _Math.ceilPowerOfTwo( value );

  		}

  	} );

  	Object.assign( Matrix3.prototype, {

  		flattenToArrayOffset: function ( array, offset ) {

  			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
  			return this.toArray( array, offset );

  		},
  		multiplyVector3: function ( vector ) {

  			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
  			return vector.applyMatrix3( this );

  		},
  		multiplyVector3Array: function ( /* a */ ) {

  			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

  		},
  		applyToBuffer: function ( buffer /*, offset, length */ ) {

  			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
  			return this.applyToBufferAttribute( buffer );

  		},
  		applyToVector3Array: function ( /* array, offset, length */ ) {

  			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

  		}

  	} );

  	Object.assign( Matrix4.prototype, {

  		extractPosition: function ( m ) {

  			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
  			return this.copyPosition( m );

  		},
  		flattenToArrayOffset: function ( array, offset ) {

  			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
  			return this.toArray( array, offset );

  		},
  		getPosition: function () {

  			var v1;

  			return function getPosition() {

  				if ( v1 === undefined ) v1 = new Vector3();
  				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
  				return v1.setFromMatrixColumn( this, 3 );

  			};

  		}(),
  		setRotationFromQuaternion: function ( q ) {

  			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
  			return this.makeRotationFromQuaternion( q );

  		},
  		multiplyToArray: function () {

  			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

  		},
  		multiplyVector3: function ( vector ) {

  			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  			return vector.applyMatrix4( this );

  		},
  		multiplyVector4: function ( vector ) {

  			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  			return vector.applyMatrix4( this );

  		},
  		multiplyVector3Array: function ( /* a */ ) {

  			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

  		},
  		rotateAxis: function ( v ) {

  			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
  			v.transformDirection( this );

  		},
  		crossVector: function ( vector ) {

  			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  			return vector.applyMatrix4( this );

  		},
  		translate: function () {

  			console.error( 'THREE.Matrix4: .translate() has been removed.' );

  		},
  		rotateX: function () {

  			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

  		},
  		rotateY: function () {

  			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

  		},
  		rotateZ: function () {

  			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

  		},
  		rotateByAxis: function () {

  			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

  		},
  		applyToBuffer: function ( buffer /*, offset, length */ ) {

  			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
  			return this.applyToBufferAttribute( buffer );

  		},
  		applyToVector3Array: function ( /* array, offset, length */ ) {

  			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

  		},
  		makeFrustum: function ( left, right, bottom, top, near, far ) {

  			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
  			return this.makePerspective( left, right, top, bottom, near, far );

  		}

  	} );

  	Plane.prototype.isIntersectionLine = function ( line ) {

  		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
  		return this.intersectsLine( line );

  	};

  	Quaternion.prototype.multiplyVector3 = function ( vector ) {

  		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
  		return vector.applyQuaternion( this );

  	};

  	Object.assign( Ray.prototype, {

  		isIntersectionBox: function ( box ) {

  			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
  			return this.intersectsBox( box );

  		},
  		isIntersectionPlane: function ( plane ) {

  			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
  			return this.intersectsPlane( plane );

  		},
  		isIntersectionSphere: function ( sphere ) {

  			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
  			return this.intersectsSphere( sphere );

  		}

  	} );

  	Object.assign( Triangle.prototype, {

  		area: function () {

  			console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
  			return this.getArea();

  		},
  		barycoordFromPoint: function ( point, target ) {

  			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
  			return this.getBarycoord( point, target );

  		},
  		midpoint: function ( target ) {

  			console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
  			return this.getMidpoint( target );

  		},
  		normal: function ( target ) {

  			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
  			return this.getNormal( target );

  		},
  		plane: function ( target ) {

  			console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
  			return this.getPlane( target );

  		}

  	} );

  	Object.assign( Triangle, {

  		barycoordFromPoint: function ( point, a, b, c, target ) {

  			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
  			return Triangle.getBarycoord( point, a, b, c, target );

  		},
  		normal: function ( a, b, c, target ) {

  			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
  			return Triangle.getNormal( a, b, c, target );

  		}

  	} );

  	Object.assign( Shape.prototype, {

  		extractAllPoints: function ( divisions ) {

  			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
  			return this.extractPoints( divisions );

  		},
  		extrude: function ( options ) {

  			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
  			return new ExtrudeGeometry( this, options );

  		},
  		makeGeometry: function ( options ) {

  			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
  			return new ShapeGeometry( this, options );

  		}

  	} );

  	Object.assign( Vector2.prototype, {

  		fromAttribute: function ( attribute, index, offset ) {

  			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  			return this.fromBufferAttribute( attribute, index, offset );

  		},
  		distanceToManhattan: function ( v ) {

  			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
  			return this.manhattanDistanceTo( v );

  		},
  		lengthManhattan: function () {

  			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
  			return this.manhattanLength();

  		}

  	} );

  	Object.assign( Vector3.prototype, {

  		setEulerFromRotationMatrix: function () {

  			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  		},
  		setEulerFromQuaternion: function () {

  			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  		},
  		getPositionFromMatrix: function ( m ) {

  			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
  			return this.setFromMatrixPosition( m );

  		},
  		getScaleFromMatrix: function ( m ) {

  			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
  			return this.setFromMatrixScale( m );

  		},
  		getColumnFromMatrix: function ( index, matrix ) {

  			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
  			return this.setFromMatrixColumn( matrix, index );

  		},
  		applyProjection: function ( m ) {

  			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
  			return this.applyMatrix4( m );

  		},
  		fromAttribute: function ( attribute, index, offset ) {

  			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  			return this.fromBufferAttribute( attribute, index, offset );

  		},
  		distanceToManhattan: function ( v ) {

  			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
  			return this.manhattanDistanceTo( v );

  		},
  		lengthManhattan: function () {

  			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
  			return this.manhattanLength();

  		}

  	} );

  	Object.assign( Vector4.prototype, {

  		fromAttribute: function ( attribute, index, offset ) {

  			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  			return this.fromBufferAttribute( attribute, index, offset );

  		},
  		lengthManhattan: function () {

  			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
  			return this.manhattanLength();

  		}

  	} );

  	//

  	Object.assign( Geometry.prototype, {

  		computeTangents: function () {

  			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

  		},
  		computeLineDistances: function () {

  			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

  		}

  	} );

  	Object.assign( Object3D.prototype, {

  		getChildByName: function ( name ) {

  			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
  			return this.getObjectByName( name );

  		},
  		renderDepth: function () {

  			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

  		},
  		translate: function ( distance, axis ) {

  			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
  			return this.translateOnAxis( axis, distance );

  		},
  		getWorldRotation: function () {

  			console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

  		}

  	} );

  	Object.defineProperties( Object3D.prototype, {

  		eulerOrder: {
  			get: function () {

  				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
  				return this.rotation.order;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
  				this.rotation.order = value;

  			}
  		},
  		useQuaternion: {
  			get: function () {

  				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  			},
  			set: function () {

  				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  			}
  		}

  	} );

  	Object.defineProperties( LOD.prototype, {

  		objects: {
  			get: function () {

  				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
  				return this.levels;

  			}
  		}

  	} );

  	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

  		get: function () {

  			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

  		},
  		set: function () {

  			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

  		}

  	} );

  	SkinnedMesh.prototype.initBones = function () {

  		console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

  	};

  	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

  		get: function () {

  			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
  			return this.arcLengthDivisions;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
  			this.arcLengthDivisions = value;

  		}

  	} );

  	//

  	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

  		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
  				"Use .setFocalLength and .filmGauge for a photographic setup." );

  		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
  		this.setFocalLength( focalLength );

  	};

  	//

  	Object.defineProperties( Light.prototype, {
  		onlyShadow: {
  			set: function () {

  				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

  			}
  		},
  		shadowCameraFov: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
  				this.shadow.camera.fov = value;

  			}
  		},
  		shadowCameraLeft: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
  				this.shadow.camera.left = value;

  			}
  		},
  		shadowCameraRight: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
  				this.shadow.camera.right = value;

  			}
  		},
  		shadowCameraTop: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
  				this.shadow.camera.top = value;

  			}
  		},
  		shadowCameraBottom: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
  				this.shadow.camera.bottom = value;

  			}
  		},
  		shadowCameraNear: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
  				this.shadow.camera.near = value;

  			}
  		},
  		shadowCameraFar: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
  				this.shadow.camera.far = value;

  			}
  		},
  		shadowCameraVisible: {
  			set: function () {

  				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

  			}
  		},
  		shadowBias: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
  				this.shadow.bias = value;

  			}
  		},
  		shadowDarkness: {
  			set: function () {

  				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

  			}
  		},
  		shadowMapWidth: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
  				this.shadow.mapSize.width = value;

  			}
  		},
  		shadowMapHeight: {
  			set: function ( value ) {

  				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
  				this.shadow.mapSize.height = value;

  			}
  		}
  	} );

  	//

  	Object.defineProperties( BufferAttribute.prototype, {

  		length: {
  			get: function () {

  				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
  				return this.array.length;

  			}
  		},
  		copyIndicesArray: function ( /* indices */ ) {

  			console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

  		}

  	} );

  	Object.assign( BufferGeometry.prototype, {

  		addIndex: function ( index ) {

  			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
  			this.setIndex( index );

  		},
  		addDrawCall: function ( start, count, indexOffset ) {

  			if ( indexOffset !== undefined ) {

  				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

  			}
  			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
  			this.addGroup( start, count );

  		},
  		clearDrawCalls: function () {

  			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
  			this.clearGroups();

  		},
  		computeTangents: function () {

  			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

  		},
  		computeOffsets: function () {

  			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

  		}

  	} );

  	Object.defineProperties( BufferGeometry.prototype, {

  		drawcalls: {
  			get: function () {

  				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
  				return this.groups;

  			}
  		},
  		offsets: {
  			get: function () {

  				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
  				return this.groups;

  			}
  		}

  	} );

  	//

  	Object.assign( ExtrudeBufferGeometry.prototype, {

  		getArrays: function () {

  			console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

  		},

  		addShapeList: function () {

  			console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

  		},

  		addShape: function () {

  			console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

  		}

  	} );

  	//

  	Object.defineProperties( Uniform.prototype, {

  		dynamic: {
  			set: function () {

  				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

  			}
  		},
  		onUpdate: {
  			value: function () {

  				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
  				return this;

  			}
  		}

  	} );

  	//

  	Object.defineProperties( Material.prototype, {

  		wrapAround: {
  			get: function () {

  				console.warn( 'THREE.Material: .wrapAround has been removed.' );

  			},
  			set: function () {

  				console.warn( 'THREE.Material: .wrapAround has been removed.' );

  			}
  		},

  		overdraw: {
  			get: function () {

  				console.warn( 'THREE.Material: .overdraw has been removed.' );

  			},
  			set: function () {

  				console.warn( 'THREE.Material: .overdraw has been removed.' );

  			}
  		},

  		wrapRGB: {
  			get: function () {

  				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
  				return new Color();

  			}
  		},

  		shading: {
  			get: function () {

  				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
  				this.flatShading = ( value === FlatShading );

  			}
  		}

  	} );

  	Object.defineProperties( MeshPhongMaterial.prototype, {

  		metal: {
  			get: function () {

  				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
  				return false;

  			},
  			set: function () {

  				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

  			}
  		}

  	} );

  	Object.defineProperties( ShaderMaterial.prototype, {

  		derivatives: {
  			get: function () {

  				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
  				return this.extensions.derivatives;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
  				this.extensions.derivatives = value;

  			}
  		}

  	} );

  	//

  	Object.assign( WebGLRenderer.prototype, {

  		clearTarget: function ( renderTarget, color, depth, stencil ) {

  			console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
  			this.setRenderTarget( renderTarget );
  			this.clear( color, depth, stencil );

  		},
  		animate: function ( callback ) {

  			console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
  			this.setAnimationLoop( callback );

  		},
  		getCurrentRenderTarget: function () {

  			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
  			return this.getRenderTarget();

  		},
  		getMaxAnisotropy: function () {

  			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
  			return this.capabilities.getMaxAnisotropy();

  		},
  		getPrecision: function () {

  			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
  			return this.capabilities.precision;

  		},
  		resetGLState: function () {

  			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
  			return this.state.reset();

  		},
  		supportsFloatTextures: function () {

  			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
  			return this.extensions.get( 'OES_texture_float' );

  		},
  		supportsHalfFloatTextures: function () {

  			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
  			return this.extensions.get( 'OES_texture_half_float' );

  		},
  		supportsStandardDerivatives: function () {

  			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
  			return this.extensions.get( 'OES_standard_derivatives' );

  		},
  		supportsCompressedTextureS3TC: function () {

  			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
  			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

  		},
  		supportsCompressedTexturePVRTC: function () {

  			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
  			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  		},
  		supportsBlendMinMax: function () {

  			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
  			return this.extensions.get( 'EXT_blend_minmax' );

  		},
  		supportsVertexTextures: function () {

  			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
  			return this.capabilities.vertexTextures;

  		},
  		supportsInstancedArrays: function () {

  			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
  			return this.extensions.get( 'ANGLE_instanced_arrays' );

  		},
  		enableScissorTest: function ( boolean ) {

  			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
  			this.setScissorTest( boolean );

  		},
  		initMaterial: function () {

  			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

  		},
  		addPrePlugin: function () {

  			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

  		},
  		addPostPlugin: function () {

  			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

  		},
  		updateShadowMap: function () {

  			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

  		},
  		setFaceCulling: function () {

  			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

  		},
  		allocTextureUnit: function () {

  			console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

  		},
  		setTexture: function () {

  			console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

  		},
  		setTexture2D: function () {

  			console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

  		},
  		setTextureCube: function () {

  			console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

  		}

  	} );

  	Object.defineProperties( WebGLRenderer.prototype, {

  		shadowMapEnabled: {
  			get: function () {

  				return this.shadowMap.enabled;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
  				this.shadowMap.enabled = value;

  			}
  		},
  		shadowMapType: {
  			get: function () {

  				return this.shadowMap.type;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
  				this.shadowMap.type = value;

  			}
  		},
  		shadowMapCullFace: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
  				return undefined;

  			},
  			set: function ( /* value */ ) {

  				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

  			}
  		}
  	} );

  	Object.defineProperties( WebGLShadowMap.prototype, {

  		cullFace: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
  				return undefined;

  			},
  			set: function ( /* cullFace */ ) {

  				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

  			}
  		},
  		renderReverseSided: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
  				return undefined;

  			},
  			set: function () {

  				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

  			}
  		},
  		renderSingleSided: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
  				return undefined;

  			},
  			set: function () {

  				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

  			}
  		}

  	} );

  	//

  	Object.defineProperties( WebGLRenderTargetCube.prototype, {

  		activeCubeFace: {
  			set: function ( /* value */ ) {

  				console.warn( 'THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().' );

  			}
  		},
  		activeMipMapLevel: {
  			set: function ( /* value */ ) {

  				console.warn( 'THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().' );

  			}
  		}

  	} );

  	//

  	Object.defineProperties( WebGLRenderTarget.prototype, {

  		wrapS: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
  				return this.texture.wrapS;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
  				this.texture.wrapS = value;

  			}
  		},
  		wrapT: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
  				return this.texture.wrapT;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
  				this.texture.wrapT = value;

  			}
  		},
  		magFilter: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
  				return this.texture.magFilter;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
  				this.texture.magFilter = value;

  			}
  		},
  		minFilter: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
  				return this.texture.minFilter;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
  				this.texture.minFilter = value;

  			}
  		},
  		anisotropy: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
  				return this.texture.anisotropy;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
  				this.texture.anisotropy = value;

  			}
  		},
  		offset: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
  				return this.texture.offset;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
  				this.texture.offset = value;

  			}
  		},
  		repeat: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
  				return this.texture.repeat;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
  				this.texture.repeat = value;

  			}
  		},
  		format: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
  				return this.texture.format;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
  				this.texture.format = value;

  			}
  		},
  		type: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
  				return this.texture.type;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
  				this.texture.type = value;

  			}
  		},
  		generateMipmaps: {
  			get: function () {

  				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
  				return this.texture.generateMipmaps;

  			},
  			set: function ( value ) {

  				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
  				this.texture.generateMipmaps = value;

  			}
  		}

  	} );

  	//

  	Object.defineProperties( WebVRManager.prototype, {

  		standing: {
  			set: function ( /* value */ ) {

  				console.warn( 'THREE.WebVRManager: .standing has been removed.' );

  			}
  		},
  		userHeight: {
  			set: function ( /* value */ ) {

  				console.warn( 'THREE.WebVRManager: .userHeight has been removed.' );

  			}
  		}

  	} );

  	//

  	Audio.prototype.load = function ( file ) {

  		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
  		var scope = this;
  		var audioLoader = new AudioLoader();
  		audioLoader.load( file, function ( buffer ) {

  			scope.setBuffer( buffer );

  		} );
  		return this;

  	};

  	AudioAnalyser.prototype.getData = function () {

  		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
  		return this.getFrequencyData();

  	};

  	//

  	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

  		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
  		return this.update( renderer, scene );

  	};

  	//

  	var GeometryUtils = {

  		merge: function ( geometry1, geometry2, materialIndexOffset ) {

  			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
  			var matrix;

  			if ( geometry2.isMesh ) {

  				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

  				matrix = geometry2.matrix;
  				geometry2 = geometry2.geometry;

  			}

  			geometry1.merge( geometry2, matrix, materialIndexOffset );

  		},

  		center: function ( geometry ) {

  			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
  			return geometry.center();

  		}

  	};

  	ImageUtils.crossOrigin = undefined;

  	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

  		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

  		var loader = new TextureLoader();
  		loader.setCrossOrigin( this.crossOrigin );

  		var texture = loader.load( url, onLoad, undefined, onError );

  		if ( mapping ) texture.mapping = mapping;

  		return texture;

  	};

  	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

  		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

  		var loader = new CubeTextureLoader();
  		loader.setCrossOrigin( this.crossOrigin );

  		var texture = loader.load( urls, onLoad, undefined, onError );

  		if ( mapping ) texture.mapping = mapping;

  		return texture;

  	};

  	ImageUtils.loadCompressedTexture = function () {

  		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

  	};

  	ImageUtils.loadCompressedTextureCube = function () {

  		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

  	};

  	//

  	function Projector() {

  		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

  		this.projectVector = function ( vector, camera ) {

  			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
  			vector.project( camera );

  		};

  		this.unprojectVector = function ( vector, camera ) {

  			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
  			vector.unproject( camera );

  		};

  		this.pickingRay = function () {

  			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

  		};

  	}

  	//

  	function CanvasRenderer() {

  		console.error( 'THREE.CanvasRenderer has been removed' );

  	}

  	//

  	function JSONLoader() {

  		console.error( 'THREE.JSONLoader has been removed.' );

  	}

  	//

  	var SceneUtils = {

  		createMultiMaterialObject: function ( /* geometry, materials */ ) {

  			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

  		},

  		detach: function ( /* child, parent, scene */ ) {

  			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

  		},

  		attach: function ( /* child, scene, parent */ ) {

  			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

  		}

  	};

  	//

  	function LensFlare() {

  		console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );

  	}

  	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
  	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
  	exports.WebGLRenderTarget = WebGLRenderTarget;
  	exports.WebGLRenderer = WebGLRenderer;
  	exports.ShaderLib = ShaderLib;
  	exports.UniformsLib = UniformsLib;
  	exports.UniformsUtils = UniformsUtils;
  	exports.ShaderChunk = ShaderChunk;
  	exports.FogExp2 = FogExp2;
  	exports.Fog = Fog;
  	exports.Scene = Scene;
  	exports.Sprite = Sprite;
  	exports.LOD = LOD;
  	exports.SkinnedMesh = SkinnedMesh;
  	exports.Skeleton = Skeleton;
  	exports.Bone = Bone;
  	exports.Mesh = Mesh;
  	exports.LineSegments = LineSegments;
  	exports.LineLoop = LineLoop;
  	exports.Line = Line;
  	exports.Points = Points;
  	exports.Group = Group;
  	exports.VideoTexture = VideoTexture;
  	exports.DataTexture = DataTexture;
  	exports.DataTexture2DArray = DataTexture2DArray;
  	exports.DataTexture3D = DataTexture3D;
  	exports.CompressedTexture = CompressedTexture;
  	exports.CubeTexture = CubeTexture;
  	exports.CanvasTexture = CanvasTexture;
  	exports.DepthTexture = DepthTexture;
  	exports.Texture = Texture;
  	exports.AnimationLoader = AnimationLoader;
  	exports.CompressedTextureLoader = CompressedTextureLoader;
  	exports.DataTextureLoader = DataTextureLoader;
  	exports.CubeTextureLoader = CubeTextureLoader;
  	exports.TextureLoader = TextureLoader;
  	exports.ObjectLoader = ObjectLoader;
  	exports.MaterialLoader = MaterialLoader;
  	exports.BufferGeometryLoader = BufferGeometryLoader;
  	exports.DefaultLoadingManager = DefaultLoadingManager;
  	exports.LoadingManager = LoadingManager;
  	exports.ImageLoader = ImageLoader;
  	exports.ImageBitmapLoader = ImageBitmapLoader;
  	exports.FontLoader = FontLoader;
  	exports.FileLoader = FileLoader;
  	exports.Loader = Loader;
  	exports.LoaderUtils = LoaderUtils;
  	exports.Cache = Cache;
  	exports.AudioLoader = AudioLoader;
  	exports.SpotLightShadow = SpotLightShadow;
  	exports.SpotLight = SpotLight;
  	exports.PointLight = PointLight;
  	exports.RectAreaLight = RectAreaLight;
  	exports.HemisphereLight = HemisphereLight;
  	exports.HemisphereLightProbe = HemisphereLightProbe;
  	exports.DirectionalLightShadow = DirectionalLightShadow;
  	exports.DirectionalLight = DirectionalLight;
  	exports.AmbientLight = AmbientLight;
  	exports.AmbientLightProbe = AmbientLightProbe;
  	exports.LightShadow = LightShadow;
  	exports.Light = Light;
  	exports.LightProbe = LightProbe;
  	exports.StereoCamera = StereoCamera;
  	exports.PerspectiveCamera = PerspectiveCamera;
  	exports.OrthographicCamera = OrthographicCamera;
  	exports.CubeCamera = CubeCamera;
  	exports.ArrayCamera = ArrayCamera;
  	exports.Camera = Camera;
  	exports.AudioListener = AudioListener;
  	exports.PositionalAudio = PositionalAudio;
  	exports.AudioContext = AudioContext;
  	exports.AudioAnalyser = AudioAnalyser;
  	exports.Audio = Audio;
  	exports.VectorKeyframeTrack = VectorKeyframeTrack;
  	exports.StringKeyframeTrack = StringKeyframeTrack;
  	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
  	exports.NumberKeyframeTrack = NumberKeyframeTrack;
  	exports.ColorKeyframeTrack = ColorKeyframeTrack;
  	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
  	exports.PropertyMixer = PropertyMixer;
  	exports.PropertyBinding = PropertyBinding;
  	exports.KeyframeTrack = KeyframeTrack;
  	exports.AnimationUtils = AnimationUtils;
  	exports.AnimationObjectGroup = AnimationObjectGroup;
  	exports.AnimationMixer = AnimationMixer;
  	exports.AnimationClip = AnimationClip;
  	exports.Uniform = Uniform;
  	exports.InstancedBufferGeometry = InstancedBufferGeometry;
  	exports.BufferGeometry = BufferGeometry;
  	exports.Geometry = Geometry;
  	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
  	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
  	exports.InterleavedBuffer = InterleavedBuffer;
  	exports.InstancedBufferAttribute = InstancedBufferAttribute;
  	exports.Face3 = Face3;
  	exports.Object3D = Object3D;
  	exports.Raycaster = Raycaster;
  	exports.Layers = Layers;
  	exports.EventDispatcher = EventDispatcher;
  	exports.Clock = Clock;
  	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
  	exports.LinearInterpolant = LinearInterpolant;
  	exports.DiscreteInterpolant = DiscreteInterpolant;
  	exports.CubicInterpolant = CubicInterpolant;
  	exports.Interpolant = Interpolant;
  	exports.Triangle = Triangle;
  	exports.Math = _Math;
  	exports.Spherical = Spherical;
  	exports.Cylindrical = Cylindrical;
  	exports.Plane = Plane;
  	exports.Frustum = Frustum;
  	exports.Sphere = Sphere;
  	exports.Ray = Ray;
  	exports.Matrix4 = Matrix4;
  	exports.Matrix3 = Matrix3;
  	exports.Box3 = Box3;
  	exports.Box2 = Box2;
  	exports.Line3 = Line3;
  	exports.Euler = Euler;
  	exports.Vector4 = Vector4;
  	exports.Vector3 = Vector3;
  	exports.Vector2 = Vector2;
  	exports.Quaternion = Quaternion;
  	exports.Color = Color;
  	exports.SphericalHarmonics3 = SphericalHarmonics3;
  	exports.ImmediateRenderObject = ImmediateRenderObject;
  	exports.VertexNormalsHelper = VertexNormalsHelper;
  	exports.SpotLightHelper = SpotLightHelper;
  	exports.SkeletonHelper = SkeletonHelper;
  	exports.PointLightHelper = PointLightHelper;
  	exports.RectAreaLightHelper = RectAreaLightHelper;
  	exports.HemisphereLightHelper = HemisphereLightHelper;
  	exports.LightProbeHelper = LightProbeHelper;
  	exports.GridHelper = GridHelper;
  	exports.PolarGridHelper = PolarGridHelper;
  	exports.PositionalAudioHelper = PositionalAudioHelper;
  	exports.FaceNormalsHelper = FaceNormalsHelper;
  	exports.DirectionalLightHelper = DirectionalLightHelper;
  	exports.CameraHelper = CameraHelper;
  	exports.BoxHelper = BoxHelper;
  	exports.Box3Helper = Box3Helper;
  	exports.PlaneHelper = PlaneHelper;
  	exports.ArrowHelper = ArrowHelper;
  	exports.AxesHelper = AxesHelper;
  	exports.Shape = Shape;
  	exports.Path = Path;
  	exports.ShapePath = ShapePath;
  	exports.Font = Font;
  	exports.CurvePath = CurvePath;
  	exports.Curve = Curve;
  	exports.ImageUtils = ImageUtils;
  	exports.ShapeUtils = ShapeUtils;
  	exports.WebGLUtils = WebGLUtils;
  	exports.WireframeGeometry = WireframeGeometry;
  	exports.ParametricGeometry = ParametricGeometry;
  	exports.ParametricBufferGeometry = ParametricBufferGeometry;
  	exports.TetrahedronGeometry = TetrahedronGeometry;
  	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
  	exports.OctahedronGeometry = OctahedronGeometry;
  	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
  	exports.IcosahedronGeometry = IcosahedronGeometry;
  	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
  	exports.DodecahedronGeometry = DodecahedronGeometry;
  	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
  	exports.PolyhedronGeometry = PolyhedronGeometry;
  	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
  	exports.TubeGeometry = TubeGeometry;
  	exports.TubeBufferGeometry = TubeBufferGeometry;
  	exports.TorusKnotGeometry = TorusKnotGeometry;
  	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
  	exports.TorusGeometry = TorusGeometry;
  	exports.TorusBufferGeometry = TorusBufferGeometry;
  	exports.TextGeometry = TextGeometry;
  	exports.TextBufferGeometry = TextBufferGeometry;
  	exports.SphereGeometry = SphereGeometry;
  	exports.SphereBufferGeometry = SphereBufferGeometry;
  	exports.RingGeometry = RingGeometry;
  	exports.RingBufferGeometry = RingBufferGeometry;
  	exports.PlaneGeometry = PlaneGeometry;
  	exports.PlaneBufferGeometry = PlaneBufferGeometry;
  	exports.LatheGeometry = LatheGeometry;
  	exports.LatheBufferGeometry = LatheBufferGeometry;
  	exports.ShapeGeometry = ShapeGeometry;
  	exports.ShapeBufferGeometry = ShapeBufferGeometry;
  	exports.ExtrudeGeometry = ExtrudeGeometry;
  	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
  	exports.EdgesGeometry = EdgesGeometry;
  	exports.ConeGeometry = ConeGeometry;
  	exports.ConeBufferGeometry = ConeBufferGeometry;
  	exports.CylinderGeometry = CylinderGeometry;
  	exports.CylinderBufferGeometry = CylinderBufferGeometry;
  	exports.CircleGeometry = CircleGeometry;
  	exports.CircleBufferGeometry = CircleBufferGeometry;
  	exports.BoxGeometry = BoxGeometry;
  	exports.CubeGeometry = BoxGeometry;
  	exports.BoxBufferGeometry = BoxBufferGeometry;
  	exports.ShadowMaterial = ShadowMaterial;
  	exports.SpriteMaterial = SpriteMaterial;
  	exports.RawShaderMaterial = RawShaderMaterial;
  	exports.ShaderMaterial = ShaderMaterial;
  	exports.PointsMaterial = PointsMaterial;
  	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
  	exports.MeshStandardMaterial = MeshStandardMaterial;
  	exports.MeshPhongMaterial = MeshPhongMaterial;
  	exports.MeshToonMaterial = MeshToonMaterial;
  	exports.MeshNormalMaterial = MeshNormalMaterial;
  	exports.MeshLambertMaterial = MeshLambertMaterial;
  	exports.MeshDepthMaterial = MeshDepthMaterial;
  	exports.MeshDistanceMaterial = MeshDistanceMaterial;
  	exports.MeshBasicMaterial = MeshBasicMaterial;
  	exports.MeshMatcapMaterial = MeshMatcapMaterial;
  	exports.LineDashedMaterial = LineDashedMaterial;
  	exports.LineBasicMaterial = LineBasicMaterial;
  	exports.Material = Material;
  	exports.Float64BufferAttribute = Float64BufferAttribute;
  	exports.Float32BufferAttribute = Float32BufferAttribute;
  	exports.Uint32BufferAttribute = Uint32BufferAttribute;
  	exports.Int32BufferAttribute = Int32BufferAttribute;
  	exports.Uint16BufferAttribute = Uint16BufferAttribute;
  	exports.Int16BufferAttribute = Int16BufferAttribute;
  	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
  	exports.Uint8BufferAttribute = Uint8BufferAttribute;
  	exports.Int8BufferAttribute = Int8BufferAttribute;
  	exports.BufferAttribute = BufferAttribute;
  	exports.ArcCurve = ArcCurve;
  	exports.CatmullRomCurve3 = CatmullRomCurve3;
  	exports.CubicBezierCurve = CubicBezierCurve;
  	exports.CubicBezierCurve3 = CubicBezierCurve3;
  	exports.EllipseCurve = EllipseCurve;
  	exports.LineCurve = LineCurve;
  	exports.LineCurve3 = LineCurve3;
  	exports.QuadraticBezierCurve = QuadraticBezierCurve;
  	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
  	exports.SplineCurve = SplineCurve;
  	exports.REVISION = REVISION;
  	exports.MOUSE = MOUSE;
  	exports.CullFaceNone = CullFaceNone;
  	exports.CullFaceBack = CullFaceBack;
  	exports.CullFaceFront = CullFaceFront;
  	exports.CullFaceFrontBack = CullFaceFrontBack;
  	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
  	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
  	exports.BasicShadowMap = BasicShadowMap;
  	exports.PCFShadowMap = PCFShadowMap;
  	exports.PCFSoftShadowMap = PCFSoftShadowMap;
  	exports.FrontSide = FrontSide;
  	exports.BackSide = BackSide;
  	exports.DoubleSide = DoubleSide;
  	exports.FlatShading = FlatShading;
  	exports.SmoothShading = SmoothShading;
  	exports.NoColors = NoColors;
  	exports.FaceColors = FaceColors;
  	exports.VertexColors = VertexColors;
  	exports.NoBlending = NoBlending;
  	exports.NormalBlending = NormalBlending;
  	exports.AdditiveBlending = AdditiveBlending;
  	exports.SubtractiveBlending = SubtractiveBlending;
  	exports.MultiplyBlending = MultiplyBlending;
  	exports.CustomBlending = CustomBlending;
  	exports.AddEquation = AddEquation;
  	exports.SubtractEquation = SubtractEquation;
  	exports.ReverseSubtractEquation = ReverseSubtractEquation;
  	exports.MinEquation = MinEquation;
  	exports.MaxEquation = MaxEquation;
  	exports.ZeroFactor = ZeroFactor;
  	exports.OneFactor = OneFactor;
  	exports.SrcColorFactor = SrcColorFactor;
  	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
  	exports.SrcAlphaFactor = SrcAlphaFactor;
  	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
  	exports.DstAlphaFactor = DstAlphaFactor;
  	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
  	exports.DstColorFactor = DstColorFactor;
  	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
  	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
  	exports.NeverDepth = NeverDepth;
  	exports.AlwaysDepth = AlwaysDepth;
  	exports.LessDepth = LessDepth;
  	exports.LessEqualDepth = LessEqualDepth;
  	exports.EqualDepth = EqualDepth;
  	exports.GreaterEqualDepth = GreaterEqualDepth;
  	exports.GreaterDepth = GreaterDepth;
  	exports.NotEqualDepth = NotEqualDepth;
  	exports.MultiplyOperation = MultiplyOperation;
  	exports.MixOperation = MixOperation;
  	exports.AddOperation = AddOperation;
  	exports.NoToneMapping = NoToneMapping;
  	exports.LinearToneMapping = LinearToneMapping;
  	exports.ReinhardToneMapping = ReinhardToneMapping;
  	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
  	exports.CineonToneMapping = CineonToneMapping;
  	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
  	exports.UVMapping = UVMapping;
  	exports.CubeReflectionMapping = CubeReflectionMapping;
  	exports.CubeRefractionMapping = CubeRefractionMapping;
  	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
  	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
  	exports.SphericalReflectionMapping = SphericalReflectionMapping;
  	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
  	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
  	exports.RepeatWrapping = RepeatWrapping;
  	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
  	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
  	exports.NearestFilter = NearestFilter;
  	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
  	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
  	exports.LinearFilter = LinearFilter;
  	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
  	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
  	exports.UnsignedByteType = UnsignedByteType;
  	exports.ByteType = ByteType;
  	exports.ShortType = ShortType;
  	exports.UnsignedShortType = UnsignedShortType;
  	exports.IntType = IntType;
  	exports.UnsignedIntType = UnsignedIntType;
  	exports.FloatType = FloatType;
  	exports.HalfFloatType = HalfFloatType;
  	exports.UnsignedShort4444Type = UnsignedShort4444Type;
  	exports.UnsignedShort5551Type = UnsignedShort5551Type;
  	exports.UnsignedShort565Type = UnsignedShort565Type;
  	exports.UnsignedInt248Type = UnsignedInt248Type;
  	exports.AlphaFormat = AlphaFormat;
  	exports.RGBFormat = RGBFormat;
  	exports.RGBAFormat = RGBAFormat;
  	exports.LuminanceFormat = LuminanceFormat;
  	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
  	exports.RGBEFormat = RGBEFormat;
  	exports.DepthFormat = DepthFormat;
  	exports.DepthStencilFormat = DepthStencilFormat;
  	exports.RedFormat = RedFormat;
  	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
  	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
  	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
  	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
  	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
  	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
  	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
  	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
  	exports.RGB_ETC1_Format = RGB_ETC1_Format;
  	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
  	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
  	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
  	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
  	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
  	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
  	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
  	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
  	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
  	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
  	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
  	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
  	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
  	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
  	exports.LoopOnce = LoopOnce;
  	exports.LoopRepeat = LoopRepeat;
  	exports.LoopPingPong = LoopPingPong;
  	exports.InterpolateDiscrete = InterpolateDiscrete;
  	exports.InterpolateLinear = InterpolateLinear;
  	exports.InterpolateSmooth = InterpolateSmooth;
  	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
  	exports.ZeroSlopeEnding = ZeroSlopeEnding;
  	exports.WrapAroundEnding = WrapAroundEnding;
  	exports.TrianglesDrawMode = TrianglesDrawMode;
  	exports.TriangleStripDrawMode = TriangleStripDrawMode;
  	exports.TriangleFanDrawMode = TriangleFanDrawMode;
  	exports.LinearEncoding = LinearEncoding;
  	exports.sRGBEncoding = sRGBEncoding;
  	exports.GammaEncoding = GammaEncoding;
  	exports.RGBEEncoding = RGBEEncoding;
  	exports.LogLuvEncoding = LogLuvEncoding;
  	exports.RGBM7Encoding = RGBM7Encoding;
  	exports.RGBM16Encoding = RGBM16Encoding;
  	exports.RGBDEncoding = RGBDEncoding;
  	exports.BasicDepthPacking = BasicDepthPacking;
  	exports.RGBADepthPacking = RGBADepthPacking;
  	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
  	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
  	exports.Face4 = Face4;
  	exports.LineStrip = LineStrip;
  	exports.LinePieces = LinePieces;
  	exports.MeshFaceMaterial = MeshFaceMaterial;
  	exports.MultiMaterial = MultiMaterial;
  	exports.PointCloud = PointCloud;
  	exports.Particle = Particle;
  	exports.ParticleSystem = ParticleSystem;
  	exports.PointCloudMaterial = PointCloudMaterial;
  	exports.ParticleBasicMaterial = ParticleBasicMaterial;
  	exports.ParticleSystemMaterial = ParticleSystemMaterial;
  	exports.Vertex = Vertex;
  	exports.DynamicBufferAttribute = DynamicBufferAttribute;
  	exports.Int8Attribute = Int8Attribute;
  	exports.Uint8Attribute = Uint8Attribute;
  	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
  	exports.Int16Attribute = Int16Attribute;
  	exports.Uint16Attribute = Uint16Attribute;
  	exports.Int32Attribute = Int32Attribute;
  	exports.Uint32Attribute = Uint32Attribute;
  	exports.Float32Attribute = Float32Attribute;
  	exports.Float64Attribute = Float64Attribute;
  	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
  	exports.SplineCurve3 = SplineCurve3;
  	exports.Spline = Spline;
  	exports.AxisHelper = AxisHelper;
  	exports.BoundingBoxHelper = BoundingBoxHelper;
  	exports.EdgesHelper = EdgesHelper;
  	exports.WireframeHelper = WireframeHelper;
  	exports.XHRLoader = XHRLoader;
  	exports.BinaryTextureLoader = BinaryTextureLoader;
  	exports.GeometryUtils = GeometryUtils;
  	exports.Projector = Projector;
  	exports.CanvasRenderer = CanvasRenderer;
  	exports.JSONLoader = JSONLoader;
  	exports.SceneUtils = SceneUtils;
  	exports.LensFlare = LensFlare;

  	Object.defineProperty(exports, '__esModule', { value: true });

  }));
  });

  unwrapExports(three);
  var three_1 = three.AmbientLight;
  var three_2 = three.BackSide;
  var three_3 = three.Box2;
  var three_4 = three.Box3;
  var three_5 = three.BufferGeometry;
  var three_6 = three.Camera;
  var three_7 = three.Color;
  var three_8 = three.DirectionalLight;
  var three_9 = three.DoubleSide;
  var three_10 = three.FaceColors;
  var three_11 = three.Float32BufferAttribute;
  var three_12 = three.FrontSide;
  var three_13 = three.Frustum;
  var three_14 = three.Geometry;
  var three_15 = three.GridHelper;
  var three_16 = three.Object3D;
  var three_17 = three.Light;
  var three_18 = three.Line;
  var three_19 = three.LineBasicMaterial;
  var three_20 = three.LineSegments;
  var three_21 = three.Matrix3;
  var three_22 = three.Matrix4;
  var three_23 = three.Mesh;
  var three_24 = three.MeshNormalMaterial;
  var three_25 = three.PerspectiveCamera;
  var three_26 = three.Points;
  var three_27 = three.PointsMaterial;
  var three_28 = three.Scene;
  var three_29 = three.Sprite;
  var three_30 = three.Vector2;
  var three_31 = three.Vector3;
  var three_32 = three.Vector4;
  var three_33 = three.VertexColors;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author julianwa / https://github.com/julianwa
   */

  const installProjector = ({ BackSide, Box3, BufferGeometry, Color, DoubleSide, FaceColors, FrontSide, Frustum, Geometry, Light, Line, LineSegments, Matrix3, Matrix4, Mesh, Points, Sprite, Vector2, Vector3, Vector4, VertexColors }) => {
    const RenderableObject = function () {
    	this.id = 0;

    	this.object = null;
    	this.z = 0;
    	this.renderOrder = 0;
    };

    //

    const RenderableFace = function () {
    	this.id = 0;

    	this.v1 = new RenderableVertex();
    	this.v2 = new RenderableVertex();
    	this.v3 = new RenderableVertex();

    	this.normalModel = new Vector3();

    	this.vertexNormalsModel = [ new Vector3(), new Vector3(), new Vector3() ];
    	this.vertexNormalsLength = 0;

    	this.color = new Color();
    	this.material = null;
    	this.uvs = [ new Vector2(), new Vector2(), new Vector2() ];

    	this.z = 0;
    	this.renderOrder = 0;
    };

    //

    const RenderableVertex = function () {
    	this.position = new Vector3();
    	this.positionWorld = new Vector3();
    	this.positionScreen = new Vector4();

    	this.visible = true;
    };

    RenderableVertex.prototype.copy = function (vertex) {
    	this.positionWorld.copy(vertex.positionWorld);
    	this.positionScreen.copy(vertex.positionScreen);
    };

    //

    const RenderableLine = function () {
    	this.id = 0;

    	this.v1 = new RenderableVertex();
    	this.v2 = new RenderableVertex();

    	this.vertexColors = [ new Color(), new Color() ];
    	this.material = null;

    	this.z = 0;
    	this.renderOrder = 0;
    };

    //

    const RenderableSprite = function () {
    	this.id = 0;

    	this.object = null;

    	this.x = 0;
    	this.y = 0;
    	this.z = 0;

    	this.rotation = 0;
    	this.scale = new Vector2();

    	this.material = null;
    	this.renderOrder = 0;
    };

    //

    const Projector = function () {
    	var _object; var _objectCount; var _objectPool = []; var _objectPoolLength = 0;
    		var _vertex; var _vertexCount; var _vertexPool = []; var _vertexPoolLength = 0;
    		var _face; var _faceCount; var _facePool = []; var _facePoolLength = 0;
    		var _line; var _lineCount; var _linePool = []; var _linePoolLength = 0;
    		var _sprite; var _spriteCount; var _spritePool = []; var _spritePoolLength = 0;

    		var _renderData = { objects: [], lights: [], elements: [] };

    		var _vector3 = new Vector3();
    		var _vector4 = new Vector4();

    		var _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
    		var _boundingBox = new Box3();
    		var _points3 = new Array(3);

    		var _viewMatrix = new Matrix4();
    		var _viewProjectionMatrix = new Matrix4();

    		var _modelMatrix;
    		var _modelViewProjectionMatrix = new Matrix4();

    		var _normalMatrix = new Matrix3();

    		var _frustum = new Frustum();

    		var _clippedVertex1PositionScreen = new Vector4();
    		var _clippedVertex2PositionScreen = new Vector4();

    	//

    	this.projectVector = function (vector, camera) {
    		console.warn('THREE.Projector: .projectVector() is now vector.project().');
    		vector.project(camera);
    	};

    	this.unprojectVector = function (vector, camera) {
    		console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
    		vector.unproject(camera);
    	};

    	this.pickingRay = function () {
    		console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
    	};

    	//

    	var RenderList = function () {
    		var normals = [];
    		var colors = [];
    		var uvs = [];

    		var object = null;
    		var material = null;

    		var normalMatrix = new Matrix3();

    		function setObject (value) {
    			object = value;
    			material = object.material;

    			normalMatrix.getNormalMatrix(object.matrixWorld);

    			normals.length = 0;
    			colors.length = 0;
    			uvs.length = 0;
    		}

    		function projectVertex (vertex) {
    			var position = vertex.position;
    			var positionWorld = vertex.positionWorld;
    			var positionScreen = vertex.positionScreen;

    			positionWorld.copy(position).applyMatrix4(_modelMatrix);
    			positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);

    			var invW = 1 / positionScreen.w;

    			positionScreen.x *= invW;
    			positionScreen.y *= invW;
    			positionScreen.z *= invW;

    			vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&
    					 positionScreen.y >= -1 && positionScreen.y <= 1 &&
    					 positionScreen.z >= -1 && positionScreen.z <= 1;
    		}

    		function pushVertex (x, y, z) {
    			_vertex = getNextVertexInPool();
    			_vertex.position.set(x, y, z);

    			projectVertex(_vertex);
    		}

    		function pushNormal (x, y, z) {
    			normals.push(x, y, z);
    		}

    		function pushColor (r, g, b) {
    			colors.push(r, g, b);
    		}

    		function pushUv (x, y) {
    			uvs.push(x, y);
    		}

    		function checkTriangleVisibility (v1, v2, v3) {
    			if (v1.visible === true || v2.visible === true || v3.visible === true) return true;

    			_points3[ 0 ] = v1.positionScreen;
    			_points3[ 1 ] = v2.positionScreen;
    			_points3[ 2 ] = v3.positionScreen;

    			return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));
    		}

    		function checkBackfaceCulling (v1, v2, v3) {
    			return ((v3.positionScreen.x - v1.positionScreen.x) *
    				    (v2.positionScreen.y - v1.positionScreen.y) -
    				    (v3.positionScreen.y - v1.positionScreen.y) *
    				    (v2.positionScreen.x - v1.positionScreen.x)) < 0;
    		}

    		function pushLine (a, b) {
    			var v1 = _vertexPool[ a ];
    			var v2 = _vertexPool[ b ];

    			// Clip

    			v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);
    			v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);

    			if (clipLine(v1.positionScreen, v2.positionScreen) === true) {
    				// Perform the perspective divide
    				v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);
    				v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);

    				_line = getNextLineInPool();
    				_line.id = object.id;
    				_line.v1.copy(v1);
    				_line.v2.copy(v2);
    				_line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);
    				_line.renderOrder = object.renderOrder;

    				_line.material = object.material;

    				if (object.material.vertexColors === VertexColors) {
    					_line.vertexColors[ 0 ].fromArray(colors, a * 3);
    					_line.vertexColors[ 1 ].fromArray(colors, b * 3);
    				}

    				_renderData.elements.push(_line);
    			}
    		}

    		function pushTriangle (a, b, c, material) {
    			var v1 = _vertexPool[ a ];
    			var v2 = _vertexPool[ b ];
    			var v3 = _vertexPool[ c ];

    			if (checkTriangleVisibility(v1, v2, v3) === false) return;

    			if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {
    				_face = getNextFaceInPool();

    				_face.id = object.id;
    				_face.v1.copy(v1);
    				_face.v2.copy(v2);
    				_face.v3.copy(v3);
    				_face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
    				_face.renderOrder = object.renderOrder;

    				// face normal
    				_vector3.subVectors(v3.position, v2.position);
    				_vector4.subVectors(v1.position, v2.position);
    				_vector3.cross(_vector4);
    				_face.normalModel.copy(_vector3);
    				_face.normalModel.applyMatrix3(normalMatrix).normalize();

    				for (var i = 0; i < 3; i++) {
    					var normal = _face.vertexNormalsModel[ i ];
    					normal.fromArray(normals, arguments[ i ] * 3);
    					normal.applyMatrix3(normalMatrix).normalize();

    					var uv = _face.uvs[ i ];
    					uv.fromArray(uvs, arguments[ i ] * 2);
    				}

    				_face.vertexNormalsLength = 3;

    				_face.material = material;

    				if (material.vertexColors === FaceColors || material.vertexColors === VertexColors) {
    					_face.color.fromArray(colors, a * 3);
    				}

    				_renderData.elements.push(_face);
    			}
    		}

    		return {
    			setObject: setObject,
    			projectVertex: projectVertex,
    			checkTriangleVisibility: checkTriangleVisibility,
    			checkBackfaceCulling: checkBackfaceCulling,
    			pushVertex: pushVertex,
    			pushNormal: pushNormal,
    			pushColor: pushColor,
    			pushUv: pushUv,
    			pushLine: pushLine,
    			pushTriangle: pushTriangle
    		};
    	};

    	var renderList = new RenderList();

    	function projectObject (object) {
    		if (object.visible === false) return;

    		if (object instanceof Light) {
    			_renderData.lights.push(object);
    		} else if (object instanceof Mesh || object instanceof Line || object instanceof Points) {
    			if (object.material.visible === false) return;
    			if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;

    			addObject(object);
    		} else if (object instanceof Sprite) {
    			if (object.material.visible === false) return;
    			if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;

    			addObject(object);
    		}

    		var children = object.children;

    		for (var i = 0, l = children.length; i < l; i++) {
    			projectObject(children[ i ]);
    		}
    	}

    	function addObject (object) {
    		_object = getNextObjectInPool();
    		_object.id = object.id;
    		_object.object = object;

    		_vector3.setFromMatrixPosition(object.matrixWorld);
    		_vector3.applyMatrix4(_viewProjectionMatrix);
    		_object.z = _vector3.z;
    		_object.renderOrder = object.renderOrder;

    		_renderData.objects.push(_object);
    	}

    	this.projectScene = function (scene, camera, sortObjects, sortElements) {
    		_faceCount = 0;
    		_lineCount = 0;
    		_spriteCount = 0;

    		_renderData.elements.length = 0;

    		if (scene.autoUpdate === true) scene.updateMatrixWorld();
    		if (camera.parent === null) camera.updateMatrixWorld();

    		_viewMatrix.copy(camera.matrixWorldInverse);
    		_viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);

    		_frustum.setFromMatrix(_viewProjectionMatrix);

    		//

    		_objectCount = 0;

    		_renderData.objects.length = 0;
    		_renderData.lights.length = 0;

    		projectObject(scene);

    		if (sortObjects === true) {
    			_renderData.objects.sort(painterSort);
    		}

    		//

    		var objects = _renderData.objects;

    		for (var o = 0, ol = objects.length; o < ol; o++) {
    			var object = objects[ o ].object;
    			var geometry = object.geometry;

    			renderList.setObject(object);

    			_modelMatrix = object.matrixWorld;

    			_vertexCount = 0;

    			if (object instanceof Mesh) {
    				if (geometry instanceof BufferGeometry) {
    					var material = object.material;

    					var isMultiMaterial = Array.isArray(material);

    					var attributes = geometry.attributes;
    					var groups = geometry.groups;

    					if (attributes.position === undefined) continue;

    					var positions = attributes.position.array;

    					for (var i = 0, l = positions.length; i < l; i += 3) {
    						var x = positions[ i ];
    						var y = positions[ i + 1 ];
    						var z = positions[ i + 2 ];

    						if (material.morphTargets === true) {
    							var morphTargets = geometry.morphAttributes.position;
    							var morphInfluences = object.morphTargetInfluences;

    							for (var t = 0, tl = morphTargets.length; t < tl; t++) {
    								var influence = morphInfluences[ t ];

    								if (influence === 0) continue;

    								var target = morphTargets[ t ];

    								x += (target.getX(i / 3) - positions[ i ]) * influence;
    								y += (target.getY(i / 3) - positions[ i + 1 ]) * influence;
    								z += (target.getZ(i / 3) - positions[ i + 2 ]) * influence;
    							}
    						}

    						renderList.pushVertex(x, y, z);
    					}

    					if (attributes.normal !== undefined) {
    						var normals = attributes.normal.array;

    						for (var i = 0, l = normals.length; i < l; i += 3) {
    							renderList.pushNormal(normals[ i ], normals[ i + 1 ], normals[ i + 2 ]);
    						}
    					}

    					if (attributes.color !== undefined) {
    						var colors = attributes.color.array;

    						for (var i = 0, l = colors.length; i < l; i += 3) {
    							renderList.pushColor(colors[ i ], colors[ i + 1 ], colors[ i + 2 ]);
    						}
    					}

    					if (attributes.uv !== undefined) {
    						var uvs = attributes.uv.array;

    						for (var i = 0, l = uvs.length; i < l; i += 2) {
    							renderList.pushUv(uvs[ i ], uvs[ i + 1 ]);
    						}
    					}

    					if (geometry.index !== null) {
    						var indices = geometry.index.array;

    						if (groups.length > 0) {
    							for (var g = 0; g < groups.length; g++) {
    								var group = groups[ g ];

    								material = isMultiMaterial === true
    									 ? object.material[ group.materialIndex ]
    									 : object.material;

    								if (material === undefined) continue;

    								for (var i = group.start, l = group.start + group.count; i < l; i += 3) {
    									renderList.pushTriangle(indices[ i ], indices[ i + 1 ], indices[ i + 2 ], material);
    								}
    							}
    						} else {
    							for (var i = 0, l = indices.length; i < l; i += 3) {
    								renderList.pushTriangle(indices[ i ], indices[ i + 1 ], indices[ i + 2 ], material);
    							}
    						}
    					} else {
    						if (groups.length > 0) {
    							for (var g = 0; g < groups.length; g++) {
    								var group = groups[ g ];

    								material = isMultiMaterial === true
    									 ? object.material[ group.materialIndex ]
    									 : object.material;

    								if (material === undefined) continue;

    								for (var i = group.start, l = group.start + group.count; i < l; i += 3) {
    									renderList.pushTriangle(i, i + 1, i + 2, material);
    								}
    							}
    						} else {
    							for (var i = 0, l = positions.length / 3; i < l; i += 3) {
    								renderList.pushTriangle(i, i + 1, i + 2, material);
    							}
    						}
    					}
    				} else if (geometry instanceof Geometry) {
    					var vertices = geometry.vertices;
    					var faces = geometry.faces;
    					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];

    					_normalMatrix.getNormalMatrix(_modelMatrix);

    					var material = object.material;

    					var isMultiMaterial = Array.isArray(material);

    					for (var v = 0, vl = vertices.length; v < vl; v++) {
    						var vertex = vertices[ v ];

    						_vector3.copy(vertex);

    						if (material.morphTargets === true) {
    							var morphTargets = geometry.morphTargets;
    							var morphInfluences = object.morphTargetInfluences;

    							for (var t = 0, tl = morphTargets.length; t < tl; t++) {
    								var influence = morphInfluences[ t ];

    								if (influence === 0) continue;

    								var target = morphTargets[ t ];
    								var targetVertex = target.vertices[ v ];

    								_vector3.x += (targetVertex.x - vertex.x) * influence;
    								_vector3.y += (targetVertex.y - vertex.y) * influence;
    								_vector3.z += (targetVertex.z - vertex.z) * influence;
    							}
    						}

    						renderList.pushVertex(_vector3.x, _vector3.y, _vector3.z);
    					}

    					for (var f = 0, fl = faces.length; f < fl; f++) {
    						var face = faces[ f ];

    						material = isMultiMaterial === true
    							 ? object.material[ face.materialIndex ]
    							 : object.material;

    						if (material === undefined) continue;

    						var side = material.side;

    						var v1 = _vertexPool[ face.a ];
    						var v2 = _vertexPool[ face.b ];
    						var v3 = _vertexPool[ face.c ];

    						if (renderList.checkTriangleVisibility(v1, v2, v3) === false) continue;

    						var visible = renderList.checkBackfaceCulling(v1, v2, v3);

    						if (side !== DoubleSide) {
    							if (side === FrontSide && visible === false) continue;
    							if (side === BackSide && visible === true) continue;
    						}

    						_face = getNextFaceInPool();

    						_face.id = object.id;
    						_face.v1.copy(v1);
    						_face.v2.copy(v2);
    						_face.v3.copy(v3);

    						_face.normalModel.copy(face.normal);

    						if (visible === false && (side === BackSide || side === DoubleSide)) {
    							_face.normalModel.negate();
    						}

    						_face.normalModel.applyMatrix3(_normalMatrix).normalize();

    						var faceVertexNormals = face.vertexNormals;

    						for (var n = 0, nl = Math.min(faceVertexNormals.length, 3); n < nl; n++) {
    							var normalModel = _face.vertexNormalsModel[ n ];
    							normalModel.copy(faceVertexNormals[ n ]);

    							if (visible === false && (side === BackSide || side === DoubleSide)) {
    								normalModel.negate();
    							}

    							normalModel.applyMatrix3(_normalMatrix).normalize();
    						}

    						_face.vertexNormalsLength = faceVertexNormals.length;

    						var vertexUvs = faceVertexUvs[ f ];

    						if (vertexUvs !== undefined) {
    							for (var u = 0; u < 3; u++) {
    								_face.uvs[ u ].copy(vertexUvs[ u ]);
    							}
    						}

    						_face.color = face.color;
    						_face.material = material;

    						_face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;
    						_face.renderOrder = object.renderOrder;

    						_renderData.elements.push(_face);
    					}
    				}
    			} else if (object instanceof Line) {
    				_modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);

    				if (geometry instanceof BufferGeometry) {
    					var attributes = geometry.attributes;

    					if (attributes.position !== undefined) {
    						var positions = attributes.position.array;

    						for (var i = 0, l = positions.length; i < l; i += 3) {
    							renderList.pushVertex(positions[ i ], positions[ i + 1 ], positions[ i + 2 ]);
    						}

    						if (attributes.color !== undefined) {
    							var colors = attributes.color.array;

    							for (var i = 0, l = colors.length; i < l; i += 3) {
    								renderList.pushColor(colors[ i ], colors[ i + 1 ], colors[ i + 2 ]);
    							}
    						}

    						if (geometry.index !== null) {
    							var indices = geometry.index.array;

    							for (var i = 0, l = indices.length; i < l; i += 2) {
    								renderList.pushLine(indices[ i ], indices[ i + 1 ]);
    							}
    						} else {
    							var step = object instanceof LineSegments ? 2 : 1;

    							for (var i = 0, l = (positions.length / 3) - 1; i < l; i += step) {
    								renderList.pushLine(i, i + 1);
    							}
    						}
    					}
    				} else if (geometry instanceof Geometry) {
    					var vertices = object.geometry.vertices;

    					if (vertices.length === 0) continue;

    					v1 = getNextVertexInPool();
    					v1.positionScreen.copy(vertices[ 0 ]).applyMatrix4(_modelViewProjectionMatrix);

    					var step = object instanceof LineSegments ? 2 : 1;

    					for (var v = 1, vl = vertices.length; v < vl; v++) {
    						v1 = getNextVertexInPool();
    						v1.positionScreen.copy(vertices[ v ]).applyMatrix4(_modelViewProjectionMatrix);

    						if ((v + 1) % step > 0) continue;

    						v2 = _vertexPool[ _vertexCount - 2 ];

    						_clippedVertex1PositionScreen.copy(v1.positionScreen);
    						_clippedVertex2PositionScreen.copy(v2.positionScreen);

    						if (clipLine(_clippedVertex1PositionScreen, _clippedVertex2PositionScreen) === true) {
    							// Perform the perspective divide
    							_clippedVertex1PositionScreen.multiplyScalar(1 / _clippedVertex1PositionScreen.w);
    							_clippedVertex2PositionScreen.multiplyScalar(1 / _clippedVertex2PositionScreen.w);

    							_line = getNextLineInPool();

    							_line.id = object.id;
    							_line.v1.positionScreen.copy(_clippedVertex1PositionScreen);
    							_line.v2.positionScreen.copy(_clippedVertex2PositionScreen);

    							_line.z = Math.max(_clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z);
    							_line.renderOrder = object.renderOrder;

    							_line.material = object.material;

    							if (object.material.vertexColors === VertexColors) {
    								_line.vertexColors[ 0 ].copy(object.geometry.colors[ v ]);
    								_line.vertexColors[ 1 ].copy(object.geometry.colors[ v - 1 ]);
    							}

    							_renderData.elements.push(_line);
    						}
    					}
    				}
    			} else if (object instanceof Points) {
    				_modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);

    				if (geometry instanceof Geometry) {
    					var vertices = object.geometry.vertices;

    					for (var v = 0, vl = vertices.length; v < vl; v++) {
    						var vertex = vertices[ v ];

    						_vector4.set(vertex.x, vertex.y, vertex.z, 1);
    						_vector4.applyMatrix4(_modelViewProjectionMatrix);

    						pushPoint(_vector4, object, camera);
    					}
    				} else if (geometry instanceof BufferGeometry) {
    					var attributes = geometry.attributes;

    					if (attributes.position !== undefined) {
    						var positions = attributes.position.array;

    						for (var i = 0, l = positions.length; i < l; i += 3) {
    							_vector4.set(positions[ i ], positions[ i + 1 ], positions[ i + 2 ], 1);
    							_vector4.applyMatrix4(_modelViewProjectionMatrix);

    							pushPoint(_vector4, object, camera);
    						}
    					}
    				}
    			} else if (object instanceof Sprite) {
    				object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    				_vector4.set(_modelMatrix.elements[ 12 ], _modelMatrix.elements[ 13 ], _modelMatrix.elements[ 14 ], 1);
    				_vector4.applyMatrix4(_viewProjectionMatrix);

    				pushPoint(_vector4, object, camera);
    			}
    		}

    		if (sortElements === true) {
    			_renderData.elements.sort(painterSort);
    		}

    		return _renderData;
    	};

    	function pushPoint (_vector4, object, camera) {
    		var invW = 1 / _vector4.w;

    		_vector4.z *= invW;

    		if (_vector4.z >= -1 && _vector4.z <= 1) {
    			_sprite = getNextSpriteInPool();
    			_sprite.id = object.id;
    			_sprite.x = _vector4.x * invW;
    			_sprite.y = _vector4.y * invW;
    			_sprite.z = _vector4.z;
    			_sprite.renderOrder = object.renderOrder;
    			_sprite.object = object;

    			_sprite.rotation = object.rotation;

    			_sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[ 0 ]) / (_vector4.w + camera.projectionMatrix.elements[ 12 ]));
    			_sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[ 5 ]) / (_vector4.w + camera.projectionMatrix.elements[ 13 ]));

    			_sprite.material = object.material;

    			_renderData.elements.push(_sprite);
    		}
    	}

    	// Pools

    	function getNextObjectInPool () {
    		if (_objectCount === _objectPoolLength) {
    			var object = new RenderableObject();
    			_objectPool.push(object);
    			_objectPoolLength++;
    			_objectCount++;
    			return object;
    		}

    		return _objectPool[ _objectCount++ ];
    	}

    	function getNextVertexInPool () {
    		if (_vertexCount === _vertexPoolLength) {
    			var vertex = new RenderableVertex();
    			_vertexPool.push(vertex);
    			_vertexPoolLength++;
    			_vertexCount++;
    			return vertex;
    		}

    		return _vertexPool[ _vertexCount++ ];
    	}

    	function getNextFaceInPool () {
    		if (_faceCount === _facePoolLength) {
    			var face = new RenderableFace();
    			_facePool.push(face);
    			_facePoolLength++;
    			_faceCount++;
    			return face;
    		}

    		return _facePool[ _faceCount++ ];
    	}

    	function getNextLineInPool () {
    		if (_lineCount === _linePoolLength) {
    			var line = new RenderableLine();
    			_linePool.push(line);
    			_linePoolLength++;
    			_lineCount++;
    			return line;
    		}

    		return _linePool[ _lineCount++ ];
    	}

    	function getNextSpriteInPool () {
    		if (_spriteCount === _spritePoolLength) {
    			var sprite = new RenderableSprite();
    			_spritePool.push(sprite);
    			_spritePoolLength++;
    			_spriteCount++;
    			return sprite;
    		}

    		return _spritePool[ _spriteCount++ ];
    	}

    	//

    	function painterSort (a, b) {
    		if (a.renderOrder !== b.renderOrder) {
    			return a.renderOrder - b.renderOrder;
    		} else if (a.z !== b.z) {
    			return b.z - a.z;
    		} else if (a.id !== b.id) {
    			return a.id - b.id;
    		} else {
    			return 0;
    		}
    	}

    	function clipLine (s1, s2) {
    		var alpha1 = 0; var alpha2 = 1;

    			// Calculate the boundary coordinate of each vertex for the near and far clip planes,
    			// Z = -1 and Z = +1, respectively.

    			var bc1near = s1.z + s1.w;
    			var bc2near = s2.z + s2.w;
    			var bc1far = -s1.z + s1.w;
    			var bc2far = -s2.z + s2.w;

    		if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {
    			// Both vertices lie entirely within all clip planes.
    			return true;
    		} else if ((bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0)) {
    			// Both vertices lie entirely outside one of the clip planes.
    			return false;
    		} else {
    			// The line segment spans at least one clip plane.

    			if (bc1near < 0) {
    				// v1 lies outside the near plane, v2 inside
    				alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));
    			} else if (bc2near < 0) {
    				// v2 lies outside the near plane, v1 inside
    				alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));
    			}

    			if (bc1far < 0) {
    				// v1 lies outside the far plane, v2 inside
    				alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));
    			} else if (bc2far < 0) {
    				// v2 lies outside the far plane, v2 inside
    				alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));
    			}

    			if (alpha2 < alpha1) {
    				// The line segment spans two boundaries, but is outside both of them.
    				// (This can't happen when we're only clipping against just near/far but good
    				//  to leave the check here for future usage if other clip planes are added.)
    				return false;
    			} else {
    				// Update the s1 and s2 vertices to match the clipped line segment.
    				s1.lerp(s2, alpha1);
    				s2.lerp(s1, 1 - alpha2);

    				return true;
    			}
    		}
    	}
    };

    return { Projector, RenderableObject, RenderableFace, RenderableVertex, RenderableLine, RenderableSprite };
  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  const installSVGRenderer = ({ Box2, Camera, Color, FaceColors, Object3D, Matrix3, Matrix4, Projector, RenderableSprite, RenderableLine, RenderableFace, Vector3, VertexColors, document }) => {
    const SVGObject = function (node) {
    	Object3D.call(this);

    	this.node = node;
    };

    SVGObject.prototype = Object.create(Object3D.prototype);
    SVGObject.prototype.constructor = SVGObject;

    const SVGRenderer = function () {
    	var _this = this;
    		var _renderData; var _elements; var _lights;
    		var _projector = new Projector();
    		var _svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    		var _svgWidth; var _svgHeight; var _svgWidthHalf; var _svgHeightHalf;

    		var _v1; var _v2; var _v3;

    		var _clipBox = new Box2();
    		var _elemBox = new Box2();

    		var _color = new Color();
    		var _diffuseColor = new Color();
    		var _ambientLight = new Color();
    		var _directionalLights = new Color();
    		var _pointLights = new Color();
    		var _clearColor = new Color();
    		var _clearAlpha = 1;

    		var _vector3 = new Vector3(); // Needed for PointLight
    		var _centroid = new Vector3();
    		var _normal = new Vector3();
    		var _normalViewMatrix = new Matrix3();

    		var _viewMatrix = new Matrix4();
    		var _viewProjectionMatrix = new Matrix4();

    		var _svgPathPool = [];
    		var _svgNode; var _pathCount = 0;

    		var _currentPath; var _currentStyle;

    		var _quality = 1; var _precision = null;

      if (_svg.style === undefined) {
        // FIX: Is this correct?
        _svg.style = {};
      }

    	this.domElement = _svg;

    	this.autoClear = true;
    	this.sortObjects = true;
    	this.sortElements = true;

    	this.info = {

    		render: {

    			vertices: 0,
    			faces: 0

    		}

    	};

    	this.setQuality = function (quality) {
    		switch (quality) {
    			case 'high': _quality = 1; break;
    			case 'low': _quality = 0; break;
    		}
    	};

    	this.setClearColor = function (color, alpha) {
    		_clearColor.set(color);
    		_clearAlpha = alpha !== undefined ? alpha : 1;
    	};

    	this.setPixelRatio = function () {};

    	this.setSize = function (width, height) {
    		_svgWidth = width; _svgHeight = height;
    		_svgWidthHalf = _svgWidth / 2; _svgHeightHalf = _svgHeight / 2;

    		_svg.setAttribute('viewBox', (-_svgWidthHalf) + ' ' + (-_svgHeightHalf) + ' ' + _svgWidth + ' ' + _svgHeight);
    		_svg.setAttribute('width', _svgWidth);
    		_svg.setAttribute('height', _svgHeight);

    		_clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf);
    		_clipBox.max.set(_svgWidthHalf, _svgHeightHalf);
    	};

    	this.setPrecision = function (precision) {
    		_precision = precision;
    	};

    	function removeChildNodes () {
    		_pathCount = 0;

    		while (_svg.childNodes.length > 0) {
    			_svg.removeChild(_svg.childNodes[ 0 ]);
    		}
    	}

    	function getSvgColor (color, opacity) {
    		var arg = Math.floor(color.r * 255) + ',' + Math.floor(color.g * 255) + ',' + Math.floor(color.b * 255);

    		if (opacity === undefined || opacity === 1) return 'rgb(' + arg + ')';

    		return 'rgb(' + arg + '); fill-opacity: ' + opacity;
    	}

    	function convert (c) {
    		return _precision !== null ? c.toFixed(_precision) : c;
    	}

    	this.clear = function () {
    		removeChildNodes();
    		_svg.style.backgroundColor = getSvgColor(_clearColor, _clearAlpha);
    	};

    	this.render = function (scene, camera) {
    		if (camera instanceof Camera === false) {
    			console.error('THREE.SVGRenderer.render: camera is not an instance of THREE.Camera.');
    			return;
    		}

    		var background = scene.background;

    		if (background && background.isColor) {
    			removeChildNodes();
    			_svg.style.backgroundColor = getSvgColor(background);
    		} else if (this.autoClear === true) {
    			this.clear();
    		}

    		_this.info.render.vertices = 0;
    		_this.info.render.faces = 0;

    		_viewMatrix.copy(camera.matrixWorldInverse);
    		_viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);

    		_renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);
    		_elements = _renderData.elements;
    		_lights = _renderData.lights;

    		_normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);

    		calculateLights(_lights);

    		 // reset accumulated path

    		_currentPath = '';
    		_currentStyle = '';

    		for (var e = 0, el = _elements.length; e < el; e++) {
    			var element = _elements[ e ];
    			var material = element.material;

    			if (material === undefined || material.opacity === 0) continue;

    			_elemBox.makeEmpty();

    			if (element instanceof RenderableSprite) {
    				_v1 = element;
    				_v1.x *= _svgWidthHalf; _v1.y *= -_svgHeightHalf;

    				renderSprite(_v1, element, material);
    			} else if (element instanceof RenderableLine) {
    				_v1 = element.v1; _v2 = element.v2;

    				_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= -_svgHeightHalf;
    				_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= -_svgHeightHalf;

    				_elemBox.setFromPoints([ _v1.positionScreen, _v2.positionScreen ]);

    				if (_clipBox.intersectsBox(_elemBox) === true) {
    					renderLine(_v1, _v2, element, material);
    				}
    			} else if (element instanceof RenderableFace) {
    				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

    				if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;
    				if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;
    				if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;

    				_v1.positionScreen.x *= _svgWidthHalf; _v1.positionScreen.y *= -_svgHeightHalf;
    				_v2.positionScreen.x *= _svgWidthHalf; _v2.positionScreen.y *= -_svgHeightHalf;
    				_v3.positionScreen.x *= _svgWidthHalf; _v3.positionScreen.y *= -_svgHeightHalf;

    				_elemBox.setFromPoints([
    					_v1.positionScreen,
    					_v2.positionScreen,
    					_v3.positionScreen
    				]);

    				if (_clipBox.intersectsBox(_elemBox) === true) {
    					renderFace3(_v1, _v2, _v3, element, material);
    				}
    			}
    		}

    		flushPath(); // just to flush last svg:path

    		scene.traverseVisible(function (object) {
    			 if (object instanceof SVGObject) {
    				_vector3.setFromMatrixPosition(object.matrixWorld);
    				_vector3.applyMatrix4(_viewProjectionMatrix);

    				if (_vector3.z < -1 || _vector3.z > 1) return;

    				var x = _vector3.x * _svgWidthHalf;
    				var y = -_vector3.y * _svgHeightHalf;

    				var node = object.node;
    				node.setAttribute('transform', 'translate(' + x + ',' + y + ')');

    				_svg.appendChild(node);
    			}
    		});
    	};

    	function calculateLights (lights) {
    		_ambientLight.setRGB(0, 0, 0);
    		_directionalLights.setRGB(0, 0, 0);
    		_pointLights.setRGB(0, 0, 0);

    		for (var l = 0, ll = lights.length; l < ll; l++) {
    			var light = lights[ l ];
    			var lightColor = light.color;

    			if (light.isAmbientLight) {
    				_ambientLight.r += lightColor.r;
    				_ambientLight.g += lightColor.g;
    				_ambientLight.b += lightColor.b;
    			} else if (light.isDirectionalLight) {
    				_directionalLights.r += lightColor.r;
    				_directionalLights.g += lightColor.g;
    				_directionalLights.b += lightColor.b;
    			} else if (light.isPointLight) {
    				_pointLights.r += lightColor.r;
    				_pointLights.g += lightColor.g;
    				_pointLights.b += lightColor.b;
    			}
    		}
    	}

    	function calculateLight (lights, position, normal, color) {
    		for (var l = 0, ll = lights.length; l < ll; l++) {
    			var light = lights[ l ];
    			var lightColor = light.color;

    			if (light.isDirectionalLight) {
    				var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();

    				var amount = normal.dot(lightPosition);

    				if (amount <= 0) continue;

    				amount *= light.intensity;

    				color.r += lightColor.r * amount;
    				color.g += lightColor.g * amount;
    				color.b += lightColor.b * amount;
    			} else if (light.isPointLight) {
    				var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);

    				var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());

    				if (amount <= 0) continue;

    				amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);

    				if (amount == 0) continue;

    				amount *= light.intensity;

    				color.r += lightColor.r * amount;
    				color.g += lightColor.g * amount;
    				color.b += lightColor.b * amount;
    			}
    		}
    	}

    	function renderSprite (v1, element, material) {
    		var scaleX = element.scale.x * _svgWidthHalf;
    		var scaleY = element.scale.y * _svgHeightHalf;

    		if (material.isPointsMaterial) {
    			scaleX *= material.size;
    			scaleY *= material.size;
    		}

    		var path = 'M' + convert(v1.x - scaleX * 0.5) + ',' + convert(v1.y - scaleY * 0.5) + 'h' + convert(scaleX) + 'v' + convert(scaleY) + 'h' + convert(-scaleX) + 'z';
    		var style = '';

    		if (material.isSpriteMaterial || material.isPointsMaterial) {
    			style = 'fill:' + getSvgColor(material.color, material.opacity);
    		}

    		addPath(style, path);
    	}

    	function renderLine (v1, v2, element, material) {
    		var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y);

    		if (material.isLineBasicMaterial) {
    			var style = 'fill:none;stroke:' + getSvgColor(material.color, material.opacity) + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;

    			if (material.isLineDashedMaterial) {
    				style = style + ';stroke-dasharray:' + material.dashSize + ',' + material.gapSize;
    			}

    			addPath(style, path);
    		}
    	}

    	function renderFace3 (v1, v2, v3, element, material) {
    		_this.info.render.vertices += 3;
    		_this.info.render.faces++;

    		var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y) + 'L' + convert(v3.positionScreen.x) + ',' + convert(v3.positionScreen.y) + 'z';
    		var style = '';

    		if (material.isMeshBasicMaterial) {
    			_color.copy(material.color);

    			if (material.vertexColors === FaceColors || material.vertexColors === VertexColors) {
    				_color.multiply(element.color);
    			}
    		} else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {
    			_diffuseColor.copy(material.color);

    			if (material.vertexColors === FaceColors || material.vertexColors === VertexColors) {
    				_diffuseColor.multiply(element.color);
    			}

    			_color.copy(_ambientLight);

    			_centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);

    			calculateLight(_lights, _centroid, element.normalModel, _color);

    			_color.multiply(_diffuseColor).add(material.emissive);
    		} else if (material.isMeshNormalMaterial) {
    			_normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix);

    			_color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);
    		}

    		if (material.wireframe) {
    			style = 'fill:none;stroke:' + getSvgColor(_color, material.opacity) + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;
    		} else {
    			style = 'fill:' + getSvgColor(_color, material.opacity);
    		}

    		addPath(style, path);
    	}

    	function addPath (style, path) {
    		if (_currentStyle === style) {
    			_currentPath += path;
    		} else {
    			flushPath();

    			_currentStyle = style;
    			_currentPath = path;
    		}
    	}

    	function flushPath () {
    		if (_currentPath) {
    			_svgNode = getPathNode(_pathCount++);
    			_svgNode.setAttribute('d', _currentPath);
    			_svgNode.setAttribute('style', _currentStyle);
    			_svg.appendChild(_svgNode);
    		}

    		_currentPath = '';
    		_currentStyle = '';
    	}

    	function getPathNode (id) {
    		if (_svgPathPool[ id ] == null) {
    			_svgPathPool[ id ] = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    			if (_quality == 0) {
    				_svgPathPool[ id ].setAttribute('shape-rendering', 'crispEdges'); // optimizeSpeed
    			}

    			return _svgPathPool[ id ];
    		}

    		return _svgPathPool[ id ];
    	}
    };

    return { SVGRenderer };
  };

  const pointsToThreejsPoints = (geometry) => {
    return geometry.points;
  };

  const pathsToThreejsSegments = (geometry) => {
    const segments = [];
    for (const path of geometry) {
      for (const [start, end] of toSegments({}, path)) {
        segments.push([start, end]);
      }
    }
    return segments;
  };

  const solidToThreejsSolid = (solid) => {
    const normals = [];
    const positions = [];
    for (const surface of solid) {
      for (const triangle of toTriangles({}, surface)) {
        for (const point of triangle) {
          const plane = toPlane(triangle);
          if (plane === undefined) continue;
          const [x, y, z] = plane;
          normals.push(x, y, z);
          positions.push(...point);
        }
      }
    }
    return { normals, positions };
  };

  const surfaceToThreejsSurface = (surface) => {
    const normals = [];
    const positions = [];
    for (const triangle of toTriangles({}, makeConvex$1(surface))) {
      for (const point of triangle) {
        const plane = toPlane(triangle);
        if (plane === undefined) continue;
        const [x, y, z] = plane;
        normals.push(x, y, z);
        positions.push(...point);
      }
    }
    return { normals, positions };
  };

  const toThreejsGeometry = (geometry, supertags) => {
    const tags = [...(supertags || []), ...(geometry.tags || [])];
    if (geometry.isThreejsGeometry) {
      return geometry;
    } else if (geometry.assembly) {
      return {
        assembly: geometry.assembly.map(item => toThreejsGeometry(item, tags)),
        tags,
        isThreejsGeometry: true
      };
    } else if (geometry.disjointAssembly) {
      const items = geometry.disjointAssembly;
      return {
        assembly: items.map(item => toThreejsGeometry(item, tags)),
        tags,
        isThreejsGeometry: true
      };
    } else if (geometry.layers) {
      return {
        assembly: geometry.layers.map(item => toThreejsGeometry(item, tags)),
        tags,
        isThreejsGeometry: true
      };
    } else if (geometry.item) {
      return {
        item: toThreejsGeometry(geometry.item, tags),
        tags,
        isThreejsGeometry: true
      };
    } else if (geometry.connection) {
      return {
        assembly: geometry.geometries.map(item => toThreejsGeometry(item, tags)),
        tags,
        isThreejsGeometry: true
      };
    } else if (geometry.paths) {
      return { threejsSegments: pathsToThreejsSegments(geometry.paths), tags, isThreejsGeometry: true };
    } else if (geometry.plan) {
      return {
        threejsPlan: geometry.plan,
        threejsMarks: geometry.marks,
        threejsVisualization: toThreejsGeometry(geometry.visualization),
        threejsContent: toThreejsGeometry(geometry.content),
        tags,
        isThreejsGeometry: true
      };
    } else if (geometry.points) {
      return { threejsSegments: pointsToThreejsPoints(geometry.points), tags, isThreejsGeometry: true };
    } else if (geometry.solid) {
      return { threejsSolid: solidToThreejsSolid(geometry.solid), tags, isThreejsGeometry: true };
    } else if (geometry.surface) {
      return { threejsSurface: surfaceToThreejsSurface(geometry.surface), tags, isThreejsGeometry: true };
    } else if (geometry.z0Surface) {
      return { threejsSurface: surfaceToThreejsSurface(geometry.z0Surface), tags, isThreejsGeometry: true };
    }
  };

  // Bootstrap start.
  const { Projector, RenderableFace, RenderableLine, RenderableSprite } = installProjector({
    BackSide: three_2,
    Box3: three_4,
    BufferGeometry: three_5,
    Color: three_7,
    DoubleSide: three_9,
    FaceColors: three_10,
    FrontSide: three_12,
    Frustum: three_13,
    Geometry: three_14,
    Light: three_17,
    Line: three_18,
    LineSegments: three_20,
    Matrix3: three_21,
    Matrix4: three_22,
    Mesh: three_23,
    Points: three_26,
    Sprite: three_29,
    Vector2: three_30,
    Vector3: three_31,
    Vector4: three_32,
    VertexColors: three_33
  });

  const { SVGRenderer } = installSVGRenderer({
    Box2: three_3,
    Camera: three_6,
    Color: three_7,
    FaceColors: three_10,
    Object3D: three_16,
    Matrix3: three_21,
    Matrix4: three_22,
    Projector,
    RenderableSprite,
    RenderableLine,
    RenderableFace,
    Vector3: three_31,
    VertexColors: three_33,
    document: new domParser_3().parseFromString('<xml></xml>', 'text/xml')
  });
  // Bootstrap done.

  const build = ({ view = {}, pageSize = [100, 100], grid = false }, geometry) => {
    const { target = [0, 0, 0], position = [40, 40, 40], up = [0, 0, 1], near = 1, far = 3500 } = view;
    const [pageWidth, pageHeight] = pageSize;
    const camera = new three_25(27, pageWidth / pageHeight, near, far);
    [camera.position.x, camera.position.y, camera.position.z] = position;
    camera.up = new three_31(...up);
    camera.lookAt(...target);
    const scene = new three_28();
    scene.background = new three_7(0xffffff);
    scene.add(camera);
    if (grid) {
      const grid = new three_15(100, 10, 'green', 'blue');
      grid.material = new three_19({ color: 0x000000 });
      grid.rotation.x = -Math.PI / 2;
      grid.position.x = 0;
      grid.position.y = 0;
      grid.position.z = 0;
      scene.add(grid);
    }
    //
    var ambientLight = new three_1(0x222222);
    scene.add(ambientLight);
    var light = new three_8(0xffffff, 1);
    light.position.set(1, 1, 1);
    camera.add(light);

    const walk = (geometry) => {
      if (geometry.assembly) {
        geometry.assembly.forEach(walk);
      } else if (geometry.disjointAssembly) {
        geometry.disjointAssembly.forEach(walk);
      } else if (geometry.threejsPoints) {
        const points = geometry.threejsPoints;
        const threejsGeometry = new three_14();
        const material = new three_27({ color: 0x0000ff });
        for (const [x, y, z] of points) {
          threejsGeometry.vertices.push(new three_31(x, y, z));
        }
        scene.add(new three_26(threejsGeometry, material));
      } else if (geometry.threejsSegments) {
        const segments = geometry.threejsSegments;
        const threejsGeometry = new three_14();
        const material = new three_19({ color: 0xff0000 });
        for (const [[aX, aY, aZ], [bX, bY, bZ]] of segments) {
          threejsGeometry.vertices.push(new three_31(aX, aY, aZ), new three_31(bX, bY, bZ));
        }
        scene.add(new three_20(threejsGeometry, material));
      } else if (geometry.threejsSolid) {
        const { positions, normals } = geometry.threejsSolid;
        const threejsGeometry = new three_5();
        threejsGeometry.addAttribute('position', new three_11(positions, 3));
        threejsGeometry.addAttribute('normal', new three_11(normals, 3));
        const material = new three_24();
        scene.add(new three_23(threejsGeometry, material));
      } else if (geometry.threejsSurface) {
        const { positions, normals } = geometry.threejsSurface;
        const threejsGeometry = new three_5();
        threejsGeometry.addAttribute('position', new three_11(positions, 3));
        threejsGeometry.addAttribute('normal', new three_11(normals, 3));
        const material = new three_24();
        scene.add(new three_23(threejsGeometry, material));
      }
    };
    const threejsGeometry = toThreejsGeometry(geometry);
    walk(toThreejsGeometry(threejsGeometry));

    return [scene, camera];
  };

  const toSvg$2 = async (options = {}, geometry) => toSvgSync(options, geometry);

  const header$1 =
`<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by jsxcad -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">
`  ;

  const toSvgSync = (options = {}, geometry) => {
    const keptGeometry = toKeptGeometry(geometry);
    const [scene, camera] = build(options, keptGeometry);
    const { includeXmlHeader = true, pageSize = [500, 500] } = options;
    const [pageWidth, pageHeight] = pageSize;

    const renderer = new SVGRenderer({});
    renderer.setSize(pageWidth, pageHeight);
    renderer.render(scene, camera);

    const serializer = new domParser_2();
    let svg = serializer.serializeToString(renderer.domElement) + '\n';
    if (includeXmlHeader) {
      svg = header$1 + svg;
    }
    return new TextEncoder('utf8').encode(svg);
  };

  /* global postMessage, onmessage:writable, self */

  const say = (message) => postMessage(message);
  const agent = async ({ ask, question }) => {
    try {
      var { key, values } = question;
      clearCache();
      switch (key) {
        case 'assemble':
          var inputs = values[0].map(Shape.fromGeometry);
          return Assembly(...inputs).toDisjointGeometry();
        case 'bounding box':
          return Shape.fromGeometry(values[0]).measureBoundingBox();
        case 'circle':
          return Circle.ofDiameter(values[0], { sides: values[1] }).toDisjointGeometry();// {center: true, sides: values[1] }).toDisjointGeometry();
        case 'color':
          if (values[1] === 'Keep Out') {
            return Shape.fromGeometry(values[0]).color('Red').material('keepout').toDisjointGeometry();
          } else {
            return Shape.fromGeometry(values[0]).color(values[1]).toDisjointGeometry();
          }
        case 'code':
          inputs = {};
          for (key in values[1]) {
            if (values[1][key] != null && typeof values[1][key] === 'object') {
              inputs[key] = Shape.fromGeometry(values[1][key]);
            } else {
              inputs[key] = values[1][key];
            }
          }
          const signature = '{ ' + Object.keys(api$1).join(', ') + ', ' + Object.keys(inputs).join(', ') + ' }';
          const foo = new Function(signature, values[0]);
          const returnVal = foo({ ...api$1, ...inputs });
          if (typeof returnVal === 'object') {
            return returnVal.toDisjointGeometry();
          } else {
            return returnVal;
          }
        case 'layout':
          console.log('Doing layout');
          const solidToSplit = Shape.fromGeometry(values[0]);
          var flatItems = [];
          solidToSplit.items().forEach(item => {
            flatItems.push(item.flat().to(Z$k(0)));
          });
          
          console.log(flatItems);
          
          const laidOut = Layers(...flatItems).Page();
          
          return laidOut.toDisjointGeometry();
        case 'difference':
          return Shape.fromGeometry(values[0]).cut(Shape.fromGeometry(values[1])).kept().toDisjointGeometry();
        case 'extractTag':
          return Shape.fromGeometry(values[0]).keep(values[1]).toKeptGeometry();
        case 'extrude':
          return Shape.fromGeometry(values[0]).extrude(values[1]).toDisjointGeometry();
        case 'hull':
          values = values.map(Shape.fromGeometry);
          return Hull(...values).toDisjointGeometry();
        case 'intersection':
          return intersection$5(Shape.fromGeometry(values[0]), Shape.fromGeometry(values[1])).toDisjointGeometry();
        case 'rectangle':
          return Square(values[0], values[1]).toDisjointGeometry();
        case 'Over Cut Inside Corners':
          const overcutShape = Shape.fromGeometry(values[0]);
          const overcutSection = overcutShape.section(Z$k());
          const toolpath = overcutSection.toolpath(values[1], { overcut: true, joinPaths: true });
          const height = overcutShape.size().height;
          const sweep = toolpath.sweep(Circle(values[1])).extrude(height);
          return overcutShape.cut(sweep).toDisjointGeometry();
        case 'render':
          var fromGeo = null;
          if (values[1] === true && values[2] === false) { // Solid, no wireframe
            fromGeo = Shape.fromGeometry(values[0]);
          } else if (values[1] === false && values[2] === true) {
            fromGeo = Shape.fromGeometry(values[0]).outline();
          } else if (values[1] === true && values[2] === true) {
            const intermediate = Shape.fromGeometry(values[0]);
            fromGeo = intermediate.with(intermediate.outline());
          } else {
            fromGeo = Empty(); // This should be an empty geometry
          }
          return toThreejsGeometry(fromGeo.toDisjointGeometry());
        case 'rotate':
          return Shape.fromGeometry(values[0]).rotateX(values[1]).rotateY(values[2]).rotateZ(values[3]).toDisjointGeometry();
        case 'scale':
          return Shape.fromGeometry(values[0]).scale(values[1]).toDisjointGeometry();
        case 'stl':
          const inflated = Shape.fromGeometry(values[0]).toKeptGeometry();
          const stlString = await toStl(inflated);
          return stlString;
        case 'stretch':
          return Shape.fromGeometry(values[0]).scale([values[1], values[2], values[3]]).toDisjointGeometry();
        case 'svg':
          const svgString = await toSvg(Shape.fromGeometry(values[0]).Union().center().section().outline().toKeptGeometry());
          return svgString;
        case 'SVG Picture':
          const shape = Shape.fromGeometry(values[0]).center();
          const bounds = shape.measureBoundingBox();
          const cameraDistance = 6 * Math.max(...bounds[1]);
          return toSvg$2({ view: { position: [0, 0, cameraDistance], near: 1, far: 10000 } }, shape.rotateX(20).rotateY(-45).toDisjointGeometry());
        case 'tag':
          return Shape.fromGeometry(values[0]).as(values[1]).toDisjointGeometry();
        case 'specify':
          return Shape.fromGeometry(values[0]).Item(values[1]).toDisjointGeometry();
        case 'translate':
          return Shape.fromGeometry(values[0]).move(values[1], values[2], values[3]).toDisjointGeometry();
        case 'getBOM':
          return Shape.fromGeometry(values[0]).bom();
        case 'union':
          return union$5(Shape.fromGeometry(values[0]), Shape.fromGeometry(values[1])).toDisjointGeometry();
        default:
          return -1;
      }
    } catch (error) {
      console.log('Called with: ');
      console.log(question);
      console.log(error);
      return -1;
    }
  };

  const bootstrap = async () => {
    await boot();
    const { ask, hear } = conversation({ agent, say });
    self.ask = ask;
    onmessage = ({ data }) => hear(data);
    if (onmessage === undefined) throw Error('die');
  };

  bootstrap();

});
