<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/js/molecules/molecule.js | canvas-template</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js">js</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/BOM.js~BOMEntry.html">BOMEntry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/globalvariables.js~GlobalVariables.html">GlobalVariables</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convertLinks">convertLinks</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extractBomTags">extractBomTags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-showGitHubSearch">showGitHubSearch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-addOrDeletePorts">addOrDeletePorts</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-GitHubModule">GitHubModule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cmenu">cmenu</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-globalVariables">globalVariables</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-licenses">licenses</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js-molecules">js/molecules</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/BOM.js~AddBOMTag.html">AddBOMTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/assembly.js~Assembly.html">Assembly</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/box.js~Box.html">Box</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/circle.js~Circle.html">Circle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/code.js~Code.html">Code</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/color.js~Color.html">Color</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/constant.js~Constant.html">Constant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/cutlayout.js~CutLayout.html">CutLayout</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/cutlist.js~CutList.html">CutList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/difference.js~Difference.html">Difference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/equation.js~Equation.html">Equation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/extracttag.js~ExtractTag.html">ExtractTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/extrude.js~Extrude.html">Extrude</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/gcode.js~Gcode.html">Gcode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/geneticAlgorithm.js~GeneticAlgorithm.html">GeneticAlgorithm</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/githubmolecule.js~GitHubMolecule.html">GitHubMolecule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/group.js~Group.html">Group</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/input.js~Input.html">Input</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/intersection.js~Intersection.html">Intersection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/molecule.js~Molecule.html">Molecule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/move.js~Move.html">Move</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/nest.js~Nest.html">Nest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/output.js~Output.html">Output</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/readme.js~Readme.html">Readme</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/rectangle.js~Rectangle.html">Rectangle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/regularPolygon.js~RegularPolygon.html">RegularPolygon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/rotate.js~Rotate.html">Rotate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/shrinkwrap.js~ShrinkWrap.html">ShrinkWrap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/stl.js~Stl.html">Stl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/svg.js~Svg.html">Svg</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/tag.js~Tag.html">Tag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/molecules/uploadSVG.js~UploadSVG.html">UploadSVG</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#js-prototypes">js/prototypes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/prototypes/atom.js~Atom.html">Atom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/prototypes/attachmentpoint.js~AttachmentPoint.html">AttachmentPoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/js/prototypes/connector.js~Connector.html">Connector</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/js/molecules/molecule.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import Atom from &apos;../prototypes/atom.js&apos;
import Connector from &apos;../prototypes/connector.js&apos;
import GlobalVariables from &apos;../globalvariables.js&apos;
//import saveAs from &apos;../lib/FileSaver.js&apos;
import { extractBomTags } from &apos;../BOM.js&apos;

/**
 * This class creates the Molecule atom.
 */
export default class Molecule extends Atom{
    
    /**
     * The constructor function.
     * @param {object} values An array of values passed in which will be assigned to the class as this.x
     */ 
    constructor(values){
        
        super(values)
        
        /** 
         * A list of all of the atoms within this Molecule which should be drawn on the screen as objects.
         * @type {array}
         */
        this.nodesOnTheScreen = []
        /** 
         * An array of the molecules inputs. Is this not inherited from atom?
         * @type {array}
         */
        this.inputs = []
        /** 
         * This atom&apos;s type
         * @type {string}
         */
        this.name = &apos;Molecule&apos;
        /** 
         * A description of this atom
         * @type {string}
         */
        this.description = &quot;Molecules provide an organizational structure to contain atoms. Double click on a molecule to enter it. Use the up arrow in the upper right hand corner of the screen to go up one level.&quot;
        /** 
         * This atom&apos;s type
         * @type {string}
         */
        this.atomType = &apos;Molecule&apos;
        /** 
         * The color for the middle dot in the molecule
         * @type {string}
         */
        this.centerColor = &apos;#949294&apos;
        /** 
         * A flag to indicate if this molecule is the top level molecule.
         * @type {boolean}
         */
        this.topLevel = false
        /** 
         * A flag to indicate if this molecule should simplify it&apos;s output.
         * @type {boolean}
         */
        this.simplify = false
        /** 
         * A flag to indicate if this molecule is currently processing.
         * @type {boolean}
         */
        this.processing = false //Should be pulled from atom. Docs made me put this here
        /** 
         * A list of things which should be displayed on the the top level sideBar when in toplevel mode.
         * @type {array}
         */
        this.runModeSidebarAdditions = []
        
        /** 
         * The total number of atoms contained in this molecule
         * @type {integer}
         */
        this.totalAtomCount = 1
        /** 
         * The total number of atoms contained in this molecule which are waiting to process
         * @type {integer}
         */
        this.toProcess = 0
        /**
         * A flag to indicate if this molecule was waiting propagation. If it is it will take place
         *the next time we go up one level.
         * @type {number}
         */
        this.awaitingPropagationFlag = false
        /**
         * A list of available units.
         * @type {object}
         */
        this.units = {&quot;MM&quot;: 1, &quot;Inches&quot;: 25.4}
        /**
         * The index of the currently selected unit.
         * @type {array}
         */
        this.unitsIndex = 0
        
        this.setValues(values)
        
        //Add the molecule&apos;s output
        this.placeAtom({
            parentMolecule: this, 
            x: GlobalVariables.pixelsToWidth(GlobalVariables.canvas.width - 20),
            y: GlobalVariables.pixelsToHeight(GlobalVariables.canvas.height/2),
            parent: this,
            name: &apos;Output&apos;,
            atomType: &apos;Output&apos;,
            uniqueID: GlobalVariables.generateUniqueID()
        }, false)
    }
    
    /**
     * Gives this molecule inputs with the same names as all of it&apos;s parent&apos;s inputs
     */ 
    copyInputsFromParent(){
        if(this.parent){
            this.parent.nodesOnTheScreen.forEach(node =&gt; {
                if(node.atomType == &quot;Input&quot;){
                    this.placeAtom({
                        parentMolecule: this,
                        y: node.y,
                        parent: this,
                        name: node.name,
                        atomType: &apos;Input&apos;,
                        uniqueID: GlobalVariables.generateUniqueID()
                    }, null, GlobalVariables.availableTypes, true)
                }
            })
        } 
    }
    
    /**
     * Add the center dot to the molecule
     */ 
    draw(){
        const percentLoaded = 1-this.toProcess/this.totalAtomCount
        if(this.toProcess &gt; 1){
            this.processing = true
        }
        else{
            this.processing = false
        }
        
        super.draw() //Super call to draw the rest
        
        //draw the circle in the middle
        GlobalVariables.c.beginPath()
        GlobalVariables.c.fillStyle = this.centerColor
        GlobalVariables.c.moveTo(GlobalVariables.widthToPixels(this.x), GlobalVariables.heightToPixels(this.y))
        GlobalVariables.c.arc(GlobalVariables.widthToPixels(this.x), GlobalVariables.heightToPixels(this.y), GlobalVariables.widthToPixels(this.radius)/2, 0, percentLoaded*Math.PI * 2, false)
        GlobalVariables.c.closePath()
        GlobalVariables.c.fill()
    }
    
    /**
     * Set the atom&apos;s response to a mouse click up. If the atom is moving this makes it stop moving.
     * @param {number} x - The X coordinate of the click
     * @param {number} y - The Y coordinate of the click
     */ 
    clickUp(x,y){
        super.clickUp(x,y)
        GlobalVariables.currentMolecule.nodesOnTheScreen.forEach(atom =&gt;{
            atom.isMoving = false
        })
    }

    /**
     * Handle double clicks by replacing the molecule currently on the screen with this one, esentially diving into it.
     * @param {number} x - The x coordinate of the click
     * @param {number} y - The y coordinate of the click
     */ 
    doubleClick(x,y){
        //returns true if something was done with the click
        x = GlobalVariables.pixelsToWidth(x)
        y = GlobalVariables.pixelsToHeight(y)
        
        var clickProcessed = false
        
        var distFromClick = GlobalVariables.distBetweenPoints(x, this.x, y, this.y)
        
        if (distFromClick &lt; this.radius*2){
            GlobalVariables.currentMolecule = this //set this to be the currently displayed molecule
            GlobalVariables.currentMolecule.backgroundClick()
            /**
            * Deselects Atom
            * @type {boolean}
            */
            this.selected = false
            clickProcessed = true
        }
        
        return clickProcessed 
    }
    
    /**
     * Handle a background click (a click which doesn&apos;t land on one of the contained molecules) by deselected everything and displaying a 3D rendering of this molecules output.
     */ 
    backgroundClick(){
        /**
         * Flag that the atom is now selected.
         */
        if(this.selected == false){
            this.selected = true
            this.updateSidebar()
            this.sendToRender()   //This is might need to be removed because it was happening too often during loading
        }
    }

    /**
     * Pushes serialized atoms into array if selected
     */
    copy(){
        this.nodesOnTheScreen.forEach(atom =&gt; {
            if(atom.selected){
                GlobalVariables.atomsSelected.push(atom.serialize({x: .03, y: .03}))
            }
        })
    }
    
    /**
     * Unselect this molecule
     */ 
    deselect(){
        this.selected = false

    }
    
    /**
     * Grab values from the inputs and push them out to the input atoms.
     */ 
    updateValue(targetName){
        
        //Molecules are fully transparent so we don&apos;t wait for all of the inputs to begin processing the things inside
        
        //Tell the correct input to update
        this.nodesOnTheScreen.forEach(atom =&gt; { //Scan all the input atoms
            if(atom.atomType == &apos;Input&apos; &amp;&amp; atom.name == targetName){  //When there is a match
                atom.updateValue() //Tell that input to update it&apos;s value
            }
        })
    }
    
    /**
     * Reads the path of this molecule&apos;s output atom
     */ 
    readOutputAtomPath(){
        var returnPath = &quot;&quot;
        this.nodesOnTheScreen.forEach(atom =&gt; {
            //If we have found this molecule&apos;s output atom use it to update the path here
            if(atom.atomType == &quot;Output&quot;){
                returnPath = atom.path
            }
        })
        return returnPath
    }
    
    /**
     * Sets the atom to wait on coming information. Basically a pass through, but used for molecules
     */ 
    waitOnComingInformation(inputName){
        this.nodesOnTheScreen.forEach( atom =&gt; {
            if(atom.name == inputName){
                atom.waitOnComingInformation()
            }
        })
    }
    
    /**
     * Called when this molecules value changes
     */ 
    propagate(){
        //Set the output nodes with type &apos;geometry&apos; to be the generated code
        try{
            this.processing = true
            const values = {op: &quot;copy&quot;, readPath: this.readOutputAtomPath(), writePath: this.path}
            const {answer} = window.ask(values)
            answer.then( () =&gt; {
                this.processing = false
                this.pushPropagation()
            })
        }catch(err){this.setAlert(err)}
    }
    
    /**
     * Called when this molecules value changes
     */ 
    pushPropagation(){
        //Only propagate up if 
        if(this != GlobalVariables.currentMolecule){
            this.output.setValue(this.path)
            this.output.ready = true
        }
        else{
            this.awaitingPropagationFlag = true
        }
        
        //If this molecule is selected, send the updated value to the renderer
        if(this.selected){
            this.sendToRender()
        }
    }
    
    /**
     * Walks through each of the atoms in this molecule and begins Propagation from them if they have no inputs to wait for
     */ 
    beginPropagation(force = false){
        
        //Tell every atom inside this molecule to begin Propagation
        this.nodesOnTheScreen.forEach(node =&gt; {
            node.beginPropagation(force)
        })
    }
    
    /**
     * Walks through each of the atoms in this molecule and takes a census of how many there are and how many are currently waiting to be processed.
     */
    census(){
        this.totalAtomCount = 0
        this.toProcess = 0
        
        this.nodesOnTheScreen.forEach(atom =&gt; {
            const newInformation = atom.census()
            this.totalAtomCount = this.totalAtomCount + newInformation[0]
            this.toProcess      = this.toProcess + newInformation[1]
        })
        
        if(this.topLevel &amp;&amp; this.selected){
            this.updateSidebar()
        }
        
        return [this.totalAtomCount, this.toProcess]
    }
    
    /**
     * Called when the simplify check box is checked or unchecked.
     */
    setSimplifyFlag(anEvent){
        this.simplify = anEvent.target.checked
        this.propagate()
    }
    
    changeUnits(newUnitsIndex){
        this.unitsIndex = newUnitsIndex
        this.updateSidebar()
    }

    /**
     * Updates the side bar to display options like &apos;go to parent&apos; and &apos;load a different project&apos;. What is displayed depends on if this atom is the top level, and if we are using run mode.
     */ 
    updateSidebar(){
        //Update the side bar to make it possible to change the molecule name
        
        var valueList = super.initializeSideBar()
        
        if(!this.topLevel){
            this.createEditableValueListItem(valueList,this,&apos;name&apos;,&apos;Name&apos;, false)
        }
        else if(this.topLevel){
            //If we are the top level molecule

            this.createSegmentSlider(valueList)

            const dropdown = document.createElement(&apos;div&apos;)
            valueList.appendChild(dropdown)
            this.createDropDown(dropdown, this, Object.keys(this.units), this.unitsIndex, &quot;Units&quot;, (index)=&gt;{this.changeUnits(index)})
        }
        
        //Display the percent loaded while loading
        const percentLoaded = 100*(1-this.toProcess/this.totalAtomCount)
        if(this.toProcess &gt; 0 &amp;&amp; this.topLevel){
            this.createNonEditableValueListItem(valueList,{percentLoaded:percentLoaded.toFixed(0) + &quot;%&quot;},&quot;percentLoaded&quot;,&apos;Loading&apos;)
        }
        
        //removes 3d view menu on background click
        let viewerBar = document.querySelector(&apos;#viewer_bar&apos;)
        if(viewerBar &amp;&amp; viewerBar.firstChild){
            while (viewerBar.firstChild) {
                viewerBar.removeChild(viewerBar.firstChild)
                viewerBar.setAttribute(&apos;style&apos;, &apos;background-color:none;&apos;)
            }
        }
        
        
        
        //Add options to set all of the inputs
        this.inputs.forEach(child =&gt; {
            if(child.type == &apos;input&apos; &amp;&amp; child.valueType != &apos;geometry&apos;){
                this.createEditableValueListItem(valueList,child,&apos;value&apos;, child.name, true)
            }
        })
        
        //Add the check box to simplify
        this.createCheckbox(valueList,&quot;Simplify output&quot;,this.simplify,(anEvent)=&gt;{this.setSimplifyFlag(anEvent)})
        
        //Only bother to generate the bom if we are not currently processing data
        if(this.toProcess == 0){
            this.displaySimpleBOM(valueList)
        }
        
        this.displaySidebarReadme(valueList)
        
        return valueList
        
    }

    /**
     * Creates segment length slider and passes value to Global Variables
     */ 
    createSegmentSlider(valueList){

        const unitsScalor = this.units[Object.keys(this.units)[this.unitsIndex]]

        //Creates value slider
        var rangeElement = document.createElement(&apos;input&apos;)
        //Div which contains the entire element
        var div = document.createElement(&apos;div&apos;)
        div.setAttribute(&apos;class&apos;, &apos;slider-container&apos;)
        valueList.appendChild(div)
        var rangeLabel = document.createElement(&apos;label&apos;)
        rangeLabel.textContent = &quot;Display quality/Length of Segments&quot;
        div.appendChild(rangeLabel)
        rangeLabel.appendChild(rangeElement)
        rangeElement.setAttribute(&apos;type&apos;, &apos;range&apos;)
        rangeElement.setAttribute(&apos;min&apos;, &apos;&apos; + .001/unitsScalor)
        rangeElement.setAttribute(&apos;max&apos;, &apos;&apos; + 1/unitsScalor)
        rangeElement.setAttribute(&apos;step&apos;, &apos;&apos; + .05/unitsScalor)
        rangeElement.setAttribute(&apos;class&apos;, &apos;slider&apos;)
        rangeElement.setAttribute(&apos;value&apos;, GlobalVariables.circleSegmentSize)
            
        var rangeValueLabel = document.createElement(&apos;ul&apos;)
        rangeValueLabel.innerHTML= &apos;&lt;li&gt;Export&lt;/li&gt;&lt;li&gt;Draft&lt;/li&gt; &apos;
        rangeValueLabel.setAttribute(&apos;class&apos;, &apos;range-labels&apos;)
        rangeLabel.appendChild(rangeValueLabel)

        var rangeValue = document.createElement(&apos;p&apos;)
        rangeValue.textContent = parseFloat(rangeElement.value).toFixed(5).toString()
        rangeLabel.appendChild(rangeValue)


        //on slider change send value to global variables
        rangeElement.oninput = function() {
            rangeValue.textContent = this.value
            GlobalVariables.circleSegmentSize = this.value
            
        }
        
        rangeElement.addEventListener(&apos;touchend&apos;, () =&gt; {
            GlobalVariables.topLevelMolecule.refreshCircles()
        })
        
        rangeElement.addEventListener(&apos;mouseup&apos;, () =&gt; {
            GlobalVariables.topLevelMolecule.refreshCircles()
        })
    }
    
    /**
     * Used to trigger all of the circle atoms within a molecule and all of the molecules within it to update their value. Used when the number of segments changes.
     */ 
    refreshCircles(){
        this.nodesOnTheScreen.forEach(atom =&gt; {
            if(atom.atomType == &quot;Circle&quot;){
                atom.updateValue()
            }
            else if(atom.atomType == &quot;Molecule&quot; || atom.atomType == &quot;GitHubMolecule&quot;){
                atom.refreshCircles()
            }
        })
    }
    
    /**
     * Creates a simple BOM list which cannot be edited. The generated element is added to the passed list.
     * @param {object} list - The HTML object to append the created element to.
     */ 
    displaySimpleBOM(list){
        try{
            
            const placementFunction = (bomList) =&gt; {
                
                if(bomList.length &gt; 0){
                
                    list.appendChild(document.createElement(&apos;br&apos;))
                    list.appendChild(document.createElement(&apos;br&apos;))
                    
                    var div = document.createElement(&apos;h3&apos;)
                    div.setAttribute(&apos;style&apos;,&apos;text-align:center;&apos;)
                    list.appendChild(div)
                    var valueText = document.createTextNode(&apos;Bill Of Materials&apos;)
                    div.appendChild(valueText)
                    
                    var x = document.createElement(&apos;HR&apos;)
                    list.appendChild(x)
                    
                    bomList.forEach(bomEntry =&gt; {
                        this.createNonEditableValueListItem(list,bomEntry,&apos;numberNeeded&apos;, bomEntry.BOMitemName, false)
                    })
                }
            }
            
            extractBomTags(this.path, placementFunction)
            
        }catch(err){
            this.setAlert(&quot;Unable to read BOM&quot;)
        }
    }
    
    /**
     * Creates markdown version of the readme content for this atom in the sidebar
     * @param {object} list - The HTML object to append the created element to.
     */ 
    displaySidebarReadme(list){
        
        
        var readmeContent = &quot;&quot;
        
        this.requestReadme().forEach(item =&gt; {
            
            readmeContent = readmeContent + item + &quot;\n\n\n&quot;
        })
        
        if(readmeContent.length &gt; 0){    //If there is anything to say
        
            list.appendChild(document.createElement(&apos;br&apos;))
            list.appendChild(document.createElement(&apos;br&apos;))

            var div = document.createElement(&apos;h3&apos;)
            div.setAttribute(&apos;style&apos;,&apos;float:right;&apos;)
           
            list.appendChild(div)
            var valueText = document.createTextNode(`- ReadMe`)
            div.appendChild(valueText)
            
            var x = document.createElement(&apos;HR&apos;)
            x.setAttribute(&apos;style&apos;,&apos;width:100%;&apos;)
            list.appendChild(x)
            
            this.createMarkdownListItem(list,readmeContent)
        }
    }
    
    /**
     * Replace the currently displayed molecule with the parent of this molecule...moves the user up one level.
     */
    goToParentMolecule(){
        //Go to the parent molecule if there is one
        if(!this.topLevel){
            this.nodesOnTheScreen.forEach(atom =&gt; {
                atom.selected = false
            })
            
            GlobalVariables.currentMolecule = this.parent //set parent this to be the currently displayed molecule
            GlobalVariables.currentMolecule.backgroundClick()
            
            //Push any changes up to the next level if there are any changes waiting in the output
            if(this.awaitingPropagationFlag == true){
                this.propagate()
                this.awaitingPropagationFlag = false
            }
        }
    }
    
    /**
     * Check to see if any of this molecules children have contributions to make to the README file. Children closer to the top left will be applied first. TODO: No contribution should be made if it&apos;s just a title.
     */
    requestReadme(){
        var generatedReadme = super.requestReadme()
        
        var sortableAtomsList = this.nodesOnTheScreen
        sortableAtomsList.sort(function(a, b){return GlobalVariables.distBetweenPoints(a.x, 0, a.y, 0)-GlobalVariables.distBetweenPoints(b.x, 0, b.y, 0)})
        
        sortableAtomsList.forEach(atom =&gt; {
            generatedReadme = generatedReadme.concat(atom.requestReadme())
        })
        
        //Check to see if any of the children added anything if not, remove the bit we added
        if(generatedReadme[generatedReadme.length - 1] == &apos;## &apos; + this.name){
            generatedReadme.pop()
        }
        
        return generatedReadme
    }
    
    /**
     * Generates and returns a object representation of this molecule and all of its children.
     */
    serialize(offset = {x: 0, y: 0}){
        
        var allAtoms = [] //An array of all the atoms contained in this molecule
        var allConnectors = [] //An array of all the connectors contained in this molecule
        
        this.nodesOnTheScreen.forEach(atom =&gt; {
            //Store a representation of the atom
            allAtoms.push(atom.serialize())
            //Store a representation of the atom&apos;s connectors
            if(atom.output){
                atom.output.connectors.forEach(connector =&gt; {
                    allConnectors.push(connector.serialize())
                })
            }
        })
        
        var thisAsObject = super.serialize(offset)    //Do the atom serialization to create an object, then add all the bits of this one to it
        thisAsObject.topLevel = this.topLevel
        thisAsObject.allAtoms = allAtoms
        thisAsObject.allConnectors = allConnectors
        thisAsObject.fileTypeVersion = 1
        thisAsObject.simplify= this.simplify
        thisAsObject.unitsIndex = this.unitsIndex
        
        return thisAsObject
    }
    
    /**
     * Load the children of this from a JSON representation
     * @param {object} json - A json representation of the molecule
     * @param {object} values - An array of values to apply to this molecule before de-serializing it&apos;s contents. Used by githubmolecules to set top level correctly
     */
    deserialize(json, values = {}, forceBeginPropagation = false){
        //Find the target molecule in the list
        let promiseArray = []
        
        this.setValues(json) //Grab the values of everything from the passed object
        this.setValues(values) //Over write those values with the passed ones where needed
        
        if(json.allAtoms){
            json.allAtoms.forEach(atom =&gt; { //Place the atoms
                const promise = this.placeAtom(atom, false)
                promiseArray.push(promise)
                this.setValues([]) //Call set values again with an empty list to trigger loading of IO values from memory
            })
        }
        
        return Promise.all(promiseArray).then( ()=&gt; { //Once all the atoms are placed we can finish
            
            this.setValues([])//Call set values again with an empty list to trigger loading of IO values from memory
            
            //Place the connectors
            if(json.allConnectors){
                json.allConnectors.forEach(connector =&gt; {
                    this.placeConnector(connector)
                })
            }
            
            if(this.topLevel){
                
                GlobalVariables.totalAtomCount = GlobalVariables.numberOfAtomsToLoad
                
                this.census()
                this.loadTree()  //Walks back up the tree from this molecule loading input values from any connected atoms
                
                const splits = this.path.split(&apos;/&apos;)
                const values = {op: &quot;getPathsList&quot;, prefacePath: splits[0]+&apos;/&apos;+splits[1]}
                const {answer} = window.ask(values)
                answer.then( answer =&gt; {
                
                    GlobalVariables.availablePaths = answer
                    this.beginPropagation(forceBeginPropagation)
                
                })
                this.backgroundClick()
            }
        })
    }
    
    /**
     * Delete this molecule and everything in it.
     */ 
    deleteNode(backgroundClickAfter = true, deletePath = true, silent = false){
        
        //make a copy of the nodes on the screen array since we will be modifying it
        const copyOfNodesOnTheScreen = [...this.nodesOnTheScreen]
        
        copyOfNodesOnTheScreen.forEach(atom =&gt; {
            atom.deleteNode(backgroundClickAfter, deletePath, silent)
        })
        
        super.deleteNode(backgroundClickAfter, deletePath, silent)
    }
    
    /**
     * Triggers the loadTree process from this molecules output
     */ 
    loadTree(){
        //We want to walk the tree from this&apos;s output and anything which has nothing coming out of it. Basically all the graph end points.
        
        this.nodesOnTheScreen.forEach(atom =&gt; {
            //If we have found this molecule&apos;s output atom use it to update the path here
            if(atom.atomType == &quot;Output&quot;){
                atom.loadTree()
            }
            //If we have found an atom with nothing connected to it
            if(atom.output){
                if(atom.output.connectors.length == 0){
                    atom.loadTree()
                }
            }
        })
        
        this.output.value = this.path
        return this.path
    }
    
    /**
     * Places a new atom inside the molecule
     * @param {object} newAtomObj - An object defining the new atom to be placed
     * @param {array} moleculeList - Only passed if we are placing an instance of Molecule.
     * @param {object} typesList - A dictionary of all of the available types with references to their constructors
     * @param {boolean} unlock - A flag to indicate if this atom should spawn in the unlocked state.
     */
    async placeAtom(newAtomObj, unlock){
        
        GlobalVariables.numberOfAtomsToLoad = GlobalVariables.numberOfAtomsToLoad + 1 //Indicate that one more atom needs to be loaded
        
        try{
            var promise = null
            
            for(var key in GlobalVariables.availableTypes) {
                if (GlobalVariables.availableTypes[key].atomType == newAtomObj.atomType){
                    newAtomObj.parent = this
                    var atom = new GlobalVariables.availableTypes[key].creator(newAtomObj)
                    
                    //reassign the name of the Inputs to preserve linking
                    if(atom.atomType == &apos;Input&apos; &amp;&amp; typeof newAtomObj.name !== &apos;undefined&apos;){
                        atom.name = newAtomObj.name
                        atom.draw() //The poling happens in draw :roll_eyes:
                    }

                    //If this is a molecule, de-serialize it
                    if(atom.atomType == &apos;Molecule&apos;){
                        promise = atom.deserialize(newAtomObj)
                    }
                    
                    //If this is a github molecule load it from the web
                    if(atom.atomType == &apos;GitHubMolecule&apos;){
                        promise = atom.loadProjectByID(atom.projectID)
                        if(unlock){
                            promise.then( ()=&gt; {
                                atom.beginPropagation()
                            })
                        }
                    }
                    
                    //If this is an output, check to make sure there are no existing outputs, and if there are delete the existing one because there can only be one
                    if(atom.atomType == &apos;Output&apos;){
                        //Check for existing outputs
                        this.nodesOnTheScreen.forEach(atom =&gt; {
                            if(atom.atomType == &apos;Output&apos;){
                                atom.deleteOutputAtom(false) //Remove them
                            }
                        })
                    }
                    
                    //Add the atom to the list to display
                    this.nodesOnTheScreen.push(atom)
                    
                    if(unlock){
                        
                        //Make this molecule spawn with all of it&apos;s parent&apos;s inputs
                        if(atom.atomType == &apos;Molecule&apos;){ //Not GitHubMolecule
                            atom.copyInputsFromParent()
                            
                            //Make begin propagation from an atom when it is placed. This is used when copy and pasting molecules.
                            if(promise != null){
                                promise.then( ()=&gt; {
                                    atom.beginPropagation()
                                })
                            }
                            else{
                                atom.beginPropagation()
                            }
                            
                        }
                        
                        //Fake a click on the newly placed atom
                        const downEvt = new MouseEvent(&apos;mousedown&apos;, {
                            clientX: atom.x,
                            clientY: atom.y
                        })
                        const upEvt = new MouseEvent(&apos;mouseup&apos;, {
                            clientX: atom.x,
                            clientY: atom.y
                        })
                        
                        atom.updateValue()
                        
                        document.getElementById(&apos;flow-canvas&apos;).dispatchEvent(downEvt)
                        document.getElementById(&apos;flow-canvas&apos;).dispatchEvent(upEvt)
                    }
                }
            }
            return promise
        }catch(err){
            console.warn(&quot;Unable to place: &quot; + newAtomObj)
            console.warn(err)
            return Promise.resolve()
        }

    }
    
    /**
     * Places a new connector within the molecule
     * @param {object} connectorObj - An object represntation of the connector specifying its inputs and outputs.
     */
    placeConnector(connectorObj){
        
        var outputAttachmentPoint = false
        var inputAttachmentPoint = false
        
        this.nodesOnTheScreen.forEach(atom =&gt; {             //Check each atom on the screen
            if (atom.uniqueID == connectorObj.ap1ID){           //When we have found the output atom
                outputAttachmentPoint = atom.output
            }
            if (atom.uniqueID == connectorObj.ap2ID){           //When we have found the input atom
                atom.inputs.forEach(input =&gt; {                  //Check each of its inputs
                    if(input.name == connectorObj.ap2Name){
                        inputAttachmentPoint = input                //Until we find the one with the right name
                    }
                })
            }
        })
        
        if(outputAttachmentPoint &amp;&amp; inputAttachmentPoint){             //If we have found the output and input
            new Connector({
                atomType: &apos;Connector&apos;,
                attachmentPoint1: outputAttachmentPoint,
                attachmentPoint2: inputAttachmentPoint,
            })
        }
        else{
            console.warn(&quot;Unable to place connector&quot;)
        }
    }
    
    /**
     * Sends the output of this molecule to be displayed in the 3D view.
     */
    sendToRender(){
        super.sendToRender()
        if(this.value != null){
            if(this.topLevel){
                this.basicThreadValueProcessing(this.value, &quot;bounding box&quot;)
            }
        }
    }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
